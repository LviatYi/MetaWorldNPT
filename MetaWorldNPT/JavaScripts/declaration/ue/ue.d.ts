/// <reference path="../puerts/index.d.ts" />
declare module UE {
    //@ts-ignore
    import {$Ref, $Nullable} from "Puerts";

    export class Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CreateDefaultSubobject(p0: string, p1: $Nullable<Class>, p2: $Nullable<Class>, p3: boolean, p4: boolean): Object;

        ExecuteUbergraph(EntryPoint: number): void;

        GetClass(): Class;

        GetName(): string;

        GetOuter(): Object;

        GetWorld(): World;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Object;

        static Load(InName: string): Object;
    }

    export class BlueprintFunctionLibrary extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionLibrary;

        static Load(InName: string): BlueprintFunctionLibrary;
    }

    export class GameplayAbilityTargetDataHandle {
        constructor();

        static StaticClass(): Class;
    }

    export class GameplayEffectSpecHandle {
        constructor();

        static StaticClass(): Class;
    }

    export enum ETickingGroup {
        TG_PrePhysics,
        TG_StartPhysics,
        TG_DuringPhysics,
        TG_EndPhysics,
        TG_PostPhysics,
        TG_PostUpdateWork,
        TG_LastDemotable,
        TG_NewlySpawned,
        TG_MAX
    }

    export enum EMWTickPolicy { TP_Default, TP_NeverTick, TP_TickOnlyOnScreen, TP_ConsistentWithOwner, TP_MAX }

    export class TickFunction {
        constructor();
        constructor(TickGroup: ETickingGroup, EndTickGroup: ETickingGroup, bTickEvenWhenPaused: boolean, bCanEverTick: boolean, bStartWithTickEnabled: boolean, bAllowTickOnDedicatedServer: boolean, TickInterval: number, TickPolicy: EMWTickPolicy, OffscreenTickRate: number);

        TickGroup: ETickingGroup;
        EndTickGroup: ETickingGroup;
        bTickEvenWhenPaused: boolean;
        bCanEverTick: boolean;
        bStartWithTickEnabled: boolean;
        bAllowTickOnDedicatedServer: boolean;
        TickInterval: number;
        TickPolicy: EMWTickPolicy;
        OffscreenTickRate: number;

        static StaticClass(): Class;
    }

    export class ActorTickFunction extends TickFunction {
        constructor();

        static StaticClass(): Class;
    }

    export enum EActorUpdateOverlapsMethod {
        UseConfigDefault,
        AlwaysUpdate,
        OnlyUpdateMovable,
        NeverUpdate,
        EActorUpdateOverlapsMethod_MAX
    }

    export enum ENetRole { ROLE_None, ROLE_SimulatedProxy, ROLE_AutonomousProxy, ROLE_Authority, ROLE_MAX }

    export enum EVectorQuantization { RoundWholeNumber, RoundOneDecimal, RoundTwoDecimals, EVectorQuantization_MAX }

    export enum ERotatorQuantization { ByteComponents, ShortComponents, ERotatorQuantization_MAX }

    export class RepMovement {
        constructor();
        constructor(LinearVelocity: Vector, AngularVelocity: Vector, Location: Vector, Rotation: Rotator, bSimulatedPhysicSleep: boolean, bRepPhysics: boolean, LocationQuantizationLevel: EVectorQuantization, VelocityQuantizationLevel: EVectorQuantization, RotationQuantizationLevel: ERotatorQuantization);

        LinearVelocity: Vector;
        AngularVelocity: Vector;
        Location: Vector;
        Rotation: Rotator;
        bSimulatedPhysicSleep: boolean;
        bRepPhysics: boolean;
        LocationQuantizationLevel: EVectorQuantization;
        VelocityQuantizationLevel: EVectorQuantization;
        RotationQuantizationLevel: ERotatorQuantization;

        static StaticClass(): Class;
    }

    export class Vector_NetQuantize100 extends Vector {
        constructor();

        static StaticClass(): Class;
    }

    export class ActorComponentTickFunction extends TickFunction {
        constructor();

        static StaticClass(): Class;
    }

    export class AssetUserData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetUserData;

        static Load(InName: string): AssetUserData;
    }

    export enum EComponentCreationMethod {
        Native,
        SimpleConstructionScript,
        UserConstructionScript,
        Instance,
        EComponentCreationMethod_MAX
    }

    export class SimpleMemberReference {
        constructor();
        constructor(MemberParent: Object, MemberName: string, MemberGuid: Guid);

        MemberParent: Object;
        MemberName: string;
        MemberGuid: Guid;

        static StaticClass(): Class;
    }

    export enum EEndPlayReason {
        Destroyed,
        LevelTransition,
        EndPlayInEditor,
        RemovedFromWorld,
        Quit,
        EEndPlayReason_MAX
    }

    export class ActorComponent extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PrimaryComponentTick: ActorComponentTickFunction;
        ComponentTags: TArray<string>;
        AssetUserData: TArray<AssetUserData>;
        UCSSerializationIndex: number;
        bNetAddressable: boolean;
        bReplicates: boolean;
        bCreatedByConstructionScript: boolean;
        bInstanceComponent: boolean;
        bAutoActivate: boolean;
        bIsActive: boolean;
        bEditableWhenInherited: boolean;
        bCanEverAffectNavigation: boolean;
        bIsEditorOnly: boolean;
        bIsVisualizationComponent: boolean;
        bNeedsUCSSerializationIndexEvaluted: boolean;
        CreationMethod: EComponentCreationMethod;
        OnComponentActivated: $MulticastDelegate<(Component: $Nullable<ActorComponent>, bReset: boolean) => void>;
        OnComponentDeactivated: $MulticastDelegate<(Component: $Nullable<ActorComponent>) => void>;
        UCSModifiedProperties: TArray<SimpleMemberReference>;

        Activate(bReset?: boolean /* = false */): void;

        AddTickPrerequisiteActor(PrerequisiteActor: $Nullable<Actor>): void;

        AddTickPrerequisiteComponent(PrerequisiteComponent: $Nullable<ActorComponent>): void;

        ComponentHasTag(Tag: string): boolean;

        Deactivate(): void;

        GetComponentTickInterval(): number;

        GetOwner(): Actor;

        IsActive(): boolean;

        IsBeingDestroyed(): boolean;

        IsComponentTickEnabled(): boolean;

        K2_DestroyComponent(Object: $Nullable<Object>): void;

        OnRep_IsActive(): void;

        ReceiveBeginPlay(): void;

        ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;

        ReceiveTick(DeltaSeconds: number): void;

        RemoveTickPrerequisiteActor(PrerequisiteActor: $Nullable<Actor>): void;

        RemoveTickPrerequisiteComponent(PrerequisiteComponent: $Nullable<ActorComponent>): void;

        SetActive(bNewActive: boolean, bReset?: boolean /* = false */): void;

        SetAutoActivate(bNewAutoActivate: boolean): void;

        SetComponentTickEnabled(bEnabled: boolean): void;

        SetComponentTickInterval(TickInterval: number): void;

        SetComponentTickIntervalAndCooldown(TickInterval: number): void;

        SetIsReplicated(ShouldReplicate: boolean): void;

        SetTickableWhenPaused(bTickableWhenPaused: boolean): void;

        SetTickGroup(NewTickGroup: ETickingGroup): void;

        ToggleActive(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorComponent;

        static Load(InName: string): ActorComponent;
    }

    export enum EBrushType { Brush_Default, Brush_Add, Brush_Subtract, Brush_MAX }

    export class Model extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Model;

        static Load(InName: string): Model;
    }

    export enum ESceneDepthPriorityGroup { SDPG_World, SDPG_Foreground, SDPG_MAX }

    export enum EIndirectLightingCacheQuality { ILCQ_Off, ILCQ_Point, ILCQ_Volume, ILCQ_MAX }

    export enum ELightmapType { Default, ForceSurface, ForceVolumetric, ELightmapType_MAX }

    export enum EHasCustomNavigableGeometry {
        No,
        Yes,
        EvenIfNotCollidable,
        DontExport,
        EHasCustomNavigableGeometry_MAX
    }

    export enum EHitProxyPriority { HPP_World, HPP_Wireframe, HPP_Foreground, HPP_UI, HPP_MAX }

    export enum ECanBeCharacterBase { ECB_No, ECB_Yes, ECB_Owner, ECB_MAX }

    export class LightingChannels {
        constructor();
        constructor(bChannel0: boolean, bChannel1: boolean, bChannel2: boolean);

        bChannel0: boolean;
        bChannel1: boolean;
        bChannel2: boolean;

        static StaticClass(): Class;
    }

    export enum ERendererStencilMask {
        ERSM_Default,
        ERSM_255,
        ERSM_1,
        ERSM_2,
        ERSM_4,
        ERSM_8,
        ERSM_16,
        ERSM_32,
        ERSM_64,
        ERSM_128,
        ERSM_MAX
    }

    export class CustomPrimitiveData {
        constructor();
        constructor(Data: TArray<number>);

        Data: TArray<number>;

        static StaticClass(): Class;
    }

    export enum ERuntimeVirtualTextureMaterialType {
        BaseColor,
        BaseColor_Normal_DEPRECATED,
        BaseColor_Normal_Specular,
        BaseColor_Normal_Specular_YCoCg,
        BaseColor_Normal_Specular_Mask_YCoCg,
        WorldHeight,
        Count,
        ERuntimeVirtualTextureMaterialType_MAX
    }

    export enum TextureGroup {
        TEXTUREGROUP_World,
        TEXTUREGROUP_WorldNormalMap,
        TEXTUREGROUP_WorldSpecular,
        TEXTUREGROUP_Character,
        TEXTUREGROUP_CharacterNormalMap,
        TEXTUREGROUP_CharacterSpecular,
        TEXTUREGROUP_Weapon,
        TEXTUREGROUP_WeaponNormalMap,
        TEXTUREGROUP_WeaponSpecular,
        TEXTUREGROUP_Vehicle,
        TEXTUREGROUP_VehicleNormalMap,
        TEXTUREGROUP_VehicleSpecular,
        TEXTUREGROUP_Cinematic,
        TEXTUREGROUP_Effects,
        TEXTUREGROUP_EffectsNotFiltered,
        TEXTUREGROUP_Skybox,
        TEXTUREGROUP_UI,
        TEXTUREGROUP_Lightmap,
        TEXTUREGROUP_RenderTarget,
        TEXTUREGROUP_MobileFlattened,
        TEXTUREGROUP_ProcBuilding_Face,
        TEXTUREGROUP_ProcBuilding_LightMap,
        TEXTUREGROUP_Shadowmap,
        TEXTUREGROUP_ColorLookupTable,
        TEXTUREGROUP_Terrain_Heightmap,
        TEXTUREGROUP_Terrain_Weightmap,
        TEXTUREGROUP_Bokeh,
        TEXTUREGROUP_IESLightProfile,
        TEXTUREGROUP_Pixels2D,
        TEXTUREGROUP_HierarchicalLOD,
        TEXTUREGROUP_Impostor,
        TEXTUREGROUP_ImpostorNormalDepth,
        TEXTUREGROUP_8BitData,
        TEXTUREGROUP_16BitData,
        TEXTUREGROUP_Project01,
        TEXTUREGROUP_Project02,
        TEXTUREGROUP_Project03,
        TEXTUREGROUP_Project04,
        TEXTUREGROUP_Project05,
        TEXTUREGROUP_Project06,
        TEXTUREGROUP_Project07,
        TEXTUREGROUP_Project08,
        TEXTUREGROUP_Project09,
        TEXTUREGROUP_Project10,
        TEXTUREGROUP_Project11,
        TEXTUREGROUP_Project12,
        TEXTUREGROUP_Project13,
        TEXTUREGROUP_Project14,
        TEXTUREGROUP_Project15,
        TEXTUREGROUP_MAX
    }

    export class StreamableRenderAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ForceMipLevelsToBeResidentTimestamp: number;
        NumCinematicMipLevels: number;
        StreamingIndex: number;
        CachedCombinedLODBias: number;
        NeverStream: boolean;
        bGlobalForceMipLevelsToBeResident: boolean;
        bHasStreamingUpdatePending: boolean;
        bForceMiplevelsToBeResident: boolean;
        bIgnoreStreamingMipBias: boolean;
        bUseCinematicMipLevels: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StreamableRenderAsset;

        static Load(InName: string): StreamableRenderAsset;
    }

    export enum ETextureSourceFormat {
        TSF_Invalid,
        TSF_G8,
        TSF_BGRA8,
        TSF_BGRE8,
        TSF_RGBA16,
        TSF_RGBA16F,
        TSF_RGBA8,
        TSF_RGBE8,
        TSF_G16,
        TSF_MAX
    }

    export class TextureSourceBlock {
        constructor();
        constructor(BlockX: number, BlockY: number, SizeX: number, SizeY: number, NumSlices: number, NumMips: number);

        BlockX: number;
        BlockY: number;
        SizeX: number;
        SizeY: number;
        NumSlices: number;
        NumMips: number;

        static StaticClass(): Class;
    }

    export class TextureSource {
        constructor();
        constructor(Id: Guid, BaseBlockX: number, BaseBlockY: number, SizeX: number, SizeY: number, NumSlices: number, NumMips: number, NumLayers: number, bPNGCompressed: boolean, bGuidIsHash: boolean, Format: ETextureSourceFormat, LayerFormat: TArray<ETextureSourceFormat>, Blocks: TArray<TextureSourceBlock>);

        Id: Guid;
        BaseBlockX: number;
        BaseBlockY: number;
        SizeX: number;
        SizeY: number;
        NumSlices: number;
        NumMips: number;
        NumLayers: number;
        bPNGCompressed: boolean;
        bGuidIsHash: boolean;
        Format: ETextureSourceFormat;
        LayerFormat: TArray<ETextureSourceFormat>;
        Blocks: TArray<TextureSourceBlock>;

        static StaticClass(): Class;
    }

    export class AssetImportInfo {
        constructor();

        static StaticClass(): Class;
    }

    export class AssetImportData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceFilePath: string;
        SourceFileTimestamp: string;
        SourceData: AssetImportInfo;

        K2_ExtractFilenames(): TArray<string>;

        K2_GetFirstFilename(): string;

        ScriptedAddFilename(InPath: string, Index: number, SourceFileLabel: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetImportData;

        static Load(InName: string): AssetImportData;
    }

    export enum ETextureLossyCompressionAmount {
        TLCA_Default,
        TLCA_None,
        TLCA_Lowest,
        TLCA_Low,
        TLCA_Medium,
        TLCA_High,
        TLCA_Highest,
        TLCA_MAX
    }

    export enum ETextureCompressionQuality {
        TCQ_Default,
        TCQ_Lowest,
        TCQ_Low,
        TCQ_Medium,
        TCQ_High,
        TCQ_Highest,
        TCQ_MAX
    }

    export enum ETexturePowerOfTwoSetting {
        None,
        PadToPowerOfTwo,
        PadToSquarePowerOfTwo,
        ETexturePowerOfTwoSetting_MAX
    }

    export enum TextureMipGenSettings {
        TMGS_FromTextureGroup,
        TMGS_SimpleAverage,
        TMGS_Sharpen0,
        TMGS_Sharpen1,
        TMGS_Sharpen2,
        TMGS_Sharpen3,
        TMGS_Sharpen4,
        TMGS_Sharpen5,
        TMGS_Sharpen6,
        TMGS_Sharpen7,
        TMGS_Sharpen8,
        TMGS_Sharpen9,
        TMGS_Sharpen10,
        TMGS_NoMipmaps,
        TMGS_LeaveExistingMips,
        TMGS_Blur1,
        TMGS_Blur2,
        TMGS_Blur3,
        TMGS_Blur4,
        TMGS_Blur5,
        TMGS_Unfiltered,
        TMGS_MAX
    }

    export enum ECompositeTextureMode {
        CTM_Disabled,
        CTM_NormalRoughnessToRed,
        CTM_NormalRoughnessToGreen,
        CTM_NormalRoughnessToBlue,
        CTM_NormalRoughnessToAlpha,
        CTM_MAX
    }

    export enum TextureCompressionSettings {
        TC_Default,
        TC_Normalmap,
        TC_Masks,
        TC_Grayscale,
        TC_Displacementmap,
        TC_VectorDisplacementmap,
        TC_HDR,
        TC_EditorIcon,
        TC_Alpha,
        TC_DistanceFieldFont,
        TC_HDR_Compressed,
        TC_BC7,
        TC_HalfFloat,
        TC_ReflectionCapture,
        TC_MAX
    }

    export class TextureFormatSettings {
        constructor();
        constructor(CompressionSettings: TextureCompressionSettings, CompressionNoAlpha: boolean, CompressionNone: boolean, CompressionYCoCg: boolean, SRGB: boolean);

        CompressionSettings: TextureCompressionSettings;
        CompressionNoAlpha: boolean;
        CompressionNone: boolean;
        CompressionYCoCg: boolean;
        SRGB: boolean;

        static StaticClass(): Class;
    }

    export enum TextureFilter { TF_Nearest, TF_Bilinear, TF_Trilinear, TF_Default, TF_MAX }

    export enum ETextureMipLoadOptions { Default, AllMips, OnlyFirstMip, ETextureMipLoadOptions_MAX }

    export class PerPlatformFloat {
        constructor();
        constructor(Default: number, PerPlatform: TMap<string, number>);

        Default: number;
        PerPlatform: TMap<string, number>;

        static StaticClass(): Class;
    }

    export enum ETextureDownscaleOptions {
        Default,
        Unfiltered,
        SimpleAverage,
        Sharpen0,
        Sharpen1,
        Sharpen2,
        Sharpen3,
        Sharpen4,
        Sharpen5,
        Sharpen6,
        Sharpen7,
        Sharpen8,
        Sharpen9,
        Sharpen10,
        ETextureDownscaleOptions_MAX
    }

    export class Texture extends StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Source: TextureSource;
        LightingGuid: Guid;
        SourceFilePath: string;
        AssetImportData: AssetImportData;
        AdjustBrightness: number;
        AdjustBrightnessCurve: number;
        AdjustVibrance: number;
        AdjustSaturation: number;
        AdjustRGBCurve: number;
        AdjustHue: number;
        AdjustMinAlpha: number;
        AdjustMaxAlpha: number;
        CompressionNoAlpha: boolean;
        CompressionNone: boolean;
        DeferCompression: boolean;
        LossyCompressionAmount: ETextureLossyCompressionAmount;
        MaxTextureSize: number;
        CompressionQuality: ETextureCompressionQuality;
        bDitherMipMapAlpha: boolean;
        AlphaCoverageThresholds: Vector4;
        bPreserveBorder: boolean;
        bFlipGreenChannel: boolean;
        bForcePVRTC4: boolean;
        PowerOfTwoMode: ETexturePowerOfTwoSetting;
        PaddingColor: Color;
        bChromaKeyTexture: boolean;
        ChromaKeyThreshold: number;
        ChromaKeyColor: Color;
        MipGenSettings: TextureMipGenSettings;
        CompositeTexture: Texture;
        CompositeTextureMode: ECompositeTextureMode;
        CompositePower: number;
        LayerFormatSettings: TArray<TextureFormatSettings>;
        LODBias: number;
        CompressionSettings: TextureCompressionSettings;
        Filter: TextureFilter;
        MipLoadOptions: ETextureMipLoadOptions;
        LODGroup: TextureGroup;
        Downscale: PerPlatformFloat;
        DownscaleOptions: ETextureDownscaleOptions;
        SRGB: boolean;
        bUseLegacyGamma: boolean;
        bNoTiling: boolean;
        VirtualTextureStreaming: boolean;
        CompressionYCoCg: boolean;
        bNotOfflineProcessed: boolean;
        bAsyncResourceReleaseHasBeenStarted: boolean;
        AssetUserData: TArray<AssetUserData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Texture;

        static Load(InName: string): Texture;
    }

    export enum TextureAddress { TA_Wrap, TA_Clamp, TA_Mirror, TA_MAX }

    export class Texture2D extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LevelIndex: number;
        FirstResourceMemMip: number;
        bTemporarilyDisableStreaming: boolean;
        bHasBeenPaintedInEditor: boolean;
        AddressX: TextureAddress;
        AddressY: TextureAddress;
        ImportedSize: IntPoint;

        Blueprint_GetSizeX(): number;

        Blueprint_GetSizeY(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Texture2D;

        static Load(InName: string): Texture2D;
    }

    export class RuntimeVirtualTextureStreamingProxy extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureStreamingProxy;

        static Load(InName: string): RuntimeVirtualTextureStreamingProxy;
    }

    export class RuntimeVirtualTexture extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TileCount: number;
        TileSize: number;
        TileBorderSize: number;
        MaterialType: ERuntimeVirtualTextureMaterialType;
        bCompressTextures: boolean;
        bClearTextures: boolean;
        bSinglePhysicalSpace: boolean;
        bPrivateSpace: boolean;
        bAdaptive: boolean;
        bContinuousUpdate: boolean;
        RemoveLowMips: number;
        LODGroup: TextureGroup;
        Size: number;
        StreamingTexture: RuntimeVirtualTextureStreamingProxy;

        GetPageTableSize(): number;

        GetSize(): number;

        GetTileBorderSize(): number;

        GetTileCount(): number;

        GetTileSize(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTexture;

        static Load(InName: string): RuntimeVirtualTexture;
    }

    export enum ERuntimeVirtualTextureMainPassType { Never, Exclusive, Always, ERuntimeVirtualTextureMainPassType_MAX }

    export class BodyInstanceCore {
        constructor();
        constructor(bSimulatePhysics: boolean, bOverrideMass: boolean, bEnableGravity: boolean, bAutoWeld: boolean, bStartAwake: boolean, bGenerateWakeEvents: boolean, bUpdateMassWhenScaleChanges: boolean);

        bSimulatePhysics: boolean;
        bOverrideMass: boolean;
        bEnableGravity: boolean;
        bAutoWeld: boolean;
        bStartAwake: boolean;
        bGenerateWakeEvents: boolean;
        bUpdateMassWhenScaleChanges: boolean;

        static StaticClass(): Class;
    }

    export enum ECollisionChannel {
        ECC_WorldStatic,
        ECC_WorldDynamic,
        ECC_Pawn,
        ECC_Visibility,
        ECC_Camera,
        ECC_PhysicsBody,
        ECC_Vehicle,
        ECC_Destructible,
        ECC_EngineTraceChannel1,
        ECC_EngineTraceChannel2,
        ECC_EngineTraceChannel3,
        ECC_EngineTraceChannel4,
        ECC_EngineTraceChannel5,
        ECC_EngineTraceChannel6,
        ECC_GameTraceChannel1,
        ECC_GameTraceChannel2,
        ECC_GameTraceChannel3,
        ECC_GameTraceChannel4,
        ECC_GameTraceChannel5,
        ECC_GameTraceChannel6,
        ECC_GameTraceChannel7,
        ECC_GameTraceChannel8,
        ECC_GameTraceChannel9,
        ECC_GameTraceChannel10,
        ECC_GameTraceChannel11,
        ECC_GameTraceChannel12,
        ECC_GameTraceChannel13,
        ECC_GameTraceChannel14,
        ECC_GameTraceChannel15,
        ECC_GameTraceChannel16,
        ECC_GameTraceChannel17,
        ECC_GameTraceChannel18,
        ECC_OverlapAll_Deprecated,
        ECC_MAX
    }

    export enum ECollisionEnabled { NoCollision, QueryOnly, PhysicsOnly, QueryAndPhysics, ECollisionEnabled_MAX }

    export enum ESleepFamily { Normal, Sensitive, Custom, ESleepFamily_MAX }

    export enum EDOFMode { Default, SixDOF, YZPlane, XZPlane, XYPlane, CustomPlane, None, EDOFMode_MAX }

    export enum ECollisionResponse { ECR_Ignore, ECR_Overlap, ECR_Block, ECR_MAX }

    export class CollisionResponseContainer {
        constructor();
        constructor(WorldStatic: ECollisionResponse, WorldDynamic: ECollisionResponse, Pawn: ECollisionResponse, Visibility: ECollisionResponse, Camera: ECollisionResponse, PhysicsBody: ECollisionResponse, Vehicle: ECollisionResponse, Destructible: ECollisionResponse, EngineTraceChannel1: ECollisionResponse, EngineTraceChannel2: ECollisionResponse, EngineTraceChannel3: ECollisionResponse, EngineTraceChannel4: ECollisionResponse, EngineTraceChannel5: ECollisionResponse, EngineTraceChannel6: ECollisionResponse, GameTraceChannel1: ECollisionResponse, GameTraceChannel2: ECollisionResponse, GameTraceChannel3: ECollisionResponse, GameTraceChannel4: ECollisionResponse, GameTraceChannel5: ECollisionResponse, GameTraceChannel6: ECollisionResponse, GameTraceChannel7: ECollisionResponse, GameTraceChannel8: ECollisionResponse, GameTraceChannel9: ECollisionResponse, GameTraceChannel10: ECollisionResponse, GameTraceChannel11: ECollisionResponse, GameTraceChannel12: ECollisionResponse, GameTraceChannel13: ECollisionResponse, GameTraceChannel14: ECollisionResponse, GameTraceChannel15: ECollisionResponse, GameTraceChannel16: ECollisionResponse, GameTraceChannel17: ECollisionResponse, GameTraceChannel18: ECollisionResponse);

        WorldStatic: ECollisionResponse;
        WorldDynamic: ECollisionResponse;
        Pawn: ECollisionResponse;
        Visibility: ECollisionResponse;
        Camera: ECollisionResponse;
        PhysicsBody: ECollisionResponse;
        Vehicle: ECollisionResponse;
        Destructible: ECollisionResponse;
        EngineTraceChannel1: ECollisionResponse;
        EngineTraceChannel2: ECollisionResponse;
        EngineTraceChannel3: ECollisionResponse;
        EngineTraceChannel4: ECollisionResponse;
        EngineTraceChannel5: ECollisionResponse;
        EngineTraceChannel6: ECollisionResponse;
        GameTraceChannel1: ECollisionResponse;
        GameTraceChannel2: ECollisionResponse;
        GameTraceChannel3: ECollisionResponse;
        GameTraceChannel4: ECollisionResponse;
        GameTraceChannel5: ECollisionResponse;
        GameTraceChannel6: ECollisionResponse;
        GameTraceChannel7: ECollisionResponse;
        GameTraceChannel8: ECollisionResponse;
        GameTraceChannel9: ECollisionResponse;
        GameTraceChannel10: ECollisionResponse;
        GameTraceChannel11: ECollisionResponse;
        GameTraceChannel12: ECollisionResponse;
        GameTraceChannel13: ECollisionResponse;
        GameTraceChannel14: ECollisionResponse;
        GameTraceChannel15: ECollisionResponse;
        GameTraceChannel16: ECollisionResponse;
        GameTraceChannel17: ECollisionResponse;
        GameTraceChannel18: ECollisionResponse;

        static StaticClass(): Class;
    }

    export class ResponseChannel {
        constructor();
        constructor(Channel: string, Response: ECollisionResponse);

        Channel: string;
        Response: ECollisionResponse;

        static StaticClass(): Class;
    }

    export class CollisionResponse {
        constructor();
        constructor(ResponseToChannels: CollisionResponseContainer, ResponseArray: TArray<ResponseChannel>);

        ResponseToChannels: CollisionResponseContainer;
        ResponseArray: TArray<ResponseChannel>;

        static StaticClass(): Class;
    }

    export enum EWalkableSlopeBehavior {
        WalkableSlope_Default,
        WalkableSlope_Increase,
        WalkableSlope_Decrease,
        WalkableSlope_Unwalkable,
        WalkableSlope_Max,
        WalkableSlope_MAX
    }

    export class WalkableSlopeOverride {
        constructor();
        constructor(WalkableSlopeBehavior: EWalkableSlopeBehavior, WalkableSlopeAngle: number);

        WalkableSlopeBehavior: EWalkableSlopeBehavior;
        WalkableSlopeAngle: number;

        static StaticClass(): Class;
    }

    export enum EFrictionCombineMode { Average, Min, Multiply, Max, EFrictionCombineMode_MAX }

    export class PhysicalMaterialPropertyBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialPropertyBase;

        static Load(InName: string): PhysicalMaterialPropertyBase;
    }

    export enum EPhysicalSurface {
        SurfaceType_Default,
        SurfaceType1,
        SurfaceType2,
        SurfaceType3,
        SurfaceType4,
        SurfaceType5,
        SurfaceType6,
        SurfaceType7,
        SurfaceType8,
        SurfaceType9,
        SurfaceType10,
        SurfaceType11,
        SurfaceType12,
        SurfaceType13,
        SurfaceType14,
        SurfaceType15,
        SurfaceType16,
        SurfaceType17,
        SurfaceType18,
        SurfaceType19,
        SurfaceType20,
        SurfaceType21,
        SurfaceType22,
        SurfaceType23,
        SurfaceType24,
        SurfaceType25,
        SurfaceType26,
        SurfaceType27,
        SurfaceType28,
        SurfaceType29,
        SurfaceType30,
        SurfaceType31,
        SurfaceType32,
        SurfaceType33,
        SurfaceType34,
        SurfaceType35,
        SurfaceType36,
        SurfaceType37,
        SurfaceType38,
        SurfaceType39,
        SurfaceType40,
        SurfaceType41,
        SurfaceType42,
        SurfaceType43,
        SurfaceType44,
        SurfaceType45,
        SurfaceType46,
        SurfaceType47,
        SurfaceType48,
        SurfaceType49,
        SurfaceType50,
        SurfaceType51,
        SurfaceType52,
        SurfaceType53,
        SurfaceType54,
        SurfaceType55,
        SurfaceType56,
        SurfaceType57,
        SurfaceType58,
        SurfaceType59,
        SurfaceType60,
        SurfaceType61,
        SurfaceType62,
        SurfaceType_Max,
        EPhysicalSurface_MAX
    }

    export class PhysicalMaterial extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Friction: number;
        StaticFriction: number;
        FrictionCombineMode: EFrictionCombineMode;
        bOverrideFrictionCombineMode: boolean;
        Restitution: number;
        RestitutionCombineMode: EFrictionCombineMode;
        bOverrideRestitutionCombineMode: boolean;
        Density: number;
        SleepLinearVelocityThreshold: number;
        SleepAngularVelocityThreshold: number;
        SleepCounterThreshold: number;
        RaiseMassToPower: number;
        DestructibleDamageThresholdScale: number;
        PhysicalMaterialProperty: PhysicalMaterialPropertyBase;
        SurfaceType: EPhysicalSurface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicalMaterial;

        static Load(InName: string): PhysicalMaterial;
    }

    export class BodyInstance extends BodyInstanceCore {
        constructor();
        constructor(ObjectType: ECollisionChannel, CollisionEnabled: ECollisionEnabled, SleepFamily: ESleepFamily, DOFMode: EDOFMode, bUseCCD: boolean, bIgnoreAnalyticCollisions: boolean, bNotifyRigidBodyCollision: boolean, bLockTranslation: boolean, bLockRotation: boolean, bLockXTranslation: boolean, bLockYTranslation: boolean, bLockZTranslation: boolean, bLockXRotation: boolean, bLockYRotation: boolean, bLockZRotation: boolean, bOverrideMaxAngularVelocity: boolean, bOverrideMaxDepenetrationVelocity: boolean, bOverrideWalkableSlopeOnInstance: boolean, bInterpolateWhenSubStepping: boolean, ResponseToChannels: CollisionResponseContainer, CollisionProfileName: string, PositionSolverIterationCount: number, VelocitySolverIterationCount: number, CollisionResponses: CollisionResponse, MaxDepenetrationVelocity: number, MassInKgOverride: number, LinearDamping: number, AngularDamping: number, CustomDOFPlaneNormal: Vector, COMNudge: Vector, MassScale: number, InertiaTensorScale: Vector, WalkableSlopeOverride: WalkableSlopeOverride, PhysMaterialOverride: PhysicalMaterial, MaxAngularVelocity: number, CustomSleepThresholdMultiplier: number, StabilizationThresholdMultiplier: number, PhysicsBlendWeight: number);

        ObjectType: ECollisionChannel;
        CollisionEnabled: ECollisionEnabled;
        SleepFamily: ESleepFamily;
        DOFMode: EDOFMode;
        bUseCCD: boolean;
        bIgnoreAnalyticCollisions: boolean;
        bNotifyRigidBodyCollision: boolean;
        bLockTranslation: boolean;
        bLockRotation: boolean;
        bLockXTranslation: boolean;
        bLockYTranslation: boolean;
        bLockZTranslation: boolean;
        bLockXRotation: boolean;
        bLockYRotation: boolean;
        bLockZRotation: boolean;
        bOverrideMaxAngularVelocity: boolean;
        bOverrideMaxDepenetrationVelocity: boolean;
        bOverrideWalkableSlopeOnInstance: boolean;
        bInterpolateWhenSubStepping: boolean;
        ResponseToChannels: CollisionResponseContainer;
        CollisionProfileName: string;
        PositionSolverIterationCount: number;
        VelocitySolverIterationCount: number;
        CollisionResponses: CollisionResponse;
        MaxDepenetrationVelocity: number;
        MassInKgOverride: number;
        LinearDamping: number;
        AngularDamping: number;
        CustomDOFPlaneNormal: Vector;
        COMNudge: Vector;
        MassScale: number;
        InertiaTensorScale: Vector;
        WalkableSlopeOverride: WalkableSlopeOverride;
        PhysMaterialOverride: PhysicalMaterial;
        MaxAngularVelocity: number;
        CustomSleepThresholdMultiplier: number;
        StabilizationThresholdMultiplier: number;
        PhysicsBlendWeight: number;

        static StaticClass(): Class;
    }

    export class Vector_NetQuantize extends Vector {
        constructor();

        static StaticClass(): Class;
    }

    export class Vector_NetQuantizeNormal extends Vector {
        constructor();

        static StaticClass(): Class;
    }

    export class HitResult {
        constructor();
        constructor(bBlockingHit: boolean, bStartPenetrating: boolean, FaceIndex: number, Time: number, Distance: number, Location: Vector_NetQuantize, ImpactPoint: Vector_NetQuantize, Normal: Vector_NetQuantizeNormal, ImpactNormal: Vector_NetQuantizeNormal, TraceStart: Vector_NetQuantize, TraceEnd: Vector_NetQuantize, PenetrationDepth: number, Item: number, ElementIndex: number, PhysMaterial: TWeakObjectPtr<PhysicalMaterial>, Actor: TWeakObjectPtr<Actor>, Component: TWeakObjectPtr<PrimitiveComponent>, BoneName: string, MyBoneName: string);

        bBlockingHit: boolean;
        bStartPenetrating: boolean;
        FaceIndex: number;
        Time: number;
        Distance: number;
        Location: Vector_NetQuantize;
        ImpactPoint: Vector_NetQuantize;
        Normal: Vector_NetQuantizeNormal;
        ImpactNormal: Vector_NetQuantizeNormal;
        TraceStart: Vector_NetQuantize;
        TraceEnd: Vector_NetQuantize;
        PenetrationDepth: number;
        Item: number;
        ElementIndex: number;
        PhysMaterial: TWeakObjectPtr<PhysicalMaterial>;
        Actor: TWeakObjectPtr<Actor>;
        Component: TWeakObjectPtr<PrimitiveComponent>;
        BoneName: string;
        MyBoneName: string;

        static StaticClass(): Class;
    }

    export class Key {
        constructor();
        constructor(KeyName: string);

        KeyName: string;

        static StaticClass(): Class;
    }

    export enum ETouchIndex {
        Touch1,
        Touch2,
        Touch3,
        Touch4,
        Touch5,
        Touch6,
        Touch7,
        Touch8,
        Touch9,
        Touch10,
        CursorPointerIndex,
        MAX_TOUCHES,
        ETouchIndex_MAX
    }

    export class SubsurfaceProfileStruct {
        constructor();
        constructor(SurfaceAlbedo: LinearColor, MeanFreePathColor: LinearColor, MeanFreePathDistance: number, WorldUnitScale: number, bEnableBurley: boolean, ScatterRadius: number, SubsurfaceColor: LinearColor, FalloffColor: LinearColor, BoundaryColorBleed: LinearColor, ExtinctionScale: number, NormalScale: number, ScatteringDistribution: number, IOR: number, Roughness0: number, Roughness1: number, LobeMix: number, TransmissionTintColor: LinearColor);

        SurfaceAlbedo: LinearColor;
        MeanFreePathColor: LinearColor;
        MeanFreePathDistance: number;
        WorldUnitScale: number;
        bEnableBurley: boolean;
        ScatterRadius: number;
        SubsurfaceColor: LinearColor;
        FalloffColor: LinearColor;
        BoundaryColorBleed: LinearColor;
        ExtinctionScale: number;
        NormalScale: number;
        ScatteringDistribution: number;
        IOR: number;
        Roughness0: number;
        Roughness1: number;
        LobeMix: number;
        TransmissionTintColor: LinearColor;

        static StaticClass(): Class;
    }

    export class SubsurfaceProfile extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: SubsurfaceProfileStruct;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfile;

        static Load(InName: string): SubsurfaceProfile;
    }

    export class LightmassMaterialInterfaceSettings {
        constructor();
        constructor(EmissiveBoost: number, DiffuseBoost: number, ExportResolutionScale: number, bCastShadowAsMasked: boolean, bOverrideCastShadowAsMasked: boolean, bOverrideEmissiveBoost: boolean, bOverrideDiffuseBoost: boolean, bOverrideExportResolutionScale: boolean);

        EmissiveBoost: number;
        DiffuseBoost: number;
        ExportResolutionScale: number;
        bCastShadowAsMasked: boolean;
        bOverrideCastShadowAsMasked: boolean;
        bOverrideEmissiveBoost: boolean;
        bOverrideDiffuseBoost: boolean;
        bOverrideExportResolutionScale: boolean;

        static StaticClass(): Class;
    }

    export class SoftObjectPath {
        constructor();
        constructor(AssetPathName: string, SubPathString: string);

        AssetPathName: string;
        SubPathString: string;

        static StaticClass(): Class;
    }

    export class MaterialTextureInfo {
        constructor();
        constructor(SamplingScale: number, UVChannelIndex: number, TextureName: string, TextureReference: SoftObjectPath, TextureIndex: number);

        SamplingScale: number;
        UVChannelIndex: number;
        TextureName: string;
        TextureReference: SoftObjectPath;
        TextureIndex: number;

        static StaticClass(): Class;
    }

    export class ThumbnailInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ThumbnailInfo;

        static Load(InName: string): ThumbnailInfo;
    }

    export class PhysicalMaterialMask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssetImportData: AssetImportData;
        MaskTexture: Texture;
        UVChannelIndex: number;
        AddressX: TextureAddress;
        AddressY: TextureAddress;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialMask;

        static Load(InName: string): PhysicalMaterialMask;
    }

    export enum EMaterialParameterAssociation {
        LayerParameter,
        BlendParameter,
        GlobalParameter,
        EMaterialParameterAssociation_MAX
    }

    export enum EMaterialFunctionUsage { Default, MaterialLayer, MaterialLayerBlend, EMaterialFunctionUsage_MAX }

    export class MaterialFunctionInterface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StateId: Guid;
        MaterialFunctionUsage: EMaterialFunctionUsage;
        CombinedInputTypes: number;
        CombinedOutputTypes: number;
        ThumbnailInfo: ThumbnailInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInterface;

        static Load(InName: string): MaterialFunctionInterface;
    }

    export class MaterialParameterInfo {
        constructor();
        constructor(Name: string, Association: EMaterialParameterAssociation, Index: number, ParameterLocation: SoftObjectPath);

        Name: string;
        Association: EMaterialParameterAssociation;
        Index: number;
        ParameterLocation: SoftObjectPath;

        static StaticClass(): Class;
    }

    export enum EEdGraphPinDirection { EGPD_Input, EGPD_Output, EGPD_MAX }

    export class EdGraphTerminalType {
        constructor();
        constructor(TerminalCategory: string, TerminalSubCategory: string, TerminalSubCategoryObject: TWeakObjectPtr<Object>, bTerminalIsConst: boolean, bTerminalIsWeakPointer: boolean, bTerminalIsUObjectWrapper: boolean);

        TerminalCategory: string;
        TerminalSubCategory: string;
        TerminalSubCategoryObject: TWeakObjectPtr<Object>;
        bTerminalIsConst: boolean;
        bTerminalIsWeakPointer: boolean;
        bTerminalIsUObjectWrapper: boolean;

        static StaticClass(): Class;
    }

    export enum EPinContainerType { None, Array, Set, Map, EPinContainerType_MAX }

    export class EdGraphPinType {
        constructor();
        constructor(PinCategory: string, PinSubCategory: string, PinSubCategoryObject: TWeakObjectPtr<Object>, PinSubCategoryMemberReference: SimpleMemberReference, PinValueType: EdGraphTerminalType, ContainerType: EPinContainerType, bIsArray: boolean, bIsReference: boolean, bIsConst: boolean, bIsWeakPointer: boolean, bIsUObjectWrapper: boolean);

        PinCategory: string;
        PinSubCategory: string;
        PinSubCategoryObject: TWeakObjectPtr<Object>;
        PinSubCategoryMemberReference: SimpleMemberReference;
        PinValueType: EdGraphTerminalType;
        ContainerType: EPinContainerType;
        bIsArray: boolean;
        bIsReference: boolean;
        bIsConst: boolean;
        bIsWeakPointer: boolean;
        bIsUObjectWrapper: boolean;

        static StaticClass(): Class;
    }

    export class EdGraphPin_Deprecated extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PinName: string;
        PinFriendlyName: string;
        PinToolTip: string;
        Direction: EEdGraphPinDirection;
        PinType: EdGraphPinType;
        DefaultValue: string;
        AutogeneratedDefaultValue: string;
        DefaultObject: Object;
        DefaultTextValue: string;
        LinkedTo: TArray<EdGraphPin_Deprecated>;
        SubPins: TArray<EdGraphPin_Deprecated>;
        ParentPin: EdGraphPin_Deprecated;
        ReferencePassThroughConnection: EdGraphPin_Deprecated;
        bHidden: boolean;
        bNotConnectable: boolean;
        bDefaultValueIsReadOnly: boolean;
        bDefaultValueIsIgnored: boolean;
        bIsDiffing: boolean;
        bAdvancedView: boolean;
        bDisplayAsMutableRef: boolean;
        PersistentGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphPin_Deprecated;

        static Load(InName: string): EdGraphPin_Deprecated;
    }

    export enum ENodeAdvancedPins { NoPins, Shown, Hidden, ENodeAdvancedPins_MAX }

    export enum ENodeEnabledState { Enabled, Disabled, DevelopmentOnly, ENodeEnabledState_MAX }

    export class EdGraphNode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DeprecatedPins: TArray<EdGraphPin_Deprecated>;
        NodePosX: number;
        NodePosY: number;
        NodeWidth: number;
        NodeHeight: number;
        AdvancedPinDisplay: ENodeAdvancedPins;
        EnabledState: ENodeEnabledState;
        bDisplayAsDisabled: boolean;
        bUserSetEnabledState: boolean;
        bIsNodeEnabled: boolean;
        bCanResizeNode: boolean;
        bHasCompilerMessage: boolean;
        bCommentBubblePinned: boolean;
        bCommentBubbleVisible: boolean;
        bCommentBubbleMakeVisible: boolean;
        bCanRenameNode: boolean;
        NodeUpgradeMessage: string;
        NodeComment: string;
        ErrorType: number;
        ErrorMsg: string;
        NodeGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphNode;

        static Load(InName: string): EdGraphNode;
    }

    export class MaterialExpressionComment extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SizeX: number;
        SizeY: number;
        Text: string;
        CommentColor: LinearColor;
        FontSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionComment;

        static Load(InName: string): MaterialExpressionComment;
    }

    export class ExpressionInput {
        constructor();
        constructor(Expression: MaterialExpression, OutputIndex: number, InputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number, ExpressionName: string);

        Expression: MaterialExpression;
        OutputIndex: number;
        InputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;
        ExpressionName: string;

        static StaticClass(): Class;
    }

    export enum EFunctionInputType {
        FunctionInput_Scalar,
        FunctionInput_Vector2,
        FunctionInput_Vector3,
        FunctionInput_Vector4,
        FunctionInput_Texture2D,
        FunctionInput_TextureCube,
        FunctionInput_Texture2DArray,
        FunctionInput_VolumeTexture,
        FunctionInput_StaticBool,
        FunctionInput_MaterialAttributes,
        FunctionInput_TextureExternal,
        FunctionInput_MAX
    }

    export class MaterialExpressionFunctionInput extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Preview: ExpressionInput;
        InputName: string;
        Description: string;
        Id: Guid;
        InputType: EFunctionInputType;
        PreviewValue: Vector4;
        bUsePreviewValueAsDefault: boolean;
        SortPriority: number;
        bCompilingFunctionPreview: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFunctionInput;

        static Load(InName: string): MaterialExpressionFunctionInput;
    }

    export class FunctionExpressionInput {
        constructor();
        constructor(ExpressionInput: MaterialExpressionFunctionInput, ExpressionInputId: Guid, Input: ExpressionInput);

        ExpressionInput: MaterialExpressionFunctionInput;
        ExpressionInputId: Guid;
        Input: ExpressionInput;

        static StaticClass(): Class;
    }

    export class MaterialExpressionFunctionOutput extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OutputName: string;
        Description: string;
        SortPriority: number;
        A: ExpressionInput;
        bLastPreviewed: boolean;
        Id: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFunctionOutput;

        static Load(InName: string): MaterialExpressionFunctionOutput;
    }

    export class ExpressionOutput {
        constructor();
        constructor(OutputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number);

        OutputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;

        static StaticClass(): Class;
    }

    export class FunctionExpressionOutput {
        constructor();
        constructor(ExpressionOutput: MaterialExpressionFunctionOutput, ExpressionOutputId: Guid, Output: ExpressionOutput);

        ExpressionOutput: MaterialExpressionFunctionOutput;
        ExpressionOutputId: Guid;
        Output: ExpressionOutput;

        static StaticClass(): Class;
    }

    export class MaterialExpressionMaterialFunctionCall extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialFunction: MaterialFunctionInterface;
        FunctionInputs: TArray<FunctionExpressionInput>;
        FunctionOutputs: TArray<FunctionExpressionOutput>;
        FunctionParameterInfo: MaterialParameterInfo;

        SetMaterialFunction(NewMaterialFunction: $Nullable<MaterialFunctionInterface>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialFunctionCall;

        static Load(InName: string): MaterialExpressionMaterialFunctionCall;
    }

    export class MaterialFunction extends MaterialFunctionInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParentFunction: MaterialFunction;
        Description: string;
        FunctionExpressions: TArray<MaterialExpression>;
        bExposeToLibrary: boolean;
        bPrefixParameterNames: boolean;
        LibraryCategories: TArray<string>;
        LibraryCategoriesText: TArray<string>;
        FunctionEditorComments: TArray<MaterialExpressionComment>;
        PreviewMaterial: Material;
        DependentFunctionExpressionCandidates: TArray<MaterialExpressionMaterialFunctionCall>;
        bReentrantFlag: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunction;

        static Load(InName: string): MaterialFunction;
    }

    export class MaterialExpression extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialExpressionEditorX: number;
        MaterialExpressionEditorY: number;
        GraphNode: EdGraphNode;
        MaterialExpressionGuid: Guid;
        Material: Material;
        Function: MaterialFunction;
        Desc: string;
        bRealtimePreview: boolean;
        bNeedToUpdatePreview: boolean;
        bIsParameterExpression: boolean;
        bCommentBubbleVisible: boolean;
        bShowOutputNameOnPin: boolean;
        bShowMaskColorsOnPin: boolean;
        bHidePreviewWindow: boolean;
        bCollapsed: boolean;
        bShaderInputData: boolean;
        bShowInputs: boolean;
        bShowOutputs: boolean;
        MenuCategories: TArray<string>;
        Outputs: TArray<ExpressionOutput>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpression;

        static Load(InName: string): MaterialExpression;
    }

    export class MaterialInput {
        constructor();
        constructor(Expression: MaterialExpression, OutputIndex: number, InputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number, ExpressionName: string);

        Expression: MaterialExpression;
        OutputIndex: number;
        InputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;
        ExpressionName: string;

        static StaticClass(): Class;
    }

    export class ColorMaterialInput extends MaterialInput {
        constructor();
        constructor(UseConstant: boolean, Constant: Color);

        UseConstant: boolean;
        Constant: Color;

        static StaticClass(): Class;
    }

    export class ScalarMaterialInput extends MaterialInput {
        constructor();
        constructor(UseConstant: boolean, Constant: number);

        UseConstant: boolean;
        Constant: number;

        static StaticClass(): Class;
    }

    export class VectorMaterialInput extends MaterialInput {
        constructor();
        constructor(UseConstant: boolean, Constant: Vector);

        UseConstant: boolean;
        Constant: Vector;

        static StaticClass(): Class;
    }

    export enum EMaterialDomain {
        MD_Surface,
        MD_DeferredDecal,
        MD_LightFunction,
        MD_Volume,
        MD_PostProcess,
        MD_UI,
        MD_RuntimeVirtualTexture,
        MD_MAX
    }

    export enum EBlendMode {
        BLEND_Opaque,
        BLEND_Masked,
        BLEND_Translucent,
        BLEND_Additive,
        BLEND_Modulate,
        BLEND_AlphaComposite,
        BLEND_AlphaHoldout,
        BLEND_AdditiveWithAlpha,
        BLEND_MAX
    }

    export enum EDecalBlendMode {
        DBM_Translucent,
        DBM_Stain,
        DBM_Normal,
        DBM_Emissive,
        DBM_DBuffer_ColorNormalRoughness,
        DBM_DBuffer_Color,
        DBM_DBuffer_ColorNormal,
        DBM_DBuffer_ColorRoughness,
        DBM_DBuffer_Normal,
        DBM_DBuffer_NormalRoughness,
        DBM_DBuffer_Roughness,
        DBM_DBuffer_Emissive,
        DBM_DBuffer_AlphaComposite,
        DBM_DBuffer_EmissiveAlphaComposite,
        DBM_Volumetric_DistanceFunction,
        DBM_AlphaComposite,
        DBM_AmbientOcclusion,
        DBM_MAX
    }

    export enum EMaterialDecalResponse {
        MDR_None,
        MDR_ColorNormalRoughness,
        MDR_Color,
        MDR_ColorNormal,
        MDR_ColorRoughness,
        MDR_Normal,
        MDR_NormalRoughness,
        MDR_Roughness,
        MDR_MAX
    }

    export enum EMaterialShadingModel {
        MSM_Unlit,
        MSM_DefaultLit,
        MSM_Subsurface,
        MSM_PreintegratedSkin,
        MSM_ClearCoat,
        MSM_SubsurfaceProfile,
        MSM_TwoSidedFoliage,
        MSM_Hair,
        MSM_Cloth,
        MSM_Eye,
        MSM_SingleLayerWater,
        MSM_ThinTranslucent,
        MSM_NUM,
        MSM_FromMaterialExpression,
        MSM_MAX
    }

    export class MaterialShadingModelField {
        constructor();
        constructor(ShadingModelField: number);

        ShadingModelField: number;

        static StaticClass(): Class;
    }

    export class Vector2MaterialInput extends MaterialInput {
        constructor();
        constructor(UseConstant: boolean, ConstantX: number, ConstantY: number);

        UseConstant: boolean;
        ConstantX: number;
        ConstantY: number;

        static StaticClass(): Class;
    }

    export class MaterialAttributesInput extends ExpressionInput {
        constructor();
        constructor(PropertyConnectedBitmask: number);

        PropertyConnectedBitmask: number;

        static StaticClass(): Class;
    }

    export class ShadingModelMaterialInput extends MaterialInput {
        constructor();

        static StaticClass(): Class;
    }

    export enum ETranslucencyLightingMode {
        TLM_VolumetricNonDirectional,
        TLM_VolumetricDirectional,
        TLM_VolumetricPerVertexNonDirectional,
        TLM_VolumetricPerVertexDirectional,
        TLM_Surface,
        TLM_SurfacePerPixelLighting,
        TLM_MAX
    }

    export enum EMaterialTessellationMode { MTM_NoTessellation, MTM_FlatTessellation, MTM_PNTriangles, MTM_MAX }

    export enum EMaterialShadingRate {
        MSR_1x1,
        MSR_2x1,
        MSR_1x2,
        MSR_2x2,
        MSR_4x2,
        MSR_2x4,
        MSR_4x4,
        MSR_Count,
        MSR_MAX
    }

    export class ParameterGroupData {
        constructor();
        constructor(GroupName: string, GroupSortPriority: number);

        GroupName: string;
        GroupSortPriority: number;

        static StaticClass(): Class;
    }

    export enum EBlendableLocation {
        BL_AfterTonemapping,
        BL_BeforeTonemapping,
        BL_BeforeTranslucency,
        BL_ReplacingTonemapper,
        BL_SSRInput,
        BL_MAX
    }

    export enum EMaterialStencilCompare {
        MSC_Less,
        MSC_LessEqual,
        MSC_Greater,
        MSC_GreaterEqual,
        MSC_Equal,
        MSC_NotEqual,
        MSC_Never,
        MSC_Always,
        MSC_Count,
        MSC_MAX
    }

    export enum ERefractionMode { RM_IndexOfRefraction, RM_PixelNormalOffset, RM_MAX }

    export class MaterialCachedParameterEntry {
        constructor();
        constructor(NameHashes: TArray<bigint>, ParameterInfos: TArray<MaterialParameterInfo>, ExpressionGuids: TArray<Guid>, Overrides: TArray<boolean>);

        NameHashes: TArray<bigint>;
        ParameterInfos: TArray<MaterialParameterInfo>;
        ExpressionGuids: TArray<Guid>;
        Overrides: TArray<boolean>;

        static StaticClass(): Class;
    }

    export enum EFontCacheType { Offline, Runtime, EFontCacheType_MAX }

    export class FontCharacter {
        constructor();
        constructor(StartU: number, StartV: number, USize: number, VSize: number, TextureIndex: number, VerticalOffset: number);

        StartU: number;
        StartV: number;
        USize: number;
        VSize: number;
        TextureIndex: number;
        VerticalOffset: number;

        static StaticClass(): Class;
    }

    export enum EFontImportCharacterSet { FontICS_Default, FontICS_Ansi, FontICS_Symbol, FontICS_MAX }

    export class FontImportOptionsData {
        constructor();
        constructor(FontName: string, Height: number, bEnableAntialiasing: boolean, bEnableBold: boolean, bEnableItalic: boolean, bEnableUnderline: boolean, bAlphaOnly: boolean, CharacterSet: EFontImportCharacterSet, Chars: string, UnicodeRange: string, CharsFilePath: string, CharsFileWildcard: string, bCreatePrintableOnly: boolean, bIncludeASCIIRange: boolean, ForegroundColor: LinearColor, bEnableDropShadow: boolean, TexturePageWidth: number, TexturePageMaxHeight: number, XPadding: number, YPadding: number, ExtendBoxTop: number, ExtendBoxBottom: number, ExtendBoxRight: number, ExtendBoxLeft: number, bEnableLegacyMode: boolean, Kerning: number, bUseDistanceFieldAlpha: boolean, DistanceFieldScaleFactor: number, DistanceFieldScanRadiusScale: number);

        FontName: string;
        Height: number;
        bEnableAntialiasing: boolean;
        bEnableBold: boolean;
        bEnableItalic: boolean;
        bEnableUnderline: boolean;
        bAlphaOnly: boolean;
        CharacterSet: EFontImportCharacterSet;
        Chars: string;
        UnicodeRange: string;
        CharsFilePath: string;
        CharsFileWildcard: string;
        bCreatePrintableOnly: boolean;
        bIncludeASCIIRange: boolean;
        ForegroundColor: LinearColor;
        bEnableDropShadow: boolean;
        TexturePageWidth: number;
        TexturePageMaxHeight: number;
        XPadding: number;
        YPadding: number;
        ExtendBoxTop: number;
        ExtendBoxBottom: number;
        ExtendBoxRight: number;
        ExtendBoxLeft: number;
        bEnableLegacyMode: boolean;
        Kerning: number;
        bUseDistanceFieldAlpha: boolean;
        DistanceFieldScaleFactor: number;
        DistanceFieldScanRadiusScale: number;

        static StaticClass(): Class;
    }

    export enum EFontHinting { Default, Auto, AutoLight, Monochrome, None, EFontHinting_MAX }

    export enum EFontLoadingPolicy { LazyLoad, Stream, Inline, EFontLoadingPolicy_MAX }

    export class FontBulkData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FontBulkData;

        static Load(InName: string): FontBulkData;
    }

    export class FontData {
        constructor();
        constructor(FontFilename: string, Hinting: EFontHinting, LoadingPolicy: EFontLoadingPolicy, SubFaceIndex: number, FontFaceAsset: Object, BulkDataPtr: FontBulkData, FontData: TArray<number>);

        FontFilename: string;
        Hinting: EFontHinting;
        LoadingPolicy: EFontLoadingPolicy;
        SubFaceIndex: number;
        FontFaceAsset: Object;
        BulkDataPtr: FontBulkData;
        FontData: TArray<number>;

        static StaticClass(): Class;
    }

    export class TypefaceEntry {
        constructor();
        constructor(Name: string, Font: FontData);

        Name: string;
        Font: FontData;

        static StaticClass(): Class;
    }

    export class Typeface {
        constructor();
        constructor(Fonts: TArray<TypefaceEntry>);

        Fonts: TArray<TypefaceEntry>;

        static StaticClass(): Class;
    }

    export class CompositeFallbackFont {
        constructor();
        constructor(Typeface: Typeface, ScalingFactor: number);

        Typeface: Typeface;
        ScalingFactor: number;

        static StaticClass(): Class;
    }

    export enum ERangeBoundTypes { Exclusive, Inclusive, Open, ERangeBoundTypes_MAX }

    export class Int32RangeBound {
        constructor();
        constructor(Type: ERangeBoundTypes, Value: number);

        Type: ERangeBoundTypes;
        Value: number;

        static StaticClass(): Class;
    }

    export class Int32Range {
        constructor();
        constructor(LowerBound: Int32RangeBound, UpperBound: Int32RangeBound);

        LowerBound: Int32RangeBound;
        UpperBound: Int32RangeBound;

        static StaticClass(): Class;
    }

    export class CompositeSubFont extends CompositeFallbackFont {
        constructor();
        constructor(CharacterRanges: TArray<Int32Range>, Cultures: string, EditorName: string);

        CharacterRanges: TArray<Int32Range>;
        Cultures: string;
        EditorName: string;

        static StaticClass(): Class;
    }

    export class CompositeFont {
        constructor();
        constructor(DefaultTypeface: Typeface, FallbackTypeface: CompositeFallbackFont, SubTypefaces: TArray<CompositeSubFont>);

        DefaultTypeface: Typeface;
        FallbackTypeface: CompositeFallbackFont;
        SubTypefaces: TArray<CompositeSubFont>;

        static StaticClass(): Class;
    }

    export class Font extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FontCacheType: EFontCacheType;
        Characters: TArray<FontCharacter>;
        Textures: TArray<Texture2D>;
        IsRemapped: number;
        EmScale: number;
        Ascent: number;
        Descent: number;
        Leading: number;
        Kerning: number;
        ImportOptions: FontImportOptionsData;
        NumCharacters: number;
        MaxCharHeight: TArray<number>;
        ScalingFactor: number;
        LegacyFontSize: number;
        LegacyFontName: string;
        CompositeFont: CompositeFont;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Font;

        static Load(InName: string): Font;
    }

    export class StaticComponentMaskValue {
        constructor();
        constructor(R: boolean, G: boolean, B: boolean, A: boolean);

        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;

        static StaticClass(): Class;
    }

    export class CurveBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssetImportData: AssetImportData;
        ImportPath: string;

        GetTimeRange(MinTime: $Ref<number>, MaxTime: $Ref<number>): void;

        GetValueRange(MinValue: $Ref<number>, MaxValue: $Ref<number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveBase;

        static Load(InName: string): CurveBase;
    }

    export class KeyHandleMap {
        constructor();

        static StaticClass(): Class;
    }

    export class IndexedCurve {
        constructor();
        constructor(KeyHandlesToIndices: KeyHandleMap);

        KeyHandlesToIndices: KeyHandleMap;

        static StaticClass(): Class;
    }

    export enum ERichCurveExtrapolation {
        RCCE_Cycle,
        RCCE_CycleWithOffset,
        RCCE_Oscillate,
        RCCE_Linear,
        RCCE_Constant,
        RCCE_None,
        RCCE_MAX
    }

    export class RealCurve extends IndexedCurve {
        constructor();
        constructor(DefaultValue: number, PreInfinityExtrap: ERichCurveExtrapolation, PostInfinityExtrap: ERichCurveExtrapolation);

        DefaultValue: number;
        PreInfinityExtrap: ERichCurveExtrapolation;
        PostInfinityExtrap: ERichCurveExtrapolation;

        static StaticClass(): Class;
    }

    export enum ERichCurveInterpMode { RCIM_Linear, RCIM_Constant, RCIM_Cubic, RCIM_None, RCIM_MAX }

    export enum ERichCurveTangentMode { RCTM_Auto, RCTM_User, RCTM_Break, RCTM_None, RCTM_MAX }

    export enum ERichCurveTangentWeightMode {
        RCTWM_WeightedNone,
        RCTWM_WeightedArrive,
        RCTWM_WeightedLeave,
        RCTWM_WeightedBoth,
        RCTWM_MAX
    }

    export class RichCurveKey {
        constructor();
        constructor(InterpMode: ERichCurveInterpMode, TangentMode: ERichCurveTangentMode, TangentWeightMode: ERichCurveTangentWeightMode, Time: number, Value: number, ArriveTangent: number, ArriveTangentWeight: number, LeaveTangent: number, LeaveTangentWeight: number);

        InterpMode: ERichCurveInterpMode;
        TangentMode: ERichCurveTangentMode;
        TangentWeightMode: ERichCurveTangentWeightMode;
        Time: number;
        Value: number;
        ArriveTangent: number;
        ArriveTangentWeight: number;
        LeaveTangent: number;
        LeaveTangentWeight: number;

        static StaticClass(): Class;
    }

    export class RichCurve extends RealCurve {
        constructor();
        constructor(Keys: TArray<RichCurveKey>);

        Keys: TArray<RichCurveKey>;

        static StaticClass(): Class;
    }

    export class CurveLinearColor extends CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatCurves: FixSizeArray<RichCurve>;
        AdjustHue: number;
        AdjustSaturation: number;
        AdjustBrightness: number;
        AdjustBrightnessCurve: number;
        AdjustVibrance: number;
        AdjustMinAlpha: number;
        AdjustMaxAlpha: number;

        GetClampedLinearColorValue(InTime: number): LinearColor;

        GetLinearColorValue(InTime: number): LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveLinearColor;

        static Load(InName: string): CurveLinearColor;
    }

    export class CurveLinearColorAtlas extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsDirty: boolean;
        TextureSize: number;
        GradientCurves: TArray<CurveLinearColor>;

        GetCurvePosition(InCurve: $Nullable<CurveLinearColor>, Position: $Ref<number>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveLinearColorAtlas;

        static Load(InName: string): CurveLinearColorAtlas;
    }

    export class ParameterChannelNames {
        constructor();
        constructor(R: string, G: string, B: string, A: string);

        R: string;
        G: string;
        B: string;
        A: string;

        static StaticClass(): Class;
    }

    export class MaterialCachedParameters {
        constructor();
        constructor(RuntimeEntries: FixSizeArray<MaterialCachedParameterEntry>, ScalarValues: TArray<number>, VectorValues: TArray<LinearColor>, TextureValues: TArray<Texture>, FontValues: TArray<Font>, FontPageValues: TArray<number>, RuntimeVirtualTextureValues: TArray<RuntimeVirtualTexture>, EditorOnlyEntries: FixSizeArray<MaterialCachedParameterEntry>, StaticSwitchValues: TArray<boolean>, StaticComponentMaskValues: TArray<StaticComponentMaskValue>, ScalarMinMaxValues: TArray<Vector2D>, ScalarCurveValues: TArray<CurveLinearColor>, ScalarCurveAtlasValues: TArray<CurveLinearColorAtlas>, VectorChannelNameValues: TArray<ParameterChannelNames>, VectorUsedAsChannelMaskValues: TArray<boolean>, TextureChannelNameValues: TArray<ParameterChannelNames>);

        RuntimeEntries: FixSizeArray<MaterialCachedParameterEntry>;
        ScalarValues: TArray<number>;
        VectorValues: TArray<LinearColor>;
        TextureValues: TArray<Texture>;
        FontValues: TArray<Font>;
        FontPageValues: TArray<number>;
        RuntimeVirtualTextureValues: TArray<RuntimeVirtualTexture>;
        EditorOnlyEntries: FixSizeArray<MaterialCachedParameterEntry>;
        StaticSwitchValues: TArray<boolean>;
        StaticComponentMaskValues: TArray<StaticComponentMaskValue>;
        ScalarMinMaxValues: TArray<Vector2D>;
        ScalarCurveValues: TArray<CurveLinearColor>;
        ScalarCurveAtlasValues: TArray<CurveLinearColorAtlas>;
        VectorChannelNameValues: TArray<ParameterChannelNames>;
        VectorUsedAsChannelMaskValues: TArray<boolean>;
        TextureChannelNameValues: TArray<ParameterChannelNames>;

        static StaticClass(): Class;
    }

    export class MaterialFunctionInfo {
        constructor();
        constructor(StateId: Guid, Function: MaterialFunctionInterface);

        StateId: Guid;
        Function: MaterialFunctionInterface;

        static StaticClass(): Class;
    }

    export class CollectionParameterBase {
        constructor();
        constructor(ParameterName: string, Id: Guid);

        ParameterName: string;
        Id: Guid;

        static StaticClass(): Class;
    }

    export class CollectionScalarParameter extends CollectionParameterBase {
        constructor();
        constructor(DefaultValue: number);

        DefaultValue: number;

        static StaticClass(): Class;
    }

    export class CollectionVectorParameter extends CollectionParameterBase {
        constructor();
        constructor(DefaultValue: LinearColor);

        DefaultValue: LinearColor;

        static StaticClass(): Class;
    }

    export class MaterialParameterCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StateId: Guid;
        ScalarParameters: TArray<CollectionScalarParameter>;
        VectorParameters: TArray<CollectionVectorParameter>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollection;

        static Load(InName: string): MaterialParameterCollection;
    }

    export class MaterialParameterCollectionInfo {
        constructor();
        constructor(StateId: Guid, ParameterCollection: MaterialParameterCollection);

        StateId: Guid;
        ParameterCollection: MaterialParameterCollection;

        static StaticClass(): Class;
    }

    export class MeshBuildSettings {
        constructor();
        constructor(bUseMikkTSpace: boolean, bRecomputeNormals: boolean, bRecomputeTangents: boolean, bComputeWeightedNormals: boolean, bRemoveDegenerates: boolean, bBuildAdjacencyBuffer: boolean, bBuildReversedIndexBuffer: boolean, bUseHighPrecisionTangentBasis: boolean, bUseFullPrecisionUVs: boolean, bGenerateLightmapUVs: boolean, bGenerateDistanceFieldAsIfTwoSided: boolean, bSupportFaceRemap: boolean, MinLightmapResolution: number, SrcLightmapIndex: number, DstLightmapIndex: number, BuildScale: number, BuildScale3D: Vector, DistanceFieldResolutionScale: number, DistanceFieldBias: number, DistanceFieldReplacementMesh: StaticMesh);

        bUseMikkTSpace: boolean;
        bRecomputeNormals: boolean;
        bRecomputeTangents: boolean;
        bComputeWeightedNormals: boolean;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bUseFullPrecisionUVs: boolean;
        bGenerateLightmapUVs: boolean;
        bGenerateDistanceFieldAsIfTwoSided: boolean;
        bSupportFaceRemap: boolean;
        MinLightmapResolution: number;
        SrcLightmapIndex: number;
        DstLightmapIndex: number;
        BuildScale: number;
        BuildScale3D: Vector;
        DistanceFieldResolutionScale: number;
        DistanceFieldBias: number;
        DistanceFieldReplacementMesh: StaticMesh;

        static StaticClass(): Class;
    }

    export enum EMeshFeatureImportance { Off, Lowest, Low, Normal, High, Highest, EMeshFeatureImportance_MAX }

    export enum EStaticMeshReductionTerimationCriterion {
        Triangles,
        Vertices,
        Any,
        EStaticMeshReductionTerimationCriterion_MAX
    }

    export class MeshReductionSettings {
        constructor();
        constructor(PercentTriangles: number, PercentVertices: number, MaxDeviation: number, PixelError: number, WeldingThreshold: number, HardAngleThreshold: number, BaseLODModel: number, SilhouetteImportance: EMeshFeatureImportance, TextureImportance: EMeshFeatureImportance, ShadingImportance: EMeshFeatureImportance, bRecalculateNormals: boolean, bGenerateUniqueLightmapUVs: boolean, bKeepSymmetry: boolean, bVisibilityAided: boolean, bCullOccluded: boolean, TerminationCriterion: EStaticMeshReductionTerimationCriterion, VisibilityAggressiveness: EMeshFeatureImportance, VertexColorImportance: EMeshFeatureImportance);

        PercentTriangles: number;
        PercentVertices: number;
        MaxDeviation: number;
        PixelError: number;
        WeldingThreshold: number;
        HardAngleThreshold: number;
        BaseLODModel: number;
        SilhouetteImportance: EMeshFeatureImportance;
        TextureImportance: EMeshFeatureImportance;
        ShadingImportance: EMeshFeatureImportance;
        bRecalculateNormals: boolean;
        bGenerateUniqueLightmapUVs: boolean;
        bKeepSymmetry: boolean;
        bVisibilityAided: boolean;
        bCullOccluded: boolean;
        TerminationCriterion: EStaticMeshReductionTerimationCriterion;
        VisibilityAggressiveness: EMeshFeatureImportance;
        VertexColorImportance: EMeshFeatureImportance;

        static StaticClass(): Class;
    }

    export class StaticMeshSourceModel {
        constructor();
        constructor(BuildSettings: MeshBuildSettings, ReductionSettings: MeshReductionSettings, LODDistance: number, ScreenSize: PerPlatformFloat, SourceImportFilename: string, bImportWithBaseMesh: boolean);

        BuildSettings: MeshBuildSettings;
        ReductionSettings: MeshReductionSettings;
        LODDistance: number;
        ScreenSize: PerPlatformFloat;
        SourceImportFilename: string;
        bImportWithBaseMesh: boolean;

        static StaticClass(): Class;
    }

    export class MeshSectionInfo {
        constructor();
        constructor(MaterialIndex: number, bEnableCollision: boolean, bCastShadow: boolean, bVisibleInRayTracing: boolean, bForceOpaque: boolean);

        MaterialIndex: number;
        bEnableCollision: boolean;
        bCastShadow: boolean;
        bVisibleInRayTracing: boolean;
        bForceOpaque: boolean;

        static StaticClass(): Class;
    }

    export class MeshSectionInfoMap {
        constructor();
        constructor(Map: TMap<number, MeshSectionInfo>);

        Map: TMap<number, MeshSectionInfo>;

        static StaticClass(): Class;
    }

    export class PerPlatformInt {
        constructor();
        constructor(Default: number, PerPlatform: TMap<string, number>);

        Default: number;
        PerPlatform: TMap<string, number>;

        static StaticClass(): Class;
    }

    export class MaterialRemapIndex {
        constructor();
        constructor(ImportVersionKey: number, MaterialRemap: TArray<number>);

        ImportVersionKey: number;
        MaterialRemap: TArray<number>;

        static StaticClass(): Class;
    }

    export class MeshUVChannelInfo {
        constructor();
        constructor(bInitialized: boolean, bOverrideDensities: boolean, LocalUVDensities: FixSizeArray<number>);

        bInitialized: boolean;
        bOverrideDensities: boolean;
        LocalUVDensities: FixSizeArray<number>;

        static StaticClass(): Class;
    }

    export class StaticMaterial {
        constructor();
        constructor(MaterialInterface: MaterialInterface, MaterialSlotName: string, ImportedMaterialSlotName: string, UVChannelData: MeshUVChannelInfo);

        MaterialInterface: MaterialInterface;
        MaterialSlotName: string;
        ImportedMaterialSlotName: string;
        UVChannelData: MeshUVChannelInfo;

        static StaticClass(): Class;
    }

    export enum EPhysicsType { PhysType_Default, PhysType_Kinematic, PhysType_Simulated, PhysType_MAX }

    export enum ECollisionTraceFlag {
        CTF_UseDefault,
        CTF_UseSimpleAndComplex,
        CTF_UseSimpleAsComplex,
        CTF_UseComplexAsSimple,
        CTF_MAX
    }

    export enum EBodyCollisionResponse { BodyCollision_Enabled, BodyCollision_Disabled, BodyCollision_MAX }

    export class BodySetupCore extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoneName: string;
        PhysicsType: EPhysicsType;
        CollisionTraceFlag: ECollisionTraceFlag;
        CollisionReponse: EBodyCollisionResponse;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BodySetupCore;

        static Load(InName: string): BodySetupCore;
    }

    export class KShapeElem {
        constructor();
        constructor(RestOffset: number, bIsGenerated: boolean, Name: string, bContributeToMass: boolean, CollisionEnabled: ECollisionEnabled);

        RestOffset: number;
        bIsGenerated: boolean;
        Name: string;
        bContributeToMass: boolean;
        CollisionEnabled: ECollisionEnabled;

        static StaticClass(): Class;
    }

    export class Plane extends Vector {
        constructor();
        constructor(W: number);

        W: number;

        static StaticClass(): Class;
    }

    export class Matrix {
        constructor();
        constructor(XPlane: Plane, YPlane: Plane, ZPlane: Plane, WPlane: Plane);

        XPlane: Plane;
        YPlane: Plane;
        ZPlane: Plane;
        WPlane: Plane;

        static StaticClass(): Class;
    }

    export class KSphereElem extends KShapeElem {
        constructor();
        constructor(TM: Matrix, Center: Vector, Radius: number);

        TM: Matrix;
        Center: Vector;
        Radius: number;

        static StaticClass(): Class;
    }

    export class KBoxElem extends KShapeElem {
        constructor();
        constructor(TM: Matrix, Orientation: Quat, Center: Vector, Rotation: Rotator, X: number, Y: number, Z: number);

        TM: Matrix;
        Orientation: Quat;
        Center: Vector;
        Rotation: Rotator;
        X: number;
        Y: number;
        Z: number;

        static StaticClass(): Class;
    }

    export class KSphylElem extends KShapeElem {
        constructor();
        constructor(TM: Matrix, Orientation: Quat, Center: Vector, Rotation: Rotator, Radius: number, Length: number);

        TM: Matrix;
        Orientation: Quat;
        Center: Vector;
        Rotation: Rotator;
        Radius: number;
        Length: number;

        static StaticClass(): Class;
    }

    export class Box {
        constructor();
        constructor(Min: Vector, Max: Vector, IsValid: number);

        Min: Vector;
        Max: Vector;
        IsValid: number;

        static StaticClass(): Class;
    }

    export class KConvexElem extends KShapeElem {
        constructor();
        constructor(VertexData: TArray<Vector>, IndexData: TArray<number>, ElemBox: Box, Transform: Transform);

        VertexData: TArray<Vector>;
        IndexData: TArray<number>;
        ElemBox: Box;
        Transform: Transform;

        static StaticClass(): Class;
    }

    export class KTaperedCapsuleElem extends KShapeElem {
        constructor();
        constructor(Center: Vector, Rotation: Rotator, Radius0: number, Radius1: number, Length: number);

        Center: Vector;
        Rotation: Rotator;
        Radius0: number;
        Radius1: number;
        Length: number;

        static StaticClass(): Class;
    }

    export class KAggregateGeom {
        constructor();
        constructor(SphereElems: TArray<KSphereElem>, BoxElems: TArray<KBoxElem>, SphylElems: TArray<KSphylElem>, ConvexElems: TArray<KConvexElem>, TaperedCapsuleElems: TArray<KTaperedCapsuleElem>);

        SphereElems: TArray<KSphereElem>;
        BoxElems: TArray<KBoxElem>;
        SphylElems: TArray<KSphylElem>;
        ConvexElems: TArray<KConvexElem>;
        TaperedCapsuleElems: TArray<KTaperedCapsuleElem>;

        static StaticClass(): Class;
    }

    export class BodySetup extends BodySetupCore {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AggGeom: KAggregateGeom;
        bAlwaysFullAnimWeight: boolean;
        bConsiderForBounds: boolean;
        bMeshCollideAll: boolean;
        bDoubleSidedGeometry: boolean;
        bGenerateNonMirroredCollision: boolean;
        bSharedCookedData: boolean;
        bGenerateMirroredCollision: boolean;
        bSupportUVsAndFaceRemap: boolean;
        PhysMaterial: PhysicalMaterial;
        WalkableSlopeOverride: WalkableSlopeOverride;
        BuildScale: number;
        DefaultInstance: BodyInstance;
        BuildScale3D: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BodySetup;

        static Load(InName: string): BodySetup;
    }

    export class AssetEditorOrbitCameraPosition {
        constructor();
        constructor(bIsSet: boolean, CamOrbitPoint: Vector, CamOrbitZoom: Vector, CamOrbitRotation: Rotator);

        bIsSet: boolean;
        CamOrbitPoint: Vector;
        CamOrbitZoom: Vector;
        CamOrbitRotation: Rotator;

        static StaticClass(): Class;
    }

    export class StaticMeshSocket extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SocketName: string;
        RelativeLocation: Vector;
        RelativeRotation: Rotator;
        RelativeScale: Vector;
        Tag: string;
        PreviewStaticMesh: StaticMesh;
        bSocketCreatedAtImport: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshSocket;

        static Load(InName: string): StaticMeshSocket;
    }

    export class BoxSphereBounds {
        constructor();
        constructor(Origin: Vector, BoxExtent: Vector, SphereRadius: number);

        Origin: Vector;
        BoxExtent: Vector;
        SphereRadius: number;

        static StaticClass(): Class;
    }

    export class NavCollisionBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsDynamicObstacle: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavCollisionBase;

        static Load(InName: string): NavCollisionBase;
    }

    export class ElementID {
        constructor();
        constructor(IDValue: number);

        IDValue: number;

        static StaticClass(): Class;
    }

    export class VertexID extends ElementID {
        constructor();

        static StaticClass(): Class;
    }

    export class PolygonID extends ElementID {
        constructor();

        static StaticClass(): Class;
    }

    export class VertexInstanceID extends ElementID {
        constructor();

        static StaticClass(): Class;
    }

    export class PolygonGroupID extends ElementID {
        constructor();

        static StaticClass(): Class;
    }

    export class TriangleID extends ElementID {
        constructor();

        static StaticClass(): Class;
    }

    export class EdgeID extends ElementID {
        constructor();

        static StaticClass(): Class;
    }

    export class MeshDescriptionBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ComputePolygonTriangulation(PolygonID: PolygonID): void;

        CreateEdge(VertexID0: VertexID, VertexID1: VertexID): EdgeID;

        CreateEdgeWithID(EdgeID: EdgeID, VertexID0: VertexID, VertexID1: VertexID): void;

        CreatePolygon(PolygonGroupID: PolygonGroupID, VertexInstanceIDs: $Ref<TArray<VertexInstanceID>>, NewEdgeIDs: $Ref<TArray<EdgeID>>): PolygonID;

        CreatePolygonGroup(): PolygonGroupID;

        CreatePolygonGroupWithID(PolygonGroupID: PolygonGroupID): void;

        CreatePolygonWithID(PolygonID: PolygonID, PolygonGroupID: PolygonGroupID, VertexInstanceIDs: $Ref<TArray<VertexInstanceID>>, NewEdgeIDs: $Ref<TArray<EdgeID>>): void;

        CreateTriangle(PolygonGroupID: PolygonGroupID, VertexInstanceIDs: TArray<VertexInstanceID>, NewEdgeIDs: $Ref<TArray<EdgeID>>): TriangleID;

        CreateTriangleWithID(TriangleID: TriangleID, PolygonGroupID: PolygonGroupID, VertexInstanceIDs: TArray<VertexInstanceID>, NewEdgeIDs: $Ref<TArray<EdgeID>>): void;

        CreateVertex(): VertexID;

        CreateVertexInstance(VertexID: VertexID): VertexInstanceID;

        CreateVertexInstanceWithID(VertexInstanceID: VertexInstanceID, VertexID: VertexID): void;

        CreateVertexWithID(VertexID: VertexID): void;

        DeleteEdge(EdgeID: EdgeID, OrphanedVertices: $Ref<TArray<VertexID>>): void;

        DeletePolygon(PolygonID: PolygonID, OrphanedEdges: $Ref<TArray<EdgeID>>, OrphanedVertexInstances: $Ref<TArray<VertexInstanceID>>, OrphanedPolygonGroups: $Ref<TArray<PolygonGroupID>>): void;

        DeletePolygonGroup(PolygonGroupID: PolygonGroupID): void;

        DeleteTriangle(TriangleID: TriangleID, OrphanedEdges: $Ref<TArray<EdgeID>>, OrphanedVertexInstances: $Ref<TArray<VertexInstanceID>>, OrphanedPolygonGroupsPtr: $Ref<TArray<PolygonGroupID>>): void;

        DeleteVertex(VertexID: VertexID): void;

        DeleteVertexInstance(VertexInstanceID: VertexInstanceID, OrphanedVertices: $Ref<TArray<VertexID>>): void;

        Empty(): void;

        GetEdgeConnectedPolygons(EdgeID: EdgeID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;

        GetEdgeConnectedTriangles(EdgeID: EdgeID, OutConnectedTriangleIDs: $Ref<TArray<TriangleID>>): void;

        GetEdgeVertex(EdgeID: EdgeID, VertexNumber: number): VertexID;

        GetEdgeVertices(EdgeID: EdgeID, OutVertexIDs: $Ref<TArray<VertexID>>): void;

        GetNumEdgeConnectedPolygons(EdgeID: EdgeID): number;

        GetNumEdgeConnectedTriangles(EdgeID: EdgeID): number;

        GetNumPolygonGroupPolygons(PolygonGroupID: PolygonGroupID): number;

        GetNumPolygonInternalEdges(PolygonID: PolygonID): number;

        GetNumPolygonTriangles(PolygonID: PolygonID): number;

        GetNumPolygonVertices(PolygonID: PolygonID): number;

        GetNumVertexConnectedEdges(VertexID: VertexID): number;

        GetNumVertexConnectedPolygons(VertexID: VertexID): number;

        GetNumVertexConnectedTriangles(VertexID: VertexID): number;

        GetNumVertexInstanceConnectedPolygons(VertexInstanceID: VertexInstanceID): number;

        GetNumVertexInstanceConnectedTriangles(VertexInstanceID: VertexInstanceID): number;

        GetNumVertexVertexInstances(VertexID: VertexID): number;

        GetPolygonAdjacentPolygons(PolygonID: PolygonID, OutPolygonIDs: $Ref<TArray<PolygonID>>): void;

        GetPolygonGroupPolygons(PolygonGroupID: PolygonGroupID, OutPolygonIDs: $Ref<TArray<PolygonID>>): void;

        GetPolygonInternalEdges(PolygonID: PolygonID, OutEdgeIDs: $Ref<TArray<EdgeID>>): void;

        GetPolygonPerimeterEdges(PolygonID: PolygonID, OutEdgeIDs: $Ref<TArray<EdgeID>>): void;

        GetPolygonPolygonGroup(PolygonID: PolygonID): PolygonGroupID;

        GetPolygonTriangles(PolygonID: PolygonID, OutTriangleIDs: $Ref<TArray<TriangleID>>): void;

        GetPolygonVertexInstances(PolygonID: PolygonID, OutVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;

        GetPolygonVertices(PolygonID: PolygonID, OutVertexIDs: $Ref<TArray<VertexID>>): void;

        GetTriangleAdjacentTriangles(TriangleID: TriangleID, OutTriangleIDs: $Ref<TArray<TriangleID>>): void;

        GetTriangleEdges(TriangleID: TriangleID, OutEdgeIDs: $Ref<TArray<EdgeID>>): void;

        GetTrianglePolygon(TriangleID: TriangleID): PolygonID;

        GetTrianglePolygonGroup(TriangleID: TriangleID): PolygonGroupID;

        GetTriangleVertexInstance(TriangleID: TriangleID, Index: number): VertexInstanceID;

        GetTriangleVertexInstances(TriangleID: TriangleID, OutVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;

        GetTriangleVertices(TriangleID: TriangleID, OutVertexIDs: $Ref<TArray<VertexID>>): void;

        GetVertexAdjacentVertices(VertexID: VertexID, OutAdjacentVertexIDs: $Ref<TArray<VertexID>>): void;

        GetVertexConnectedEdges(VertexID: VertexID, OutEdgeIDs: $Ref<TArray<EdgeID>>): void;

        GetVertexConnectedPolygons(VertexID: VertexID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;

        GetVertexConnectedTriangles(VertexID: VertexID, OutConnectedTriangleIDs: $Ref<TArray<TriangleID>>): void;

        GetVertexInstanceConnectedPolygons(VertexInstanceID: VertexInstanceID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;

        GetVertexInstanceConnectedTriangles(VertexInstanceID: VertexInstanceID, OutConnectedTriangleIDs: $Ref<TArray<TriangleID>>): void;

        GetVertexInstanceForPolygonVertex(PolygonID: PolygonID, VertexID: VertexID): VertexInstanceID;

        GetVertexInstanceForTriangleVertex(TriangleID: TriangleID, VertexID: VertexID): VertexInstanceID;

        GetVertexInstancePairEdge(VertexInstanceID0: VertexInstanceID, VertexInstanceID1: VertexInstanceID): EdgeID;

        GetVertexInstanceVertex(VertexInstanceID: VertexInstanceID): VertexID;

        GetVertexPairEdge(VertexID0: VertexID, VertexID1: VertexID): EdgeID;

        GetVertexPosition(VertexID: VertexID): Vector;

        GetVertexVertexInstances(VertexID: VertexID, OutVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;

        IsEdgeInternal(EdgeID: EdgeID): boolean;

        IsEdgeInternalToPolygon(EdgeID: EdgeID, PolygonID: PolygonID): boolean;

        IsEdgeValid(EdgeID: EdgeID): boolean;

        IsEmpty(): boolean;

        IsPolygonGroupValid(PolygonGroupID: PolygonGroupID): boolean;

        IsPolygonValid(PolygonID: PolygonID): boolean;

        IsTrianglePartOfNgon(TriangleID: TriangleID): boolean;

        IsTriangleValid(TriangleID: TriangleID): boolean;

        IsVertexInstanceValid(VertexInstanceID: VertexInstanceID): boolean;

        IsVertexOrphaned(VertexID: VertexID): boolean;

        IsVertexValid(VertexID: VertexID): boolean;

        ReserveNewEdges(NumberOfNewEdges: number): void;

        ReserveNewPolygonGroups(NumberOfNewPolygonGroups: number): void;

        ReserveNewPolygons(NumberOfNewPolygons: number): void;

        ReserveNewTriangles(NumberOfNewTriangles: number): void;

        ReserveNewVertexInstances(NumberOfNewVertexInstances: number): void;

        ReserveNewVertices(NumberOfNewVertices: number): void;

        ReversePolygonFacing(PolygonID: PolygonID): void;

        SetPolygonPolygonGroup(PolygonID: PolygonID, PolygonGroupID: PolygonGroupID): void;

        SetPolygonVertexInstance(PolygonID: PolygonID, PerimeterIndex: number, VertexInstanceID: VertexInstanceID): void;

        SetVertexPosition(VertexID: VertexID, Position: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshDescriptionBase;

        static Load(InName: string): MeshDescriptionBase;
    }

    export class StaticMeshDescription extends MeshDescriptionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CreateCube(Center: Vector, HalfExtents: Vector, PolygonGroup: PolygonGroupID, PolygonID_PlusX: $Ref<PolygonID>, PolygonID_MinusX: $Ref<PolygonID>, PolygonID_PlusY: $Ref<PolygonID>, PolygonID_MinusY: $Ref<PolygonID>, PolygonID_PlusZ: $Ref<PolygonID>, PolygonID_MinusZ: $Ref<PolygonID>): void;

        GetVertexInstanceUV(VertexInstanceID: VertexInstanceID, UVIndex?: number /* = 0 */): Vector2D;

        SetPolygonGroupMaterialSlotName(PolygonGroupID: PolygonGroupID, SlotName: string): void;

        SetVertexInstanceUV(VertexInstanceID: VertexInstanceID, UV: Vector2D, UVIndex?: number /* = 0 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshDescription;

        static Load(InName: string): StaticMeshDescription;
    }

    export class StaticMesh extends StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceModels: TArray<StaticMeshSourceModel>;
        SectionInfoMap: MeshSectionInfoMap;
        OriginalSectionInfoMap: MeshSectionInfoMap;
        LODGroup: string;
        NumStreamedLODs: PerPlatformInt;
        ImportVersion: number;
        MaterialRemapIndexPerImportVersion: TArray<MaterialRemapIndex>;
        LightmapUVVersion: number;
        bAutoComputeLODScreenSize: boolean;
        Materials: TArray<MaterialInterface>;
        MinLOD: PerPlatformInt;
        LpvBiasMultiplier: number;
        StaticMaterials: TArray<StaticMaterial>;
        LightmapUVDensity: number;
        LightMapResolution: number;
        LightMapCoordinateIndex: number;
        DistanceFieldSelfShadowBias: number;
        BodySetup: BodySetup;
        LODForCollision: number;
        bGenerateMeshDistanceField: boolean;
        bStripComplexCollisionForConsole: boolean;
        bHasNavigationData: boolean;
        bSupportUniformlyDistributedSampling: boolean;
        bSupportPhysicalMaterialMasks: boolean;
        bIsBuiltAtRuntime: boolean;
        bAllowCPUAccess: boolean;
        bSupportGpuUniformlyDistributedSampling: boolean;
        AssetImportData: AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        ThumbnailInfo: ThumbnailInfo;
        EditorCameraPosition: AssetEditorOrbitCameraPosition;
        bCustomizedCollision: boolean;
        LODForOccluderMesh: number;
        Sockets: TArray<StaticMeshSocket>;
        PositiveBoundsExtension: Vector;
        NegativeBoundsExtension: Vector;
        ExtendedBounds: BoxSphereBounds;
        ElementToIgnoreForTexFactor: number;
        AssetUserData: TArray<AssetUserData>;
        EditableMesh: Object;
        ComplexCollisionMesh: StaticMesh;
        NavCollision: NavCollisionBase;

        AddMaterial(Material: $Nullable<MaterialInterface>): string;

        AddSocket(Socket: $Nullable<StaticMeshSocket>): void;

        BuildFromStaticMeshDescriptions(StaticMeshDescriptions: TArray<StaticMeshDescription>, bBuildSimpleCollision?: boolean /* = false */): void;

        FindSocket(InSocketName: string): StaticMeshSocket;

        GetBoundingBox(): Box;

        GetBounds(): BoxSphereBounds;

        GetMaterial(MaterialIndex: number): MaterialInterface;

        GetMaterialIndex(MaterialSlotName: string): number;

        GetMinimumLODForPlatform(PlatformName: string): number;

        GetMinimumLODForPlatforms(PlatformMinimumLODs: $Ref<TMap<string, number>>): void;

        GetNumLODs(): number;

        GetNumSections(InLOD: number): number;

        RemoveSocket(Socket: $Nullable<StaticMeshSocket>): void;

        SetLODGroup(NewGroup: string, bRebuildImmediately?: boolean /* = true */): void;

        SetMaterial(MaterialIndex: number, NewMaterial: $Nullable<MaterialInterface>): void;

        SetNumSourceModels(Num: number): void;

        static CreateStaticMeshDescription(Outer?: Object /* = None */): StaticMeshDescription;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMesh;

        static Load(InName: string): StaticMesh;
    }

    export enum EGrassScaling { Uniform, Free, LockXY, EGrassScaling_MAX }

    export class FloatInterval {
        constructor();
        constructor(Min: number, Max: number);

        Min: number;
        Max: number;

        static StaticClass(): Class;
    }

    export class GrassVariety {
        constructor();
        constructor(GrassMesh: StaticMesh, OverrideMaterials: TArray<MaterialInterface>, GrassDensity: PerPlatformFloat, bUseGrid: boolean, PlacementJitter: number, StartCullDistance: PerPlatformInt, EndCullDistance: PerPlatformInt, MinLOD: number, Scaling: EGrassScaling, ScaleX: FloatInterval, ScaleY: FloatInterval, ScaleZ: FloatInterval, RandomRotation: boolean, AlignToSurface: boolean, bUseLandscapeLightmap: boolean, LightingChannels: LightingChannels, bReceivesDecals: boolean, bCastDynamicShadow: boolean, bKeepInstanceBufferCPUCopy: boolean);

        GrassMesh: StaticMesh;
        OverrideMaterials: TArray<MaterialInterface>;
        GrassDensity: PerPlatformFloat;
        bUseGrid: boolean;
        PlacementJitter: number;
        StartCullDistance: PerPlatformInt;
        EndCullDistance: PerPlatformInt;
        MinLOD: number;
        Scaling: EGrassScaling;
        ScaleX: FloatInterval;
        ScaleY: FloatInterval;
        ScaleZ: FloatInterval;
        RandomRotation: boolean;
        AlignToSurface: boolean;
        bUseLandscapeLightmap: boolean;
        LightingChannels: LightingChannels;
        bReceivesDecals: boolean;
        bCastDynamicShadow: boolean;
        bKeepInstanceBufferCPUCopy: boolean;

        static StaticClass(): Class;
    }

    export class LandscapeGrassType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GrassVarieties: TArray<GrassVariety>;
        bEnableDensityScaling: boolean;
        GrassMesh: StaticMesh;
        GrassDensity: number;
        PlacementJitter: number;
        StartCullDistance: number;
        EndCullDistance: number;
        RandomRotation: boolean;
        AlignToSurface: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeGrassType;

        static Load(InName: string): LandscapeGrassType;
    }

    export class MaterialCachedExpressionData {
        constructor();
        constructor(Parameters: MaterialCachedParameters, ReferencedTextures: TArray<Object>, FunctionInfos: TArray<MaterialFunctionInfo>, ParameterCollectionInfos: TArray<MaterialParameterCollectionInfo>, DefaultLayers: TArray<MaterialFunctionInterface>, DefaultLayerBlends: TArray<MaterialFunctionInterface>, GrassTypes: TArray<LandscapeGrassType>, DynamicParameterNames: TArray<string>, QualityLevelsUsed: TArray<boolean>, bHasRuntimeVirtualTextureOutput: boolean, bHasSceneColor: boolean);

        Parameters: MaterialCachedParameters;
        ReferencedTextures: TArray<Object>;
        FunctionInfos: TArray<MaterialFunctionInfo>;
        ParameterCollectionInfos: TArray<MaterialParameterCollectionInfo>;
        DefaultLayers: TArray<MaterialFunctionInterface>;
        DefaultLayerBlends: TArray<MaterialFunctionInterface>;
        GrassTypes: TArray<LandscapeGrassType>;
        DynamicParameterNames: TArray<string>;
        QualityLevelsUsed: TArray<boolean>;
        bHasRuntimeVirtualTextureOutput: boolean;
        bHasSceneColor: boolean;

        static StaticClass(): Class;
    }

    export class Material extends MaterialInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysMaterial: PhysicalMaterial;
        PhysMaterialMask: PhysicalMaterialMask;
        PhysicalMaterialMap: FixSizeArray<PhysicalMaterial>;
        DiffuseColor: ColorMaterialInput;
        SpecularColor: ColorMaterialInput;
        BaseColor: ColorMaterialInput;
        Metallic: ScalarMaterialInput;
        Specular: ScalarMaterialInput;
        Roughness: ScalarMaterialInput;
        Anisotropy: ScalarMaterialInput;
        Normal: VectorMaterialInput;
        Tangent: VectorMaterialInput;
        EmissiveColor: ColorMaterialInput;
        Opacity: ScalarMaterialInput;
        OpacityMask: ScalarMaterialInput;
        MaterialDomain: EMaterialDomain;
        BlendMode: EBlendMode;
        DecalBlendMode: EDecalBlendMode;
        MaterialDecalResponse: EMaterialDecalResponse;
        ShadingModel: EMaterialShadingModel;
        bCastDynamicShadowAsMasked: boolean;
        ShadingModels: MaterialShadingModelField;
        UsedShadingModels: string;
        OpacityMaskClipValue: number;
        WorldPositionOffset: VectorMaterialInput;
        WorldDisplacement: VectorMaterialInput;
        TessellationMultiplier: ScalarMaterialInput;
        SubsurfaceColor: ColorMaterialInput;
        ClearCoat: ScalarMaterialInput;
        ClearCoatRoughness: ScalarMaterialInput;
        AmbientOcclusion: ScalarMaterialInput;
        Refraction: ScalarMaterialInput;
        CustomizedUVs: FixSizeArray<Vector2MaterialInput>;
        MaterialAttributes: MaterialAttributesInput;
        PixelDepthOffset: ScalarMaterialInput;
        ShadingModelFromMaterialExpression: ShadingModelMaterialInput;
        bEnableSeparateTranslucency: boolean;
        bEnableResponsiveAA: boolean;
        bScreenSpaceReflections: boolean;
        bContactShadows: boolean;
        TwoSided: boolean;
        DitheredLODTransition: boolean;
        DitherOpacityMask: boolean;
        bAllowNegativeEmissiveColor: boolean;
        TranslucencyLightingMode: ETranslucencyLightingMode;
        bEnableMobileSeparateTranslucency: boolean;
        NumCustomizedUVs: number;
        TranslucencyDirectionalLightingIntensity: number;
        TranslucentShadowDensityScale: number;
        TranslucentSelfShadowDensityScale: number;
        TranslucentSelfShadowSecondDensityScale: number;
        TranslucentSelfShadowSecondOpacity: number;
        TranslucentBackscatteringExponent: number;
        TranslucentMultipleScatteringExtinction: LinearColor;
        TranslucentShadowStartOffset: number;
        bDisableDepthTest: boolean;
        bWriteOnlyAlpha: boolean;
        bGenerateSphericalParticleNormals: boolean;
        bTangentSpaceNormal: boolean;
        bUseEmissiveForDynamicAreaLighting: boolean;
        bBlockGI: boolean;
        bUsedAsSpecialEngineMaterial: boolean;
        bUsedWithSkeletalMesh: boolean;
        bUsedWithEditorCompositing: boolean;
        bUsedWithParticleSprites: boolean;
        bUsedWithBeamTrails: boolean;
        bUsedWithMeshParticles: boolean;
        bUsedWithNiagaraSprites: boolean;
        bUsedWithNiagaraRibbons: boolean;
        bUsedWithNiagaraMeshParticles: boolean;
        bUsedWithGeometryCache: boolean;
        bUsedWithStaticLighting: boolean;
        bUsedWithMorphTargets: boolean;
        bUsedWithSplineMeshes: boolean;
        bUsedWithInstancedStaticMeshes: boolean;
        bUsedWithGeometryCollections: boolean;
        bUsesDistortion: boolean;
        bUsedWithClothing: boolean;
        bUsedWithWater: boolean;
        bUsedWithHairStrands: boolean;
        bUsedWithLidarPointCloud: boolean;
        bUsedWithVirtualHeightfieldMesh: boolean;
        bUsedWithUI: boolean;
        bAutomaticallySetUsageInEditor: boolean;
        bFullyRough: boolean;
        bUseFullPrecision: boolean;
        bUseLightmapDirectionality: boolean;
        bUseAlphaToCoverage: boolean;
        bForwardRenderUsePreintegratedGFForSimpleIBL: boolean;
        bUseHQForwardReflections: boolean;
        bUsePlanarForwardReflections: boolean;
        bNormalCurvatureToRoughness: boolean;
        D3D11TessellationMode: EMaterialTessellationMode;
        bEnableCrackFreeDisplacement: boolean;
        bEnableAdaptiveTessellation: boolean;
        AllowTranslucentCustomDepthWrites: boolean;
        Wireframe: boolean;
        ShadingRate: EMaterialShadingRate;
        EditorX: number;
        EditorY: number;
        EditorPitch: number;
        EditorYaw: number;
        Expressions: TArray<MaterialExpression>;
        EditorComments: TArray<MaterialExpressionComment>;
        ParameterGroupData: TArray<ParameterGroupData>;
        bCanMaskedBeAssumedOpaque: boolean;
        bIsMasked: boolean;
        bIsPreviewMaterial: boolean;
        bIsFunctionPreviewMaterial: boolean;
        bUseMaterialAttributes: boolean;
        bCastRayTracedShadows: boolean;
        bUseTranslucencyVertexFog: boolean;
        bApplyCloudFogging: boolean;
        bIsSky: boolean;
        bAllowNegativePixelDepthOffset: boolean;
        bComputeFogPerPixel: boolean;
        bOutputTranslucentVelocity: boolean;
        bAllowDevelopmentShaderCompile: boolean;
        bIsMaterialEditorStatsMaterial: boolean;
        BlendableLocation: EBlendableLocation;
        BlendableOutputAlpha: boolean;
        bEnableStencilTest: boolean;
        StencilCompare: EMaterialStencilCompare;
        StencilRefValue: number;
        RefractionMode: ERefractionMode;
        BlendablePriority: number;
        bIsBlendable: boolean;
        UsageFlagWarnings: number;
        RefractionDepthBias: number;
        StateId: Guid;
        MaxDisplacement: number;
        CachedExpressionData: MaterialCachedExpressionData;
        ReferencedTextureGuids: TArray<Guid>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Material;

        static Load(InName: string): Material;
    }

    export class MaterialInterface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SubsurfaceProfile: SubsurfaceProfile;
        LightmassSettings: LightmassMaterialInterfaceSettings;
        bTextureStreamingDataSorted: boolean;
        TextureStreamingDataVersion: number;
        TextureStreamingData: TArray<MaterialTextureInfo>;
        AssetUserData: TArray<AssetUserData>;
        TextureStreamingDataMissingEntries: TArray<MaterialTextureInfo>;
        PreviewMesh: SoftObjectPath;
        ThumbnailInfo: ThumbnailInfo;
        LayerParameterExpansion: TMap<string, boolean>;
        ParameterOverviewExpansion: TMap<string, boolean>;
        AssetImportData: AssetImportData;
        LightingGuid: Guid;

        GetBaseMaterial(): Material;

        GetParameterInfo(Association: EMaterialParameterAssociation, ParameterName: string, LayerFunction: $Nullable<MaterialFunctionInterface>): MaterialParameterInfo;

        GetPhysicalMaterial(): PhysicalMaterial;

        GetPhysicalMaterialFromMap(Index: number): PhysicalMaterial;

        GetPhysicalMaterialMask(): PhysicalMaterialMask;

        SetForceMipLevelsToBeResident(OverrideForceMiplevelsToBeResident: boolean, bForceMiplevelsToBeResidentValue: boolean, ForceDuration: number, CinematicTextureGroups?: number /* = 0 */, bFastResponse?: boolean /* = false */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialInterface;

        static Load(InName: string): MaterialInterface;
    }

    export class Field extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Field;

        static Load(InName: string): Field;
    }

    export class Struct extends Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Struct;

        static Load(InName: string): Struct;
    }

    export class Class extends Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Class;

        static Load(InName: string): Class;
    }

    export class ScalarParameterAtlasInstanceData {
        constructor();
        constructor(bIsUsedAsAtlasPosition: boolean, Curve: TSoftObjectPtr<CurveLinearColor>, Atlas: TSoftObjectPtr<CurveLinearColorAtlas>);

        bIsUsedAsAtlasPosition: boolean;
        Curve: TSoftObjectPtr<CurveLinearColor>;
        Atlas: TSoftObjectPtr<CurveLinearColorAtlas>;

        static StaticClass(): Class;
    }

    export class ScalarParameterValue {
        constructor();
        constructor(ParameterName: string, AtlasData: ScalarParameterAtlasInstanceData, ParameterInfo: MaterialParameterInfo, ParameterValue: number, ExpressionGUID: Guid);

        ParameterName: string;
        AtlasData: ScalarParameterAtlasInstanceData;
        ParameterInfo: MaterialParameterInfo;
        ParameterValue: number;
        ExpressionGUID: Guid;

        static StaticClass(): Class;
    }

    export class VectorParameterValue {
        constructor();
        constructor(ParameterName: string, ParameterInfo: MaterialParameterInfo, ParameterValue: LinearColor, ExpressionGUID: Guid);

        ParameterName: string;
        ParameterInfo: MaterialParameterInfo;
        ParameterValue: LinearColor;
        ExpressionGUID: Guid;

        static StaticClass(): Class;
    }

    export class TextureParameterValue {
        constructor();
        constructor(ParameterName: string, ParameterInfo: MaterialParameterInfo, ParameterValue: Texture, ExpressionGUID: Guid);

        ParameterName: string;
        ParameterInfo: MaterialParameterInfo;
        ParameterValue: Texture;
        ExpressionGUID: Guid;

        static StaticClass(): Class;
    }

    export class RuntimeVirtualTextureParameterValue {
        constructor();
        constructor(ParameterInfo: MaterialParameterInfo, ParameterValue: RuntimeVirtualTexture, ExpressionGUID: Guid);

        ParameterInfo: MaterialParameterInfo;
        ParameterValue: RuntimeVirtualTexture;
        ExpressionGUID: Guid;

        static StaticClass(): Class;
    }

    export class FontParameterValue {
        constructor();
        constructor(ParameterName: string, ParameterInfo: MaterialParameterInfo, FontValue: Font, FontPage: number, ExpressionGUID: Guid);

        ParameterName: string;
        ParameterInfo: MaterialParameterInfo;
        FontValue: Font;
        FontPage: number;
        ExpressionGUID: Guid;

        static StaticClass(): Class;
    }

    export class MaterialInstanceBasePropertyOverrides {
        constructor();
        constructor(bOverride_OpacityMaskClipValue: boolean, bOverride_BlendMode: boolean, bOverride_ShadingModel: boolean, bOverride_DitheredLODTransition: boolean, bOverride_CastDynamicShadowAsMasked: boolean, bOverride_TwoSided: boolean, TwoSided: boolean, DitheredLODTransition: boolean, bCastDynamicShadowAsMasked: boolean, BlendMode: EBlendMode, ShadingModel: EMaterialShadingModel, OpacityMaskClipValue: number);

        bOverride_OpacityMaskClipValue: boolean;
        bOverride_BlendMode: boolean;
        bOverride_ShadingModel: boolean;
        bOverride_DitheredLODTransition: boolean;
        bOverride_CastDynamicShadowAsMasked: boolean;
        bOverride_TwoSided: boolean;
        TwoSided: boolean;
        DitheredLODTransition: boolean;
        bCastDynamicShadowAsMasked: boolean;
        BlendMode: EBlendMode;
        ShadingModel: EMaterialShadingModel;
        OpacityMaskClipValue: number;

        static StaticClass(): Class;
    }

    export class StaticParameterBase {
        constructor();
        constructor(ParameterInfo: MaterialParameterInfo, bOverride: boolean, ExpressionGUID: Guid);

        ParameterInfo: MaterialParameterInfo;
        bOverride: boolean;
        ExpressionGUID: Guid;

        static StaticClass(): Class;
    }

    export class StaticSwitchParameter extends StaticParameterBase {
        constructor();
        constructor(Value: boolean);

        Value: boolean;

        static StaticClass(): Class;
    }

    export class StaticComponentMaskParameter extends StaticParameterBase {
        constructor();
        constructor(R: boolean, G: boolean, B: boolean, A: boolean);

        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;

        static StaticClass(): Class;
    }

    export class StaticTerrainLayerWeightParameter extends StaticParameterBase {
        constructor();
        constructor(WeightmapIndex: number, bWeightBasedBlend: boolean);

        WeightmapIndex: number;
        bWeightBasedBlend: boolean;

        static StaticClass(): Class;
    }

    export enum EMaterialLayerLinkState {
        Uninitialized,
        LinkedToParent,
        UnlinkedFromParent,
        NotFromParent,
        EMaterialLayerLinkState_MAX
    }

    export class MaterialLayersFunctions {
        constructor();
        constructor(Layers: TArray<MaterialFunctionInterface>, Blends: TArray<MaterialFunctionInterface>, LayerStates: TArray<boolean>, LayerNames: TArray<string>, RestrictToLayerRelatives: TArray<boolean>, RestrictToBlendRelatives: TArray<boolean>, LayerGuids: TArray<Guid>, LayerLinkStates: TArray<EMaterialLayerLinkState>, DeletedParentLayerGuids: TArray<Guid>, KeyString: string);

        Layers: TArray<MaterialFunctionInterface>;
        Blends: TArray<MaterialFunctionInterface>;
        LayerStates: TArray<boolean>;
        LayerNames: TArray<string>;
        RestrictToLayerRelatives: TArray<boolean>;
        RestrictToBlendRelatives: TArray<boolean>;
        LayerGuids: TArray<Guid>;
        LayerLinkStates: TArray<EMaterialLayerLinkState>;
        DeletedParentLayerGuids: TArray<Guid>;
        KeyString: string;

        static StaticClass(): Class;
    }

    export class StaticMaterialLayersParameter extends StaticParameterBase {
        constructor();
        constructor(Value: MaterialLayersFunctions);

        Value: MaterialLayersFunctions;

        static StaticClass(): Class;
    }

    export class StaticParameterSet {
        constructor();
        constructor(StaticSwitchParameters: TArray<StaticSwitchParameter>, StaticComponentMaskParameters: TArray<StaticComponentMaskParameter>, TerrainLayerWeightParameters: TArray<StaticTerrainLayerWeightParameter>, MaterialLayersParameters: TArray<StaticMaterialLayersParameter>);

        StaticSwitchParameters: TArray<StaticSwitchParameter>;
        StaticComponentMaskParameters: TArray<StaticComponentMaskParameter>;
        TerrainLayerWeightParameters: TArray<StaticTerrainLayerWeightParameter>;
        MaterialLayersParameters: TArray<StaticMaterialLayersParameter>;

        static StaticClass(): Class;
    }

    export class MaterialInstance extends MaterialInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysMaterial: PhysicalMaterial;
        PhysicalMaterialMap: FixSizeArray<PhysicalMaterial>;
        Parent: MaterialInterface;
        bHasStaticPermutationResource: boolean;
        bOverrideSubsurfaceProfile: boolean;
        ScalarParameterValues: TArray<ScalarParameterValue>;
        VectorParameterValues: TArray<VectorParameterValue>;
        TextureParameterValues: TArray<TextureParameterValue>;
        RuntimeVirtualTextureParameterValues: TArray<RuntimeVirtualTextureParameterValue>;
        FontParameterValues: TArray<FontParameterValue>;
        bOverrideBaseProperties: boolean;
        BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
        ReferencedTextureGuids: TArray<Guid>;
        StaticParameters: StaticParameterSet;
        CachedLayerParameters: MaterialCachedParameters;
        CachedReferencedTextures: TArray<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialInstance;

        static Load(InName: string): MaterialInstance;
    }

    export class MaterialInstanceDynamic extends MaterialInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CopyInterpParameters(Source: $Nullable<MaterialInstance>): void;

        CopyParameterOverrides(MaterialInstance: $Nullable<MaterialInstance>): void;

        K2_CopyMaterialInstanceParameters(Source: $Nullable<MaterialInterface>, bQuickParametersOnly?: boolean /* = false */): void;

        K2_GetScalarParameterValue(ParameterName: string): number;

        K2_GetScalarParameterValueByInfo(ParameterInfo: MaterialParameterInfo): number;

        K2_GetTextureParameterValue(ParameterName: string): Texture;

        K2_GetTextureParameterValueByInfo(ParameterInfo: MaterialParameterInfo): Texture;

        K2_GetVectorParameterValue(ParameterName: string): LinearColor;

        K2_GetVectorParameterValueByInfo(ParameterInfo: MaterialParameterInfo): LinearColor;

        K2_InterpolateMaterialInstanceParams(SourceA: $Nullable<MaterialInstance>, SourceB: $Nullable<MaterialInstance>, Alpha: number): void;

        SetScalarParameterValue(ParameterName: string, Value: number): void;

        SetScalarParameterValueByInfo(ParameterInfo: MaterialParameterInfo, Value: number): void;

        SetTextureParameterValue(ParameterName: string, Value: $Nullable<Texture>): void;

        SetTextureParameterValueByInfo(ParameterInfo: MaterialParameterInfo, Value: $Nullable<Texture>): void;

        SetVectorParameterValue(ParameterName: string, Value: LinearColor): void;

        SetVectorParameterValueByInfo(ParameterInfo: MaterialParameterInfo, Value: LinearColor): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialInstanceDynamic;

        static Load(InName: string): MaterialInstanceDynamic;
    }

    export enum EAutoReceiveInput {
        Disabled,
        Player0,
        Player1,
        Player2,
        Player3,
        Player4,
        Player5,
        Player6,
        Player7,
        EAutoReceiveInput_MAX
    }

    export enum EAutoPossessAI { Disabled, PlacedInWorld, Spawned, PlacedInWorldOrSpawned, EAutoPossessAI_MAX }

    export class SpriteCategoryInfo {
        constructor();
        constructor(Category: string, DisplayName: string, Description: string);

        Category: string;
        DisplayName: string;
        Description: string;

        static StaticClass(): Class;
    }

    export class BillboardComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sprite: Texture2D;
        bIsScreenSizeScaled: boolean;
        ScreenSize: number;
        U: number;
        UL: number;
        V: number;
        VL: number;
        SpriteCategoryName: string;
        SpriteInfo: SpriteCategoryInfo;
        bUseInEditorScaling: boolean;

        SetSprite(NewSprite: $Nullable<Texture2D>): void;

        SetSpriteAndUV(NewSprite: $Nullable<Texture2D>, NewU: number, NewUL: number, NewV: number, NewVL: number): void;

        SetUV(NewU: number, NewUL: number, NewV: number, NewVL: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BillboardComponent;

        static Load(InName: string): BillboardComponent;
    }

    export class Info extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpriteComponent: BillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Info;

        static Load(InName: string): Info;
    }

    export class UniqueNetIdWrapper {
        constructor();

        static StaticClass(): Class;
    }

    export class UniqueNetIdRepl extends UniqueNetIdWrapper {
        constructor();
        constructor(ReplicationBytes: TArray<number>);

        ReplicationBytes: TArray<number>;

        static StaticClass(): Class;
    }

    export class PlayerState extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Score: number;
        PlayerId: number;
        Ping: number;
        bShouldUpdateReplicatedPing: boolean;
        bIsSpectator: boolean;
        bOnlySpectator: boolean;
        bIsABot: boolean;
        bIsInactive: boolean;
        bFromPreviousLevel: boolean;
        StartTime: number;
        EngineMessageClass: Class;
        SavedNetworkAddress: string;
        UniqueId: UniqueNetIdRepl;
        PawnPrivate: Pawn;
        PlayerNamePrivate: string;

        GetPlayerName(): string;

        OnRep_bIsInactive(): void;

        OnRep_PlayerId(): void;

        OnRep_PlayerName(): void;

        OnRep_Score(): void;

        OnRep_UniqueId(): void;

        ReceiveCopyProperties(NewPlayerState: $Nullable<PlayerState>): void;

        ReceiveOverrideWith(OldPlayerState: $Nullable<PlayerState>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlayerState;

        static Load(InName: string): PlayerState;
    }

    export class DamageType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCausedByWorld: boolean;
        bScaleMomentumByMass: boolean;
        bRadialDamageVelChange: boolean;
        DamageImpulse: number;
        DestructibleImpulse: number;
        DestructibleDamageSpreadScale: number;
        DamageFalloff: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DamageType;

        static Load(InName: string): DamageType;
    }

    export class MeshComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OverrideMaterials: TArray<MaterialInterface>;
        bEnableMaterialParameterCaching: boolean;

        GetMaterialIndex(MaterialSlotName: string): number;

        GetMaterials(): TArray<MaterialInterface>;

        GetMaterialSlotNames(): TArray<string>;

        IsMaterialSlotNameValid(MaterialSlotName: string): boolean;

        PrestreamTextures(Seconds: number, bPrioritizeCharacterTextures: boolean, CinematicTextureGroups?: number /* = 0 */): void;

        SetScalarParameterValueOnMaterials(ParameterName: string, ParameterValue: number): void;

        SetVectorParameterValueOnMaterials(ParameterName: string, ParameterValue: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshComponent;

        static Load(InName: string): MeshComponent;
    }

    export class SkeletalMeshEditorData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshEditorData;

        static Load(InName: string): SkeletalMeshEditorData;
    }

    export enum EBoneTranslationRetargetingMode {
        Animation,
        Skeleton,
        AnimationScaled,
        AnimationRelative,
        OrientAndScale,
        EBoneTranslationRetargetingMode_MAX
    }

    export class BoneNode {
        constructor();
        constructor(Name: string, ParentIndex: number, TranslationRetargetingMode: EBoneTranslationRetargetingMode);

        Name: string;
        ParentIndex: number;
        TranslationRetargetingMode: EBoneTranslationRetargetingMode;

        static StaticClass(): Class;
    }

    export class VirtualBone {
        constructor();
        constructor(SourceBoneName: string, TargetBoneName: string, VirtualBoneName: string);

        SourceBoneName: string;
        TargetBoneName: string;
        VirtualBoneName: string;

        static StaticClass(): Class;
    }

    export class SkeletalMeshSocket extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SocketName: string;
        BoneName: string;
        RelativeLocation: Vector;
        RelativeRotation: Rotator;
        RelativeScale: Vector;
        bForceAlwaysAnimated: boolean;

        GetSocketLocation(SkelComp: $Nullable<SkeletalMeshComponent>): Vector;

        InitializeSocketFromLocation(SkelComp: $Nullable<SkeletalMeshComponent>, WorldLocation: Vector, WorldNormal: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSocket;

        static Load(InName: string): SkeletalMeshSocket;
    }

    export class SmartNameContainer {
        constructor();

        static StaticClass(): Class;
    }

    export class BoneReference {
        constructor();
        constructor(BoneName: string);

        BoneName: string;

        static StaticClass(): Class;
    }

    export class BlendProfileBoneEntry {
        constructor();
        constructor(BoneReference: BoneReference, BlendScale: number);

        BoneReference: BoneReference;
        BlendScale: number;

        static StaticClass(): Class;
    }

    export class BlendProfile extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwningSkeleton: Skeleton;
        ProfileEntries: TArray<BlendProfileBoneEntry>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlendProfile;

        static Load(InName: string): BlendProfile;
    }

    export class AnimSlotGroup {
        constructor();
        constructor(GroupName: string, SlotNames: TArray<string>);

        GroupName: string;
        SlotNames: TArray<string>;

        static StaticClass(): Class;
    }

    export class DataAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NativeClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DataAsset;

        static Load(InName: string): DataAsset;
    }

    export enum EConstraintTransform { Absolute, Relative, EConstraintTransform_MAX }

    export class RigTransformConstraint {
        constructor();
        constructor(TranformType: EConstraintTransform, ParentSpace: string, Weight: number);

        TranformType: EConstraintTransform;
        ParentSpace: string;
        Weight: number;

        static StaticClass(): Class;
    }

    export class TransformBaseConstraint {
        constructor();
        constructor(TransformConstraints: TArray<RigTransformConstraint>);

        TransformConstraints: TArray<RigTransformConstraint>;

        static StaticClass(): Class;
    }

    export class TransformBase {
        constructor();
        constructor(Node: string, Constraints: FixSizeArray<TransformBaseConstraint>);

        Node: string;
        Constraints: FixSizeArray<TransformBaseConstraint>;

        static StaticClass(): Class;
    }

    export class Node {
        constructor();
        constructor(Name: string, ParentName: string, Transform: Transform, DisplayName: string, bAdvanced: boolean);

        Name: string;
        ParentName: string;
        Transform: Transform;
        DisplayName: string;
        bAdvanced: boolean;

        static StaticClass(): Class;
    }

    export class Rig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TransformBases: TArray<TransformBase>;
        Nodes: TArray<Node>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Rig;

        static Load(InName: string): Rig;
    }

    export class NameMapping {
        constructor();
        constructor(NodeName: string, BoneName: string);

        NodeName: string;
        BoneName: string;

        static StaticClass(): Class;
    }

    export class RigConfiguration {
        constructor();
        constructor(Rig: Rig, BoneMappingTable: TArray<NameMapping>);

        Rig: Rig;
        BoneMappingTable: TArray<NameMapping>;

        static StaticClass(): Class;
    }

    export class PreviewAttachedObjectPair {
        constructor();
        constructor(AttachedObject: TSoftObjectPtr<Object>, Object: Object, AttachedTo: string);

        AttachedObject: TSoftObjectPtr<Object>;
        Object: Object;
        AttachedTo: string;

        static StaticClass(): Class;
    }

    export class PreviewAssetAttachContainer {
        constructor();
        constructor(AttachedObjects: TArray<PreviewAttachedObjectPair>);

        AttachedObjects: TArray<PreviewAttachedObjectPair>;

        static StaticClass(): Class;
    }

    export class Skeleton extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoneTree: TArray<BoneNode>;
        RefLocalPoses: TArray<Transform>;
        VirtualBoneGuid: Guid;
        VirtualBones: TArray<VirtualBone>;
        Sockets: TArray<SkeletalMeshSocket>;
        SmartNames: SmartNameContainer;
        BlendProfiles: TArray<BlendProfile>;
        SlotGroups: TArray<AnimSlotGroup>;
        PreviewSkeletalMesh: TSoftObjectPtr<SkeletalMesh>;
        AdditionalPreviewSkeletalMeshes: TSoftObjectPtr<DataAsset>;
        RigConfig: RigConfiguration;
        AnimationNotifies: TArray<string>;
        PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
        AssetUserData: TArray<AssetUserData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Skeleton;

        static Load(InName: string): Skeleton;
    }

    export class SkeletalMaterial {
        constructor();
        constructor(MaterialInterface: MaterialInterface, MaterialSlotName: string, bEnableShadowCasting: boolean, bRecomputeTangent: boolean, ImportedMaterialSlotName: string, UVChannelData: MeshUVChannelInfo);

        MaterialInterface: MaterialInterface;
        MaterialSlotName: string;
        bEnableShadowCasting: boolean;
        bRecomputeTangent: boolean;
        ImportedMaterialSlotName: string;
        UVChannelData: MeshUVChannelInfo;

        static StaticClass(): Class;
    }

    export enum EAxis { None, X, Y, Z, EAxis_MAX }

    export class BoneMirrorInfo {
        constructor();
        constructor(SourceIndex: number, BoneFlipAxis: EAxis);

        SourceIndex: number;
        BoneFlipAxis: EAxis;

        static StaticClass(): Class;
    }

    export class SkeletalMeshBuildSettings {
        constructor();
        constructor(bRecomputeNormals: boolean, bRecomputeTangents: boolean, bUseMikkTSpace: boolean, bComputeWeightedNormals: boolean, bRemoveDegenerates: boolean, bUseHighPrecisionTangentBasis: boolean, bUseFullPrecisionUVs: boolean, bBuildAdjacencyBuffer: boolean, ThresholdPosition: number, ThresholdTangentNormal: number, ThresholdUV: number, MorphThresholdPosition: number);

        bRecomputeNormals: boolean;
        bRecomputeTangents: boolean;
        bUseMikkTSpace: boolean;
        bComputeWeightedNormals: boolean;
        bRemoveDegenerates: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bUseFullPrecisionUVs: boolean;
        bBuildAdjacencyBuffer: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
        MorphThresholdPosition: number;

        static StaticClass(): Class;
    }

    export enum SkeletalMeshTerminationCriterion {
        SMTC_NumOfTriangles,
        SMTC_NumOfVerts,
        SMTC_TriangleOrVert,
        SMTC_AbsNumOfTriangles,
        SMTC_AbsNumOfVerts,
        SMTC_AbsTriangleOrVert,
        SMTC_MAX
    }

    export enum SkeletalMeshOptimizationType {
        SMOT_NumOfTriangles,
        SMOT_MaxDeviation,
        SMOT_TriangleOrDeviation,
        SMOT_MAX
    }

    export enum SkeletalMeshOptimizationImportance {
        SMOI_Off,
        SMOI_Lowest,
        SMOI_Low,
        SMOI_Normal,
        SMOI_High,
        SMOI_Highest,
        SMOI_MAX
    }

    export class AnimMetaData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimMetaData;

        static Load(InName: string): AnimMetaData;
    }

    export class AssetMapping {
        constructor();
        constructor(SourceAsset: AnimationAsset, TargetAsset: AnimationAsset);

        SourceAsset: AnimationAsset;
        TargetAsset: AnimationAsset;

        static StaticClass(): Class;
    }

    export class AssetMappingTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MappedAssets: TArray<AssetMapping>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetMappingTable;

        static Load(InName: string): AssetMappingTable;
    }

    export class SmartName {
        constructor();
        constructor(DisplayName: string);

        DisplayName: string;

        static StaticClass(): Class;
    }

    export class PoseData {
        constructor();
        constructor(SourceLocalSpacePose: TArray<Transform>, SourceCurveData: TArray<number>, LocalSpacePose: TArray<Transform>, TrackToBufferIndex: TMap<number, number>, CurveData: TArray<number>);

        SourceLocalSpacePose: TArray<Transform>;
        SourceCurveData: TArray<number>;
        LocalSpacePose: TArray<Transform>;
        TrackToBufferIndex: TMap<number, number>;
        CurveData: TArray<number>;

        static StaticClass(): Class;
    }

    export class AnimCurveBase {
        constructor();
        constructor(LastObservedName: string, Name: SmartName, Color: LinearColor, CurveTypeFlags: number);

        LastObservedName: string;
        Name: SmartName;
        Color: LinearColor;
        CurveTypeFlags: number;

        static StaticClass(): Class;
    }

    export class PoseDataContainer {
        constructor();
        constructor(PoseNames: TArray<SmartName>, Tracks: TArray<string>, TrackMap: TMap<string, number>, Poses: TArray<PoseData>, Curves: TArray<AnimCurveBase>);

        PoseNames: TArray<SmartName>;
        Tracks: TArray<string>;
        TrackMap: TMap<string, number>;
        Poses: TArray<PoseData>;
        Curves: TArray<AnimCurveBase>;

        static StaticClass(): Class;
    }

    export class PoseAsset extends AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PoseContainer: PoseDataContainer;
        bAdditivePose: boolean;
        BasePoseIndex: number;
        RetargetSource: string;
        SourceAnimation: AnimSequence;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PoseAsset;

        static Load(InName: string): PoseAsset;
    }

    export class AnimationAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Skeleton: Skeleton;
        MetaData: TArray<AnimMetaData>;
        ParentAsset: AnimationAsset;
        ChildrenAssets: TArray<AnimationAsset>;
        AssetMappingTable: AssetMappingTable;
        AssetUserData: TArray<AssetUserData>;
        ThumbnailInfo: ThumbnailInfo;
        PreviewPoseAsset: PoseAsset;
        PreviewSkeletalMesh: TSoftObjectPtr<SkeletalMesh>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationAsset;

        static Load(InName: string): AnimationAsset;
    }

    export class AnimCompositeBase extends AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompositeBase;

        static Load(InName: string): AnimCompositeBase;
    }

    export class CurveFloat extends CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatCurve: RichCurve;
        bIsEventCurve: boolean;

        GetFloatValue(InTime: number): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveFloat;

        static Load(InName: string): CurveFloat;
    }

    export enum EAlphaBlendOption {
        Linear,
        Cubic,
        HermiteCubic,
        Sinusoidal,
        QuadraticInOut,
        CubicInOut,
        QuarticInOut,
        QuinticInOut,
        CircularIn,
        CircularOut,
        CircularInOut,
        ExpIn,
        ExpOut,
        ExpInOut,
        Custom,
        EAlphaBlendOption_MAX
    }

    export class AlphaBlend {
        constructor();
        constructor(CustomCurve: CurveFloat, BlendTime: number, BlendOption: EAlphaBlendOption);

        CustomCurve: CurveFloat;
        BlendTime: number;
        BlendOption: EAlphaBlendOption;

        static StaticClass(): Class;
    }

    export class AnimSyncMarker {
        constructor();
        constructor(MarkerName: string, Time: number, TrackIndex: number, Guid: Guid);

        MarkerName: string;
        Time: number;
        TrackIndex: number;
        Guid: Guid;

        static StaticClass(): Class;
    }

    export class MarkerSyncData {
        constructor();
        constructor(AuthoredSyncMarkers: TArray<AnimSyncMarker>);

        AuthoredSyncMarkers: TArray<AnimSyncMarker>;

        static StaticClass(): Class;
    }

    export class CompositeSection extends AnimLinkableElement {
        constructor();
        constructor(SectionName: string, StartTime: number, NextSectionName: string, MetaData: TArray<AnimMetaData>);

        SectionName: string;
        StartTime: number;
        NextSectionName: string;
        MetaData: TArray<AnimMetaData>;

        static StaticClass(): Class;
    }

    export class AnimSegment {
        constructor();
        constructor(AnimReference: AnimSequenceBase, StartPos: number, AnimStartTime: number, AnimEndTime: number, AnimPlayRate: number, LoopingCount: number);

        AnimReference: AnimSequenceBase;
        StartPos: number;
        AnimStartTime: number;
        AnimEndTime: number;
        AnimPlayRate: number;
        LoopingCount: number;

        static StaticClass(): Class;
    }

    export class AnimTrack {
        constructor();
        constructor(AnimSegments: TArray<AnimSegment>);

        AnimSegments: TArray<AnimSegment>;

        static StaticClass(): Class;
    }

    export class SlotAnimationTrack {
        constructor();
        constructor(SlotName: string, AnimTrack: AnimTrack);

        SlotName: string;
        AnimTrack: AnimTrack;

        static StaticClass(): Class;
    }

    export class BranchingPoint extends AnimLinkableElement {
        constructor();
        constructor(EventName: string, DisplayTime: number, TriggerTimeOffset: number);

        EventName: string;
        DisplayTime: number;
        TriggerTimeOffset: number;

        static StaticClass(): Class;
    }

    export enum ERootMotionRootLock { RefPose, AnimFirstFrame, Zero, ERootMotionRootLock_MAX }

    export enum EAnimNotifyEventType { Begin, End, EAnimNotifyEventType_MAX }

    export class BranchingPointMarker {
        constructor();
        constructor(NotifyIndex: number, TriggerTime: number, NotifyEventType: EAnimNotifyEventType);

        NotifyIndex: number;
        TriggerTime: number;
        NotifyEventType: EAnimNotifyEventType;

        static StaticClass(): Class;
    }

    export class TimeStretchCurveMarker {
        constructor();
        constructor(Time: FixSizeArray<number>, Alpha: number);

        Time: FixSizeArray<number>;
        Alpha: number;

        static StaticClass(): Class;
    }

    export class TimeStretchCurve {
        constructor();
        constructor(SamplingRate: number, CurveValueMinPrecision: number, Markers: TArray<TimeStretchCurveMarker>, Sum_dT_i_by_C_i: FixSizeArray<number>);

        SamplingRate: number;
        CurveValueMinPrecision: number;
        Markers: TArray<TimeStretchCurveMarker>;
        Sum_dT_i_by_C_i: FixSizeArray<number>;

        static StaticClass(): Class;
    }

    export class AnimMontage extends AnimCompositeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlendIn: AlphaBlend;
        BlendInTime: number;
        BlendOut: AlphaBlend;
        BlendOutTime: number;
        BlendOutTriggerTime: number;
        SyncGroup: string;
        SyncSlotIndex: number;
        MarkerData: MarkerSyncData;
        CompositeSections: TArray<CompositeSection>;
        SlotAnimTracks: TArray<SlotAnimationTrack>;
        BranchingPoints: TArray<BranchingPoint>;
        bEnableRootMotionTranslation: boolean;
        bEnableRootMotionRotation: boolean;
        bEnableAutoBlendOut: boolean;
        RootMotionRootLock: ERootMotionRootLock;
        PreviewBasePose: AnimSequence;
        BranchingPointMarkers: TArray<BranchingPointMarker>;
        BranchingPointStateNotifyIndices: TArray<number>;
        TimeStretchCurve: TimeStretchCurve;
        TimeStretchCurveName: string;

        GetDefaultBlendOutTime(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimMontage;

        static Load(InName: string): AnimMontage;
    }

    export enum EAnimLinkMethod { Absolute, Relative, Proportional, EAnimLinkMethod_MAX }

    export class AnimLinkableElement {
        constructor();
        constructor(LinkedMontage: AnimMontage, SlotIndex: number, SegmentIndex: number, LinkMethod: EAnimLinkMethod, CachedLinkMethod: EAnimLinkMethod, SegmentBeginTime: number, SegmentLength: number, LinkValue: number, LinkedSequence: AnimSequenceBase);

        LinkedMontage: AnimMontage;
        SlotIndex: number;
        SegmentIndex: number;
        LinkMethod: EAnimLinkMethod;
        CachedLinkMethod: EAnimLinkMethod;
        SegmentBeginTime: number;
        SegmentLength: number;
        LinkValue: number;
        LinkedSequence: AnimSequenceBase;

        static StaticClass(): Class;
    }

    export class AnimNotify extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NotifyColor: Color;

        GetNotifyName(): string;

        Received_Notify(MeshComp: $Nullable<SkeletalMeshComponent>, Animation: $Nullable<AnimSequenceBase>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify;

        static Load(InName: string): AnimNotify;
    }

    export class AnimNotifyState extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NotifyColor: Color;

        GetNotifyName(): string;

        Received_NotifyBegin(MeshComp: $Nullable<SkeletalMeshComponent>, Animation: $Nullable<AnimSequenceBase>, TotalDuration: number): boolean;

        Received_NotifyEnd(MeshComp: $Nullable<SkeletalMeshComponent>, Animation: $Nullable<AnimSequenceBase>): boolean;

        Received_NotifyTick(MeshComp: $Nullable<SkeletalMeshComponent>, Animation: $Nullable<AnimSequenceBase>, FrameDeltaTime: number): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotifyState;

        static Load(InName: string): AnimNotifyState;
    }

    export enum EMontageNotifyTickType { Queued, BranchingPoint, EMontageNotifyTickType_MAX }

    export enum ENotifyFilterType { NoFiltering, LOD, ENotifyFilterType_MAX }

    export class AnimNotifyEvent extends AnimLinkableElement {
        constructor();
        constructor(DisplayTime: number, TriggerTimeOffset: number, EndTriggerTimeOffset: number, TriggerWeightThreshold: number, NotifyName: string, Notify: AnimNotify, NotifyStateClass: AnimNotifyState, Duration: number, EndLink: AnimLinkableElement, bConvertedFromBranchingPoint: boolean, MontageTickType: EMontageNotifyTickType, NotifyTriggerChance: number, NotifyFilterType: ENotifyFilterType, NotifyFilterLOD: number, bTriggerOnDedicatedServer: boolean, bTriggerOnFollower: boolean, NotifyColor: Color, Guid: Guid, TrackIndex: number);

        DisplayTime: number;
        TriggerTimeOffset: number;
        EndTriggerTimeOffset: number;
        TriggerWeightThreshold: number;
        NotifyName: string;
        Notify: AnimNotify;
        NotifyStateClass: AnimNotifyState;
        Duration: number;
        EndLink: AnimLinkableElement;
        bConvertedFromBranchingPoint: boolean;
        MontageTickType: EMontageNotifyTickType;
        NotifyTriggerChance: number;
        NotifyFilterType: ENotifyFilterType;
        NotifyFilterLOD: number;
        bTriggerOnDedicatedServer: boolean;
        bTriggerOnFollower: boolean;
        NotifyColor: Color;
        Guid: Guid;
        TrackIndex: number;

        static StaticClass(): Class;
    }

    export class FloatCurve extends AnimCurveBase {
        constructor();
        constructor(FloatCurve: RichCurve);

        FloatCurve: RichCurve;

        static StaticClass(): Class;
    }

    export class VectorCurve extends AnimCurveBase {
        constructor();
        constructor(FloatCurves: FixSizeArray<RichCurve>);

        FloatCurves: FixSizeArray<RichCurve>;

        static StaticClass(): Class;
    }

    export class TransformCurve extends AnimCurveBase {
        constructor();
        constructor(TranslationCurve: VectorCurve, RotationCurve: VectorCurve, ScaleCurve: VectorCurve);

        TranslationCurve: VectorCurve;
        RotationCurve: VectorCurve;
        ScaleCurve: VectorCurve;

        static StaticClass(): Class;
    }

    export class RawCurveTracks {
        constructor();
        constructor(FloatCurves: TArray<FloatCurve>, VectorCurves: TArray<VectorCurve>, TransformCurves: TArray<TransformCurve>);

        FloatCurves: TArray<FloatCurve>;
        VectorCurves: TArray<VectorCurve>;
        TransformCurves: TArray<TransformCurve>;

        static StaticClass(): Class;
    }

    export class AnimNotifyTrack {
        constructor();
        constructor(TrackName: string, TrackColor: LinearColor);

        TrackName: string;
        TrackColor: LinearColor;

        static StaticClass(): Class;
    }

    export class AnimSequenceBase extends AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Notifies: TArray<AnimNotifyEvent>;
        SequenceLength: number;
        RateScale: number;
        RawCurveData: RawCurveTracks;
        AnimNotifyTracks: TArray<AnimNotifyTrack>;

        GetPlayLength(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSequenceBase;

        static Load(InName: string): AnimSequenceBase;
    }

    export class TrackToSkeletonMap {
        constructor();
        constructor(BoneTreeIndex: number);

        BoneTreeIndex: number;

        static StaticClass(): Class;
    }

    export class AnimBoneCompressionCodec extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Description: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimBoneCompressionCodec;

        static Load(InName: string): AnimBoneCompressionCodec;
    }

    export class AnimBoneCompressionSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Codecs: TArray<AnimBoneCompressionCodec>;
        ErrorThreshold: number;
        bForceBelowThreshold: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimBoneCompressionSettings;

        static Load(InName: string): AnimBoneCompressionSettings;
    }

    export class AnimCurveCompressionCodec extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec;

        static Load(InName: string): AnimCurveCompressionCodec;
    }

    export class AnimCurveCompressionSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Codec: AnimCurveCompressionCodec;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionSettings;

        static Load(InName: string): AnimCurveCompressionSettings;
    }

    export enum EAdditiveAnimationType { AAT_None, AAT_LocalSpaceBase, AAT_RotationOffsetMeshSpace, AAT_MAX }

    export enum EAdditiveBasePoseType { ABPT_None, ABPT_RefPose, ABPT_AnimScaled, ABPT_AnimFrame, ABPT_MAX }

    export enum EAnimInterpolationType { Linear, Step, EAnimInterpolationType_MAX }

    export class CustomAttribute {
        constructor();
        constructor(Name: string, VariantType: number, Times: TArray<number>);

        Name: string;
        VariantType: number;
        Times: TArray<number>;

        static StaticClass(): Class;
    }

    export class CustomAttributePerBoneData {
        constructor();
        constructor(BoneTreeIndex: number, Attributes: TArray<CustomAttribute>);

        BoneTreeIndex: number;
        Attributes: TArray<CustomAttribute>;

        static StaticClass(): Class;
    }

    export class StringCurveKey {
        constructor();
        constructor(Time: number, Value: string);

        Time: number;
        Value: string;

        static StaticClass(): Class;
    }

    export class StringCurve extends IndexedCurve {
        constructor();
        constructor(DefaultValue: string, Keys: TArray<StringCurveKey>);

        DefaultValue: string;
        Keys: TArray<StringCurveKey>;

        static StaticClass(): Class;
    }

    export class BakedStringCustomAttribute {
        constructor();
        constructor(AttributeName: string, StringCurve: StringCurve);

        AttributeName: string;
        StringCurve: StringCurve;

        static StaticClass(): Class;
    }

    export class IntegralKey {
        constructor();
        constructor(Time: number, Value: number);

        Time: number;
        Value: number;

        static StaticClass(): Class;
    }

    export class IntegralCurve extends IndexedCurve {
        constructor();
        constructor(Keys: TArray<IntegralKey>, DefaultValue: number, bUseDefaultValueBeforeFirstKey: boolean);

        Keys: TArray<IntegralKey>;
        DefaultValue: number;
        bUseDefaultValueBeforeFirstKey: boolean;

        static StaticClass(): Class;
    }

    export class BakedIntegerCustomAttribute {
        constructor();
        constructor(AttributeName: string, IntCurve: IntegralCurve);

        AttributeName: string;
        IntCurve: IntegralCurve;

        static StaticClass(): Class;
    }

    export class SimpleCurveKey {
        constructor();
        constructor(Time: number, Value: number);

        Time: number;
        Value: number;

        static StaticClass(): Class;
    }

    export class SimpleCurve extends RealCurve {
        constructor();
        constructor(InterpMode: ERichCurveInterpMode, Keys: TArray<SimpleCurveKey>);

        InterpMode: ERichCurveInterpMode;
        Keys: TArray<SimpleCurveKey>;

        static StaticClass(): Class;
    }

    export class BakedFloatCustomAttribute {
        constructor();
        constructor(AttributeName: string, FloatCurve: SimpleCurve);

        AttributeName: string;
        FloatCurve: SimpleCurve;

        static StaticClass(): Class;
    }

    export class BakedCustomAttributePerBoneData {
        constructor();
        constructor(BoneTreeIndex: number, StringAttributes: TArray<BakedStringCustomAttribute>, IntAttributes: TArray<BakedIntegerCustomAttribute>, FloatAttributes: TArray<BakedFloatCustomAttribute>);

        BoneTreeIndex: number;
        StringAttributes: TArray<BakedStringCustomAttribute>;
        IntAttributes: TArray<BakedIntegerCustomAttribute>;
        FloatAttributes: TArray<BakedFloatCustomAttribute>;

        static StaticClass(): Class;
    }

    export class AnimSequence extends AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImportFileFramerate: number;
        ImportResampleFramerate: number;
        NumFrames: number;
        TrackToSkeletonMapTable: TArray<TrackToSkeletonMap>;
        RawDataGuid: Guid;
        AnimationTrackNames: TArray<string>;
        bAllowFrameStripping: boolean;
        CompressionErrorThresholdScale: number;
        BoneCompressionSettings: AnimBoneCompressionSettings;
        CurveCompressionSettings: AnimCurveCompressionSettings;
        AdditiveAnimType: EAdditiveAnimationType;
        RefPoseType: EAdditiveBasePoseType;
        RefPoseSeq: AnimSequence;
        RefFrameIndex: number;
        RetargetSource: string;
        Interpolation: EAnimInterpolationType;
        bEnableRootMotion: boolean;
        RootMotionRootLock: ERootMotionRootLock;
        bForceRootLock: boolean;
        bUseNormalizedRootMotionScale: boolean;
        bRootMotionSettingsCopiedFromMontage: boolean;
        CompressCommandletVersion: number;
        bDoNotOverrideCompression: boolean;
        AssetImportData: AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        bNeedsRebake: boolean;
        AuthoredSyncMarkers: TArray<AnimSyncMarker>;
        PerBoneCustomAttributeData: TArray<CustomAttributePerBoneData>;
        CustomAttributesGuid: Guid;
        BakedCustomAttributesGuid: Guid;
        BakedPerBoneCustomAttributeData: TArray<BakedCustomAttributePerBoneData>;

        AddBoneFloatCustomAttribute(BoneName: string, AttributeName: string, TimeKeys: TArray<number>, ValueKeys: TArray<number>): void;

        AddBoneIntegerCustomAttribute(BoneName: string, AttributeName: string, TimeKeys: TArray<number>, ValueKeys: TArray<number>): void;

        AddBoneStringCustomAttribute(BoneName: string, AttributeName: string, TimeKeys: TArray<number>, ValueKeys: TArray<string>): void;

        RemoveAllCustomAttributes(): void;

        RemoveAllCustomAttributesForBone(BoneName: string): void;

        RemoveCustomAttribute(BoneName: string, AttributeName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSequence;

        static Load(InName: string): AnimSequence;
    }

    export class SkeletalMeshOptimizationSettings {
        constructor();
        constructor(TerminationCriterion: SkeletalMeshTerminationCriterion, NumOfTrianglesPercentage: number, NumOfVertPercentage: number, MaxNumOfTriangles: number, MaxNumOfVerts: number, MaxNumOfTrianglesPercentage: number, MaxNumOfVertsPercentage: number, MaxDeviationPercentage: number, ReductionMethod: SkeletalMeshOptimizationType, SilhouetteImportance: SkeletalMeshOptimizationImportance, TextureImportance: SkeletalMeshOptimizationImportance, ShadingImportance: SkeletalMeshOptimizationImportance, SkinningImportance: SkeletalMeshOptimizationImportance, bRemapMorphTargets: boolean, bRecalcNormals: boolean, WeldingThreshold: number, NormalsThreshold: number, MaxBonesPerVertex: number, bEnforceBoneBoundaries: boolean, VolumeImportance: number, bLockEdges: boolean, bLockColorBounaries: boolean, BaseLOD: number, BonesToRemove: TArray<BoneReference>, BakePose: AnimSequence);

        TerminationCriterion: SkeletalMeshTerminationCriterion;
        NumOfTrianglesPercentage: number;
        NumOfVertPercentage: number;
        MaxNumOfTriangles: number;
        MaxNumOfVerts: number;
        MaxNumOfTrianglesPercentage: number;
        MaxNumOfVertsPercentage: number;
        MaxDeviationPercentage: number;
        ReductionMethod: SkeletalMeshOptimizationType;
        SilhouetteImportance: SkeletalMeshOptimizationImportance;
        TextureImportance: SkeletalMeshOptimizationImportance;
        ShadingImportance: SkeletalMeshOptimizationImportance;
        SkinningImportance: SkeletalMeshOptimizationImportance;
        bRemapMorphTargets: boolean;
        bRecalcNormals: boolean;
        WeldingThreshold: number;
        NormalsThreshold: number;
        MaxBonesPerVertex: number;
        bEnforceBoneBoundaries: boolean;
        VolumeImportance: number;
        bLockEdges: boolean;
        bLockColorBounaries: boolean;
        BaseLOD: number;
        BonesToRemove: TArray<BoneReference>;
        BakePose: AnimSequence;

        static StaticClass(): Class;
    }

    export enum ESkinCacheUsage { Auto, Disabled, Enabled, ESkinCacheUsage_MAX }

    export class SkeletalMeshLODInfo {
        constructor();
        constructor(ScreenSize: PerPlatformFloat, LODHysteresis: number, LODMaterialMap: TArray<number>, bEnableShadowCasting: TArray<boolean>, RemovedBones: TArray<string>, BuildSettings: SkeletalMeshBuildSettings, ReductionSettings: SkeletalMeshOptimizationSettings, BonesToRemove: TArray<BoneReference>, BonesToPrioritize: TArray<BoneReference>, WeightOfPrioritization: number, BakePose: AnimSequence, BakePoseOverride: AnimSequence, SourceImportFilename: string, SkinCacheUsage: ESkinCacheUsage, bHasBeenSimplified: boolean, bHasPerLODVertexColors: boolean, bAllowCPUAccess: boolean, bSupportUniformlyDistributedSampling: boolean, bImportWithBaseMesh: boolean);

        ScreenSize: PerPlatformFloat;
        LODHysteresis: number;
        LODMaterialMap: TArray<number>;
        bEnableShadowCasting: TArray<boolean>;
        RemovedBones: TArray<string>;
        BuildSettings: SkeletalMeshBuildSettings;
        ReductionSettings: SkeletalMeshOptimizationSettings;
        BonesToRemove: TArray<BoneReference>;
        BonesToPrioritize: TArray<BoneReference>;
        WeightOfPrioritization: number;
        BakePose: AnimSequence;
        BakePoseOverride: AnimSequence;
        SourceImportFilename: string;
        SkinCacheUsage: ESkinCacheUsage;
        bHasBeenSimplified: boolean;
        bHasPerLODVertexColors: boolean;
        bAllowCPUAccess: boolean;
        bSupportUniformlyDistributedSampling: boolean;
        bImportWithBaseMesh: boolean;

        static StaticClass(): Class;
    }

    export class PerPlatformBool {
        constructor();
        constructor(Default: boolean, PerPlatform: TMap<string, boolean>);

        Default: boolean;
        PerPlatform: TMap<string, boolean>;

        static StaticClass(): Class;
    }

    export enum EBoneFilterActionOption { Remove, Keep, Invalid, EBoneFilterActionOption_MAX }

    export class BoneFilter {
        constructor();
        constructor(bExcludeSelf: boolean, BoneName: string);

        bExcludeSelf: boolean;
        BoneName: string;

        static StaticClass(): Class;
    }

    export class SkeletalMeshLODGroupSettings {
        constructor();
        constructor(ScreenSize: PerPlatformFloat, LODHysteresis: number, BoneFilterActionOption: EBoneFilterActionOption, BoneList: TArray<BoneFilter>, BonesToPrioritize: TArray<string>, WeightOfPrioritization: number, BakePose: AnimSequence, ReductionSettings: SkeletalMeshOptimizationSettings);

        ScreenSize: PerPlatformFloat;
        LODHysteresis: number;
        BoneFilterActionOption: EBoneFilterActionOption;
        BoneList: TArray<BoneFilter>;
        BonesToPrioritize: TArray<string>;
        WeightOfPrioritization: number;
        BakePose: AnimSequence;
        ReductionSettings: SkeletalMeshOptimizationSettings;

        static StaticClass(): Class;
    }

    export class SkeletalMeshLODSettings extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MinLod: PerPlatformInt;
        DisableBelowMinLodStripping: PerPlatformBool;
        bOverrideLODStreamingSettings: boolean;
        bSupportLODStreaming: PerPlatformBool;
        MaxNumStreamedLODs: PerPlatformInt;
        MaxNumOptionalLODs: PerPlatformInt;
        LODGroups: TArray<SkeletalMeshLODGroupSettings>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshLODSettings;

        static Load(InName: string): SkeletalMeshLODSettings;
    }

    export class PhysicalAnimationData {
        constructor();
        constructor(BodyName: string, bIsLocalSimulation: boolean, OrientationStrength: number, AngularVelocityStrength: number, PositionStrength: number, VelocityStrength: number, MaxLinearForce: number, MaxAngularForce: number);

        BodyName: string;
        bIsLocalSimulation: boolean;
        OrientationStrength: number;
        AngularVelocityStrength: number;
        PositionStrength: number;
        VelocityStrength: number;
        MaxLinearForce: number;
        MaxAngularForce: number;

        static StaticClass(): Class;
    }

    export class PhysicalAnimationProfile {
        constructor();
        constructor(ProfileName: string, PhysicalAnimationData: PhysicalAnimationData);

        ProfileName: string;
        PhysicalAnimationData: PhysicalAnimationData;

        static StaticClass(): Class;
    }

    export class SkeletalBodySetup extends BodySetup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentPhysicalAnimationProfile: PhysicalAnimationProfile;
        bSkipScaleFromAnimation: boolean;
        PhysicalAnimationData: TArray<PhysicalAnimationProfile>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalBodySetup;

        static Load(InName: string): SkeletalBodySetup;
    }

    export class ConstraintInstanceBase {
        constructor();

        static StaticClass(): Class;
    }

    export class ConstraintBaseParams {
        constructor();
        constructor(Stiffness: number, Damping: number, Restitution: number, ContactDistance: number, bSoftConstraint: boolean);

        Stiffness: number;
        Damping: number;
        Restitution: number;
        ContactDistance: number;
        bSoftConstraint: boolean;

        static StaticClass(): Class;
    }

    export enum ELinearConstraintMotion { LCM_Free, LCM_Limited, LCM_Locked, LCM_MAX }

    export class LinearConstraint extends ConstraintBaseParams {
        constructor();
        constructor(Limit: number, XMotion: ELinearConstraintMotion, YMotion: ELinearConstraintMotion, ZMotion: ELinearConstraintMotion);

        Limit: number;
        XMotion: ELinearConstraintMotion;
        YMotion: ELinearConstraintMotion;
        ZMotion: ELinearConstraintMotion;

        static StaticClass(): Class;
    }

    export enum EAngularConstraintMotion { ACM_Free, ACM_Limited, ACM_Locked, ACM_MAX }

    export class ConeConstraint extends ConstraintBaseParams {
        constructor();
        constructor(Swing1LimitDegrees: number, Swing2LimitDegrees: number, Swing1Motion: EAngularConstraintMotion, Swing2Motion: EAngularConstraintMotion);

        Swing1LimitDegrees: number;
        Swing2LimitDegrees: number;
        Swing1Motion: EAngularConstraintMotion;
        Swing2Motion: EAngularConstraintMotion;

        static StaticClass(): Class;
    }

    export class TwistConstraint extends ConstraintBaseParams {
        constructor();
        constructor(TwistLimitDegrees: number, TwistMotion: EAngularConstraintMotion);

        TwistLimitDegrees: number;
        TwistMotion: EAngularConstraintMotion;

        static StaticClass(): Class;
    }

    export class ConstraintDrive {
        constructor();
        constructor(Stiffness: number, Damping: number, MaxForce: number, bEnablePositionDrive: boolean, bEnableVelocityDrive: boolean);

        Stiffness: number;
        Damping: number;
        MaxForce: number;
        bEnablePositionDrive: boolean;
        bEnableVelocityDrive: boolean;

        static StaticClass(): Class;
    }

    export class LinearDriveConstraint {
        constructor();
        constructor(PositionTarget: Vector, VelocityTarget: Vector, XDrive: ConstraintDrive, YDrive: ConstraintDrive, ZDrive: ConstraintDrive, bEnablePositionDrive: boolean);

        PositionTarget: Vector;
        VelocityTarget: Vector;
        XDrive: ConstraintDrive;
        YDrive: ConstraintDrive;
        ZDrive: ConstraintDrive;
        bEnablePositionDrive: boolean;

        static StaticClass(): Class;
    }

    export enum EAngularDriveMode { SLERP, TwistAndSwing, EAngularDriveMode_MAX }

    export class AngularDriveConstraint {
        constructor();
        constructor(TwistDrive: ConstraintDrive, SwingDrive: ConstraintDrive, SlerpDrive: ConstraintDrive, OrientationTarget: Rotator, AngularVelocityTarget: Vector, AngularDriveMode: EAngularDriveMode);

        TwistDrive: ConstraintDrive;
        SwingDrive: ConstraintDrive;
        SlerpDrive: ConstraintDrive;
        OrientationTarget: Rotator;
        AngularVelocityTarget: Vector;
        AngularDriveMode: EAngularDriveMode;

        static StaticClass(): Class;
    }

    export class ConstraintProfileProperties {
        constructor();
        constructor(ProjectionLinearTolerance: number, ProjectionAngularTolerance: number, ProjectionLinearAlpha: number, ProjectionAngularAlpha: number, LinearBreakThreshold: number, AngularBreakThreshold: number, LinearLimit: LinearConstraint, ConeLimit: ConeConstraint, TwistLimit: TwistConstraint, LinearDrive: LinearDriveConstraint, AngularDrive: AngularDriveConstraint, bDisableCollision: boolean, bParentDominates: boolean, bEnableProjection: boolean, bEnableSoftProjection: boolean, bAngularBreakable: boolean, bLinearBreakable: boolean);

        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        ProjectionLinearAlpha: number;
        ProjectionAngularAlpha: number;
        LinearBreakThreshold: number;
        AngularBreakThreshold: number;
        LinearLimit: LinearConstraint;
        ConeLimit: ConeConstraint;
        TwistLimit: TwistConstraint;
        LinearDrive: LinearDriveConstraint;
        AngularDrive: AngularDriveConstraint;
        bDisableCollision: boolean;
        bParentDominates: boolean;
        bEnableProjection: boolean;
        bEnableSoftProjection: boolean;
        bAngularBreakable: boolean;
        bLinearBreakable: boolean;

        static StaticClass(): Class;
    }

    export class ConstraintInstance extends ConstraintInstanceBase {
        constructor();
        constructor(JointName: string, ConstraintBone1: string, ConstraintBone2: string, Pos1: Vector, PriAxis1: Vector, SecAxis1: Vector, Pos2: Vector, PriAxis2: Vector, SecAxis2: Vector, AngularRotationOffset: Rotator, bScaleLinearLimits: boolean, ProfileInstance: ConstraintProfileProperties, bDisableCollision: boolean, bEnableProjection: boolean, ProjectionLinearTolerance: number, ProjectionAngularTolerance: number, LinearXMotion: ELinearConstraintMotion, LinearYMotion: ELinearConstraintMotion, LinearZMotion: ELinearConstraintMotion, LinearLimitSize: number, bLinearLimitSoft: boolean, LinearLimitStiffness: number, LinearLimitDamping: number, bLinearBreakable: boolean, LinearBreakThreshold: number, AngularSwing1Motion: EAngularConstraintMotion, AngularTwistMotion: EAngularConstraintMotion, AngularSwing2Motion: EAngularConstraintMotion, bSwingLimitSoft: boolean, bTwistLimitSoft: boolean, Swing1LimitAngle: number, TwistLimitAngle: number, Swing2LimitAngle: number, SwingLimitStiffness: number, SwingLimitDamping: number, TwistLimitStiffness: number, TwistLimitDamping: number, bAngularBreakable: boolean, AngularBreakThreshold: number, bLinearXPositionDrive: boolean, bLinearXVelocityDrive: boolean, bLinearYPositionDrive: boolean, bLinearYVelocityDrive: boolean, bLinearZPositionDrive: boolean, bLinearZVelocityDrive: boolean, bLinearPositionDrive: boolean, bLinearVelocityDrive: boolean, LinearPositionTarget: Vector, LinearVelocityTarget: Vector, LinearDriveSpring: number, LinearDriveDamping: number, LinearDriveForceLimit: number, bSwingPositionDrive: boolean, bSwingVelocityDrive: boolean, bTwistPositionDrive: boolean, bTwistVelocityDrive: boolean, bAngularSlerpDrive: boolean, bAngularOrientationDrive: boolean, bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bAngularVelocityDrive: boolean, AngularPositionTarget: Quat, AngularDriveMode: EAngularDriveMode, AngularOrientationTarget: Rotator, AngularVelocityTarget: Vector, AngularDriveSpring: number, AngularDriveDamping: number, AngularDriveForceLimit: number);

        JointName: string;
        ConstraintBone1: string;
        ConstraintBone2: string;
        Pos1: Vector;
        PriAxis1: Vector;
        SecAxis1: Vector;
        Pos2: Vector;
        PriAxis2: Vector;
        SecAxis2: Vector;
        AngularRotationOffset: Rotator;
        bScaleLinearLimits: boolean;
        ProfileInstance: ConstraintProfileProperties;
        bDisableCollision: boolean;
        bEnableProjection: boolean;
        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        LinearXMotion: ELinearConstraintMotion;
        LinearYMotion: ELinearConstraintMotion;
        LinearZMotion: ELinearConstraintMotion;
        LinearLimitSize: number;
        bLinearLimitSoft: boolean;
        LinearLimitStiffness: number;
        LinearLimitDamping: number;
        bLinearBreakable: boolean;
        LinearBreakThreshold: number;
        AngularSwing1Motion: EAngularConstraintMotion;
        AngularTwistMotion: EAngularConstraintMotion;
        AngularSwing2Motion: EAngularConstraintMotion;
        bSwingLimitSoft: boolean;
        bTwistLimitSoft: boolean;
        Swing1LimitAngle: number;
        TwistLimitAngle: number;
        Swing2LimitAngle: number;
        SwingLimitStiffness: number;
        SwingLimitDamping: number;
        TwistLimitStiffness: number;
        TwistLimitDamping: number;
        bAngularBreakable: boolean;
        AngularBreakThreshold: number;
        bLinearXPositionDrive: boolean;
        bLinearXVelocityDrive: boolean;
        bLinearYPositionDrive: boolean;
        bLinearYVelocityDrive: boolean;
        bLinearZPositionDrive: boolean;
        bLinearZVelocityDrive: boolean;
        bLinearPositionDrive: boolean;
        bLinearVelocityDrive: boolean;
        LinearPositionTarget: Vector;
        LinearVelocityTarget: Vector;
        LinearDriveSpring: number;
        LinearDriveDamping: number;
        LinearDriveForceLimit: number;
        bSwingPositionDrive: boolean;
        bSwingVelocityDrive: boolean;
        bTwistPositionDrive: boolean;
        bTwistVelocityDrive: boolean;
        bAngularSlerpDrive: boolean;
        bAngularOrientationDrive: boolean;
        bEnableSwingDrive: boolean;
        bEnableTwistDrive: boolean;
        bAngularVelocityDrive: boolean;
        AngularPositionTarget: Quat;
        AngularDriveMode: EAngularDriveMode;
        AngularOrientationTarget: Rotator;
        AngularVelocityTarget: Vector;
        AngularDriveSpring: number;
        AngularDriveDamping: number;
        AngularDriveForceLimit: number;

        static StaticClass(): Class;
    }

    export class PhysicsConstraintProfileHandle {
        constructor();
        constructor(ProfileProperties: ConstraintProfileProperties, ProfileName: string);

        ProfileProperties: ConstraintProfileProperties;
        ProfileName: string;

        static StaticClass(): Class;
    }

    export class PhysicsConstraintTemplate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultInstance: ConstraintInstance;
        ProfileHandles: TArray<PhysicsConstraintProfileHandle>;
        DefaultProfile: ConstraintProfileProperties;
        JointName: string;
        ConstraintBone1: string;
        ConstraintBone2: string;
        Pos1: Vector;
        PriAxis1: Vector;
        SecAxis1: Vector;
        Pos2: Vector;
        PriAxis2: Vector;
        SecAxis2: Vector;
        bEnableProjection: boolean;
        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        LinearXMotion: ELinearConstraintMotion;
        LinearYMotion: ELinearConstraintMotion;
        LinearZMotion: ELinearConstraintMotion;
        LinearLimitSize: number;
        bLinearLimitSoft: boolean;
        LinearLimitStiffness: number;
        LinearLimitDamping: number;
        bLinearBreakable: boolean;
        LinearBreakThreshold: number;
        AngularSwing1Motion: EAngularConstraintMotion;
        AngularSwing2Motion: EAngularConstraintMotion;
        AngularTwistMotion: EAngularConstraintMotion;
        bSwingLimitSoft: boolean;
        bTwistLimitSoft: boolean;
        Swing1LimitAngle: number;
        Swing2LimitAngle: number;
        TwistLimitAngle: number;
        SwingLimitStiffness: number;
        SwingLimitDamping: number;
        TwistLimitStiffness: number;
        TwistLimitDamping: number;
        bAngularBreakable: boolean;
        AngularBreakThreshold: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintTemplate;

        static Load(InName: string): PhysicsConstraintTemplate;
    }

    export class SolverIterations {
        constructor();
        constructor(FixedTimeStep: number, SolverIterations: number, JointIterations: number, CollisionIterations: number, SolverPushOutIterations: number, JointPushOutIterations: number, CollisionPushOutIterations: number);

        FixedTimeStep: number;
        SolverIterations: number;
        JointIterations: number;
        CollisionIterations: number;
        SolverPushOutIterations: number;
        JointPushOutIterations: number;
        CollisionPushOutIterations: number;

        static StaticClass(): Class;
    }

    export class PhysicsAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultSkelMesh: SkeletalMesh;
        PreviewSkeletalMesh: TSoftObjectPtr<SkeletalMesh>;
        PhysicalAnimationProfiles: TArray<string>;
        ConstraintProfiles: TArray<string>;
        CurrentPhysicalAnimationProfileName: string;
        CurrentConstraintProfileName: string;
        BoundsBodies: TArray<number>;
        SkeletalBodySetups: TArray<SkeletalBodySetup>;
        ConstraintSetup: TArray<PhysicsConstraintTemplate>;
        SolverIterations: SolverIterations;
        bNotForDedicatedServer: boolean;
        ThumbnailInfo: ThumbnailInfo;
        BodySetup: TArray<BodySetup>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsAsset;

        static Load(InName: string): PhysicsAsset;
    }

    export class NodeItem {
        constructor();
        constructor(ParentName: string, Transform: Transform);

        ParentName: string;
        Transform: Transform;

        static StaticClass(): Class;
    }

    export class NodeMappingContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceItems: TMap<string, NodeItem>;
        TargetItems: TMap<string, NodeItem>;
        SourceToTarget: TMap<string, string>;
        SourceAsset: TSoftObjectPtr<Object>;
        TargetAsset: TSoftObjectPtr<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NodeMappingContainer;

        static Load(InName: string): NodeMappingContainer;
    }

    export class MorphTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BaseSkelMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MorphTarget;

        static Load(InName: string): MorphTarget;
    }

    export class ClothPhysicsProperties_Legacy {
        constructor();
        constructor(VerticalResistance: number, HorizontalResistance: number, BendResistance: number, ShearResistance: number, Friction: number, Damping: number, TetherStiffness: number, TetherLimit: number, Drag: number, StiffnessFrequency: number, GravityScale: number, MassScale: number, InertiaBlend: number, SelfCollisionThickness: number, SelfCollisionSquashScale: number, SelfCollisionStiffness: number, SolverFrequency: number, FiberCompression: number, FiberExpansion: number, FiberResistance: number);

        VerticalResistance: number;
        HorizontalResistance: number;
        BendResistance: number;
        ShearResistance: number;
        Friction: number;
        Damping: number;
        TetherStiffness: number;
        TetherLimit: number;
        Drag: number;
        StiffnessFrequency: number;
        GravityScale: number;
        MassScale: number;
        InertiaBlend: number;
        SelfCollisionThickness: number;
        SelfCollisionSquashScale: number;
        SelfCollisionStiffness: number;
        SolverFrequency: number;
        FiberCompression: number;
        FiberExpansion: number;
        FiberResistance: number;

        static StaticClass(): Class;
    }

    export class ClothingAssetData_Legacy {
        constructor();
        constructor(AssetName: string, ApexFileName: string, bClothPropertiesChanged: boolean, PhysicsProperties: ClothPhysicsProperties_Legacy);

        AssetName: string;
        ApexFileName: string;
        bClothPropertiesChanged: boolean;
        PhysicsProperties: ClothPhysicsProperties_Legacy;

        static StaticClass(): Class;
    }

    export class ClothingAssetBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImportedFilePath: string;
        AssetGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingAssetBase;

        static Load(InName: string): ClothingAssetBase;
    }

    export class SkeletalMeshSamplingRegionMaterialFilter {
        constructor();
        constructor(MaterialName: string);

        MaterialName: string;

        static StaticClass(): Class;
    }

    export class SkeletalMeshSamplingRegionBoneFilter {
        constructor();
        constructor(BoneName: string, bIncludeOrExclude: boolean, bApplyToChildren: boolean);

        BoneName: string;
        bIncludeOrExclude: boolean;
        bApplyToChildren: boolean;

        static StaticClass(): Class;
    }

    export class SkeletalMeshSamplingRegion {
        constructor();
        constructor(Name: string, LODIndex: number, bSupportUniformlyDistributedSampling: boolean, MaterialFilters: TArray<SkeletalMeshSamplingRegionMaterialFilter>, BoneFilters: TArray<SkeletalMeshSamplingRegionBoneFilter>);

        Name: string;
        LODIndex: number;
        bSupportUniformlyDistributedSampling: boolean;
        MaterialFilters: TArray<SkeletalMeshSamplingRegionMaterialFilter>;
        BoneFilters: TArray<SkeletalMeshSamplingRegionBoneFilter>;

        static StaticClass(): Class;
    }

    export class SkeletalMeshSamplingLODBuiltData {
        constructor();

        static StaticClass(): Class;
    }

    export class SkeletalMeshSamplingRegionBuiltData {
        constructor();

        static StaticClass(): Class;
    }

    export class SkeletalMeshSamplingBuiltData {
        constructor();
        constructor(WholeMeshBuiltData: TArray<SkeletalMeshSamplingLODBuiltData>, RegionBuiltData: TArray<SkeletalMeshSamplingRegionBuiltData>);

        WholeMeshBuiltData: TArray<SkeletalMeshSamplingLODBuiltData>;
        RegionBuiltData: TArray<SkeletalMeshSamplingRegionBuiltData>;

        static StaticClass(): Class;
    }

    export class SkeletalMeshSamplingInfo {
        constructor();
        constructor(Regions: TArray<SkeletalMeshSamplingRegion>, BuiltData: SkeletalMeshSamplingBuiltData);

        Regions: TArray<SkeletalMeshSamplingRegion>;
        BuiltData: SkeletalMeshSamplingBuiltData;

        static StaticClass(): Class;
    }

    export class SkinWeightProfileInfo {
        constructor();
        constructor(Name: string, DefaultProfile: PerPlatformBool, DefaultProfileFromLODIndex: PerPlatformInt, PerLODSourceFiles: TMap<number, string>);

        Name: string;
        DefaultProfile: PerPlatformBool;
        DefaultProfileFromLODIndex: PerPlatformInt;
        PerLODSourceFiles: TMap<number, string>;

        static StaticClass(): Class;
    }

    export class BlueprintCore extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SkeletonGeneratedClass: Class;
        GeneratedClass: Class;
        bLegacyNeedToPurgeSkelRefs: boolean;
        BlueprintGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintCore;

        static Load(InName: string): BlueprintCore;
    }

    export enum EBlueprintType {
        BPTYPE_Normal,
        BPTYPE_Const,
        BPTYPE_MacroLibrary,
        BPTYPE_Interface,
        BPTYPE_LevelScript,
        BPTYPE_FunctionLibrary,
        BPTYPE_MAX
    }

    export enum EBlueprintNativizationFlag { Disabled, Dependency, ExplicitlyEnabled, EBlueprintNativizationFlag_MAX }

    export enum EBlueprintCompileMode { Default, Development, FinalRelease, EBlueprintCompileMode_MAX }

    export enum EBlueprintStatus {
        BS_Unknown,
        BS_Dirty,
        BS_Error,
        BS_UpToDate,
        BS_BeingCreated,
        BS_UpToDateWithWarnings,
        BS_MAX
    }

    export class BlueprintComponentChangedPropertyInfo {
        constructor();
        constructor(PropertyName: string, ArrayIndex: number, PropertyScope: Struct);

        PropertyName: string;
        ArrayIndex: number;
        PropertyScope: Struct;

        static StaticClass(): Class;
    }

    export class BlueprintCookedComponentInstancingData {
        constructor();
        constructor(ChangedPropertyList: TArray<BlueprintComponentChangedPropertyInfo>, bHasValidCookedData: boolean);

        ChangedPropertyList: TArray<BlueprintComponentChangedPropertyInfo>;
        bHasValidCookedData: boolean;

        static StaticClass(): Class;
    }

    export class BPVariableMetaDataEntry {
        constructor();
        constructor(DataKey: string, DataValue: string);

        DataKey: string;
        DataValue: string;

        static StaticClass(): Class;
    }

    export class SCS_Node extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ComponentClass: Class;
        ComponentTemplate: ActorComponent;
        CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
        CategoryName: string;
        AttachToName: string;
        ParentComponentOrVariableName: string;
        ParentComponentOwnerClassName: string;
        bIsParentComponentNative: boolean;
        ChildNodes: TArray<SCS_Node>;
        MetaDataArray: TArray<BPVariableMetaDataEntry>;
        VariableGuid: Guid;
        bIsNative: boolean;
        NativeComponentName: string;
        bVariableNameAutoGenerated: boolean;
        InternalVariableName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SCS_Node;

        static Load(InName: string): SCS_Node;
    }

    export class SimpleConstructionScript extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootNodes: TArray<SCS_Node>;
        AllNodes: TArray<SCS_Node>;
        DefaultSceneRootNode: SCS_Node;
        RootNode: SCS_Node;
        ActorComponentNodes: TArray<SCS_Node>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SimpleConstructionScript;

        static Load(InName: string): SimpleConstructionScript;
    }

    export class EdGraph extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Schema: Class;
        Nodes: TArray<EdGraphNode>;
        bEditable: boolean;
        bAllowDeletion: boolean;
        bAllowRenaming: boolean;
        SubGraphs: TArray<EdGraph>;
        GraphGuid: Guid;
        InterfaceGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraph;

        static Load(InName: string): EdGraph;
    }

    export class BlueprintMacroCosmeticInfo {
        constructor();

        static StaticClass(): Class;
    }

    export enum ETimelineLengthMode { TL_TimelineLength, TL_LastKeyFrame, TL_MAX }

    export class TTTrackBase {
        constructor();
        constructor(TrackName: string, bIsExternalCurve: boolean, bIsExpanded: boolean, bIsCurveViewSynchronized: boolean);

        TrackName: string;
        bIsExternalCurve: boolean;
        bIsExpanded: boolean;
        bIsCurveViewSynchronized: boolean;

        static StaticClass(): Class;
    }

    export class TTEventTrack extends TTTrackBase {
        constructor();
        constructor(FunctionName: string, CurveKeys: CurveFloat);

        FunctionName: string;
        CurveKeys: CurveFloat;

        static StaticClass(): Class;
    }

    export class TTPropertyTrack extends TTTrackBase {
        constructor();
        constructor(PropertyName: string);

        PropertyName: string;

        static StaticClass(): Class;
    }

    export class TTFloatTrack extends TTPropertyTrack {
        constructor();
        constructor(CurveFloat: CurveFloat);

        CurveFloat: CurveFloat;

        static StaticClass(): Class;
    }

    export class CurveVector extends CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatCurves: FixSizeArray<RichCurve>;

        GetVectorValue(InTime: number): Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveVector;

        static Load(InName: string): CurveVector;
    }

    export class TTVectorTrack extends TTPropertyTrack {
        constructor();
        constructor(CurveVector: CurveVector);

        CurveVector: CurveVector;

        static StaticClass(): Class;
    }

    export class TTLinearColorTrack extends TTPropertyTrack {
        constructor();
        constructor(CurveLinearColor: CurveLinearColor);

        CurveLinearColor: CurveLinearColor;

        static StaticClass(): Class;
    }

    export class TTTrackId {
        constructor();
        constructor(TrackType: number, TrackIndex: number);

        TrackType: number;
        TrackIndex: number;

        static StaticClass(): Class;
    }

    export class TimelineTemplate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TimelineLength: number;
        LengthMode: ETimelineLengthMode;
        bAutoPlay: boolean;
        bLoop: boolean;
        bReplicated: boolean;
        bIgnoreTimeDilation: boolean;
        EventTracks: TArray<TTEventTrack>;
        FloatTracks: TArray<TTFloatTrack>;
        VectorTracks: TArray<TTVectorTrack>;
        LinearColorTracks: TArray<TTLinearColorTrack>;
        MetaDataArray: TArray<BPVariableMetaDataEntry>;
        TimelineGuid: Guid;
        VariableName: string;
        DirectionPropertyName: string;
        UpdateFunctionName: string;
        FinishedFunctionName: string;
        TrackDisplayOrder: TArray<TTTrackId>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TimelineTemplate;

        static Load(InName: string): TimelineTemplate;
    }

    export class BPComponentClassOverride {
        constructor();
        constructor(ComponentName: string, ComponentClass: Class);

        ComponentName: string;
        ComponentClass: Class;

        static StaticClass(): Class;
    }

    export class ComponentKey {
        constructor();
        constructor(OwnerClass: Class, SCSVariableName: string, AssociatedGuid: Guid);

        OwnerClass: Class;
        SCSVariableName: string;
        AssociatedGuid: Guid;

        static StaticClass(): Class;
    }

    export class ComponentOverrideRecord {
        constructor();
        constructor(ComponentClass: Class, ComponentTemplate: ActorComponent, ComponentKey: ComponentKey, CookedComponentInstancingData: BlueprintCookedComponentInstancingData);

        ComponentClass: Class;
        ComponentTemplate: ActorComponent;
        ComponentKey: ComponentKey;
        CookedComponentInstancingData: BlueprintCookedComponentInstancingData;

        static StaticClass(): Class;
    }

    export class InheritableComponentHandler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Records: TArray<ComponentOverrideRecord>;
        UnnecessaryComponents: TArray<ActorComponent>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InheritableComponentHandler;

        static Load(InName: string): InheritableComponentHandler;
    }

    export enum ELifetimeCondition {
        COND_None,
        COND_InitialOnly,
        COND_OwnerOnly,
        COND_SkipOwner,
        COND_SimulatedOnly,
        COND_AutonomousOnly,
        COND_SimulatedOrPhysics,
        COND_InitialOrOwner,
        COND_Custom,
        COND_ReplayOrOwner,
        COND_ReplayOnly,
        COND_SimulatedOnlyNoReplay,
        COND_SimulatedOrPhysicsNoReplay,
        COND_SkipReplay,
        COND_Never,
        COND_Max,
        COND_MAX
    }

    export class BPVariableDescription {
        constructor();
        constructor(VarName: string, VarGuid: Guid, VarType: EdGraphPinType, FriendlyName: string, Category: string, PropertyFlags: bigint, RepNotifyFunc: string, ReplicationCondition: ELifetimeCondition, MetaDataArray: TArray<BPVariableMetaDataEntry>, DefaultValue: string);

        VarName: string;
        VarGuid: Guid;
        VarType: EdGraphPinType;
        FriendlyName: string;
        Category: string;
        PropertyFlags: bigint;
        RepNotifyFunc: string;
        ReplicationCondition: ELifetimeCondition;
        MetaDataArray: TArray<BPVariableMetaDataEntry>;
        DefaultValue: string;

        static StaticClass(): Class;
    }

    export class BPInterfaceDescription {
        constructor();
        constructor(Interface: Class, Graphs: TArray<EdGraph>);

        Interface: Class;
        Graphs: TArray<EdGraph>;

        static StaticClass(): Class;
    }

    export class EditedDocumentInfo {
        constructor();
        constructor(EditedObjectPath: SoftObjectPath, SavedViewOffset: Vector2D, SavedZoomAmount: number, EditedObject: Object);

        EditedObjectPath: SoftObjectPath;
        SavedViewOffset: Vector2D;
        SavedZoomAmount: number;
        EditedObject: Object;

        static StaticClass(): Class;
    }

    export class BPEditorBookmarkNode {
        constructor();
        constructor(NodeGuid: Guid, ParentGuid: Guid, DisplayName: string);

        NodeGuid: Guid;
        ParentGuid: Guid;
        DisplayName: string;

        static StaticClass(): Class;
    }

    export class Breakpoint extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bEnabled: boolean;
        Node: EdGraphNode;
        bStepOnce: boolean;
        bStepOnce_WasPreviouslyDisabled: boolean;
        bStepOnce_RemoveAfterHit: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Breakpoint;

        static Load(InName: string): Breakpoint;
    }

    export class EdGraphPinReference {
        constructor();
        constructor(OwningNode: TWeakObjectPtr<EdGraphNode>, PinId: Guid);

        OwningNode: TWeakObjectPtr<EdGraphNode>;
        PinId: Guid;

        static StaticClass(): Class;
    }

    export class BlueprintExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintExtension;

        static Load(InName: string): BlueprintExtension;
    }

    export class Blueprint extends BlueprintCore {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParentClass: Class;
        BlueprintType: EBlueprintType;
        bRecompileOnLoad: boolean;
        bHasBeenRegenerated: boolean;
        bIsRegeneratingOnLoad: boolean;
        bBeingCompiled: boolean;
        bIsNewlyCreated: boolean;
        bForceFullEditor: boolean;
        bQueuedForCompilation: boolean;
        bRunConstructionScriptOnDrag: boolean;
        bRunConstructionScriptInSequencer: boolean;
        bGenerateConstClass: boolean;
        bGenerateAbstractClass: boolean;
        bDisplayCompilePIEWarning: boolean;
        bDeprecate: boolean;
        bDuplicatingReadOnly: boolean;
        bNativize: boolean;
        NativizationFlag: EBlueprintNativizationFlag;
        CompileMode: EBlueprintCompileMode;
        Status: EBlueprintStatus;
        BlueprintDisplayName: string;
        BlueprintDescription: string;
        BlueprintNamespace: string;
        BlueprintCategory: string;
        HideCategories: TArray<string>;
        BlueprintSystemVersion: number;
        SimpleConstructionScript: SimpleConstructionScript;
        UbergraphPages: TArray<EdGraph>;
        FunctionGraphs: TArray<EdGraph>;
        DelegateSignatureGraphs: TArray<EdGraph>;
        MacroGraphs: TArray<EdGraph>;
        IntermediateGeneratedGraphs: TArray<EdGraph>;
        EventGraphs: TArray<EdGraph>;
        PRIVATE_CachedMacroInfo: TMap<EdGraph, BlueprintMacroCosmeticInfo>;
        ComponentTemplates: TArray<ActorComponent>;
        Timelines: TArray<TimelineTemplate>;
        ComponentClassOverrides: TArray<BPComponentClassOverride>;
        InheritableComponentHandler: InheritableComponentHandler;
        NewVariables: TArray<BPVariableDescription>;
        CategorySorting: TArray<string>;
        ImplementedInterfaces: TArray<BPInterfaceDescription>;
        LastEditedDocuments: TArray<EditedDocumentInfo>;
        Bookmarks: TMap<Guid, EditedDocumentInfo>;
        BookmarkNodes: TArray<BPEditorBookmarkNode>;
        Breakpoints: TArray<Breakpoint>;
        WatchedPins: TArray<EdGraphPinReference>;
        DeprecatedPinWatches: TArray<EdGraphPin_Deprecated>;
        ComponentTemplateNameIndex: TMap<string, number>;
        OldToNewComponentTemplateNames: TMap<string, string>;
        Extensions: TArray<BlueprintExtension>;
        ThumbnailInfo: ThumbnailInfo;
        CrcLastCompiledCDO: number;
        CrcLastCompiledSignature: number;
        OriginalClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Blueprint;

        static Load(InName: string): Blueprint;
    }

    export class SkeletalMesh extends StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MeshEditorDataObject: SkeletalMeshEditorData;
        Skeleton: Skeleton;
        ImportedBounds: BoxSphereBounds;
        ExtendedBounds: BoxSphereBounds;
        PositiveBoundsExtension: Vector;
        NegativeBoundsExtension: Vector;
        Materials: TArray<SkeletalMaterial>;
        SkelMirrorTable: TArray<BoneMirrorInfo>;
        LODInfo: TArray<SkeletalMeshLODInfo>;
        MinLod: PerPlatformInt;
        DisableBelowMinLodStripping: PerPlatformBool;
        bOverrideLODStreamingSettings: boolean;
        bSupportLODStreaming: PerPlatformBool;
        MaxNumStreamedLODs: PerPlatformInt;
        MaxNumOptionalLODs: PerPlatformInt;
        LODSettings: SkeletalMeshLODSettings;
        DefaultAnimatingRig: TSoftObjectPtr<Object>;
        SkelMirrorAxis: EAxis;
        SkelMirrorFlipAxis: EAxis;
        bUseFullPrecisionUVs: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bHasBeenSimplified: boolean;
        bHasVertexColors: boolean;
        bEnablePerPolyCollision: boolean;
        VertexColorGuid: Guid;
        BodySetup: BodySetup;
        PhysicsAsset: PhysicsAsset;
        ShadowPhysicsAsset: PhysicsAsset;
        NodeMappingData: TArray<NodeMappingContainer>;
        AssetImportData: AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        ThumbnailInfo: ThumbnailInfo;
        bHasCustomDefaultEditorCamera: boolean;
        DefaultEditorCameraLocation: Vector;
        DefaultEditorCameraRotation: Rotator;
        DefaultEditorCameraLookAt: Vector;
        DefaultEditorCameraOrthoZoom: number;
        PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
        MorphTargets: TArray<MorphTarget>;
        FloorOffset: number;
        RetargetBasePose: TArray<Transform>;
        ClothingAssets: TArray<ClothingAssetData_Legacy>;
        PostProcessAnimBlueprint: Class;
        MeshClothingAssets: TArray<ClothingAssetBase>;
        SamplingInfo: SkeletalMeshSamplingInfo;
        AssetUserData: TArray<AssetUserData>;
        Sockets: TArray<SkeletalMeshSocket>;
        SkinWeightProfiles: TArray<SkinWeightProfileInfo>;

        AllocNewRenderDataForUnload(NewSkeletalMesh: $Nullable<SkeletalMesh>): void;

        FindSocket(InSocketName: string): SkeletalMeshSocket;

        FindSocketAndIndex(InSocketName: string, OutIndex: $Ref<number>): SkeletalMeshSocket;

        FindSocketInfo(InSocketName: string, OutTransform: $Ref<Transform>, OutBoneIndex: $Ref<number>, OutIndex: $Ref<number>): SkeletalMeshSocket;

        GetBounds(): BoxSphereBounds;

        GetDefaultAnimatingRig(): TSoftObjectPtr<Object>;

        GetImportedBounds(): BoxSphereBounds;

        GetNegativeBoundsExtension(): Vector;

        GetNodeMappingContainer(SourceAsset: $Nullable<Blueprint>): NodeMappingContainer;

        GetPositiveBoundsExtension(): Vector;

        GetSocketByIndex(Index: number): SkeletalMeshSocket;

        IsRenderDataValid(): boolean;

        IsSectionUsingCloth(InSectionIndex: number, bCheckCorrespondingSections?: boolean /* = true */): boolean;

        K2_GetAllMorphTargetNames(): TArray<string>;

        NumSockets(): number;

        ReleaseNewSkeletalMeshRenderData(): void;

        ReplaceSkeletalMeshAssetUserData(TargetSkeletalMesh: $Nullable<SkeletalMesh>): void;

        ReplaceSkeletalMeshRenderData(TargetSkeletalMesh: $Nullable<SkeletalMesh>, bShouldRelease: boolean): void;

        SetDefaultAnimatingRig(InAnimatingRig: TSoftObjectPtr<Object>): void;

        SetLODSettings(InLODSettings: $Nullable<SkeletalMeshLODSettings>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMesh;

        static Load(InName: string): SkeletalMesh;
    }

    export class VertexOffsetUsage {
        constructor();
        constructor(Usage: number);

        Usage: number;

        static StaticClass(): Class;
    }

    export class SkelMeshComponentLODInfo {
        constructor();
        constructor(HiddenMaterials: TArray<boolean>);

        HiddenMaterials: TArray<boolean>;

        static StaticClass(): Class;
    }

    export enum EVisibilityBasedAnimTickOption {
        AlwaysTickPoseAndRefreshBones,
        AlwaysTickPose,
        OnlyTickMontagesWhenNotRendered,
        OnlyTickPoseWhenRendered,
        EVisibilityBasedAnimTickOption_MAX
    }

    export class SkelMeshSkinWeightInfo {
        constructor();
        constructor(Bones: FixSizeArray<number>, Weights: FixSizeArray<number>);

        Bones: FixSizeArray<number>;
        Weights: FixSizeArray<number>;

        static StaticClass(): Class;
    }

    export enum EPhysBodyOp { PBO_None, PBO_Term, PBO_MAX }

    export class SkinnedMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SkeletalMesh: SkeletalMesh;
        MasterPoseComponent: TWeakObjectPtr<SkinnedMeshComponent>;
        SkinCacheUsage: TArray<ESkinCacheUsage>;
        VertexOffsetUsage: TArray<VertexOffsetUsage>;
        WireframeColor: Color;
        PhysicsAssetOverride: PhysicsAsset;
        ForcedLodModel: number;
        MinLodModel: number;
        StreamingDistanceMultiplier: number;
        LODInfo: TArray<SkelMeshComponentLODInfo>;
        VisibilityBasedAnimTickOption: EVisibilityBasedAnimTickOption;
        bOverrideMinLod: boolean;
        bUseBoundsFromMasterPoseComponent: boolean;
        bForceWireframe: boolean;
        bDisplayBones: boolean;
        bDisableMorphTarget: boolean;
        bHideSkin: boolean;
        bPerBoneMotionBlur: boolean;
        bComponentUseFixedSkelBounds: boolean;
        bConsiderAllBodiesForBounds: boolean;
        bSyncAttachParentLOD: boolean;
        bCanHighlightSelectedSections: boolean;
        bRecentlyRendered: boolean;
        bCastCapsuleDirectShadow: boolean;
        bCastCapsuleIndirectShadow: boolean;
        bCPUSkinning: boolean;
        bEnableUpdateRateOptimizations: boolean;
        bDisplayDebugUpdateRateOptimizations: boolean;
        bRenderStatic: boolean;
        bIgnoreMasterPoseComponentLOD: boolean;
        bCachedLocalBoundsUpToDate: boolean;
        bForceMeshObjectUpdate: boolean;
        CapsuleIndirectShadowMinVisibility: number;
        CachedWorldSpaceBounds: BoxSphereBounds;
        CachedWorldToLocalTransform: Matrix;

        BoneIsChildOf(BoneName: string, ParentBoneName: string): boolean;

        ClearSkinWeightOverride(LODIndex: number): void;

        ClearSkinWeightProfile(): void;

        ClearVertexColorOverride(LODIndex: number): void;

        FindClosestBone_K2(TestLocation: Vector, BoneLocation: $Ref<Vector>, IgnoreScale?: number /* = 0.000000 */, bRequirePhysicsAsset?: boolean /* = false */): string;

        GetBoneIndex(BoneName: string): number;

        GetBoneName(BoneIndex: number): string;

        GetCurrentSkinWeightProfileName(): string;

        GetDeltaTransformFromRefPose(BoneName: string, BaseName?: string /* = "None" */): Transform;

        GetForcedLOD(): number;

        GetNumBones(): number;

        GetNumLODs(): number;

        GetParentBone(BoneName: string): string;

        GetRefPosePosition(BoneIndex: number): Vector;

        GetSocketBoneName(InSocketName: string): string;

        GetTwistAndSwingAngleOfDeltaRotationFromRefPose(BoneName: string, OutTwistAngle: $Ref<number>, OutSwingAngle: $Ref<number>): boolean;

        GetVertexOffsetUsage(LODIndex: number): number;

        HideBoneByName(BoneName: string, PhysBodyOption: EPhysBodyOp): void;

        IsBoneHiddenByName(BoneName: string): boolean;

        IsMaterialSectionShown(MaterialID: number, LODIndex: number): boolean;

        IsUsingSkinWeightProfile(): boolean;

        SetCapsuleIndirectShadowMinVisibility(NewValue: number): void;

        SetCastCapsuleDirectShadow(bNewValue: boolean): void;

        SetCastCapsuleIndirectShadow(bNewValue: boolean): void;

        SetForcedLOD(InNewForcedLOD: number): void;

        SetMasterPoseComponent(NewMasterBoneComponent: $Nullable<SkinnedMeshComponent>, bForceUpdate?: boolean /* = false */): void;

        SetMinLOD(InNewMinLOD: number): void;

        SetPhysicsAsset(NewPhysicsAsset: $Nullable<PhysicsAsset>, bForceReInit?: boolean /* = false */): void;

        SetPostSkinningOffsets(LODIndex: number, Offsets: TArray<Vector>): void;

        SetPreSkinningOffsets(LODIndex: number, Offsets: TArray<Vector>): void;

        SetRenderStatic(bNewValue: boolean): void;

        SetSkeletalMesh(NewMesh: $Nullable<SkeletalMesh>, bReinitPose?: boolean /* = true */): void;

        SetSkinWeightOverride(LODIndex: number, SkinWeights: TArray<SkelMeshSkinWeightInfo>): void;

        SetSkinWeightProfile(InProfileName: string): boolean;

        SetVertexColorOverride_LinearColor(LODIndex: number, VertexColors: TArray<LinearColor>): void;

        SetVertexOffsetUsage(LODIndex: number, Usage: number): void;

        ShowAllMaterialSections(LODIndex: number): void;

        ShowMaterialSection(MaterialID: number, SectionIndex: number, bShow: boolean, LODIndex: number): void;

        TransformFromBoneSpace(BoneName: string, InPosition: Vector, InRotation: Rotator, OutPosition: $Ref<Vector>, OutRotation: $Ref<Rotator>): void;

        TransformToBoneSpace(BoneName: string, InPosition: Vector, InRotation: Rotator, OutPosition: $Ref<Vector>, OutRotation: $Ref<Rotator>): void;

        UnHideBoneByName(BoneName: string): void;

        UnloadSkinWeightProfile(InProfileName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkinnedMeshComponent;

        static Load(InName: string): SkinnedMeshComponent;
    }

    export class AnimGroupInfo {
        constructor();
        constructor(Name: string, Color: LinearColor);

        Name: string;
        Color: LinearColor;

        static StaticClass(): Class;
    }

    export class AnimParentNodeAssetOverride {
        constructor();
        constructor(NewAsset: AnimationAsset, ParentNodeGuid: Guid);

        NewAsset: AnimationAsset;
        ParentNodeGuid: Guid;

        static StaticClass(): Class;
    }

    export class PoseWatch extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: EdGraphNode;
        PoseWatchColour: Color;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PoseWatch;

        static Load(InName: string): PoseWatch;
    }

    export enum EPreviewAnimationBlueprintApplicationMethod {
        LinkedLayers,
        LinkedAnimGraph,
        EPreviewAnimationBlueprintApplicationMethod_MAX
    }

    export class AnimBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeleton: Skeleton;
        Groups: TArray<AnimGroupInfo>;
        bUseMultiThreadedAnimationUpdate: boolean;
        bWarnAboutBlueprintUsage: boolean;
        ParentAssetOverrides: TArray<AnimParentNodeAssetOverride>;
        PoseWatches: TArray<PoseWatch>;
        PreviewSkeletalMesh: TSoftObjectPtr<SkeletalMesh>;
        PreviewAnimationBlueprint: TSoftObjectPtr<AnimBlueprint>;
        PreviewAnimationBlueprintApplicationMethod: EPreviewAnimationBlueprintApplicationMethod;
        PreviewAnimationBlueprintTag: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimBlueprint;

        static Load(InName: string): AnimBlueprint;
    }

    export class DynamicBlueprintBinding extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DynamicBlueprintBinding;

        static Load(InName: string): DynamicBlueprintBinding;
    }

    export class Property extends Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Property;

        static Load(InName: string): Property;
    }

    export class StructProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StructProperty;

        static Load(InName: string): StructProperty;
    }

    export class Function extends Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Function;

        static Load(InName: string): Function;
    }

    export class EventGraphFastCallPair {
        constructor();
        constructor(FunctionToPatch: Function, EventGraphCallOffset: number);

        FunctionToPatch: Function;
        EventGraphCallOffset: number;

        static StaticClass(): Class;
    }

    export class BlueprintGeneratedClass extends Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumReplicatedProperties: number;
        bHasNativizedParent: boolean;
        bHasCookedComponentInstancingData: boolean;
        bIsSparseClassDataSerializable: boolean;
        DynamicBindingObjects: TArray<DynamicBlueprintBinding>;
        ComponentTemplates: TArray<ActorComponent>;
        Timelines: TArray<TimelineTemplate>;
        ComponentClassOverrides: TArray<BPComponentClassOverride>;
        SimpleConstructionScript: SimpleConstructionScript;
        InheritableComponentHandler: InheritableComponentHandler;
        UberGraphFramePointerProperty: StructProperty;
        UberGraphFunction: Function;
        FastCallPairs: TArray<EventGraphFastCallPair>;
        OverridenArchetypeForCDO: Object;
        PropertyGuids: TMap<string, Guid>;
        CalledFunctions: TArray<Function>;
        CookedComponentInstancingData: TMap<string, BlueprintCookedComponentInstancingData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintGeneratedClass;

        static Load(InName: string): BlueprintGeneratedClass;
    }

    export class BakedStateExitTransition {
        constructor();
        constructor(CanTakeDelegateIndex: number, CustomResultNodeIndex: number, TransitionIndex: number, bDesiredTransitionReturnValue: boolean, bAutomaticRemainingTimeRule: boolean, PoseEvaluatorLinks: TArray<number>);

        CanTakeDelegateIndex: number;
        CustomResultNodeIndex: number;
        TransitionIndex: number;
        bDesiredTransitionReturnValue: boolean;
        bAutomaticRemainingTimeRule: boolean;
        PoseEvaluatorLinks: TArray<number>;

        static StaticClass(): Class;
    }

    export class BakedAnimationState {
        constructor();
        constructor(StateName: string, Transitions: TArray<BakedStateExitTransition>, StateRootNodeIndex: number, StartNotify: number, EndNotify: number, FullyBlendedNotify: number, bIsAConduit: boolean, EntryRuleNodeIndex: number, PlayerNodeIndices: TArray<number>, LayerNodeIndices: TArray<number>, bAlwaysResetOnEntry: boolean);

        StateName: string;
        Transitions: TArray<BakedStateExitTransition>;
        StateRootNodeIndex: number;
        StartNotify: number;
        EndNotify: number;
        FullyBlendedNotify: number;
        bIsAConduit: boolean;
        EntryRuleNodeIndex: number;
        PlayerNodeIndices: TArray<number>;
        LayerNodeIndices: TArray<number>;
        bAlwaysResetOnEntry: boolean;

        static StaticClass(): Class;
    }

    export class AnimationStateBase {
        constructor();
        constructor(StateName: string);

        StateName: string;

        static StaticClass(): Class;
    }

    export enum ETransitionLogicType { TLT_StandardBlend, TLT_Inertialization, TLT_Custom, TLT_MAX }

    export class AnimationTransitionBetweenStates extends AnimationStateBase {
        constructor();
        constructor(PreviousState: number, NextState: number, CrossfadeDuration: number, StartNotify: number, EndNotify: number, InterruptNotify: number, BlendMode: EAlphaBlendOption, CustomCurve: CurveFloat, BlendProfile: BlendProfile, LogicType: ETransitionLogicType);

        PreviousState: number;
        NextState: number;
        CrossfadeDuration: number;
        StartNotify: number;
        EndNotify: number;
        InterruptNotify: number;
        BlendMode: EAlphaBlendOption;
        CustomCurve: CurveFloat;
        BlendProfile: BlendProfile;
        LogicType: ETransitionLogicType;

        static StaticClass(): Class;
    }

    export class BakedAnimationStateMachine {
        constructor();
        constructor(MachineName: string, InitialState: number, States: TArray<BakedAnimationState>, Transitions: TArray<AnimationTransitionBetweenStates>);

        MachineName: string;
        InitialState: number;
        States: TArray<BakedAnimationState>;
        Transitions: TArray<AnimationTransitionBetweenStates>;

        static StaticClass(): Class;
    }

    export class CachedPoseIndices {
        constructor();
        constructor(OrderedSavedPoseNodeIndices: TArray<number>);

        OrderedSavedPoseNodeIndices: TArray<number>;

        static StaticClass(): Class;
    }

    export enum EPostCopyOperation { None, LogicalNegateBool, EPostCopyOperation_MAX }

    export class ExposedValueCopyRecord {
        constructor();
        constructor(CopyIndex: number, PostCopyOperation: EPostCopyOperation);

        CopyIndex: number;
        PostCopyOperation: EPostCopyOperation;

        static StaticClass(): Class;
    }

    export class ExposedValueHandler {
        BoundFunction: string;
        CopyRecords: TArray<ExposedValueCopyRecord>;
        Function: Function;

        static StaticClass(): Class;
    }

    export class GraphAssetPlayerInformation {
        constructor();
        constructor(PlayerNodeIndices: TArray<number>);

        PlayerNodeIndices: TArray<number>;

        static StaticClass(): Class;
    }

    export class AnimGraphBlendOptions {
        constructor();
        constructor(BlendInTime: number, BlendOutTime: number);

        BlendInTime: number;
        BlendOutTime: number;

        static StaticClass(): Class;
    }

    export class PropertyAccessSegment {
        Name: string;
        Struct: Struct;
        Function: Function;
        ArrayIndex: number;
        Flags: number;

        static StaticClass(): Class;
    }

    export class PropertyAccessPath {
        constructor();
        constructor(PathSegmentStartIndex: number, PathSegmentCount: number, bHasEvents: boolean);

        PathSegmentStartIndex: number;
        PathSegmentCount: number;
        bHasEvents: boolean;

        static StaticClass(): Class;
    }

    export enum EPropertyAccessCopyType {
        None,
        Plain,
        Complex,
        Bool,
        Struct,
        Object,
        Name,
        Array,
        PromoteBoolToByte,
        PromoteBoolToInt32,
        PromoteBoolToInt64,
        PromoteBoolToFloat,
        PromoteByteToInt32,
        PromoteByteToInt64,
        PromoteByteToFloat,
        PromoteInt32ToInt64,
        PromoteInt32ToFloat,
        EPropertyAccessCopyType_MAX
    }

    export class PropertyAccessCopy {
        constructor();
        constructor(AccessIndex: number, DestAccessStartIndex: number, DestAccessEndIndex: number, Type: EPropertyAccessCopyType);

        AccessIndex: number;
        DestAccessStartIndex: number;
        DestAccessEndIndex: number;
        Type: EPropertyAccessCopyType;

        static StaticClass(): Class;
    }

    export class PropertyAccessCopyBatch {
        constructor();
        constructor(Copies: TArray<PropertyAccessCopy>);

        Copies: TArray<PropertyAccessCopy>;

        static StaticClass(): Class;
    }

    export class PropertyAccessIndirectionChain {
        IndirectionStartIndex: number;
        IndirectionEndIndex: number;
        EventId: number;

        static StaticClass(): Class;
    }

    export enum EPropertyAccessObjectType { None, Object, WeakObject, SoftObject, EPropertyAccessObjectType_MAX }

    export enum EPropertyAccessIndirectionType {
        Offset,
        Object,
        Array,
        ScriptFunction,
        NativeFunction,
        EPropertyAccessIndirectionType_MAX
    }

    export class PropertyAccessIndirection {
        Function: Function;
        ReturnBufferSize: number;
        ReturnBufferAlignment: number;
        ArrayIndex: number;
        Offset: number;
        ObjectType: EPropertyAccessObjectType;
        Type: EPropertyAccessIndirectionType;

        static StaticClass(): Class;
    }

    export class PropertyAccessLibrary {
        constructor();
        constructor(PathSegments: TArray<PropertyAccessSegment>, SrcPaths: TArray<PropertyAccessPath>, DestPaths: TArray<PropertyAccessPath>, CopyBatches: FixSizeArray<PropertyAccessCopyBatch>, SrcAccesses: TArray<PropertyAccessIndirectionChain>, DestAccesses: TArray<PropertyAccessIndirectionChain>, Indirections: TArray<PropertyAccessIndirection>, EventAccessIndices: TArray<number>);

        PathSegments: TArray<PropertyAccessSegment>;
        SrcPaths: TArray<PropertyAccessPath>;
        DestPaths: TArray<PropertyAccessPath>;
        CopyBatches: FixSizeArray<PropertyAccessCopyBatch>;
        SrcAccesses: TArray<PropertyAccessIndirectionChain>;
        DestAccesses: TArray<PropertyAccessIndirectionChain>;
        Indirections: TArray<PropertyAccessIndirection>;
        EventAccessIndices: TArray<number>;

        static StaticClass(): Class;
    }

    export class AnimBlueprintGeneratedClass extends BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BakedStateMachines: TArray<BakedAnimationStateMachine>;
        TargetSkeleton: Skeleton;
        AnimNotifies: TArray<AnimNotifyEvent>;
        OrderedSavedPoseIndicesMap: TMap<string, CachedPoseIndices>;
        SyncGroupNames: TArray<string>;
        EvaluateGraphExposedInputs: TArray<ExposedValueHandler>;
        GraphAssetPlayerInformation: TMap<string, GraphAssetPlayerInformation>;
        GraphBlendOptions: TMap<string, AnimGraphBlendOptions>;
        PropertyAccessLibrary: PropertyAccessLibrary;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimBlueprintGeneratedClass;

        static Load(InName: string): AnimBlueprintGeneratedClass;
    }

    export enum ERootMotionMode {
        NoRootMotionExtraction,
        IgnoreRootMotion,
        RootMotionFromEverything,
        RootMotionFromMontagesOnly,
        ERootMotionMode_MAX
    }

    export class SoftClassPath extends SoftObjectPath {
        constructor();

        static StaticClass(): Class;
    }

    export class AnimNotifyEventReference {
        constructor();
        constructor(NotifySource: Object);

        NotifySource: Object;

        static StaticClass(): Class;
    }

    export class AnimNotifyArray {
        constructor();
        constructor(Notifies: TArray<AnimNotifyEventReference>);

        Notifies: TArray<AnimNotifyEventReference>;

        static StaticClass(): Class;
    }

    export class AnimNotifyQueue {
        constructor();
        constructor(AnimNotifies: TArray<AnimNotifyEventReference>, UnfilteredMontageAnimNotifies: TMap<string, AnimNotifyArray>);

        AnimNotifies: TArray<AnimNotifyEventReference>;
        UnfilteredMontageAnimNotifies: TMap<string, AnimNotifyArray>;

        static StaticClass(): Class;
    }

    export class PoseSnapshot {
        constructor();
        constructor(LocalTransforms: TArray<Transform>, BoneNames: TArray<string>, SkeletalMeshName: string, SnapshotName: string, bIsValid: boolean);

        LocalTransforms: TArray<Transform>;
        BoneNames: TArray<string>;
        SkeletalMeshName: string;
        SnapshotName: string;
        bIsValid: boolean;

        static StaticClass(): Class;
    }

    export enum ETeleportType { None, TeleportPhysics, ResetPhysics, ETeleportType_MAX }

    export enum EMontagePlayReturnType { MontageLength, Duration, EMontagePlayReturnType_MAX }

    export class MarkerSyncAnimPosition {
        constructor();
        constructor(PreviousMarkerName: string, NextMarkerName: string, PositionBetweenMarkers: number);

        PreviousMarkerName: string;
        NextMarkerName: string;
        PositionBetweenMarkers: number;

        static StaticClass(): Class;
    }

    export enum EAnimCurveType { AttributeCurve, MaterialCurve, MorphTargetCurve, MaxAnimCurveType, EAnimCurveType_MAX }

    export class AnimInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentSkeleton: Skeleton;
        RootMotionMode: ERootMotionMode;
        DeltaTime: number;
        bRunUpdatesInWorkerThreads: boolean;
        bCanUseParallelUpdateAnimation: boolean;
        bWarnAboutBlueprintUsage: boolean;
        bUseMultiThreadedAnimationUpdate: boolean;
        bUsingCopyPoseFromMesh: boolean;
        bReceiveNotifiesFromLinkedInstances: boolean;
        bPropagateNotifiesToLinkedInstances: boolean;
        bQueueMontageEvents: boolean;
        OnMontageBlendingOut: $MulticastDelegate<(Montage: $Nullable<AnimMontage>, bInterrupted: boolean) => void>;
        OnMontageStarted: $MulticastDelegate<(Montage: $Nullable<AnimMontage>) => void>;
        OnMontageEnded: $MulticastDelegate<(Montage: $Nullable<AnimMontage>, bInterrupted: boolean) => void>;
        OnAllMontageInstancesEnded: $MulticastDelegate<() => void>;
        PostCompileValidationClassName: SoftClassPath;
        NotifyQueue: AnimNotifyQueue;
        ActiveAnimNotifyState: TArray<AnimNotifyEvent>;

        BlueprintBeginPlay(): void;

        BlueprintInitializeAnimation(): void;

        BlueprintLinkedAnimationLayersInitialized(): void;

        BlueprintPostEvaluateAnimation(): void;

        BlueprintUpdateAnimation(DeltaTimeX: number): void;

        CalculateDirection(Velocity: Vector, BaseRotation: Rotator): number;

        ClearMorphTargets(): void;

        GetActiveCurveNames(CurveType: EAnimCurveType, OutNames: $Ref<TArray<string>>): void;

        GetAllCurveNames(OutNames: $Ref<TArray<string>>): void;

        GetCurrentActiveMontage(): AnimMontage;

        GetCurrentStateName(MachineIndex: number): string;

        GetCurveValue(CurveName: string): number;

        GetInstanceAssetPlayerLength(AssetPlayerIndex: number): number;

        GetInstanceAssetPlayerTime(AssetPlayerIndex: number): number;

        GetInstanceAssetPlayerTimeFraction(AssetPlayerIndex: number): number;

        GetInstanceAssetPlayerTimeFromEnd(AssetPlayerIndex: number): number;

        GetInstanceAssetPlayerTimeFromEndFraction(AssetPlayerIndex: number): number;

        GetInstanceCurrentStateElapsedTime(MachineIndex: number): number;

        GetInstanceMachineWeight(MachineIndex: number): number;

        GetInstanceStateWeight(MachineIndex: number, StateIndex: number): number;

        GetInstanceTransitionCrossfadeDuration(MachineIndex: number, TransitionIndex: number): number;

        GetInstanceTransitionTimeElapsed(MachineIndex: number, TransitionIndex: number): number;

        GetInstanceTransitionTimeElapsedFraction(MachineIndex: number, TransitionIndex: number): number;

        GetLinkedAnimGraphInstanceByTag(InTag: string): AnimInstance;

        GetLinkedAnimGraphInstancesByTag(InTag: string, OutLinkedInstances: $Ref<TArray<AnimInstance>>): void;

        GetLinkedAnimLayerInstanceByClass(InClass: $Nullable<Class>): AnimInstance;

        GetLinkedAnimLayerInstanceByGroup(InGroup: string): AnimInstance;

        GetLinkedAnimLayerInstanceByGroupAndClass(InGroup: string, InClass: $Nullable<Class>): AnimInstance;

        GetLinkedAnimLayerInstancesByGroup(InGroup: string, OutLinkedInstances: $Ref<TArray<AnimInstance>>): void;

        GetOwningActor(): Actor;

        GetOwningComponent(): SkeletalMeshComponent;

        GetPropagateNotifiesToLinkedInstances(): boolean;

        GetReceiveNotifiesFromLinkedInstances(): boolean;

        GetRelevantAnimLength(MachineIndex: number, StateIndex: number): number;

        GetRelevantAnimTime(MachineIndex: number, StateIndex: number): number;

        GetRelevantAnimTimeFraction(MachineIndex: number, StateIndex: number): number;

        GetRelevantAnimTimeRemaining(MachineIndex: number, StateIndex: number): number;

        GetRelevantAnimTimeRemainingFraction(MachineIndex: number, StateIndex: number): number;

        GetSyncGroupPosition(InSyncGroupName: string): MarkerSyncAnimPosition;

        GetTimeToClosestMarker(SyncGroup: string, MarkerName: string, OutMarkerTime: $Ref<number>): boolean;

        HasMarkerBeenHitThisFrame(SyncGroup: string, MarkerName: string): boolean;

        IsAnyMontagePlaying(): boolean;

        IsPlayingSlotAnimation(Asset: $Nullable<AnimSequenceBase>, SlotNodeName: string): boolean;

        IsSyncGroupBetweenMarkers(InSyncGroupName: string, PreviousMarker: string, NextMarker: string, bRespectMarkerOrder?: boolean /* = true */): boolean;

        LinkAnimClassLayers(InClass: $Nullable<Class>): void;

        LinkAnimGraphByTag(InTag: string, InClass: $Nullable<Class>): void;

        LockAIResources(bLockMovement: boolean, LockAILogic: boolean): void;

        Montage_GetBlendTime(Montage: $Nullable<AnimMontage>): number;

        Montage_GetCurrentSection(Montage?: AnimMontage /* = None */): string;

        Montage_GetIsStopped(Montage: $Nullable<AnimMontage>): boolean;

        Montage_GetPlayRate(Montage: $Nullable<AnimMontage>): number;

        Montage_GetPosition(Montage: $Nullable<AnimMontage>): number;

        Montage_IsActive(Montage: $Nullable<AnimMontage>): boolean;

        Montage_IsPlaying(Montage: $Nullable<AnimMontage>): boolean;

        Montage_JumpToSection(SectionName: string, Montage?: AnimMontage /* = None */): void;

        Montage_JumpToSectionsEnd(SectionName: string, Montage?: AnimMontage /* = None */): void;

        Montage_Pause(Montage?: AnimMontage /* = None */): void;

        Montage_Play(MontageToPlay: $Nullable<AnimMontage>, InPlayRate?: number /* = 1.000000 */, ReturnValueType?: EMontagePlayReturnType /* = MontageLength */, InTimeToStartMontageAt?: number /* = 0.000000 */, bStopAllMontages?: boolean /* = true */): number;

        Montage_Resume(Montage: $Nullable<AnimMontage>): void;

        Montage_SetNextSection(SectionNameToChange: string, NextSection: string, Montage?: AnimMontage /* = None */): void;

        Montage_SetPlayRate(Montage: $Nullable<AnimMontage>, NewPlayRate?: number /* = 1.000000 */): void;

        Montage_SetPosition(Montage: $Nullable<AnimMontage>, NewPosition: number): void;

        Montage_Stop(InBlendOutTime: number, Montage?: AnimMontage /* = None */): void;

        Montage_StopGroupByName(InBlendOutTime: number, GroupName: string): void;

        PlaySlotAnimation(Asset: $Nullable<AnimSequenceBase>, SlotNodeName: string, BlendInTime?: number /* = 0.250000 */, BlendOutTime?: number /* = 0.250000 */, InPlayRate?: number /* = 1.000000 */, LoopCount?: number /* = 1 */): number;

        PlaySlotAnimationAsDynamicMontage(Asset: $Nullable<AnimSequenceBase>, SlotNodeName: string, BlendInTime?: number /* = 0.250000 */, BlendOutTime?: number /* = 0.250000 */, InPlayRate?: number /* = 1.000000 */, LoopCount?: number /* = 1 */, BlendOutTriggerTime?: number /* = -1.000000 */, InTimeToStartMontageAt?: number /* = 0.000000 */): AnimMontage;

        ResetDynamics(InTeleportType: ETeleportType): void;

        SavePoseSnapshot(SnapshotName: string): void;

        SetMorphTarget(MorphTargetName: string, Value: number): void;

        SetPropagateNotifiesToLinkedInstances(bSet: boolean): void;

        SetReceiveNotifiesFromLinkedInstances(bSet: boolean): void;

        SetRootMotionMode(Value: ERootMotionMode): void;

        SnapshotPose(Snapshot: $Ref<PoseSnapshot>): void;

        StopSlotAnimation(InBlendOutTime?: number /* = 0.250000 */, SlotNodeName?: string /* = "None" */): void;

        TryGetPawnOwner(): Pawn;

        UnlinkAnimClassLayers(InClass: $Nullable<Class>): void;

        UnlockAIResources(bUnlockMovement: boolean, UnlockAILogic: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimInstance;

        static Load(InName: string): AnimInstance;
    }

    export enum EMultiPassParam {
        MP_TriangleList,
        MP_TriangleStrip,
        MP_LineList,
        MP_QuadList,
        MP_PointList,
        MP_RectList,
        MP_MAX
    }

    export class MultiPassMeshMaterialParam {
        constructor();
        constructor(PassMaterial: MaterialInterface, bReverseCulling: boolean, bDisableBackfaceCulling: boolean, CastShadow: boolean, bUseForMaterial: boolean, bUseForDepthPass: boolean, bUseAsOccluder: boolean, bWireframe: boolean, bUseSelectionOutline: boolean, bSelectable: boolean, Type: EMultiPassParam, bCanApplyViewModeOverrides: boolean, bUseWireframeSelectionColoring: boolean, bDitheredLODTransition: boolean, bRenderToVirtualTexture: boolean);

        PassMaterial: MaterialInterface;
        bReverseCulling: boolean;
        bDisableBackfaceCulling: boolean;
        CastShadow: boolean;
        bUseForMaterial: boolean;
        bUseForDepthPass: boolean;
        bUseAsOccluder: boolean;
        bWireframe: boolean;
        bUseSelectionOutline: boolean;
        bSelectable: boolean;
        Type: EMultiPassParam;
        bCanApplyViewModeOverrides: boolean;
        bUseWireframeSelectionColoring: boolean;
        bDitheredLODTransition: boolean;
        bRenderToVirtualTexture: boolean;

        static StaticClass(): Class;
    }

    export enum EOutlineMaterialType {
        OMT_Common,
        OMT_Common_ConsiderCameraPosition,
        OMT_Silhouette,
        OMT_Silhouette_ConsiderCameraPosition,
        OMT_MAX
    }

    export class MultiPassMeshParam {
        constructor();
        constructor(bEnableThisPass: boolean, PassMaterialParams: TArray<MultiPassMeshMaterialParam>);

        bEnableThisPass: boolean;
        PassMaterialParams: TArray<MultiPassMeshMaterialParam>;

        static StaticClass(): Class;
    }

    export class SingleAnimationPlayData {
        constructor();
        constructor(AnimToPlay: AnimationAsset, bSavedLooping: boolean, bSavedPlaying: boolean, SavedPosition: number, SavedPlayRate: number);

        AnimToPlay: AnimationAsset;
        bSavedLooping: boolean;
        bSavedPlaying: boolean;
        SavedPosition: number;
        SavedPlayRate: number;

        static StaticClass(): Class;
    }

    export enum EKinematicBonesUpdateToPhysics { SkipSimulatingBones, SkipAllBones, EKinematicBonesUpdateToPhysics_MAX }

    export enum EPhysicsTransformUpdateMode {
        SimulationUpatesComponentTransform,
        ComponentTransformIsKinematic,
        EPhysicsTransformUpdateMode_MAX
    }

    export enum EAnimationMode { AnimationBlueprint, AnimationSingleNode, AnimationCustomMode, EAnimationMode_MAX }

    export enum EClothMassMode { UniformMass, TotalMass, Density, MaxClothMassMode, EClothMassMode_MAX }

    export class ClothingSimulationInteractor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ClothConfigUpdated(): void;

        DisableGravityOverride(): void;

        EnableGravityOverride(InVector: Vector): void;

        GetNumCloths(): number;

        GetNumDynamicParticles(): number;

        GetNumIterations(): number;

        GetNumKinematicParticles(): number;

        GetNumSubsteps(): number;

        GetSimulationTime(): number;

        PhysicsAssetUpdated(): void;

        SetAnimDriveSpringStiffness(InStiffness: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingSimulationInteractor;

        static Load(InName: string): ClothingSimulationInteractor;
    }

    export enum ECustomBoneAttributeLookup {
        BoneOnly,
        ImmediateParent,
        ParentHierarchy,
        ECustomBoneAttributeLookup_MAX
    }

    export class SkeletalMeshComponent extends SkinnedMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimationBlueprint: AnimBlueprint;
        AnimBlueprintGeneratedClass: AnimBlueprintGeneratedClass;
        AnimClass: Class;
        AnimScriptInstance: AnimInstance;
        SubInstances: TArray<AnimInstance>;
        PostProcessAnimInstance: AnimInstance;
        SpecifyPassIndex: number;
        UnifyPassMaterialParams: MultiPassMeshMaterialParam;
        OutlineMaterialType: EOutlineMaterialType;
        PassArray: TArray<MultiPassMeshParam>;
        OutlinePassIndex: number;
        AnimationData: SingleAnimationPlayData;
        RootBoneTranslation: Vector;
        LineCheckBoundsScale: Vector;
        LinkedInstances: TArray<AnimInstance>;
        CachedBoneSpaceTransforms: TArray<Transform>;
        CachedComponentSpaceTransforms: TArray<Transform>;
        GlobalAnimRateScale: number;
        KinematicBonesUpdateType: EKinematicBonesUpdateToPhysics;
        PhysicsTransformUpdateMode: EPhysicsTransformUpdateMode;
        AnimationMode: EAnimationMode;
        bDisablePostProcessBlueprint: boolean;
        bUpdateOverlapsOnAnimationFinalize: boolean;
        bHasValidBodies: boolean;
        bBlendPhysics: boolean;
        bEnablePhysicsOnDedicatedServer: boolean;
        bUpdateJointsFromAnimation: boolean;
        bDisableClothSimulation: boolean;
        bDisableRigidBodyAnimNode: boolean;
        bAllowAnimCurveEvaluation: boolean;
        bDisableAnimCurves: boolean;
        bCollideWithEnvironment: boolean;
        bCollideWithAttachedChildren: boolean;
        bLocalSpaceSimulation: boolean;
        bResetAfterTeleport: boolean;
        bDeferKinematicBoneUpdate: boolean;
        bNoSkeletonUpdate: boolean;
        bPauseAnims: boolean;
        bUseRefPoseOnInitAnim: boolean;
        bEnablePerPolyCollision: boolean;
        bForceRefpose: boolean;
        bOnlyAllowAutonomousTickPose: boolean;
        bIsAutonomousTickPose: boolean;
        bOldForceRefPose: boolean;
        bShowPrePhysBones: boolean;
        bRequiredBonesUpToDate: boolean;
        bAnimTreeInitialised: boolean;
        bIncludeComponentLocationIntoBounds: boolean;
        bEnableLineCheckWithBounds: boolean;
        bUseBendingElements: boolean;
        bUseTetrahedralConstraints: boolean;
        bUseThinShellVolumeConstraints: boolean;
        bUseSelfCollisions: boolean;
        bUseContinuousCollisionDetection: boolean;
        bPropagateCurvesToSlaves: boolean;
        bSkipKinematicUpdateWhenInterpolating: boolean;
        bSkipBoundsUpdateWhenInterpolating: boolean;
        bUpdateAnimationInEditor: boolean;
        bUpdateClothInEditor: boolean;
        bNeedsQueuedAnimEventsDispatched: boolean;
        CachedAnimCurveUidVersion: number;
        MassMode: EClothMassMode;
        UniformMass: number;
        TotalMass: number;
        Density: number;
        MinPerParticleMass: number;
        ClothBlendWeight: number;
        EdgeStiffness: number;
        BendingStiffness: number;
        AreaStiffness: number;
        VolumeStiffness: number;
        StrainLimitingStiffness: number;
        ShapeTargetStiffness: number;
        bWaitForParallelClothTask: boolean;
        DisallowedAnimCurves: TArray<string>;
        BodySetup: BodySetup;
        OnConstraintBroken: $MulticastDelegate<(ConstraintIndex: number) => void>;
        ClothingSimulationFactory: Class;
        TeleportDistanceThreshold: number;
        TeleportRotationThreshold: number;
        LastPoseTickFrame: number;
        ClothingInteractor: ClothingSimulationInteractor;
        OnAnimInitialized: $MulticastDelegate<() => void>;
        SequenceToPlay: AnimSequence;
        AnimToPlay: AnimationAsset;
        bDefaultLooping: boolean;
        bDefaultPlaying: boolean;
        DefaultPosition: number;
        DefaultPlayRate: number;

        AccumulateAllBodiesBelowPhysicsBlendWeight(InBoneName: string, AddPhysicsBlendWeight: number, bSkipCustomPhysicsType?: boolean /* = false */): void;

        AddForceToAllBodiesBelow(Force: Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */, bIncludeSelf?: boolean /* = true */): void;

        AddImpulseToAllBodiesBelow(Impulse: Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */, bIncludeSelf?: boolean /* = true */): void;

        AllowAnimCurveEvaluation(NameOfCurve: string, bAllow: boolean): void;

        BindClothToMasterPoseComponent(): void;

        BreakConstraint(Impulse: Vector, HitLocation: Vector, InBoneName: string): void;

        ClearMorphTargets(): void;

        FindConstraintBoneName(ConstraintIndex: number): string;

        ForceClothNextUpdateTeleport(): void;

        ForceClothNextUpdateTeleportAndReset(): void;

        GetAllowedAnimCurveEvaluate(): boolean;

        GetAllowRigidBodyAnimNode(): boolean;

        GetAnimationMode(): EAnimationMode;

        GetAnimClass(): Class;

        GetAnimInstance(): AnimInstance;

        GetBoneMass(BoneName?: string /* = "None" */, bScaleMass?: boolean /* = true */): number;

        GetClothingSimulationInteractor(): ClothingSimulationInteractor;

        GetClothMaxDistanceScale(): number;

        GetCurrentJointAngles(InBoneName: string, Swing1Angle: $Ref<number>, TwistAngle: $Ref<number>, Swing2Angle: $Ref<number>): void;

        GetDisableAnimCurves(): boolean;

        GetDisablePostProcessBlueprint(): boolean;

        GetFloatAttribute(BoneName: string, AttributeName: string, DefaultValue: number, OutValue: $Ref<number>, LookupType?: ECustomBoneAttributeLookup /* = BoneOnly */): boolean;

        GetFloatAttribute_Ref(BoneName: string, AttributeName: string, OutValue: $Ref<number>, LookupType?: ECustomBoneAttributeLookup /* = BoneOnly */): boolean;

        GetIntegerAttribute(BoneName: string, AttributeName: string, DefaultValue: number, OutValue: $Ref<number>, LookupType?: ECustomBoneAttributeLookup /* = BoneOnly */): boolean;

        GetIntegerAttribute_Ref(BoneName: string, AttributeName: string, OutValue: $Ref<number>, LookupType?: ECustomBoneAttributeLookup /* = BoneOnly */): boolean;

        GetLinkedAnimGraphInstanceByTag(InTag: string): AnimInstance;

        GetLinkedAnimGraphInstancesByTag(InTag: string, OutLinkedInstances: $Ref<TArray<AnimInstance>>): void;

        GetLinkedAnimLayerInstanceByClass(InClass: $Nullable<Class>): AnimInstance;

        GetLinkedAnimLayerInstanceByGroup(InGroup: string): AnimInstance;

        GetMorphTarget(MorphTargetName: string): number;

        GetPlayRate(): number;

        GetPosition(): number;

        GetPostProcessInstance(): AnimInstance;

        GetSkeletalCenterOfMass(): Vector;

        GetStringAttribute(BoneName: string, AttributeName: string, DefaultValue: string, OutValue: $Ref<string>, LookupType?: ECustomBoneAttributeLookup /* = BoneOnly */): boolean;

        GetStringAttribute_Ref(BoneName: string, AttributeName: string, OutValue: $Ref<string>, LookupType?: ECustomBoneAttributeLookup /* = BoneOnly */): boolean;

        GetTeleportDistanceThreshold(): number;

        GetTeleportRotationThreshold(): number;

        HasValidAnimationInstance(): boolean;

        IsBodyGravityEnabled(BoneName: string): boolean;

        IsClothingSimulationSuspended(): boolean;

        IsPlaying(): boolean;

        K2_GetClosestPointOnPhysicsAsset(WorldPosition: Vector, ClosestWorldPosition: $Ref<Vector>, Normal: $Ref<Vector>, BoneName: $Ref<string>, Distance: $Ref<number>): boolean;

        LinkAnimClassLayers(InClass: $Nullable<Class>): void;

        LinkAnimGraphByTag(InTag: string, InClass: $Nullable<Class>): void;

        OutlineEffectAdd(): void;

        OutlineEffectRemove(): void;

        OverrideAnimationData(InAnimToPlay: $Nullable<AnimationAsset>, bIsLooping?: boolean /* = true */, bIsPlaying?: boolean /* = true */, Position?: number /* = 0.000000 */, PlayRate?: number /* = 1.000000 */): void;

        Play(bLooping: boolean): void;

        PlayAnimation(NewAnimToPlay: $Nullable<AnimationAsset>, bLooping: boolean): void;

        ResetAllBodiesSimulatePhysics(): void;

        ResetAllowedAnimCurveEvaluation(): void;

        ResetAnimInstanceDynamics(InTeleportType?: ETeleportType /* = ResetPhysics */): void;

        ResetClothTeleportMode(): void;

        ResumeClothingSimulation(): void;

        SetAllBodiesBelowPhysicsBlendWeight(InBoneName: string, PhysicsBlendWeight: number, bSkipCustomPhysicsType?: boolean /* = false */, bIncludeSelf?: boolean /* = true */): void;

        SetAllBodiesBelowSimulatePhysics(InBoneName: string, bNewSimulate: boolean, bIncludeSelf?: boolean /* = true */): void;

        SetAllBodiesPhysicsBlendWeight(PhysicsBlendWeight: number, bSkipCustomPhysicsType?: boolean /* = false */): void;

        SetAllBodiesSimulatePhysics(bNewSimulate: boolean): void;

        SetAllMotorsAngularDriveParams(InSpring: number, InDamping: number, InForceLimit: number, bSkipCustomPhysicsType?: boolean /* = false */): void;

        SetAllMotorsAngularPositionDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bSkipCustomPhysicsType?: boolean /* = false */): void;

        SetAllMotorsAngularVelocityDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bSkipCustomPhysicsType?: boolean /* = false */): void;

        SetAllowAnimCurveEvaluation(bInAllow: boolean): void;

        SetAllowedAnimCurvesEvaluation(List: TArray<string>, bAllow: boolean): void;

        SetAllowRigidBodyAnimNode(bInAllow: boolean, bReinitAnim?: boolean /* = true */): void;

        SetAngularLimits(InBoneName: string, Swing1LimitAngle: number, TwistLimitAngle: number, Swing2LimitAngle: number): void;

        SetAnimation(NewAnimToPlay: $Nullable<AnimationAsset>): void;

        SetAnimationMode(InAnimationMode: EAnimationMode): void;

        SetAnimClass(NewClass: $Nullable<Class>): void;

        SetBodyNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean, BoneName?: string /* = "None" */): void;

        SetClothMaxDistanceScale(Scale: number): void;

        SetConstraintProfile(JointName: string, ProfileName: string, bDefaultIfNotFound?: boolean /* = false */): void;

        SetConstraintProfileForAll(ProfileName: string, bDefaultIfNotFound?: boolean /* = false */): void;

        SetDisableAnimCurves(bInDisableAnimCurves: boolean): void;

        SetDisablePostProcessBlueprint(bInDisablePostProcess: boolean): void;

        SetEnableBodyGravity(bEnableGravity: boolean, BoneName: string): void;

        SetEnableGravityOnAllBodiesBelow(bEnableGravity: boolean, BoneName: string, bIncludeSelf?: boolean /* = true */): void;

        SetEnablePhysicsBlending(bNewBlendPhysics: boolean): void;

        SetMorphTarget(MorphTargetName: string, Value: number, bRemoveZeroWeight?: boolean /* = true */): void;

        SetNotifyRigidBodyCollisionBelow(bNewNotifyRigidBodyCollision: boolean, BoneName?: string /* = "None" */, bIncludeSelf?: boolean /* = true */): void;

        SetPhysicsBlendWeight(PhysicsBlendWeight: number): void;

        SetPlayRate(Rate: number): void;

        SetPosition(InPos: number, bFireNotifies?: boolean /* = true */): void;

        SetTeleportDistanceThreshold(Threshold: number): void;

        SetTeleportRotationThreshold(Threshold: number): void;

        SetUpdateAnimationInEditor(NewUpdateState: boolean): void;

        SetUpdateClothInEditor(NewUpdateState: boolean): void;

        SnapshotPose(Snapshot: $Ref<PoseSnapshot>): void;

        Stop(): void;

        SuspendClothingSimulation(): void;

        TermBodiesBelow(ParentBoneName: string): void;

        ToggleDisablePostProcessBlueprint(): void;

        UnbindClothFromMasterPoseComponent(bRestoreSimulationSpace?: boolean /* = true */): void;

        UnifySpecifyPassWithOutlineMaterialType(): void;

        UnifySpecifyPassWithPassMaterialParams(): void;

        UnlinkAnimClassLayers(InClass: $Nullable<Class>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshComponent;

        static Load(InName: string): SkeletalMeshComponent;
    }

    export enum EPlaneConstraintAxisSetting {
        Custom,
        X,
        Y,
        Z,
        UseGlobalPhysicsSetting,
        EPlaneConstraintAxisSetting_MAX
    }

    export class MovementComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UpdatedComponent: SceneComponent;
        UpdatedPrimitive: PrimitiveComponent;
        Velocity: Vector;
        PlaneConstraintNormal: Vector;
        PlaneConstraintOrigin: Vector;
        bUpdateOnlyIfRendered: boolean;
        bAutoUpdateTickRegistration: boolean;
        bTickBeforeOwner: boolean;
        bAutoRegisterUpdatedComponent: boolean;
        bConstrainToPlane: boolean;
        bSnapToPlaneAtStart: boolean;
        bAutoRegisterPhysicsVolumeUpdates: boolean;
        bComponentShouldUpdatePhysicsVolume: boolean;
        PlaneConstraintAxisSetting: EPlaneConstraintAxisSetting;

        ConstrainDirectionToPlane(Direction: Vector): Vector;

        ConstrainLocationToPlane(Location: Vector): Vector;

        ConstrainNormalToPlane(Normal: Vector): Vector;

        GetGravityZ(): number;

        GetMaxSpeed(): number;

        GetPhysicsVolume(): PhysicsVolume;

        GetPlaneConstraintAxisSetting(): EPlaneConstraintAxisSetting;

        GetPlaneConstraintNormal(): Vector;

        GetPlaneConstraintOrigin(): Vector;

        IsExceedingMaxSpeed(MaxSpeed: number): boolean;

        K2_GetMaxSpeedModifier(): number;

        K2_GetModifiedMaxSpeed(): number;

        K2_MoveUpdatedComponent(Delta: Vector, NewRotation: Rotator, OutHit: $Ref<HitResult>, bSweep?: boolean /* = true */, bTeleport?: boolean /* = false */): boolean;

        PhysicsVolumeChanged(NewVolume: $Nullable<PhysicsVolume>): void;

        SetPlaneConstraintAxisSetting(NewAxisSetting: EPlaneConstraintAxisSetting): void;

        SetPlaneConstraintEnabled(bEnabled: boolean): void;

        SetPlaneConstraintFromVectors(Forward: Vector, Up: Vector): void;

        SetPlaneConstraintNormal(PlaneNormal: Vector): void;

        SetPlaneConstraintOrigin(PlaneOrigin: Vector): void;

        SetUpdatedComponent(NewUpdatedComponent: $Nullable<SceneComponent>): void;

        SnapUpdatedComponentToPlane(): void;

        StopMovementImmediately(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovementComponent;

        static Load(InName: string): MovementComponent;
    }

    export class MovementProperties {
        constructor();
        constructor(bCanCrouch: boolean, bCanJump: boolean, bCanWalk: boolean, bCanSwim: boolean, bCanFly: boolean);

        bCanCrouch: boolean;
        bCanJump: boolean;
        bCanWalk: boolean;
        bCanSwim: boolean;
        bCanFly: boolean;

        static StaticClass(): Class;
    }

    export class NavAgentProperties extends MovementProperties {
        constructor();
        constructor(AgentRadius: number, AgentHeight: number, AgentStepHeight: number, NavWalkingSearchHeightScale: number, PreferredNavData: SoftClassPath);

        AgentRadius: number;
        AgentHeight: number;
        AgentStepHeight: number;
        NavWalkingSearchHeightScale: number;
        PreferredNavData: SoftClassPath;

        static StaticClass(): Class;
    }

    export class NavMovementComponent extends MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NavAgentProps: NavAgentProperties;
        FixedPathBrakingDistance: number;
        bUpdateNavAgentWithOwnersCollision: boolean;
        bUseAccelerationForPaths: boolean;
        bUseFixedBrakingDistanceForPaths: boolean;
        MovementState: MovementProperties;
        PathFollowingComp: Object;

        IsCrouching(): boolean;

        IsFalling(): boolean;

        IsFlying(): boolean;

        IsMovingOnGround(): boolean;

        IsSwimming(): boolean;

        StopActiveMovement(): void;

        StopMovementKeepPathing(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavMovementComponent;

        static Load(InName: string): NavMovementComponent;
    }

    export class PawnMovementComponent extends NavMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PawnOwner: Pawn;

        AddInputVector(WorldVector: Vector, bForce?: boolean /* = false */): void;

        ConsumeInputVector(): Vector;

        GetLastInputVector(): Vector;

        GetPawnOwner(): Pawn;

        GetPendingInputVector(): Vector;

        IsMoveInputIgnored(): boolean;

        K2_GetInputVector(): Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnMovementComponent;

        static Load(InName: string): PawnMovementComponent;
    }

    export enum EMovementMode {
        MOVE_None,
        MOVE_Walking,
        MOVE_NavWalking,
        MOVE_Falling,
        MOVE_Swimming,
        MOVE_Flying,
        MOVE_Custom,
        MOVE_MAX
    }

    export enum ENetworkSmoothingMode { Disabled, Linear, Exponential, Replay, ENetworkSmoothingMode_MAX }

    export class FindFloorResult {
        constructor();
        constructor(bBlockingHit: boolean, bWalkableFloor: boolean, bLineTrace: boolean, FloorDist: number, LineDist: number, HitResult: HitResult);

        bBlockingHit: boolean;
        bWalkableFloor: boolean;
        bLineTrace: boolean;
        FloorDist: number;
        LineDist: number;
        HitResult: HitResult;

        static StaticClass(): Class;
    }

    export class NavAvoidanceMask {
        constructor();
        constructor(bGroup0: boolean, bGroup1: boolean, bGroup2: boolean, bGroup3: boolean, bGroup4: boolean, bGroup5: boolean, bGroup6: boolean, bGroup7: boolean, bGroup8: boolean, bGroup9: boolean, bGroup10: boolean, bGroup11: boolean, bGroup12: boolean, bGroup13: boolean, bGroup14: boolean, bGroup15: boolean, bGroup16: boolean, bGroup17: boolean, bGroup18: boolean, bGroup19: boolean, bGroup20: boolean, bGroup21: boolean, bGroup22: boolean, bGroup23: boolean, bGroup24: boolean, bGroup25: boolean, bGroup26: boolean, bGroup27: boolean, bGroup28: boolean, bGroup29: boolean, bGroup30: boolean, bGroup31: boolean);

        bGroup0: boolean;
        bGroup1: boolean;
        bGroup2: boolean;
        bGroup3: boolean;
        bGroup4: boolean;
        bGroup5: boolean;
        bGroup6: boolean;
        bGroup7: boolean;
        bGroup8: boolean;
        bGroup9: boolean;
        bGroup10: boolean;
        bGroup11: boolean;
        bGroup12: boolean;
        bGroup13: boolean;
        bGroup14: boolean;
        bGroup15: boolean;
        bGroup16: boolean;
        bGroup17: boolean;
        bGroup18: boolean;
        bGroup19: boolean;
        bGroup20: boolean;
        bGroup21: boolean;
        bGroup22: boolean;
        bGroup23: boolean;
        bGroup24: boolean;
        bGroup25: boolean;
        bGroup26: boolean;
        bGroup27: boolean;
        bGroup28: boolean;
        bGroup29: boolean;
        bGroup30: boolean;
        bGroup31: boolean;

        static StaticClass(): Class;
    }

    export class CharacterMovementComponentPostPhysicsTickFunction extends TickFunction {
        constructor();

        static StaticClass(): Class;
    }

    export class RootMotionSourceSettings {
        constructor();
        constructor(Flags: number);

        Flags: number;

        static StaticClass(): Class;
    }

    export class Vector_NetQuantize10 extends Vector {
        constructor();

        static StaticClass(): Class;
    }

    export class RootMotionSourceGroup {
        constructor();
        constructor(bHasAdditiveSources: boolean, bHasOverrideSources: boolean, bHasOverrideSourcesWithIgnoreZAccumulate: boolean, bIsAdditiveVelocityApplied: boolean, LastAccumulatedSettings: RootMotionSourceSettings, LastPreAdditiveVelocity: Vector_NetQuantize10);

        bHasAdditiveSources: boolean;
        bHasOverrideSources: boolean;
        bHasOverrideSourcesWithIgnoreZAccumulate: boolean;
        bIsAdditiveVelocityApplied: boolean;
        LastAccumulatedSettings: RootMotionSourceSettings;
        LastPreAdditiveVelocity: Vector_NetQuantize10;

        static StaticClass(): Class;
    }

    export class RootMotionMovementParams {
        constructor();
        constructor(bHasRootMotion: boolean, BlendWeight: number, RootMotionTransform: Transform);

        bHasRootMotion: boolean;
        BlendWeight: number;
        RootMotionTransform: Transform;

        static StaticClass(): Class;
    }

    export class CharacterMovementComponent extends PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CharacterOwner: Character;
        GravityScale: number;
        MaxStepHeight: number;
        JumpZVelocity: number;
        JumpOffJumpZFactor: number;
        WalkableFloorAngle: number;
        WalkableFloorZ: number;
        MovementMode: EMovementMode;
        CustomMovementMode: number;
        NetworkSmoothingMode: ENetworkSmoothingMode;
        GroundFriction: number;
        MaxWalkSpeed: number;
        MaxWalkSpeedCrouched: number;
        MaxSwimSpeed: number;
        MaxFlySpeed: number;
        MaxCustomMovementSpeed: number;
        MaxAcceleration: number;
        MinAnalogWalkSpeed: number;
        BrakingFrictionFactor: number;
        BrakingFriction: number;
        BrakingSubStepTime: number;
        BrakingDecelerationWalking: number;
        BrakingDecelerationFalling: number;
        BrakingDecelerationSwimming: number;
        BrakingDecelerationFlying: number;
        AirControl: number;
        AirControlBoostMultiplier: number;
        AirControlBoostVelocityThreshold: number;
        FallingLateralFriction: number;
        CrouchedHalfHeight: number;
        Buoyancy: number;
        PerchRadiusThreshold: number;
        PerchAdditionalHeight: number;
        RotationRate: Rotator;
        bUseSeparateBrakingFriction: boolean;
        bApplyGravityWhileJumping: boolean;
        bUseControllerDesiredRotation: boolean;
        bOrientRotationToMovement: boolean;
        bSweepWhileNavWalking: boolean;
        bMovementInProgress: boolean;
        bEnableScopedMovementUpdates: boolean;
        bEnableServerDualMoveScopedMovementUpdates: boolean;
        bForceMaxAccel: boolean;
        bRunPhysicsWithNoController: boolean;
        bForceNextFloorCheck: boolean;
        bShrinkProxyCapsule: boolean;
        bCanWalkOffLedges: boolean;
        bCanWalkOffLedgesWhenCrouching: boolean;
        bNetworkSkipProxyPredictionOnNetUpdate: boolean;
        bNetworkAlwaysReplicateTransformUpdateTimestamp: boolean;
        bDeferUpdateMoveComponent: boolean;
        bEnablePhysicsInteraction: boolean;
        bTouchForceScaledToMass: boolean;
        bPushForceScaledToMass: boolean;
        bPushForceUsingZOffset: boolean;
        bScalePushForceToVelocity: boolean;
        DeferredUpdatedMoveComponent: SceneComponent;
        MaxOutOfWaterStepHeight: number;
        OutofWaterZ: number;
        Mass: number;
        StandingDownwardForceScale: number;
        InitialPushForceFactor: number;
        PushForceFactor: number;
        PushForcePointZOffsetFactor: number;
        TouchForceFactor: number;
        MinTouchForce: number;
        MaxTouchForce: number;
        RepulsionForce: number;
        bForceBraking: boolean;
        CrouchedSpeedMultiplier: number;
        UpperImpactNormalScale: number;
        Acceleration: Vector;
        LastUpdateRotation: Quat;
        LastUpdateLocation: Vector;
        LastUpdateVelocity: Vector;
        ServerLastTransformUpdateTimeStamp: number;
        ServerLastClientGoodMoveAckTime: number;
        ServerLastClientAdjustmentTime: number;
        PendingImpulseToApply: Vector;
        PendingForceToApply: Vector;
        AnalogInputModifier: number;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        MaxJumpApexAttemptsPerSimulation: number;
        MaxDepenetrationWithGeometry: number;
        MaxDepenetrationWithGeometryAsProxy: number;
        MaxDepenetrationWithPawn: number;
        MaxDepenetrationWithPawnAsProxy: number;
        NetworkSimulatedSmoothLocationTime: number;
        NetworkSimulatedSmoothRotationTime: number;
        ListenServerNetworkSimulatedSmoothLocationTime: number;
        ListenServerNetworkSimulatedSmoothRotationTime: number;
        NetProxyShrinkRadius: number;
        NetProxyShrinkHalfHeight: number;
        NetworkMaxSmoothUpdateDistance: number;
        NetworkNoSmoothUpdateDistance: number;
        NetworkMinTimeBetweenClientAckGoodMoves: number;
        NetworkMinTimeBetweenClientAdjustments: number;
        NetworkMinTimeBetweenClientAdjustmentsLargeCorrection: number;
        NetworkLargeClientCorrectionDistance: number;
        LedgeCheckThreshold: number;
        JumpOutOfWaterPitch: number;
        CurrentFloor: FindFloorResult;
        DefaultLandMovementMode: EMovementMode;
        DefaultWaterMovementMode: EMovementMode;
        GroundMovementMode: EMovementMode;
        bMaintainHorizontalGroundVelocity: boolean;
        bImpartBaseVelocityX: boolean;
        bImpartBaseVelocityY: boolean;
        bImpartBaseVelocityZ: boolean;
        bImpartBaseAngularVelocity: boolean;
        bJustTeleported: boolean;
        bNetworkUpdateReceived: boolean;
        bNetworkMovementModeChanged: boolean;
        bIgnoreClientMovementErrorChecksAndCorrection: boolean;
        bServerAcceptClientAuthoritativePosition: boolean;
        bNotifyApex: boolean;
        bCheatFlying: boolean;
        bWantsToCrouch: boolean;
        bCrouchMaintainsBaseLocation: boolean;
        bIgnoreBaseRotation: boolean;
        bFastAttachedMove: boolean;
        bAlwaysCheckFloor: boolean;
        bUseFlatBaseForFloorChecks: boolean;
        bPerformingJumpOff: boolean;
        bWantsToLeaveNavWalking: boolean;
        bUseRVOAvoidance: boolean;
        bRequestedMoveUseAcceleration: boolean;
        bWasSimulatingRootMotion: boolean;
        bAllowPhysicsRotationDuringAnimRootMotion: boolean;
        bHasRequestedVelocity: boolean;
        bRequestedMoveWithMaxSpeed: boolean;
        bWasAvoidanceUpdated: boolean;
        bProjectNavMeshWalking: boolean;
        bProjectNavMeshOnBothWorldChannels: boolean;
        AvoidanceConsiderationRadius: number;
        RequestedVelocity: Vector;
        AvoidanceUID: number;
        AvoidanceGroup: NavAvoidanceMask;
        GroupsToAvoid: NavAvoidanceMask;
        GroupsToIgnore: NavAvoidanceMask;
        AvoidanceWeight: number;
        PendingLaunchVelocity: Vector;
        NavMeshProjectionInterval: number;
        NavMeshProjectionTimer: number;
        NavMeshProjectionInterpSpeed: number;
        NavMeshProjectionHeightScaleUp: number;
        NavMeshProjectionHeightScaleDown: number;
        NavWalkingFloorDistTolerance: number;
        PostPhysicsTickFunction: CharacterMovementComponentPostPhysicsTickFunction;
        MinTimeBetweenTimeStampResets: number;
        CurrentRootMotion: RootMotionSourceGroup;
        ServerCorrectionRootMotion: RootMotionSourceGroup;
        RootMotionParams: RootMotionMovementParams;
        AnimRootMotionVelocity: Vector;

        AddForce(Force: Vector): void;

        AddImpulse(Impulse: Vector, bVelocityChange?: boolean /* = false */): void;

        CalcVelocity(DeltaTime: number, Friction: number, bFluid: boolean, BrakingDeceleration: number): void;

        CapsuleTouched(OverlappedComp: $Nullable<PrimitiveComponent>, Other: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult): void;

        ClearAccumulatedForces(): void;

        DisableMovement(): void;

        GetAnalogInputModifier(): number;

        GetCharacterOwner(): Character;

        GetCurrentAcceleration(): Vector;

        GetImpartedMovementBaseVelocity(): Vector;

        GetLastUpdateLocation(): Vector;

        GetLastUpdateRotation(): Rotator;

        GetLastUpdateVelocity(): Vector;

        GetMaxAcceleration(): number;

        GetMaxBrakingDeceleration(): number;

        GetMaxJumpHeight(): number;

        GetMaxJumpHeightWithJumpTime(): number;

        GetMinAnalogSpeed(): number;

        GetMovementBase(): PrimitiveComponent;

        GetPerchRadiusThreshold(): number;

        GetValidPerchRadius(): number;

        IsWalkable(Hit: HitResult): boolean;

        IsWalking(): boolean;

        K2_ComputeFloorDist(CapsuleLocation: Vector, LineDistance: number, SweepDistance: number, SweepRadius: number, FloorResult: $Ref<FindFloorResult>): void;

        K2_FindFloor(CapsuleLocation: Vector, FloorResult: $Ref<FindFloorResult>): void;

        K2_GetModifiedMaxAcceleration(): number;

        K2_GetWalkableFloorAngle(): number;

        K2_GetWalkableFloorZ(): number;

        SetAvoidanceEnabled(bEnable: boolean): void;

        SetAvoidanceGroup(GroupFlags: number): void;

        SetAvoidanceGroupMask(GroupMask: NavAvoidanceMask): void;

        SetGroupsToAvoid(GroupFlags: number): void;

        SetGroupsToAvoidMask(GroupMask: NavAvoidanceMask): void;

        SetGroupsToIgnore(GroupFlags: number): void;

        SetGroupsToIgnoreMask(GroupMask: NavAvoidanceMask): void;

        SetMovementMode(NewMovementMode: EMovementMode, NewCustomMode?: number /* = 0 */): void;

        SetWalkableFloorAngle(InWalkableFloorAngle: number): void;

        SetWalkableFloorZ(InWalkableFloorZ: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CharacterMovementComponent;

        static Load(InName: string): CharacterMovementComponent;
    }

    export class ShapeComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShapeBodySetup: BodySetup;
        AreaClass: Class;
        ShapeColor: Color;
        bDrawOnlyIfSelected: boolean;
        bShouldCollideWhenPlacing: boolean;
        bDynamicObstacle: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ShapeComponent;

        static Load(InName: string): ShapeComponent;
    }

    export class CapsuleComponent extends ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CapsuleHalfHeight: number;
        CapsuleRadius: number;
        CapsuleHeight: number;

        GetScaledCapsuleHalfHeight(): number;

        GetScaledCapsuleHalfHeight_WithoutHemisphere(): number;

        GetScaledCapsuleRadius(): number;

        GetScaledCapsuleSize(OutRadius: $Ref<number>, OutHalfHeight: $Ref<number>): void;

        GetScaledCapsuleSize_WithoutHemisphere(OutRadius: $Ref<number>, OutHalfHeightWithoutHemisphere: $Ref<number>): void;

        GetShapeScale(): number;

        GetUnscaledCapsuleHalfHeight(): number;

        GetUnscaledCapsuleHalfHeight_WithoutHemisphere(): number;

        GetUnscaledCapsuleRadius(): number;

        GetUnscaledCapsuleSize(OutRadius: $Ref<number>, OutHalfHeight: $Ref<number>): void;

        GetUnscaledCapsuleSize_WithoutHemisphere(OutRadius: $Ref<number>, OutHalfHeightWithoutHemisphere: $Ref<number>): void;

        SetCapsuleHalfHeight(HalfHeight: number, bUpdateOverlaps?: boolean /* = true */): void;

        SetCapsuleRadius(Radius: number, bUpdateOverlaps?: boolean /* = true */): void;

        SetCapsuleSize(InRadius: number, InHalfHeight: number, bUpdateOverlaps?: boolean /* = true */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CapsuleComponent;

        static Load(InName: string): CapsuleComponent;
    }

    export class ArrowComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ArrowColor: Color;
        ArrowSize: number;
        ArrowLength: number;
        ScreenSize: number;
        bIsScreenSizeScaled: boolean;
        bTreatAsASprite: boolean;
        SpriteCategoryName: string;
        SpriteInfo: SpriteCategoryInfo;
        bLightAttachment: boolean;
        bUseInEditorScaling: boolean;

        SetArrowColor(NewColor: LinearColor): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ArrowComponent;

        static Load(InName: string): ArrowComponent;
    }

    export class BasedMovementInfo {
        constructor();
        constructor(MovementBase: PrimitiveComponent, BoneName: string, Location: Vector_NetQuantize100, Rotation: Rotator, bServerHasBaseComponent: boolean, bRelativeRotation: boolean, bServerHasVelocity: boolean);

        MovementBase: PrimitiveComponent;
        BoneName: string;
        Location: Vector_NetQuantize100;
        Rotation: Rotator;
        bServerHasBaseComponent: boolean;
        bRelativeRotation: boolean;
        bServerHasVelocity: boolean;

        static StaticClass(): Class;
    }

    export class RepRootMotionMontage {
        constructor();
        constructor(bIsActive: boolean, AnimMontage: AnimMontage, Position: number, Location: Vector_NetQuantize100, Rotation: Rotator, MovementBase: PrimitiveComponent, MovementBaseBoneName: string, bRelativePosition: boolean, bRelativeRotation: boolean, AuthoritativeRootMotion: RootMotionSourceGroup, Acceleration: Vector_NetQuantize10, LinearVelocity: Vector_NetQuantize10);

        bIsActive: boolean;
        AnimMontage: AnimMontage;
        Position: number;
        Location: Vector_NetQuantize100;
        Rotation: Rotator;
        MovementBase: PrimitiveComponent;
        MovementBaseBoneName: string;
        bRelativePosition: boolean;
        bRelativeRotation: boolean;
        AuthoritativeRootMotion: RootMotionSourceGroup;
        Acceleration: Vector_NetQuantize10;
        LinearVelocity: Vector_NetQuantize10;

        static StaticClass(): Class;
    }

    export class SimulatedRootMotionReplicatedMove {
        constructor();
        constructor(Time: number, RootMotion: RepRootMotionMontage);

        Time: number;
        RootMotion: RepRootMotionMontage;

        static StaticClass(): Class;
    }

    export class CharacterNetworkSerializationPackedBits {
        constructor();

        static StaticClass(): Class;
    }

    export class CharacterServerMovePackedBits extends CharacterNetworkSerializationPackedBits {
        constructor();

        static StaticClass(): Class;
    }

    export class CharacterMoveResponsePackedBits extends CharacterNetworkSerializationPackedBits {
        constructor();

        static StaticClass(): Class;
    }

    export class Character extends Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Mesh: SkeletalMeshComponent;
        CharacterMovement: CharacterMovementComponent;
        CapsuleComponent: CapsuleComponent;
        ArrowComponent: ArrowComponent;
        BasedMovement: BasedMovementInfo;
        ReplicatedBasedMovement: BasedMovementInfo;
        AnimRootMotionTranslationScale: number;
        BaseTranslationOffset: Vector;
        BaseRotationOffset: Quat;
        ReplicatedServerLastTransformUpdateTimeStamp: number;
        ReplayLastTransformUpdateTimeStamp: number;
        ReplicatedMovementMode: number;
        bInBaseReplication: boolean;
        CrouchedEyeHeight: number;
        bIsCrouched: boolean;
        bProxyIsJumpForceApplied: boolean;
        bPressedJump: boolean;
        bClientUpdating: boolean;
        bClientWasFalling: boolean;
        bClientResimulateRootMotion: boolean;
        bClientResimulateRootMotionSources: boolean;
        bSimGravityDisabled: boolean;
        bClientCheckEncroachmentOnNetUpdate: boolean;
        bServerMoveIgnoreRootMotion: boolean;
        bWasJumping: boolean;
        JumpKeyHoldTime: number;
        JumpForceTimeRemaining: number;
        ProxyJumpForceStartedTime: number;
        JumpMaxHoldTime: number;
        JumpMaxCount: number;
        JumpCurrentCount: number;
        JumpCurrentCountPreJump: number;
        OnReachedJumpApex: $MulticastDelegate<() => void>;
        MovementModeChangedDelegate: $MulticastDelegate<(Character: $Nullable<Character>, PrevMovementMode: EMovementMode, PreviousCustomMode: number) => void>;
        OnCharacterMovementUpdated: $MulticastDelegate<(DeltaSeconds: number, OldLocation: Vector, OldVelocity: Vector) => void>;
        SavedRootMotion: RootMotionSourceGroup;
        ClientRootMotionParams: RootMotionMovementParams;
        RootMotionRepMoves: TArray<SimulatedRootMotionReplicatedMove>;
        RepRootMotion: RepRootMotionMontage;

        CacheInitialMeshOffset(MeshRelativeLocation: Vector, MeshRelativeRotation: Rotator): void;

        CanCrouch(): boolean;

        CanJump(): boolean;

        CanJumpInternal(): boolean;

        ClientAckGoodMove(TimeStamp: number): void;

        ClientAdjustPosition(TimeStamp: number, NewLoc: Vector, NewVel: Vector, NewBase: $Nullable<PrimitiveComponent>, NewBaseBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number): void;

        ClientAdjustRootMotionPosition(TimeStamp: number, ServerMontageTrackPosition: number, ServerLoc: Vector, ServerRotation: Vector_NetQuantizeNormal, ServerVelZ: number, ServerBase: $Nullable<PrimitiveComponent>, ServerBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number): void;

        ClientAdjustRootMotionSourcePosition(TimeStamp: number, ServerRootMotion: RootMotionSourceGroup, bHasAnimRootMotion: boolean, ServerMontageTrackPosition: number, ServerLoc: Vector, ServerRotation: Vector_NetQuantizeNormal, ServerVelZ: number, ServerBase: $Nullable<PrimitiveComponent>, ServerBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number): void;

        ClientCheatFly(): void;

        ClientCheatGhost(): void;

        ClientCheatWalk(): void;

        ClientMoveResponsePacked(PackedBits: CharacterMoveResponsePackedBits): void;

        ClientVeryShortAdjustPosition(TimeStamp: number, NewLoc: Vector, NewBase: $Nullable<PrimitiveComponent>, NewBaseBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number): void;

        Crouch(bClientSimulation?: boolean /* = false */): void;

        GetAnimRootMotionTranslationScale(): number;

        GetBaseRotationOffsetRotator(): Rotator;

        GetBaseTranslationOffset(): Vector;

        GetCurrentMontage(): AnimMontage;

        HasAnyRootMotion(): boolean;

        IsJumpProvidingForce(): boolean;

        IsPlayingNetworkedRootMotionMontage(): boolean;

        IsPlayingRootMotion(): boolean;

        Jump(): void;

        K2_OnEndCrouch(HalfHeightAdjust: number, ScaledHalfHeightAdjust: number): void;

        K2_OnMovementModeChanged(PrevMovementMode: EMovementMode, NewMovementMode: EMovementMode, PrevCustomMode: number, NewCustomMode: number): void;

        K2_OnStartCrouch(HalfHeightAdjust: number, ScaledHalfHeightAdjust: number): void;

        K2_UpdateCustomMovement(DeltaTime: number): void;

        LaunchCharacter(LaunchVelocity: Vector, bXYOverride: boolean, bZOverride: boolean): void;

        OnJumped(): void;

        OnLanded(Hit: HitResult): void;

        OnLaunched(LaunchVelocity: Vector, bXYOverride: boolean, bZOverride: boolean): void;

        OnRep_IsCrouched(): void;

        OnRep_ReplayLastTransformUpdateTimeStamp(): void;

        OnRep_ReplicatedBasedMovement(): void;

        OnRep_RootMotion(): void;

        OnWalkingOffLedge(PreviousFloorImpactNormal: Vector, PreviousFloorContactNormal: Vector, PreviousLocation: Vector, TimeDelta: number): void;

        PlayAnimMontage(AnimMontage: $Nullable<AnimMontage>, InPlayRate?: number /* = 1.000000 */, StartSectionName?: string /* = "None" */): number;

        RootMotionDebugClientPrintOnScreen(InString: string): void;

        ServerMove(TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, CompressedMoveFlags: number, ClientRoll: number, View: number, ClientMovementBase: $Nullable<PrimitiveComponent>, ClientBaseBoneName: string, ClientMovementMode: number): void;

        ServerMoveDual(TimeStamp0: number, InAccel0: Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementBase: $Nullable<PrimitiveComponent>, ClientBaseBoneName: string, ClientMovementMode: number): void;

        ServerMoveDualHybridRootMotion(TimeStamp0: number, InAccel0: Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementBase: $Nullable<PrimitiveComponent>, ClientBaseBoneName: string, ClientMovementMode: number): void;

        ServerMoveDualNoBase(TimeStamp0: number, InAccel0: Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementMode: number): void;

        ServerMoveNoBase(TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, CompressedMoveFlags: number, ClientRoll: number, View: number, ClientMovementMode: number): void;

        ServerMoveOld(OldTimeStamp: number, OldAccel: Vector_NetQuantize10, OldMoveFlags: number): void;

        ServerMovePacked(PackedBits: CharacterServerMovePackedBits): void;

        StopAnimMontage(AnimMontage?: AnimMontage /* = None */): void;

        StopJumping(): void;

        UnCrouch(bClientSimulation?: boolean /* = false */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Character;

        static Load(InName: string): Character;
    }

    export class Player extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerController: PlayerController;
        CurrentNetSpeed: number;
        ConfiguredInternetSpeed: number;
        ConfiguredLanSpeed: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Player;

        static Load(InName: string): Player;
    }

    export class InterpTrackInst extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInst;

        static Load(InName: string): InterpTrackInst;
    }

    export class InterpTrackInstDirector extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OldViewTarget: Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstDirector;

        static Load(InName: string): InterpTrackInstDirector;
    }

    export class ReporterBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReporterBase;

        static Load(InName: string): ReporterBase;
    }

    export class ReporterGraph extends ReporterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReporterGraph;

        static Load(InName: string): ReporterGraph;
    }

    export class CanvasUVTri {
        constructor();
        constructor(V0_Pos: Vector2D, V0_UV: Vector2D, V0_Color: LinearColor, V1_Pos: Vector2D, V1_UV: Vector2D, V1_Color: LinearColor, V2_Pos: Vector2D, V2_UV: Vector2D, V2_Color: LinearColor);

        V0_Pos: Vector2D;
        V0_UV: Vector2D;
        V0_Color: LinearColor;
        V1_Pos: Vector2D;
        V1_UV: Vector2D;
        V1_Color: LinearColor;
        V2_Pos: Vector2D;
        V2_UV: Vector2D;
        V2_Color: LinearColor;

        static StaticClass(): Class;
    }

    export class Canvas extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OrgX: number;
        OrgY: number;
        ClipX: number;
        ClipY: number;
        DrawColor: Color;
        bCenterX: boolean;
        bCenterY: boolean;
        bNoSmooth: boolean;
        SizeX: number;
        SizeY: number;
        ColorModulate: Plane;
        DefaultTexture: Texture2D;
        GradientTexture0: Texture2D;
        ReporterGraph: ReporterGraph;

        K2_Deproject(ScreenPosition: Vector2D, WorldOrigin: $Ref<Vector>, WorldDirection: $Ref<Vector>): void;

        K2_DrawBorder(BorderTexture: $Nullable<Texture>, BackgroundTexture: $Nullable<Texture>, LeftBorderTexture: $Nullable<Texture>, RightBorderTexture: $Nullable<Texture>, TopBorderTexture: $Nullable<Texture>, BottomBorderTexture: $Nullable<Texture>, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize?: Vector2D /* = (X=1.000,Y=1.000) */, RenderColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, BorderScale?: Vector2D /* = (X=0.100,Y=0.100) */, BackgroundScale?: Vector2D /* = (X=0.100,Y=0.100) */, Rotation?: number /* = 0.000000 */, PivotPoint?: Vector2D /* = (X=0.500,Y=0.500) */, CornerSize?: Vector2D /* =  */): void;

        K2_DrawBox(ScreenPosition: Vector2D, ScreenSize: Vector2D, Thickness?: number /* = 1.000000 */, RenderColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        K2_DrawLine(ScreenPositionA?: Vector2D /* =  */, ScreenPositionB?: Vector2D /* =  */, Thickness?: number /* = 1.000000 */, RenderColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        K2_DrawMaterial(RenderMaterial: $Nullable<MaterialInterface>, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize?: Vector2D /* = (X=1.000,Y=1.000) */, Rotation?: number /* = 0.000000 */, PivotPoint?: Vector2D /* = (X=0.500,Y=0.500) */, bUseLighting?: boolean /* = false */): void;

        K2_DrawMaterialTriangle(RenderMaterial: $Nullable<MaterialInterface>, Triangles: TArray<CanvasUVTri>): void;

        K2_DrawPolygon(RenderTexture: $Nullable<Texture>, ScreenPosition: Vector2D, Radius?: Vector2D /* = (X=1.000,Y=1.000) */, NumberOfSides?: number /* = 3 */, RenderColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        K2_DrawText(RenderFont: $Nullable<Font>, RenderText: string, ScreenPosition: Vector2D, Scale?: Vector2D /* = (X=1.000,Y=1.000) */, RenderColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Kerning?: number /* = 0.000000 */, ShadowColor?: LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */, ShadowOffset?: Vector2D /* = (X=1.000,Y=1.000) */, bCentreX?: boolean /* = false */, bCentreY?: boolean /* = false */, bOutlined?: boolean /* = false */, OutlineColor?: LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */): void;

        K2_DrawTexture(RenderTexture: $Nullable<Texture>, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize?: Vector2D /* = (X=1.000,Y=1.000) */, RenderColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, BlendMode?: EBlendMode /* = BLEND_Translucent */, Rotation?: number /* = 0.000000 */, PivotPoint?: Vector2D /* = (X=0.500,Y=0.500) */): void;

        K2_DrawTriangle(RenderTexture: $Nullable<Texture>, Triangles: TArray<CanvasUVTri>): void;

        K2_Project(WorldLocation: Vector): Vector;

        K2_StrLen(RenderFont: $Nullable<Font>, RenderText: string): Vector2D;

        K2_TextSize(RenderFont: $Nullable<Font>, RenderText: string, Scale?: Vector2D /* = (X=1.000,Y=1.000) */): Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Canvas;

        static Load(InName: string): Canvas;
    }

    export class DebugTextInfo {
        constructor();
        constructor(SrcActor: Actor, SrcActorOffset: Vector, SrcActorDesiredOffset: Vector, DebugText: string, TimeRemaining: number, Duration: number, TextColor: Color, bAbsoluteLocation: boolean, bKeepAttachedToActor: boolean, bDrawShadow: boolean, OrigActorLocation: Vector, Font: Font, FontScale: number);

        SrcActor: Actor;
        SrcActorOffset: Vector;
        SrcActorDesiredOffset: Vector;
        DebugText: string;
        TimeRemaining: number;
        Duration: number;
        TextColor: Color;
        bAbsoluteLocation: boolean;
        bKeepAttachedToActor: boolean;
        bDrawShadow: boolean;
        OrigActorLocation: Vector;
        Font: Font;
        FontScale: number;

        static StaticClass(): Class;
    }

    export class HUD extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerOwner: PlayerController;
        bLostFocusPaused: boolean;
        bShowHUD: boolean;
        bShowDebugInfo: boolean;
        CurrentTargetIndex: number;
        bShowHitBoxDebugInfo: boolean;
        bShowOverlays: boolean;
        bEnableDebugTextShadow: boolean;
        PostRenderedActors: TArray<Actor>;
        DebugDisplay: TArray<string>;
        ToggledDebugCategories: TArray<string>;
        Canvas: Canvas;
        DebugCanvas: Canvas;
        DebugTextList: TArray<DebugTextInfo>;
        ShowDebugTargetDesiredClass: Class;
        ShowDebugTargetActor: Actor;

        AddDebugText(DebugText: string, SrcActor: $Nullable<Actor>, Duration: number, Offset: Vector, DesiredOffset: Vector, TextColor: Color, bSkipOverwriteCheck: boolean, bAbsoluteLocation: boolean, bKeepAttachedToActor: boolean, InFont: $Nullable<Font>, FontScale: number, bDrawShadow: boolean): void;

        AddHitBox(Position: Vector2D, Size: Vector2D, InName: string, bConsumesInput: boolean, Priority?: number /* = 0 */): void;

        Deproject(ScreenX: number, ScreenY: number, WorldPosition: $Ref<Vector>, WorldDirection: $Ref<Vector>): void;

        DrawLine(StartScreenX: number, StartScreenY: number, EndScreenX: number, EndScreenY: number, LineColor: LinearColor, LineThickness?: number /* = 0.000000 */): void;

        DrawMaterial(Material: $Nullable<MaterialInterface>, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, MaterialU: number, MaterialV: number, MaterialUWidth: number, MaterialVHeight: number, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */, Rotation?: number /* = 0.000000 */, RotPivot?: Vector2D /* =  */): void;

        DrawMaterialSimple(Material: $Nullable<MaterialInterface>, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */): void;

        DrawMaterialTriangle(Material: $Nullable<MaterialInterface>, V0_Pos: Vector2D, V1_Pos: Vector2D, V2_Pos: Vector2D, V0_UV: Vector2D, V1_UV: Vector2D, V2_UV: Vector2D, V0_Color?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, V1_Color?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, V2_Color?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        DrawRect(RectColor: LinearColor, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number): void;

        DrawText(Text: string, TextColor: LinearColor, ScreenX: number, ScreenY: number, Font?: Font /* = None */, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */): void;

        DrawTexture(Texture: $Nullable<Texture>, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, TextureU: number, TextureV: number, TextureUWidth: number, TextureVHeight: number, TintColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, BlendMode?: EBlendMode /* = BLEND_Translucent */, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */, Rotation?: number /* = 0.000000 */, RotPivot?: Vector2D /* =  */): void;

        DrawTextureSimple(Texture: $Nullable<Texture>, ScreenX: number, ScreenY: number, Scale?: number /* = 1.000000 */, bScalePosition?: boolean /* = false */): void;

        GetActorsInSelectionRectangle(ClassFilter: $Nullable<Class>, FirstPoint: Vector2D, SecondPoint: Vector2D, OutActors: $Ref<TArray<Actor>>, bIncludeNonCollidingComponents?: boolean /* = true */, bActorMustBeFullyEnclosed?: boolean /* = false */): void;

        GetOwningPawn(): Pawn;

        GetOwningPlayerController(): PlayerController;

        GetTextSize(Text: string, OutWidth: $Ref<number>, OutHeight: $Ref<number>, Font?: Font /* = None */, Scale?: number /* = 1.000000 */): void;

        NextDebugTarget(): void;

        PreviousDebugTarget(): void;

        Project(Location: Vector): Vector;

        ReceiveDrawHUD(SizeX: number, SizeY: number): void;

        ReceiveHitBoxBeginCursorOver(BoxName: string): void;

        ReceiveHitBoxClick(BoxName: string): void;

        ReceiveHitBoxEndCursorOver(BoxName: string): void;

        ReceiveHitBoxRelease(BoxName: string): void;

        RemoveAllDebugStrings(): void;

        RemoveDebugText(SrcActor: $Nullable<Actor>, bLeaveDurationText: boolean): void;

        ShowDebug(DebugType?: string /* = "None" */): void;

        ShowDebugForReticleTargetToggle(DesiredClass: $Nullable<Class>): void;

        ShowDebugToggleSubCategory(Category: string): void;

        ShowHUD(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HUD;

        static Load(InName: string): HUD;
    }

    export enum ECameraProjectionMode { Perspective, Orthographic, ECameraProjectionMode_MAX }

    export enum EBloomMethod { BM_SOG, BM_FFT, BM_MAX }

    export enum EAutoExposureMethod { AEM_Histogram, AEM_Basic, AEM_Manual, AEM_MAX }

    export enum EDepthOfFieldMethod { DOFM_BokehDOF, DOFM_Gaussian, DOFM_CircleDOF, DOFM_MAX }

    export class TextureCube extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureCube;

        static Load(InName: string): TextureCube;
    }

    export enum ERayTracingGlobalIlluminationType {
        Disabled,
        BruteForce,
        FinalGather,
        ERayTracingGlobalIlluminationType_MAX
    }

    export enum EReflectionsType { ScreenSpace, RayTracing, EReflectionsType_MAX }

    export enum EReflectedAndRefractedRayTracedShadows {
        Disabled,
        Hard_shadows,
        Area_shadows,
        EReflectedAndRefractedRayTracedShadows_MAX
    }

    export enum ETranslucencyType { Raster, RayTracing, ETranslucencyType_MAX }

    export class WeightedBlendable {
        constructor();
        constructor(Weight: number, Object: Object);

        Weight: number;
        Object: Object;

        static StaticClass(): Class;
    }

    export class WeightedBlendables {
        constructor();
        constructor(Array: TArray<WeightedBlendable>);

        Array: TArray<WeightedBlendable>;

        static StaticClass(): Class;
    }

    export class PostProcessSettings {
        constructor();
        constructor(bOverride_WhiteTemp: boolean, bOverride_WhiteTint: boolean, bOverride_ColorSaturation: boolean, bOverride_ColorContrast: boolean, bOverride_ColorGamma: boolean, bOverride_ColorGain: boolean, bOverride_ColorOffset: boolean, bOverride_ColorSaturationShadows: boolean, bOverride_ColorContrastShadows: boolean, bOverride_ColorGammaShadows: boolean, bOverride_ColorGainShadows: boolean, bOverride_ColorOffsetShadows: boolean, bOverride_ColorSaturationMidtones: boolean, bOverride_ColorContrastMidtones: boolean, bOverride_ColorGammaMidtones: boolean, bOverride_ColorGainMidtones: boolean, bOverride_ColorOffsetMidtones: boolean, bOverride_ColorSaturationHighlights: boolean, bOverride_ColorContrastHighlights: boolean, bOverride_ColorGammaHighlights: boolean, bOverride_ColorGainHighlights: boolean, bOverride_ColorOffsetHighlights: boolean, bOverride_ColorCorrectionShadowsMax: boolean, bOverride_ColorCorrectionHighlightsMin: boolean, bOverride_BlueCorrection: boolean, bOverride_ExpandGamut: boolean, bOverride_ToneCurveAmount: boolean, bOverride_FilmWhitePoint: boolean, bOverride_FilmSaturation: boolean, bOverride_FilmChannelMixerRed: boolean, bOverride_FilmChannelMixerGreen: boolean, bOverride_FilmChannelMixerBlue: boolean, bOverride_FilmContrast: boolean, bOverride_FilmDynamicRange: boolean, bOverride_FilmHealAmount: boolean, bOverride_FilmToeAmount: boolean, bOverride_FilmShadowTint: boolean, bOverride_FilmShadowTintBlend: boolean, bOverride_FilmShadowTintAmount: boolean, bOverride_FilmSlope: boolean, bOverride_FilmToe: boolean, bOverride_FilmShoulder: boolean, bOverride_FilmBlackClip: boolean, bOverride_FilmWhiteClip: boolean, bOverride_SceneColorTint: boolean, bOverride_SceneFringeIntensity: boolean, bOverride_ChromaticAberrationStartOffset: boolean, bOverride_AmbientCubemapTint: boolean, bOverride_AmbientCubemapIntensity: boolean, bOverride_BloomMethod: boolean, bOverride_BloomIntensity: boolean, bOverride_BloomThreshold: boolean, bOverride_Bloom1Tint: boolean, bOverride_Bloom1Size: boolean, bOverride_Bloom2Size: boolean, bOverride_Bloom2Tint: boolean, bOverride_Bloom3Tint: boolean, bOverride_Bloom3Size: boolean, bOverride_Bloom4Tint: boolean, bOverride_Bloom4Size: boolean, bOverride_Bloom5Tint: boolean, bOverride_Bloom5Size: boolean, bOverride_Bloom6Tint: boolean, bOverride_Bloom6Size: boolean, bOverride_BloomSizeScale: boolean, bOverride_BloomConvolutionTexture: boolean, bOverride_BloomConvolutionSize: boolean, bOverride_BloomConvolutionCenterUV: boolean, bOverride_BloomConvolutionPreFilter: boolean, bOverride_BloomConvolutionPreFilterMin: boolean, bOverride_BloomConvolutionPreFilterMax: boolean, bOverride_BloomConvolutionPreFilterMult: boolean, bOverride_BloomConvolutionBufferScale: boolean, bOverride_BloomDirtMaskIntensity: boolean, bOverride_BloomDirtMaskTint: boolean, bOverride_BloomDirtMask: boolean, bOverride_CameraShutterSpeed: boolean, bOverride_CameraISO: boolean, bOverride_AutoExposureMethod: boolean, bOverride_AutoExposureLowPercent: boolean, bOverride_AutoExposureHighPercent: boolean, bOverride_AutoExposureMinBrightness: boolean, bOverride_AutoExposureMaxBrightness: boolean, bOverride_AutoExposureCalibrationConstant: boolean, bOverride_AutoExposureSpeedUp: boolean, bOverride_AutoExposureSpeedDown: boolean, bOverride_AutoExposureBias: boolean, bOverride_AutoExposureBiasCurve: boolean, bOverride_AutoExposureMeterMask: boolean, bOverride_AutoExposureApplyPhysicalCameraExposure: boolean, bOverride_HistogramLogMin: boolean, bOverride_HistogramLogMax: boolean, bOverride_LensFlareIntensity: boolean, bOverride_LensFlareTint: boolean, bOverride_LensFlareTints: boolean, bOverride_LensFlareBokehSize: boolean, bOverride_LensFlareBokehShape: boolean, bOverride_LensFlareThreshold: boolean, bOverride_VignetteIntensity: boolean, bOverride_GrainIntensity: boolean, bOverride_GrainJitter: boolean, bOverride_AmbientOcclusionIntensity: boolean, bOverride_AmbientOcclusionStaticFraction: boolean, bOverride_AmbientOcclusionRadius: boolean, bOverride_AmbientOcclusionFadeDistance: boolean, bOverride_AmbientOcclusionFadeRadius: boolean, bOverride_AmbientOcclusionDistance: boolean, bOverride_AmbientOcclusionRadiusInWS: boolean, bOverride_AmbientOcclusionPower: boolean, bOverride_AmbientOcclusionBias: boolean, bOverride_AmbientOcclusionQuality: boolean, bOverride_AmbientOcclusionMipBlend: boolean, bOverride_AmbientOcclusionMipScale: boolean, bOverride_AmbientOcclusionMipThreshold: boolean, bOverride_AmbientOcclusionTemporalBlendWeight: boolean, bOverride_RayTracingAO: boolean, bOverride_RayTracingAOSamplesPerPixel: boolean, bOverride_RayTracingAOIntensity: boolean, bOverride_RayTracingAORadius: boolean, bOverride_LPVIntensity: boolean, bOverride_LPVDirectionalOcclusionIntensity: boolean, bOverride_LPVDirectionalOcclusionRadius: boolean, bOverride_LPVDiffuseOcclusionExponent: boolean, bOverride_LPVSpecularOcclusionExponent: boolean, bOverride_LPVDiffuseOcclusionIntensity: boolean, bOverride_LPVSpecularOcclusionIntensity: boolean, bOverride_LPVSize: boolean, bOverride_LPVSecondaryOcclusionIntensity: boolean, bOverride_LPVSecondaryBounceIntensity: boolean, bOverride_LPVGeometryVolumeBias: boolean, bOverride_LPVVplInjectionBias: boolean, bOverride_LPVEmissiveInjectionIntensity: boolean, bOverride_LPVFadeRange: boolean, bOverride_LPVDirectionalOcclusionFadeRange: boolean, bOverride_IndirectLightingColor: boolean, bOverride_IndirectLightingIntensity: boolean, bOverride_ColorGradingIntensity: boolean, bOverride_ColorGradingLUT: boolean, bOverride_DepthOfFieldFocalDistance: boolean, bOverride_DepthOfFieldFstop: boolean, bOverride_DepthOfFieldMinFstop: boolean, bOverride_DepthOfFieldBladeCount: boolean, bOverride_DepthOfFieldSensorWidth: boolean, bOverride_DepthOfFieldDepthBlurRadius: boolean, bOverride_DepthOfFieldDepthBlurAmount: boolean, bOverride_DepthOfFieldFocalRegion: boolean, bOverride_DepthOfFieldNearTransitionRegion: boolean, bOverride_DepthOfFieldFarTransitionRegion: boolean, bOverride_DepthOfFieldScale: boolean, bOverride_DepthOfFieldNearBlurSize: boolean, bOverride_DepthOfFieldFarBlurSize: boolean, bOverride_MobileHQGaussian: boolean, bOverride_DepthOfFieldOcclusion: boolean, bOverride_DepthOfFieldSkyFocusDistance: boolean, bOverride_DepthOfFieldVignetteSize: boolean, bOverride_MotionBlurAmount: boolean, bOverride_MotionBlurMax: boolean, bOverride_MotionBlurTargetFPS: boolean, bOverride_MotionBlurPerObjectSize: boolean, bOverride_ScreenPercentage: boolean, bOverride_ScreenSpaceReflectionIntensity: boolean, bOverride_ScreenSpaceReflectionQuality: boolean, bOverride_ScreenSpaceReflectionMaxRoughness: boolean, bOverride_ScreenSpaceReflectionRoughnessScale: boolean, bOverride_ReflectionsType: boolean, bOverride_RayTracingReflectionsMaxRoughness: boolean, bOverride_RayTracingReflectionsMaxBounces: boolean, bOverride_RayTracingReflectionsSamplesPerPixel: boolean, bOverride_RayTracingReflectionsShadows: boolean, bOverride_RayTracingReflectionsTranslucency: boolean, bOverride_TranslucencyType: boolean, bOverride_RayTracingTranslucencyMaxRoughness: boolean, bOverride_RayTracingTranslucencyRefractionRays: boolean, bOverride_RayTracingTranslucencySamplesPerPixel: boolean, bOverride_RayTracingTranslucencyShadows: boolean, bOverride_RayTracingTranslucencyRefraction: boolean, bOverride_RayTracingGI: boolean, bOverride_RayTracingGIMaxBounces: boolean, bOverride_RayTracingGISamplesPerPixel: boolean, bOverride_PathTracingMaxBounces: boolean, bOverride_PathTracingSamplesPerPixel: boolean, bMobileHQGaussian: boolean, BloomMethod: EBloomMethod, AutoExposureMethod: EAutoExposureMethod, DepthOfFieldMethod: EDepthOfFieldMethod, WhiteTemp: number, WhiteTint: number, ColorSaturation: Vector4, ColorContrast: Vector4, ColorGamma: Vector4, ColorGain: Vector4, ColorOffset: Vector4, ColorSaturationShadows: Vector4, ColorContrastShadows: Vector4, ColorGammaShadows: Vector4, ColorGainShadows: Vector4, ColorOffsetShadows: Vector4, ColorSaturationMidtones: Vector4, ColorContrastMidtones: Vector4, ColorGammaMidtones: Vector4, ColorGainMidtones: Vector4, ColorOffsetMidtones: Vector4, ColorSaturationHighlights: Vector4, ColorContrastHighlights: Vector4, ColorGammaHighlights: Vector4, ColorGainHighlights: Vector4, ColorOffsetHighlights: Vector4, ColorCorrectionHighlightsMin: number, ColorCorrectionShadowsMax: number, BlueCorrection: number, ExpandGamut: number, ToneCurveAmount: number, FilmSlope: number, FilmToe: number, FilmShoulder: number, FilmBlackClip: number, FilmWhiteClip: number, FilmWhitePoint: LinearColor, FilmShadowTint: LinearColor, FilmShadowTintBlend: number, FilmShadowTintAmount: number, FilmSaturation: number, FilmChannelMixerRed: LinearColor, FilmChannelMixerGreen: LinearColor, FilmChannelMixerBlue: LinearColor, FilmContrast: number, FilmToeAmount: number, FilmHealAmount: number, FilmDynamicRange: number, SceneColorTint: LinearColor, SceneFringeIntensity: number, ChromaticAberrationStartOffset: number, BloomIntensity: number, BloomThreshold: number, BloomSizeScale: number, Bloom1Size: number, Bloom2Size: number, Bloom3Size: number, Bloom4Size: number, Bloom5Size: number, Bloom6Size: number, Bloom1Tint: LinearColor, Bloom2Tint: LinearColor, Bloom3Tint: LinearColor, Bloom4Tint: LinearColor, Bloom5Tint: LinearColor, Bloom6Tint: LinearColor, BloomConvolutionSize: number, BloomConvolutionTexture: Texture2D, BloomConvolutionCenterUV: Vector2D, BloomConvolutionPreFilter: Vector, BloomConvolutionPreFilterMin: number, BloomConvolutionPreFilterMax: number, BloomConvolutionPreFilterMult: number, BloomConvolutionBufferScale: number, BloomDirtMask: Texture, BloomDirtMaskIntensity: number, BloomDirtMaskTint: LinearColor, AmbientCubemapTint: LinearColor, AmbientCubemapIntensity: number, AmbientCubemap: TextureCube, CameraShutterSpeed: number, CameraISO: number, DepthOfFieldFstop: number, DepthOfFieldMinFstop: number, DepthOfFieldBladeCount: number, AutoExposureBias: number, AutoExposureBiasBackup: number, bOverride_AutoExposureBiasBackup: boolean, AutoExposureApplyPhysicalCameraExposure: boolean, AutoExposureBiasCurve: CurveFloat, AutoExposureMeterMask: Texture, AutoExposureLowPercent: number, AutoExposureHighPercent: number, AutoExposureMinBrightness: number, AutoExposureMaxBrightness: number, AutoExposureSpeedUp: number, AutoExposureSpeedDown: number, HistogramLogMin: number, HistogramLogMax: number, AutoExposureCalibrationConstant: number, LensFlareIntensity: number, LensFlareTint: LinearColor, LensFlareBokehSize: number, LensFlareThreshold: number, LensFlareBokehShape: Texture, LensFlareTints: FixSizeArray<LinearColor>, VignetteIntensity: number, GrainJitter: number, GrainIntensity: number, AmbientOcclusionIntensity: number, AmbientOcclusionStaticFraction: number, AmbientOcclusionRadius: number, AmbientOcclusionRadiusInWS: boolean, AmbientOcclusionFadeDistance: number, AmbientOcclusionFadeRadius: number, AmbientOcclusionDistance: number, AmbientOcclusionPower: number, AmbientOcclusionBias: number, AmbientOcclusionQuality: number, AmbientOcclusionMipBlend: number, AmbientOcclusionMipScale: number, AmbientOcclusionMipThreshold: number, AmbientOcclusionTemporalBlendWeight: number, RayTracingAO: boolean, RayTracingAOSamplesPerPixel: number, RayTracingAOIntensity: number, RayTracingAORadius: number, IndirectLightingColor: LinearColor, IndirectLightingIntensity: number, RayTracingGI: boolean, RayTracingGIType: ERayTracingGlobalIlluminationType, RayTracingGIMaxBounces: number, RayTracingGISamplesPerPixel: number, ColorGradingIntensity: number, ColorGradingLUT: Texture, DepthOfFieldSensorWidth: number, DepthOfFieldFocalDistance: number, DepthOfFieldDepthBlurAmount: number, DepthOfFieldDepthBlurRadius: number, DepthOfFieldFocalRegion: number, DepthOfFieldNearTransitionRegion: number, DepthOfFieldFarTransitionRegion: number, DepthOfFieldScale: number, DepthOfFieldNearBlurSize: number, DepthOfFieldFarBlurSize: number, DepthOfFieldOcclusion: number, DepthOfFieldSkyFocusDistance: number, DepthOfFieldVignetteSize: number, MotionBlurAmount: number, MotionBlurMax: number, MotionBlurTargetFPS: number, MotionBlurPerObjectSize: number, LPVIntensity: number, LPVVplInjectionBias: number, LPVSize: number, LPVSecondaryOcclusionIntensity: number, LPVSecondaryBounceIntensity: number, LPVGeometryVolumeBias: number, LPVEmissiveInjectionIntensity: number, LPVDirectionalOcclusionIntensity: number, LPVDirectionalOcclusionRadius: number, LPVDiffuseOcclusionExponent: number, LPVSpecularOcclusionExponent: number, LPVDiffuseOcclusionIntensity: number, LPVSpecularOcclusionIntensity: number, ReflectionsType: EReflectionsType, ScreenSpaceReflectionIntensity: number, ScreenSpaceReflectionQuality: number, ScreenSpaceReflectionMaxRoughness: number, RayTracingReflectionsMaxRoughness: number, RayTracingReflectionsMaxBounces: number, RayTracingReflectionsSamplesPerPixel: number, RayTracingReflectionsShadows: EReflectedAndRefractedRayTracedShadows, RayTracingReflectionsTranslucency: boolean, TranslucencyType: ETranslucencyType, RayTracingTranslucencyMaxRoughness: number, RayTracingTranslucencyRefractionRays: number, RayTracingTranslucencySamplesPerPixel: number, RayTracingTranslucencyShadows: EReflectedAndRefractedRayTracedShadows, RayTracingTranslucencyRefraction: boolean, PathTracingMaxBounces: number, PathTracingSamplesPerPixel: number, LPVFadeRange: number, LPVDirectionalOcclusionFadeRange: number, ScreenPercentage: number, WeightedBlendables: WeightedBlendables, Blendables: TArray<Object>);

        bOverride_WhiteTemp: boolean;
        bOverride_WhiteTint: boolean;
        bOverride_ColorSaturation: boolean;
        bOverride_ColorContrast: boolean;
        bOverride_ColorGamma: boolean;
        bOverride_ColorGain: boolean;
        bOverride_ColorOffset: boolean;
        bOverride_ColorSaturationShadows: boolean;
        bOverride_ColorContrastShadows: boolean;
        bOverride_ColorGammaShadows: boolean;
        bOverride_ColorGainShadows: boolean;
        bOverride_ColorOffsetShadows: boolean;
        bOverride_ColorSaturationMidtones: boolean;
        bOverride_ColorContrastMidtones: boolean;
        bOverride_ColorGammaMidtones: boolean;
        bOverride_ColorGainMidtones: boolean;
        bOverride_ColorOffsetMidtones: boolean;
        bOverride_ColorSaturationHighlights: boolean;
        bOverride_ColorContrastHighlights: boolean;
        bOverride_ColorGammaHighlights: boolean;
        bOverride_ColorGainHighlights: boolean;
        bOverride_ColorOffsetHighlights: boolean;
        bOverride_ColorCorrectionShadowsMax: boolean;
        bOverride_ColorCorrectionHighlightsMin: boolean;
        bOverride_BlueCorrection: boolean;
        bOverride_ExpandGamut: boolean;
        bOverride_ToneCurveAmount: boolean;
        bOverride_FilmWhitePoint: boolean;
        bOverride_FilmSaturation: boolean;
        bOverride_FilmChannelMixerRed: boolean;
        bOverride_FilmChannelMixerGreen: boolean;
        bOverride_FilmChannelMixerBlue: boolean;
        bOverride_FilmContrast: boolean;
        bOverride_FilmDynamicRange: boolean;
        bOverride_FilmHealAmount: boolean;
        bOverride_FilmToeAmount: boolean;
        bOverride_FilmShadowTint: boolean;
        bOverride_FilmShadowTintBlend: boolean;
        bOverride_FilmShadowTintAmount: boolean;
        bOverride_FilmSlope: boolean;
        bOverride_FilmToe: boolean;
        bOverride_FilmShoulder: boolean;
        bOverride_FilmBlackClip: boolean;
        bOverride_FilmWhiteClip: boolean;
        bOverride_SceneColorTint: boolean;
        bOverride_SceneFringeIntensity: boolean;
        bOverride_ChromaticAberrationStartOffset: boolean;
        bOverride_AmbientCubemapTint: boolean;
        bOverride_AmbientCubemapIntensity: boolean;
        bOverride_BloomMethod: boolean;
        bOverride_BloomIntensity: boolean;
        bOverride_BloomThreshold: boolean;
        bOverride_Bloom1Tint: boolean;
        bOverride_Bloom1Size: boolean;
        bOverride_Bloom2Size: boolean;
        bOverride_Bloom2Tint: boolean;
        bOverride_Bloom3Tint: boolean;
        bOverride_Bloom3Size: boolean;
        bOverride_Bloom4Tint: boolean;
        bOverride_Bloom4Size: boolean;
        bOverride_Bloom5Tint: boolean;
        bOverride_Bloom5Size: boolean;
        bOverride_Bloom6Tint: boolean;
        bOverride_Bloom6Size: boolean;
        bOverride_BloomSizeScale: boolean;
        bOverride_BloomConvolutionTexture: boolean;
        bOverride_BloomConvolutionSize: boolean;
        bOverride_BloomConvolutionCenterUV: boolean;
        bOverride_BloomConvolutionPreFilter: boolean;
        bOverride_BloomConvolutionPreFilterMin: boolean;
        bOverride_BloomConvolutionPreFilterMax: boolean;
        bOverride_BloomConvolutionPreFilterMult: boolean;
        bOverride_BloomConvolutionBufferScale: boolean;
        bOverride_BloomDirtMaskIntensity: boolean;
        bOverride_BloomDirtMaskTint: boolean;
        bOverride_BloomDirtMask: boolean;
        bOverride_CameraShutterSpeed: boolean;
        bOverride_CameraISO: boolean;
        bOverride_AutoExposureMethod: boolean;
        bOverride_AutoExposureLowPercent: boolean;
        bOverride_AutoExposureHighPercent: boolean;
        bOverride_AutoExposureMinBrightness: boolean;
        bOverride_AutoExposureMaxBrightness: boolean;
        bOverride_AutoExposureCalibrationConstant: boolean;
        bOverride_AutoExposureSpeedUp: boolean;
        bOverride_AutoExposureSpeedDown: boolean;
        bOverride_AutoExposureBias: boolean;
        bOverride_AutoExposureBiasCurve: boolean;
        bOverride_AutoExposureMeterMask: boolean;
        bOverride_AutoExposureApplyPhysicalCameraExposure: boolean;
        bOverride_HistogramLogMin: boolean;
        bOverride_HistogramLogMax: boolean;
        bOverride_LensFlareIntensity: boolean;
        bOverride_LensFlareTint: boolean;
        bOverride_LensFlareTints: boolean;
        bOverride_LensFlareBokehSize: boolean;
        bOverride_LensFlareBokehShape: boolean;
        bOverride_LensFlareThreshold: boolean;
        bOverride_VignetteIntensity: boolean;
        bOverride_GrainIntensity: boolean;
        bOverride_GrainJitter: boolean;
        bOverride_AmbientOcclusionIntensity: boolean;
        bOverride_AmbientOcclusionStaticFraction: boolean;
        bOverride_AmbientOcclusionRadius: boolean;
        bOverride_AmbientOcclusionFadeDistance: boolean;
        bOverride_AmbientOcclusionFadeRadius: boolean;
        bOverride_AmbientOcclusionDistance: boolean;
        bOverride_AmbientOcclusionRadiusInWS: boolean;
        bOverride_AmbientOcclusionPower: boolean;
        bOverride_AmbientOcclusionBias: boolean;
        bOverride_AmbientOcclusionQuality: boolean;
        bOverride_AmbientOcclusionMipBlend: boolean;
        bOverride_AmbientOcclusionMipScale: boolean;
        bOverride_AmbientOcclusionMipThreshold: boolean;
        bOverride_AmbientOcclusionTemporalBlendWeight: boolean;
        bOverride_RayTracingAO: boolean;
        bOverride_RayTracingAOSamplesPerPixel: boolean;
        bOverride_RayTracingAOIntensity: boolean;
        bOverride_RayTracingAORadius: boolean;
        bOverride_LPVIntensity: boolean;
        bOverride_LPVDirectionalOcclusionIntensity: boolean;
        bOverride_LPVDirectionalOcclusionRadius: boolean;
        bOverride_LPVDiffuseOcclusionExponent: boolean;
        bOverride_LPVSpecularOcclusionExponent: boolean;
        bOverride_LPVDiffuseOcclusionIntensity: boolean;
        bOverride_LPVSpecularOcclusionIntensity: boolean;
        bOverride_LPVSize: boolean;
        bOverride_LPVSecondaryOcclusionIntensity: boolean;
        bOverride_LPVSecondaryBounceIntensity: boolean;
        bOverride_LPVGeometryVolumeBias: boolean;
        bOverride_LPVVplInjectionBias: boolean;
        bOverride_LPVEmissiveInjectionIntensity: boolean;
        bOverride_LPVFadeRange: boolean;
        bOverride_LPVDirectionalOcclusionFadeRange: boolean;
        bOverride_IndirectLightingColor: boolean;
        bOverride_IndirectLightingIntensity: boolean;
        bOverride_ColorGradingIntensity: boolean;
        bOverride_ColorGradingLUT: boolean;
        bOverride_DepthOfFieldFocalDistance: boolean;
        bOverride_DepthOfFieldFstop: boolean;
        bOverride_DepthOfFieldMinFstop: boolean;
        bOverride_DepthOfFieldBladeCount: boolean;
        bOverride_DepthOfFieldSensorWidth: boolean;
        bOverride_DepthOfFieldDepthBlurRadius: boolean;
        bOverride_DepthOfFieldDepthBlurAmount: boolean;
        bOverride_DepthOfFieldFocalRegion: boolean;
        bOverride_DepthOfFieldNearTransitionRegion: boolean;
        bOverride_DepthOfFieldFarTransitionRegion: boolean;
        bOverride_DepthOfFieldScale: boolean;
        bOverride_DepthOfFieldNearBlurSize: boolean;
        bOverride_DepthOfFieldFarBlurSize: boolean;
        bOverride_MobileHQGaussian: boolean;
        bOverride_DepthOfFieldOcclusion: boolean;
        bOverride_DepthOfFieldSkyFocusDistance: boolean;
        bOverride_DepthOfFieldVignetteSize: boolean;
        bOverride_MotionBlurAmount: boolean;
        bOverride_MotionBlurMax: boolean;
        bOverride_MotionBlurTargetFPS: boolean;
        bOverride_MotionBlurPerObjectSize: boolean;
        bOverride_ScreenPercentage: boolean;
        bOverride_ScreenSpaceReflectionIntensity: boolean;
        bOverride_ScreenSpaceReflectionQuality: boolean;
        bOverride_ScreenSpaceReflectionMaxRoughness: boolean;
        bOverride_ScreenSpaceReflectionRoughnessScale: boolean;
        bOverride_ReflectionsType: boolean;
        bOverride_RayTracingReflectionsMaxRoughness: boolean;
        bOverride_RayTracingReflectionsMaxBounces: boolean;
        bOverride_RayTracingReflectionsSamplesPerPixel: boolean;
        bOverride_RayTracingReflectionsShadows: boolean;
        bOverride_RayTracingReflectionsTranslucency: boolean;
        bOverride_TranslucencyType: boolean;
        bOverride_RayTracingTranslucencyMaxRoughness: boolean;
        bOverride_RayTracingTranslucencyRefractionRays: boolean;
        bOverride_RayTracingTranslucencySamplesPerPixel: boolean;
        bOverride_RayTracingTranslucencyShadows: boolean;
        bOverride_RayTracingTranslucencyRefraction: boolean;
        bOverride_RayTracingGI: boolean;
        bOverride_RayTracingGIMaxBounces: boolean;
        bOverride_RayTracingGISamplesPerPixel: boolean;
        bOverride_PathTracingMaxBounces: boolean;
        bOverride_PathTracingSamplesPerPixel: boolean;
        bMobileHQGaussian: boolean;
        BloomMethod: EBloomMethod;
        AutoExposureMethod: EAutoExposureMethod;
        DepthOfFieldMethod: EDepthOfFieldMethod;
        WhiteTemp: number;
        WhiteTint: number;
        ColorSaturation: Vector4;
        ColorContrast: Vector4;
        ColorGamma: Vector4;
        ColorGain: Vector4;
        ColorOffset: Vector4;
        ColorSaturationShadows: Vector4;
        ColorContrastShadows: Vector4;
        ColorGammaShadows: Vector4;
        ColorGainShadows: Vector4;
        ColorOffsetShadows: Vector4;
        ColorSaturationMidtones: Vector4;
        ColorContrastMidtones: Vector4;
        ColorGammaMidtones: Vector4;
        ColorGainMidtones: Vector4;
        ColorOffsetMidtones: Vector4;
        ColorSaturationHighlights: Vector4;
        ColorContrastHighlights: Vector4;
        ColorGammaHighlights: Vector4;
        ColorGainHighlights: Vector4;
        ColorOffsetHighlights: Vector4;
        ColorCorrectionHighlightsMin: number;
        ColorCorrectionShadowsMax: number;
        BlueCorrection: number;
        ExpandGamut: number;
        ToneCurveAmount: number;
        FilmSlope: number;
        FilmToe: number;
        FilmShoulder: number;
        FilmBlackClip: number;
        FilmWhiteClip: number;
        FilmWhitePoint: LinearColor;
        FilmShadowTint: LinearColor;
        FilmShadowTintBlend: number;
        FilmShadowTintAmount: number;
        FilmSaturation: number;
        FilmChannelMixerRed: LinearColor;
        FilmChannelMixerGreen: LinearColor;
        FilmChannelMixerBlue: LinearColor;
        FilmContrast: number;
        FilmToeAmount: number;
        FilmHealAmount: number;
        FilmDynamicRange: number;
        SceneColorTint: LinearColor;
        SceneFringeIntensity: number;
        ChromaticAberrationStartOffset: number;
        BloomIntensity: number;
        BloomThreshold: number;
        BloomSizeScale: number;
        Bloom1Size: number;
        Bloom2Size: number;
        Bloom3Size: number;
        Bloom4Size: number;
        Bloom5Size: number;
        Bloom6Size: number;
        Bloom1Tint: LinearColor;
        Bloom2Tint: LinearColor;
        Bloom3Tint: LinearColor;
        Bloom4Tint: LinearColor;
        Bloom5Tint: LinearColor;
        Bloom6Tint: LinearColor;
        BloomConvolutionSize: number;
        BloomConvolutionTexture: Texture2D;
        BloomConvolutionCenterUV: Vector2D;
        BloomConvolutionPreFilter: Vector;
        BloomConvolutionPreFilterMin: number;
        BloomConvolutionPreFilterMax: number;
        BloomConvolutionPreFilterMult: number;
        BloomConvolutionBufferScale: number;
        BloomDirtMask: Texture;
        BloomDirtMaskIntensity: number;
        BloomDirtMaskTint: LinearColor;
        AmbientCubemapTint: LinearColor;
        AmbientCubemapIntensity: number;
        AmbientCubemap: TextureCube;
        CameraShutterSpeed: number;
        CameraISO: number;
        DepthOfFieldFstop: number;
        DepthOfFieldMinFstop: number;
        DepthOfFieldBladeCount: number;
        AutoExposureBias: number;
        AutoExposureBiasBackup: number;
        bOverride_AutoExposureBiasBackup: boolean;
        AutoExposureApplyPhysicalCameraExposure: boolean;
        AutoExposureBiasCurve: CurveFloat;
        AutoExposureMeterMask: Texture;
        AutoExposureLowPercent: number;
        AutoExposureHighPercent: number;
        AutoExposureMinBrightness: number;
        AutoExposureMaxBrightness: number;
        AutoExposureSpeedUp: number;
        AutoExposureSpeedDown: number;
        HistogramLogMin: number;
        HistogramLogMax: number;
        AutoExposureCalibrationConstant: number;
        LensFlareIntensity: number;
        LensFlareTint: LinearColor;
        LensFlareBokehSize: number;
        LensFlareThreshold: number;
        LensFlareBokehShape: Texture;
        LensFlareTints: FixSizeArray<LinearColor>;
        VignetteIntensity: number;
        GrainJitter: number;
        GrainIntensity: number;
        AmbientOcclusionIntensity: number;
        AmbientOcclusionStaticFraction: number;
        AmbientOcclusionRadius: number;
        AmbientOcclusionRadiusInWS: boolean;
        AmbientOcclusionFadeDistance: number;
        AmbientOcclusionFadeRadius: number;
        AmbientOcclusionDistance: number;
        AmbientOcclusionPower: number;
        AmbientOcclusionBias: number;
        AmbientOcclusionQuality: number;
        AmbientOcclusionMipBlend: number;
        AmbientOcclusionMipScale: number;
        AmbientOcclusionMipThreshold: number;
        AmbientOcclusionTemporalBlendWeight: number;
        RayTracingAO: boolean;
        RayTracingAOSamplesPerPixel: number;
        RayTracingAOIntensity: number;
        RayTracingAORadius: number;
        IndirectLightingColor: LinearColor;
        IndirectLightingIntensity: number;
        RayTracingGI: boolean;
        RayTracingGIType: ERayTracingGlobalIlluminationType;
        RayTracingGIMaxBounces: number;
        RayTracingGISamplesPerPixel: number;
        ColorGradingIntensity: number;
        ColorGradingLUT: Texture;
        DepthOfFieldSensorWidth: number;
        DepthOfFieldFocalDistance: number;
        DepthOfFieldDepthBlurAmount: number;
        DepthOfFieldDepthBlurRadius: number;
        DepthOfFieldFocalRegion: number;
        DepthOfFieldNearTransitionRegion: number;
        DepthOfFieldFarTransitionRegion: number;
        DepthOfFieldScale: number;
        DepthOfFieldNearBlurSize: number;
        DepthOfFieldFarBlurSize: number;
        DepthOfFieldOcclusion: number;
        DepthOfFieldSkyFocusDistance: number;
        DepthOfFieldVignetteSize: number;
        MotionBlurAmount: number;
        MotionBlurMax: number;
        MotionBlurTargetFPS: number;
        MotionBlurPerObjectSize: number;
        LPVIntensity: number;
        LPVVplInjectionBias: number;
        LPVSize: number;
        LPVSecondaryOcclusionIntensity: number;
        LPVSecondaryBounceIntensity: number;
        LPVGeometryVolumeBias: number;
        LPVEmissiveInjectionIntensity: number;
        LPVDirectionalOcclusionIntensity: number;
        LPVDirectionalOcclusionRadius: number;
        LPVDiffuseOcclusionExponent: number;
        LPVSpecularOcclusionExponent: number;
        LPVDiffuseOcclusionIntensity: number;
        LPVSpecularOcclusionIntensity: number;
        ReflectionsType: EReflectionsType;
        ScreenSpaceReflectionIntensity: number;
        ScreenSpaceReflectionQuality: number;
        ScreenSpaceReflectionMaxRoughness: number;
        RayTracingReflectionsMaxRoughness: number;
        RayTracingReflectionsMaxBounces: number;
        RayTracingReflectionsSamplesPerPixel: number;
        RayTracingReflectionsShadows: EReflectedAndRefractedRayTracedShadows;
        RayTracingReflectionsTranslucency: boolean;
        TranslucencyType: ETranslucencyType;
        RayTracingTranslucencyMaxRoughness: number;
        RayTracingTranslucencyRefractionRays: number;
        RayTracingTranslucencySamplesPerPixel: number;
        RayTracingTranslucencyShadows: EReflectedAndRefractedRayTracedShadows;
        RayTracingTranslucencyRefraction: boolean;
        PathTracingMaxBounces: number;
        PathTracingSamplesPerPixel: number;
        LPVFadeRange: number;
        LPVDirectionalOcclusionFadeRange: number;
        ScreenPercentage: number;
        WeightedBlendables: WeightedBlendables;
        Blendables: TArray<Object>;

        static StaticClass(): Class;
    }

    export class MinimalViewInfo {
        constructor();
        constructor(Location: Vector, Rotation: Rotator, FOV: number, DesiredFOV: number, OrthoWidth: number, OrthoNearClipPlane: number, OrthoFarClipPlane: number, AspectRatio: number, bConstrainAspectRatio: boolean, bUseFieldOfViewForLOD: boolean, ProjectionMode: ECameraProjectionMode, PostProcessBlendWeight: number, PostProcessSettings: PostProcessSettings, OffCenterProjectionOffset: Vector2D);

        Location: Vector;
        Rotation: Rotator;
        FOV: number;
        DesiredFOV: number;
        OrthoWidth: number;
        OrthoNearClipPlane: number;
        OrthoFarClipPlane: number;
        AspectRatio: number;
        bConstrainAspectRatio: boolean;
        bUseFieldOfViewForLOD: boolean;
        ProjectionMode: ECameraProjectionMode;
        PostProcessBlendWeight: number;
        PostProcessSettings: PostProcessSettings;
        OffCenterProjectionOffset: Vector2D;

        static StaticClass(): Class;
    }

    export class CameraCacheEntry {
        constructor();
        constructor(TimeStamp: number, POV: MinimalViewInfo);

        TimeStamp: number;
        POV: MinimalViewInfo;

        static StaticClass(): Class;
    }

    export class TViewTarget {
        constructor();
        constructor(Target: Actor, POV: MinimalViewInfo, PlayerState: PlayerState);

        Target: Actor;
        POV: MinimalViewInfo;
        PlayerState: PlayerState;

        static StaticClass(): Class;
    }

    export class CameraModifier extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDebug: boolean;
        bExclusive: boolean;
        Priority: number;
        CameraOwner: PlayerCameraManager;
        AlphaInTime: number;
        AlphaOutTime: number;
        Alpha: number;

        BlueprintModifyCamera(DeltaTime: number, ViewLocation: Vector, ViewRotation: Rotator, FOV: number, NewViewLocation: $Ref<Vector>, NewViewRotation: $Ref<Rotator>, NewFOV: $Ref<number>): void;

        BlueprintModifyPostProcess(DeltaTime: number, PostProcessBlendWeight: $Ref<number>, PostProcessSettings: $Ref<PostProcessSettings>): void;

        DisableModifier(bImmediate?: boolean /* = false */): void;

        EnableModifier(): void;

        GetViewTarget(): Actor;

        IsDisabled(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraModifier;

        static Load(InName: string): CameraModifier;
    }

    export enum EAttachmentRule { KeepRelative, KeepWorld, SnapToTarget, EAttachmentRule_MAX }

    export class FXSystemAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxPoolSize: number;
        PoolPrimeSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FXSystemAsset;

        static Load(InName: string): FXSystemAsset;
    }

    export class FXSystemComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetFXSystemAsset(): FXSystemAsset;

        ReleaseToPool(): void;

        SetActorParameter(ParameterName: string, Param: $Nullable<Actor>): void;

        SetAutoAttachmentParameters(Parent: $Nullable<SceneComponent>, SocketName: string, LocationRule: EAttachmentRule, RotationRule: EAttachmentRule, ScaleRule: EAttachmentRule): void;

        SetBoolParameter(ParameterName: string, Param: boolean): void;

        SetColorParameter(ParameterName: string, Param: LinearColor): void;

        SetEmitterEnable(EmitterName: string, bNewEnableState: boolean): void;

        SetFloatParameter(ParameterName: string, Param: number): void;

        SetIntParameter(ParameterName: string, Param: number): void;

        SetUseAutoManageAttachment(bAutoManage: boolean): void;

        SetVectorParameter(ParameterName: string, Param: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FXSystemComponent;

        static Load(InName: string): FXSystemComponent;
    }

    export enum EEmitterRenderMode { ERM_Normal, ERM_Point, ERM_Cross, ERM_LightsOnly, ERM_None, ERM_MAX }

    export enum EParticleSignificanceLevel { Low, Medium, High, Critical, Num, EParticleSignificanceLevel_MAX }

    export enum EDetailMode { DM_Low, DM_Medium, DM_High, DM_MAX }

    export class ParticleModule extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSpawnModule: boolean;
        bUpdateModule: boolean;
        bFinalUpdateModule: boolean;
        bUpdateForGPUEmitter: boolean;
        bCurvesAsColor: boolean;
        b3DDrawMode: boolean;
        bSupported3DDrawMode: boolean;
        bEnabled: boolean;
        bEditable: boolean;
        LODDuplicate: boolean;
        bSupportsRandomSeed: boolean;
        bRequiresLoopingNotification: boolean;
        LODValidity: number;
        ModuleEditorColor: Color;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModule;

        static Load(InName: string): ParticleModule;
    }

    export enum EParticleScreenAlignment {
        PSA_FacingCameraPosition,
        PSA_Square,
        PSA_Rectangle,
        PSA_Velocity,
        PSA_AwayFromCenter,
        PSA_TypeSpecific,
        PSA_FacingCameraDistanceBlend,
        PSA_MAX
    }

    export enum EParticleSortMode {
        PSORTMODE_None,
        PSORTMODE_ViewProjDepth,
        PSORTMODE_DistanceToView,
        PSORTMODE_Age_OldestFirst,
        PSORTMODE_Age_NewestFirst,
        PSORTMODE_MAX
    }

    export class DistributionLookupTable {
        constructor();
        constructor(TimeScale: number, TimeBias: number, Values: TArray<number>, Op: number, EntryCount: number, EntryStride: number, SubEntryStride: number, LockFlag: number);

        TimeScale: number;
        TimeBias: number;
        Values: TArray<number>;
        Op: number;
        EntryCount: number;
        EntryStride: number;
        SubEntryStride: number;
        LockFlag: number;

        static StaticClass(): Class;
    }

    export class RawDistribution {
        constructor();
        constructor(Table: DistributionLookupTable);

        Table: DistributionLookupTable;

        static StaticClass(): Class;
    }

    export class Distribution extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Distribution;

        static Load(InName: string): Distribution;
    }

    export class DistributionFloat extends Distribution {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCanBeBaked: boolean;
        bBakedDataSuccesfully: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionFloat;

        static Load(InName: string): DistributionFloat;
    }

    export class RawDistributionFloat extends RawDistribution {
        constructor();
        constructor(MinValue: number, MaxValue: number, Distribution: DistributionFloat);

        MinValue: number;
        MaxValue: number;
        Distribution: DistributionFloat;

        static StaticClass(): Class;
    }

    export class ParticleBurst {
        constructor();
        constructor(Count: number, CountLow: number, Time: number);

        Count: number;
        CountLow: number;
        Time: number;

        static StaticClass(): Class;
    }

    export enum EParticleSubUVInterpMethod {
        PSUVIM_None,
        PSUVIM_Linear,
        PSUVIM_Linear_Blend,
        PSUVIM_Random,
        PSUVIM_Random_Blend,
        PSUVIM_MAX
    }

    export enum EParticleBurstMethod { EPBM_Instant, EPBM_Interpolated, EPBM_MAX }

    export enum EOpacitySourceMode {
        OSM_Alpha,
        OSM_ColorBrightness,
        OSM_RedChannel,
        OSM_GreenChannel,
        OSM_BlueChannel,
        OSM_MAX
    }

    export enum EEmitterNormalsMode { ENM_CameraFacing, ENM_Spherical, ENM_Cylindrical, ENM_MAX }

    export enum EParticleUVFlipMode {
        None,
        FlipUV,
        FlipUOnly,
        FlipVOnly,
        RandomFlipUV,
        RandomFlipUOnly,
        RandomFlipVOnly,
        RandomFlipUVIndependent,
        EParticleUVFlipMode_MAX
    }

    export enum ESubUVBoundingVertexCount { BVC_FourVertices, BVC_EightVertices, BVC_MAX }

    export class ParticleModuleRequired extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Material: MaterialInterface;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
        EmitterOrigin: Vector;
        EmitterRotation: Rotator;
        ScreenAlignment: EParticleScreenAlignment;
        bUseLocalSpace: boolean;
        bKillOnDeactivate: boolean;
        bKillOnCompleted: boolean;
        SortMode: EParticleSortMode;
        bUseLegacyEmitterTime: boolean;
        bRemoveHMDRoll: boolean;
        bEmitterDurationUseRange: boolean;
        EmitterDuration: number;
        SpawnRate: RawDistributionFloat;
        BurstList: TArray<ParticleBurst>;
        EmitterDelay: number;
        EmitterDelayLow: number;
        bDelayFirstLoopOnly: boolean;
        InterpolationMethod: EParticleSubUVInterpMethod;
        bScaleUV: boolean;
        bEmitterDelayUseRange: boolean;
        ParticleBurstMethod: EParticleBurstMethod;
        bOverrideSystemMacroUV: boolean;
        bUseMaxDrawCount: boolean;
        OpacitySourceMode: EOpacitySourceMode;
        EmitterNormalsMode: EEmitterNormalsMode;
        bOrbitModuleAffectsVelocityAlignment: boolean;
        SubImages_Horizontal: number;
        SubImages_Vertical: number;
        RandomImageTime: number;
        RandomImageChanges: number;
        MacroUVPosition: Vector;
        MacroUVRadius: number;
        UVFlippingMode: EParticleUVFlipMode;
        BoundingMode: ESubUVBoundingVertexCount;
        bDurationRecalcEachLoop: boolean;
        NormalsSphereCenter: Vector;
        AlphaThreshold: number;
        EmitterLoops: number;
        CutoutTexture: Texture2D;
        MaxDrawCount: number;
        EmitterDurationLow: number;
        NormalsCylinderDirection: Vector;
        NamedMaterialOverrides: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRequired;

        static Load(InName: string): ParticleModuleRequired;
    }

    export class ParticleModuleTypeDataBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataBase;

        static Load(InName: string): ParticleModuleTypeDataBase;
    }

    export class ParticleModuleSpawnBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bProcessSpawnRate: boolean;
        bProcessBurstList: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawnBase;

        static Load(InName: string): ParticleModuleSpawnBase;
    }

    export class ParticleModuleSpawn extends ParticleModuleSpawnBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Rate: RawDistributionFloat;
        RateScale: RawDistributionFloat;
        ParticleBurstMethod: EParticleBurstMethod;
        BurstList: TArray<ParticleBurst>;
        BurstScale: RawDistributionFloat;
        bApplyGlobalSpawnRateScale: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawn;

        static Load(InName: string): ParticleModuleSpawn;
    }

    export class ParticleModuleEventBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventBase;

        static Load(InName: string): ParticleModuleEventBase;
    }

    export enum EParticleEventType {
        EPET_Any,
        EPET_Spawn,
        EPET_Death,
        EPET_Collision,
        EPET_Burst,
        EPET_Blueprint,
        EPET_MAX
    }

    export class ParticleModuleEventSendToGame extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventSendToGame;

        static Load(InName: string): ParticleModuleEventSendToGame;
    }

    export class ParticleEvent_GenerateInfo {
        constructor();
        constructor(Type: EParticleEventType, Frequency: number, ParticleFrequency: number, FirstTimeOnly: boolean, LastTimeOnly: boolean, UseReflectedImpactVector: boolean, bUseOrbitOffset: boolean, CustomName: string, ParticleModuleEventsToSendToGame: TArray<ParticleModuleEventSendToGame>);

        Type: EParticleEventType;
        Frequency: number;
        ParticleFrequency: number;
        FirstTimeOnly: boolean;
        LastTimeOnly: boolean;
        UseReflectedImpactVector: boolean;
        bUseOrbitOffset: boolean;
        CustomName: string;
        ParticleModuleEventsToSendToGame: TArray<ParticleModuleEventSendToGame>;

        static StaticClass(): Class;
    }

    export class ParticleModuleEventGenerator extends ParticleModuleEventBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Events: TArray<ParticleEvent_GenerateInfo>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventGenerator;

        static Load(InName: string): ParticleModuleEventGenerator;
    }

    export class ParticleModuleOrbitBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseEmitterTime: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrbitBase;

        static Load(InName: string): ParticleModuleOrbitBase;
    }

    export enum EOrbitChainMode { EOChainMode_Add, EOChainMode_Scale, EOChainMode_Link, EOChainMode_MAX }

    export class DistributionVector extends Distribution {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCanBeBaked: boolean;
        bIsDirty: boolean;
        bBakedDataSuccesfully: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionVector;

        static Load(InName: string): DistributionVector;
    }

    export class RawDistributionVector extends RawDistribution {
        constructor();
        constructor(MinValue: number, MaxValue: number, MinValueVec: Vector, MaxValueVec: Vector, Distribution: DistributionVector);

        MinValue: number;
        MaxValue: number;
        MinValueVec: Vector;
        MaxValueVec: Vector;
        Distribution: DistributionVector;

        static StaticClass(): Class;
    }

    export class OrbitOptions {
        constructor();
        constructor(bProcessDuringSpawn: boolean, bProcessDuringUpdate: boolean, bUseEmitterTime: boolean);

        bProcessDuringSpawn: boolean;
        bProcessDuringUpdate: boolean;
        bUseEmitterTime: boolean;

        static StaticClass(): Class;
    }

    export class ParticleModuleOrbit extends ParticleModuleOrbitBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChainMode: EOrbitChainMode;
        OffsetAmount: RawDistributionVector;
        OffsetOptions: OrbitOptions;
        RotationAmount: RawDistributionVector;
        RotationOptions: OrbitOptions;
        RotationRateAmount: RawDistributionVector;
        RotationRateOptions: OrbitOptions;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrbit;

        static Load(InName: string): ParticleModuleOrbit;
    }

    export class ParticleModuleEventReceiverBase extends ParticleModuleEventBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventGeneratorType: EParticleEventType;
        EventName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverBase;

        static Load(InName: string): ParticleModuleEventReceiverBase;
    }

    export class ParticleLODLevel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Level: number;
        bEnabled: boolean;
        RequiredModule: ParticleModuleRequired;
        Modules: TArray<ParticleModule>;
        TypeDataModule: ParticleModuleTypeDataBase;
        SpawnModule: ParticleModuleSpawn;
        EventGenerator: ParticleModuleEventGenerator;
        SpawningModules: TArray<ParticleModuleSpawnBase>;
        SpawnModules: TArray<ParticleModule>;
        UpdateModules: TArray<ParticleModule>;
        OrbitModules: TArray<ParticleModuleOrbit>;
        EventReceiverModules: TArray<ParticleModuleEventReceiverBase>;
        ConvertedModules: boolean;
        PeakActiveParticles: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleLODLevel;

        static Load(InName: string): ParticleLODLevel;
    }

    export class ParticleEmitter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterName: string;
        SubUVDataOffset: number;
        EmitterRenderMode: EEmitterRenderMode;
        SignificanceLevel: EParticleSignificanceLevel;
        bUseLegacySpawningBehavior: boolean;
        ConvertedModules: boolean;
        bIsSoloing: boolean;
        bCookedOut: boolean;
        bDisabledLODsKeepEmitterAlive: boolean;
        bDisableWhenInsignficant: boolean;
        bCollapsed: boolean;
        DetailMode: EDetailMode;
        EmitterEditorColor: Color;
        LODLevels: TArray<ParticleLODLevel>;
        PeakActiveParticles: number;
        InitialAllocationCount: number;
        QualityLevelSpawnRateScale: number;
        DetailModeBitmask: number;
        DetailModeDisplay: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleEmitter;

        static Load(InName: string): ParticleEmitter;
    }

    export class CurveEdEntry {
        constructor();
        constructor(CurveObject: Object, CurveColor: Color, CurveName: string, bHideCurve: number, bColorCurve: number, bFloatingPointColorCurve: number, bClamp: number, ClampLow: number, ClampHigh: number);

        CurveObject: Object;
        CurveColor: Color;
        CurveName: string;
        bHideCurve: number;
        bColorCurve: number;
        bFloatingPointColorCurve: number;
        bClamp: number;
        ClampLow: number;
        ClampHigh: number;

        static StaticClass(): Class;
    }

    export class CurveEdTab {
        constructor();
        constructor(TabName: string, Curves: TArray<CurveEdEntry>, ViewStartInput: number, ViewEndInput: number, ViewStartOutput: number, ViewEndOutput: number);

        TabName: string;
        Curves: TArray<CurveEdEntry>;
        ViewStartInput: number;
        ViewEndInput: number;
        ViewStartOutput: number;
        ViewEndOutput: number;

        static StaticClass(): Class;
    }

    export class InterpCurveEdSetup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Tabs: TArray<CurveEdTab>;
        ActiveTab: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpCurveEdSetup;

        static Load(InName: string): InterpCurveEdSetup;
    }

    export class ParticleSystemLOD {
        constructor();

        static StaticClass(): Class;
    }

    export enum EParticleSystemUpdateMode { EPSUM_RealTime, EPSUM_FixedTime, EPSUM_MAX }

    export enum ParticleSystemLODMethod {
        PARTICLESYSTEMLODMETHOD_Automatic,
        PARTICLESYSTEMLODMETHOD_DirectSet,
        PARTICLESYSTEMLODMETHOD_ActivateAutomatic,
        PARTICLESYSTEMLODMETHOD_MAX
    }

    export enum EParticleSystemInsignificanceReaction {
        Auto,
        Complete,
        DisableTick,
        DisableTickAndKill,
        Num,
        EParticleSystemInsignificanceReaction_MAX
    }

    export enum EParticleSystemOcclusionBoundsMethod {
        EPSOBM_None,
        EPSOBM_ParticleBounds,
        EPSOBM_CustomBounds,
        EPSOBM_MAX
    }

    export class LODSoloTrack {
        constructor();
        constructor(SoloEnableSetting: TArray<number>);

        SoloEnableSetting: TArray<number>;

        static StaticClass(): Class;
    }

    export class NamedEmitterMaterial {
        constructor();
        constructor(Name: string, Material: MaterialInterface);

        Name: string;
        Material: MaterialInterface;

        static StaticClass(): Class;
    }

    export class ParticleSystem extends FXSystemAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UpdateTime_FPS: number;
        UpdateTime_Delta: number;
        WarmupTime: number;
        WarmupTickRate: number;
        Emitters: TArray<ParticleEmitter>;
        PreviewComponent: ParticleSystemComponent;
        ThumbnailAngle: Rotator;
        ThumbnailDistance: number;
        ThumbnailWarmup: number;
        CurveEdSetup: InterpCurveEdSetup;
        LODDistanceCheckTime: number;
        MacroUVRadius: number;
        LODDistances: TArray<number>;
        EditorLODSetting: number;
        LODSettings: TArray<ParticleSystemLOD>;
        FixedRelativeBoundingBox: Box;
        SecondsBeforeInactive: number;
        FloorMesh: string;
        FloorPosition: Vector;
        FloorRotation: Rotator;
        FloorScale: number;
        FloorScale3D: Vector;
        BackgroundColor: Color;
        Delay: number;
        DelayLow: number;
        bOrientZAxisTowardCamera: boolean;
        bUseFixedRelativeBoundingBox: boolean;
        bShouldResetPeakCounts: boolean;
        bHasPhysics: boolean;
        bUseRealtimeThumbnail: boolean;
        ThumbnailImageOutOfDate: boolean;
        ThumbnailImage: Texture2D;
        bUseDelayRange: boolean;
        bAllowManagedTicking: boolean;
        bAutoDeactivate: boolean;
        bRegenerateLODDuplicate: boolean;
        SystemUpdateMode: EParticleSystemUpdateMode;
        LODMethod: ParticleSystemLODMethod;
        InsignificantReaction: EParticleSystemInsignificanceReaction;
        OcclusionBoundsMethod: EParticleSystemOcclusionBoundsMethod;
        MaxSignificanceLevel: EParticleSignificanceLevel;
        MinTimeBetweenTicks: number;
        InsignificanceDelay: number;
        MacroUVPosition: Vector;
        CustomOcclusionBounds: Box;
        SoloTracking: TArray<LODSoloTrack>;
        NamedMaterialSlots: TArray<NamedEmitterMaterial>;

        ContainsEmitterType(TypeData: $Nullable<Class>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleSystem;

        static Load(InName: string): ParticleSystem;
    }

    export enum EParticleSysParamType {
        PSPT_None,
        PSPT_Scalar,
        PSPT_ScalarRand,
        PSPT_Vector,
        PSPT_VectorRand,
        PSPT_Color,
        PSPT_Actor,
        PSPT_Material,
        PSPT_VectorUnitRand,
        PSPT_MAX
    }

    export class ParticleSysParam {
        constructor();
        constructor(Name: string, ParamType: EParticleSysParamType, Scalar: number, Scalar_Low: number, Vector: Vector, Vector_Low: Vector, Color: Color, Actor: Actor, Material: MaterialInterface);

        Name: string;
        ParamType: EParticleSysParamType;
        Scalar: number;
        Scalar_Low: number;
        Vector: Vector;
        Vector_Low: Vector;
        Color: Color;
        Actor: Actor;
        Material: MaterialInterface;

        static StaticClass(): Class;
    }

    export class ParticleSystemReplay extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ClipIDNumber: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleSystemReplay;

        static Load(InName: string): ParticleSystemReplay;
    }

    export enum EAttachLocation {
        KeepRelativeOffset,
        KeepWorldPosition,
        SnapToTarget,
        SnapToTargetIncludingScale,
        EAttachLocation_MAX
    }

    export enum ETrailWidthMode {
        ETrailWidthMode_FromCentre,
        ETrailWidthMode_FromFirst,
        ETrailWidthMode_FromSecond,
        ETrailWidthMode_MAX
    }

    export class ParticleSystemComponent extends FXSystemComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Template: ParticleSystem;
        EmitterMaterials: TArray<MaterialInterface>;
        SkelMeshComponents: TArray<SkeletalMeshComponent>;
        bResetOnDetach: boolean;
        bUpdateOnDedicatedServer: boolean;
        bAllowRecycling: boolean;
        bAutoManageAttachment: boolean;
        bAutoAttachWeldSimulatedBodies: boolean;
        bWarmingUp: boolean;
        bOverrideLODMethod: boolean;
        bSkipUpdateDynamicDataDuringTick: boolean;
        LODMethod: ParticleSystemLODMethod;
        RequiredSignificance: EParticleSignificanceLevel;
        InstanceParameters: TArray<ParticleSysParam>;
        OnParticleSpawn: $MulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
        OnParticleBurst: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
        OnParticleDeath: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
        OnParticleCollide: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: $Nullable<PhysicalMaterial>) => void>;
        bOldPositionValid: boolean;
        OldPosition: Vector;
        PartSysVelocity: Vector;
        WarmupTime: number;
        WarmupTickRate: number;
        SecondsBeforeInactive: number;
        MaxTimeBeforeForceUpdateTransform: number;
        EditorLODLevel: number;
        EditorDetailMode: number;
        ReplayClips: TArray<ParticleSystemReplay>;
        CustomTimeDilation: number;
        AutoAttachParent: TWeakObjectPtr<SceneComponent>;
        AutoAttachSocketName: string;
        AutoAttachLocationType: EAttachLocation;
        AutoAttachLocationRule: EAttachmentRule;
        AutoAttachRotationRule: EAttachmentRule;
        AutoAttachScaleRule: EAttachmentRule;
        OnSystemFinished: $MulticastDelegate<(PSystem: $Nullable<ParticleSystemComponent>) => void>;

        BeginTrails(InFirstSocketName: string, InSecondSocketName: string, InWidthMode: ETrailWidthMode, InWidth: number): void;

        CreateNamedDynamicMaterialInstance(InName: string, SourceMaterial?: MaterialInterface /* = None */): MaterialInstanceDynamic;

        EndTrails(): void;

        GenerateParticleEvent(InEventName: string, InEmitterTime: number, InLocation: Vector, InDirection: Vector, InVelocity: Vector): void;

        GetBeamEndPoint(EmitterIndex: number, OutEndPoint: $Ref<Vector>): boolean;

        GetBeamSourcePoint(EmitterIndex: number, SourceIndex: number, OutSourcePoint: $Ref<Vector>): boolean;

        GetBeamSourceStrength(EmitterIndex: number, SourceIndex: number, OutSourceStrength: $Ref<number>): boolean;

        GetBeamSourceTangent(EmitterIndex: number, SourceIndex: number, OutTangentPoint: $Ref<Vector>): boolean;

        GetBeamTargetPoint(EmitterIndex: number, TargetIndex: number, OutTargetPoint: $Ref<Vector>): boolean;

        GetBeamTargetStrength(EmitterIndex: number, TargetIndex: number, OutTargetStrength: $Ref<number>): boolean;

        GetBeamTargetTangent(EmitterIndex: number, TargetIndex: number, OutTangentPoint: $Ref<Vector>): boolean;

        GetNamedMaterial(InName: string): MaterialInterface;

        GetNumActiveParticles(): number;

        SetAutoAttachParams(Parent: $Nullable<SceneComponent>, SocketName?: string /* = "None" */, LocationType?: EAttachLocation /* = KeepRelativeOffset */): void;

        SetBeamEndPoint(EmitterIndex: number, NewEndPoint: Vector): void;

        SetBeamSourcePoint(EmitterIndex: number, NewSourcePoint: Vector, SourceIndex: number): void;

        SetBeamSourceStrength(EmitterIndex: number, NewSourceStrength: number, SourceIndex: number): void;

        SetBeamSourceTangent(EmitterIndex: number, NewTangentPoint: Vector, SourceIndex: number): void;

        SetBeamTargetPoint(EmitterIndex: number, NewTargetPoint: Vector, TargetIndex: number): void;

        SetBeamTargetStrength(EmitterIndex: number, NewTargetStrength: number, TargetIndex: number): void;

        SetBeamTargetTangent(EmitterIndex: number, NewTangentPoint: Vector, TargetIndex: number): void;

        SetMaterialParameter(ParameterName: string, Param: $Nullable<MaterialInterface>): void;

        SetTemplate(NewTemplate: $Nullable<ParticleSystem>): void;

        SetTrailSourceData(InFirstSocketName: string, InSecondSocketName: string, InWidthMode: ETrailWidthMode, InWidth: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleSystemComponent;

        static Load(InName: string): ParticleSystemComponent;
    }

    export class Emitter extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParticleSystemComponent: ParticleSystemComponent;
        bDestroyOnSystemFinish: boolean;
        bPostUpdateTickGroup: boolean;
        bCurrentlyActive: boolean;
        OnParticleSpawn: $MulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
        OnParticleBurst: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
        OnParticleDeath: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
        OnParticleCollide: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: $Nullable<PhysicalMaterial>) => void>;
        SpriteComponent: BillboardComponent;
        ArrowComponent: ArrowComponent;

        Activate(): void;

        Deactivate(): void;

        IsActive(): boolean;

        OnParticleSystemFinished(FinishedComponent: $Nullable<ParticleSystemComponent>): void;

        OnRep_bCurrentlyActive(): void;

        SetActorParameter(ParameterName: string, Param: $Nullable<Actor>): void;

        SetColorParameter(ParameterName: string, Param: LinearColor): void;

        SetFloatParameter(ParameterName: string, Param: number): void;

        SetMaterialParameter(ParameterName: string, Param: $Nullable<MaterialInterface>): void;

        SetTemplate(NewTemplate: $Nullable<ParticleSystem>): void;

        SetVectorParameter(ParameterName: string, Param: Vector): void;

        ToggleActive(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Emitter;

        static Load(InName: string): Emitter;
    }

    export class EmitterCameraLensEffectBase extends Emitter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PS_CameraEffect: ParticleSystem;
        PS_CameraEffectNonExtremeContent: ParticleSystem;
        BaseCamera: PlayerCameraManager;
        RelativeTransform: Transform;
        BaseFOV: number;
        bAllowMultipleInstances: boolean;
        bResetWhenRetriggered: boolean;
        EmittersToTreatAsSame: TArray<Class>;
        DistFromCamera: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EmitterCameraLensEffectBase;

        static Load(InName: string): EmitterCameraLensEffectBase;
    }

    export class CameraShakeBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSingleInstance: boolean;
        ShakeScale: number;
        CameraManager: PlayerCameraManager;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraShakeBase;

        static Load(InName: string): CameraShakeBase;
    }

    export enum ECameraShakeAttenuation { Linear, Quadratic, ECameraShakeAttenuation_MAX }

    export enum ECameraShakePlaySpace { CameraLocal, World, UserDefined, ECameraShakePlaySpace_MAX }

    export class CameraShakeSourceComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Attenuation: ECameraShakeAttenuation;
        InnerAttenuationRadius: number;
        OuterAttenuationRadius: number;
        CameraShake: Class;
        bAutoStart: boolean;
        EditorSpriteTexture: Texture2D;
        EditorSpriteTextureScale: number;

        GetAttenuationFactor(Location: Vector): number;

        Start(): void;

        StartCameraShake(InCameraShake: $Nullable<Class>, Scale?: number /* = 1.000000 */, PlaySpace?: ECameraShakePlaySpace /* = CameraLocal */, UserPlaySpaceRot?: Rotator /* =  */): void;

        StopAllCameraShakes(bImmediately?: boolean /* = true */): void;

        StopAllCameraShakesOfType(InCameraShake: $Nullable<Class>, bImmediately?: boolean /* = true */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraShakeSourceComponent;

        static Load(InName: string): CameraShakeSourceComponent;
    }

    export class ActiveCameraShakeInfo {
        constructor();
        constructor(ShakeInstance: CameraShakeBase, ShakeSource: TWeakObjectPtr<CameraShakeSourceComponent>);

        ShakeInstance: CameraShakeBase;
        ShakeSource: TWeakObjectPtr<CameraShakeSourceComponent>;

        static StaticClass(): Class;
    }

    export class PooledCameraShakes {
        constructor();
        constructor(PooledShakes: TArray<CameraShakeBase>);

        PooledShakes: TArray<CameraShakeBase>;

        static StaticClass(): Class;
    }

    export class CameraModifier_CameraShake extends CameraModifier {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActiveShakes: TArray<ActiveCameraShakeInfo>;
        ExpiredPooledShakesMap: TMap<Class, PooledCameraShakes>;
        SplitScreenShakeScale: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraModifier_CameraShake;

        static Load(InName: string): CameraModifier_CameraShake;
    }

    export class SubTrackGroup {
        constructor();
        constructor(GroupName: string, TrackIndices: TArray<number>, bIsCollapsed: boolean, bIsSelected: boolean);

        GroupName: string;
        TrackIndices: TArray<number>;
        bIsCollapsed: boolean;
        bIsSelected: boolean;

        static StaticClass(): Class;
    }

    export class SupportedSubTrackInfo {
        constructor();
        constructor(SupportedClass: Class, SubTrackName: string, GroupIndex: number);

        SupportedClass: Class;
        SubTrackName: string;
        GroupIndex: number;

        static StaticClass(): Class;
    }

    export enum ETrackActiveCondition { ETAC_Always, ETAC_GoreEnabled, ETAC_GoreDisabled, ETAC_MAX }

    export class InterpTrack extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SubTracks: TArray<InterpTrack>;
        SubTrackGroups: TArray<SubTrackGroup>;
        SupportedSubTracks: TArray<SupportedSubTrackInfo>;
        TrackInstClass: Class;
        ActiveCondition: ETrackActiveCondition;
        TrackTitle: string;
        bOnePerGroup: boolean;
        bDirGroupOnly: boolean;
        bDisableTrack: boolean;
        bIsSelected: boolean;
        TrackIcon: Texture2D;
        bIsAnimControlTrack: boolean;
        bSubTrackOnly: boolean;
        bVisible: boolean;
        bIsRecording: boolean;
        bIsCollapsed: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrack;

        static Load(InName: string): InterpTrack;
    }

    export class InterpGroup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InterpTracks: TArray<InterpTrack>;
        GroupName: string;
        GroupColor: Color;
        bCollapsed: boolean;
        bVisible: boolean;
        bIsFolder: boolean;
        bIsParented: boolean;
        bIsSelected: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpGroup;

        static Load(InName: string): InterpGroup;
    }

    export class CameraAnim extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraInterpGroup: InterpGroup;
        PreviewInterpGroup: InterpGroup;
        AnimLength: number;
        BoundingBox: Box;
        bRelativeToInitialTransform: boolean;
        bRelativeToInitialFOV: boolean;
        BaseFOV: number;
        BasePostProcessSettings: PostProcessSettings;
        BasePostProcessBlendWeight: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraAnim;

        static Load(InName: string): CameraAnim;
    }

    export class InterpGroupInst extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Group: InterpGroup;
        GroupActor: Actor;
        TrackInst: TArray<InterpTrackInst>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpGroupInst;

        static Load(InName: string): InterpGroupInst;
    }

    export enum EInterpCurveMode {
        CIM_Linear,
        CIM_CurveAuto,
        CIM_Constant,
        CIM_CurveUser,
        CIM_CurveBreak,
        CIM_CurveAutoClamped,
        CIM_MAX
    }

    export class InterpCurvePointVector {
        constructor();
        constructor(InVal: number, OutVal: Vector, ArriveTangent: Vector, LeaveTangent: Vector, InterpMode: EInterpCurveMode);

        InVal: number;
        OutVal: Vector;
        ArriveTangent: Vector;
        LeaveTangent: Vector;
        InterpMode: EInterpCurveMode;

        static StaticClass(): Class;
    }

    export class InterpCurveVector {
        constructor();
        constructor(Points: TArray<InterpCurvePointVector>, bIsLooped: boolean, LoopKeyOffset: number);

        Points: TArray<InterpCurvePointVector>;
        bIsLooped: boolean;
        LoopKeyOffset: number;

        static StaticClass(): Class;
    }

    export class InterpLookupPoint {
        constructor();
        constructor(GroupName: string, Time: number);

        GroupName: string;
        Time: number;

        static StaticClass(): Class;
    }

    export class InterpLookupTrack {
        constructor();
        constructor(Points: TArray<InterpLookupPoint>);

        Points: TArray<InterpLookupPoint>;

        static StaticClass(): Class;
    }

    export enum EInterpTrackMoveRotMode { IMR_Keyframed, IMR_LookAtGroup, IMR_Ignore, IMR_MAX }

    export class InterpTrackMove extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PosTrack: InterpCurveVector;
        EulerTrack: InterpCurveVector;
        LookupTrack: InterpLookupTrack;
        LookAtGroupName: string;
        LinCurveTension: number;
        AngCurveTension: number;
        bUseQuatInterpolation: boolean;
        bShowArrowAtKeys: boolean;
        bDisableMovement: boolean;
        bShowTranslationOnCurveEd: boolean;
        bShowRotationOnCurveEd: boolean;
        bHide3DTrack: boolean;
        RotMode: EInterpTrackMoveRotMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackMove;

        static Load(InName: string): InterpTrackMove;
    }

    export class InterpTrackInstMove extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ResetLocation: Vector;
        ResetRotation: Rotator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstMove;

        static Load(InName: string): InterpTrackInstMove;
    }

    export class CameraAnimInst extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CamAnim: CameraAnim;
        InterpGroupInst: InterpGroupInst;
        PlayRate: number;
        MoveTrack: InterpTrackMove;
        MoveInst: InterpTrackInstMove;
        PlaySpace: ECameraShakePlaySpace;

        SetDuration(NewDuration: number): void;

        SetScale(NewDuration: number): void;

        Stop(bImmediate?: boolean /* = false */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraAnimInst;

        static Load(InName: string): CameraAnimInst;
    }

    export class Interface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Interface;

        static Load(InName: string): Interface;
    }

    export class BlendableInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlendableInterface;

        static Load(InName: string): BlendableInterface;
    }

    export class CameraComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FieldOfView: number;
        OrthoWidth: number;
        OrthoNearClipPlane: number;
        OrthoFarClipPlane: number;
        AspectRatio: number;
        bConstrainAspectRatio: boolean;
        bUseFieldOfViewForLOD: boolean;
        bCameraMeshHiddenInGame: boolean;
        bLockToHmd: boolean;
        bUsePawnControlRotation: boolean;
        ProjectionMode: ECameraProjectionMode;
        CameraMesh: StaticMesh;
        PostProcessBlendWeight: number;
        PostProcessSettings: PostProcessSettings;
        bUseControllerViewRotation: boolean;

        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight?: number /* = 1.000000 */): void;

        GetCameraView(DeltaTime: number, DesiredView: $Ref<MinimalViewInfo>): void;

        GetFilmbackText(): string;

        OnCameraMeshHiddenChanged(): void;

        RemoveBlendable(InBlendableObject: BlendableInterface): void;

        SetAspectRatio(InAspectRatio: number): void;

        SetConstraintAspectRatio(bInConstrainAspectRatio: boolean): void;

        SetFieldOfView(InFieldOfView: number): void;

        SetOrthoFarClipPlane(InOrthoFarClipPlane: number): void;

        SetOrthoNearClipPlane(InOrthoNearClipPlane: number): void;

        SetOrthoWidth(InOrthoWidth: number): void;

        SetPostProcessBlendWeight(InPostProcessBlendWeight: number): void;

        SetProjectionMode(InProjectionMode: ECameraProjectionMode): void;

        SetUseFieldOfViewForLOD(bInUseFieldOfViewForLOD: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraComponent;

        static Load(InName: string): CameraComponent;
    }

    export class CameraActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AutoActivateForPlayer: EAutoReceiveInput;
        CameraComponent: CameraComponent;
        SceneComponent: SceneComponent;
        bConstrainAspectRatio: boolean;
        AspectRatio: number;
        FOVAngle: number;
        PostProcessBlendWeight: number;
        PostProcessSettings: PostProcessSettings;

        GetAutoActivatePlayerIndex(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraActor;

        static Load(InName: string): CameraActor;
    }

    export enum EInitialOscillatorOffset { EOO_OffsetRandom, EOO_OffsetZero, EOO_MAX }

    export enum EOscillatorWaveform { SineWave, PerlinNoise, EOscillatorWaveform_MAX }

    export class FOscillator {
        constructor();
        constructor(Amplitude: number, Frequency: number, InitialOffset: EInitialOscillatorOffset, Waveform: EOscillatorWaveform);

        Amplitude: number;
        Frequency: number;
        InitialOffset: EInitialOscillatorOffset;
        Waveform: EOscillatorWaveform;

        static StaticClass(): Class;
    }

    export class ROscillator {
        constructor();
        constructor(Pitch: FOscillator, Yaw: FOscillator, Roll: FOscillator);

        Pitch: FOscillator;
        Yaw: FOscillator;
        Roll: FOscillator;

        static StaticClass(): Class;
    }

    export class VOscillator {
        constructor();
        constructor(X: FOscillator, Y: FOscillator, Z: FOscillator);

        X: FOscillator;
        Y: FOscillator;
        Z: FOscillator;

        static StaticClass(): Class;
    }

    export class MatineeCameraShake extends CameraShakeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OscillationDuration: number;
        OscillationBlendInTime: number;
        OscillationBlendOutTime: number;
        RotOscillation: ROscillator;
        LocOscillation: VOscillator;
        FOVOscillation: FOscillator;
        AnimPlayRate: number;
        AnimScale: number;
        AnimBlendInTime: number;
        AnimBlendOutTime: number;
        RandomAnimSegmentDuration: number;
        Anim: CameraAnim;
        bRandomAnimSegment: boolean;
        OscillatorTimeRemaining: number;
        AnimInst: CameraAnimInst;

        BlueprintUpdateCameraShake(DeltaTime: number, Alpha: number, POV: MinimalViewInfo, ModifiedPOV: $Ref<MinimalViewInfo>): void;

        ReceiveIsFinished(): boolean;

        ReceivePlayShake(Scale: number): void;

        ReceiveStopShake(bImmediately: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MatineeCameraShake;

        static Load(InName: string): MatineeCameraShake;
    }

    export class PlayerCameraManager extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PCOwner: PlayerController;
        TransformComponent: SceneComponent;
        DefaultFOV: number;
        DefaultOrthoWidth: number;
        DefaultAspectRatio: number;
        CameraCache: CameraCacheEntry;
        LastFrameCameraCache: CameraCacheEntry;
        ViewTarget: TViewTarget;
        PendingViewTarget: TViewTarget;
        CameraCachePrivate: CameraCacheEntry;
        LastFrameCameraCachePrivate: CameraCacheEntry;
        ModifierList: TArray<CameraModifier>;
        DefaultModifiers: TArray<Class>;
        FreeCamDistance: number;
        FreeCamOffset: Vector;
        ViewTargetOffset: Vector;
        OnAudioFadeChangeEvent: $MulticastDelegate<(bFadeOut: boolean, FadeTime: number) => void>;
        CameraLensEffects: TArray<EmitterCameraLensEffectBase>;
        CachedCameraShakeMod: CameraModifier_CameraShake;
        AnimInstPool: FixSizeArray<CameraAnimInst>;
        PostProcessBlendCache: TArray<PostProcessSettings>;
        ActiveAnims: TArray<CameraAnimInst>;
        FreeAnims: TArray<CameraAnimInst>;
        AnimCameraActor: CameraActor;
        bIsOrthographic: boolean;
        bDefaultConstrainAspectRatio: boolean;
        bClientSimulatingViewTarget: boolean;
        bUseClientSideCameraUpdates: boolean;
        bGameCameraCutThisFrame: boolean;
        ViewPitchMin: number;
        ViewPitchMax: number;
        ViewYawMin: number;
        ViewYawMax: number;
        ViewRollMin: number;
        ViewRollMax: number;
        ServerUpdateCameraTimeout: number;

        AddCameraLensEffect(LensEffectEmitterClass: $Nullable<Class>): EmitterCameraLensEffectBase;

        AddNewCameraModifier(ModifierClass: $Nullable<Class>): CameraModifier;

        BlueprintUpdateCamera(CameraTarget: $Nullable<Actor>, NewCameraLocation: $Ref<Vector>, NewCameraRotation: $Ref<Rotator>, NewCameraFOV: $Ref<number>): boolean;

        ClearCameraLensEffects(): void;

        FindCameraModifierByClass(ModifierClass: $Nullable<Class>): CameraModifier;

        GetCameraLocation(): Vector;

        GetCameraRotation(): Rotator;

        GetFOVAngle(): number;

        GetOwningPlayerController(): PlayerController;

        OnPhotographyMultiPartCaptureEnd(): void;

        OnPhotographyMultiPartCaptureStart(): void;

        OnPhotographySessionEnd(): void;

        OnPhotographySessionStart(): void;

        PhotographyCameraModify(NewCameraLocation: Vector, PreviousCameraLocation: Vector, OriginalCameraLocation: Vector, ResultCameraLocation: $Ref<Vector>): void;

        PlayCameraAnim(Anim: $Nullable<CameraAnim>, Rate?: number /* = 1.000000 */, Scale?: number /* = 1.000000 */, BlendInTime?: number /* = 0.000000 */, BlendOutTime?: number /* = 0.000000 */, bLoop?: boolean /* = false */, bRandomStartTime?: boolean /* = false */, Duration?: number /* = 0.000000 */, PlaySpace?: ECameraShakePlaySpace /* = CameraLocal */, UserPlaySpaceRot?: Rotator /* =  */): CameraAnimInst;

        RemoveCameraLensEffect(Emitter: $Nullable<EmitterCameraLensEffectBase>): void;

        RemoveCameraModifier(ModifierToRemove: $Nullable<CameraModifier>): boolean;

        SetGameCameraCutThisFrame(): void;

        SetManualCameraFade(InFadeAmount: number, Color: LinearColor, bInFadeAudio: boolean): void;

        StartCameraFade(FromAlpha: number, ToAlpha: number, Duration: number, Color: LinearColor, bShouldFadeAudio?: boolean /* = false */, bHoldWhenFinished?: boolean /* = false */): void;

        StartCameraShake(ShakeClass: $Nullable<Class>, Scale?: number /* = 1.000000 */, PlaySpace?: ECameraShakePlaySpace /* = CameraLocal */, UserPlaySpaceRot?: Rotator /* =  */): CameraShakeBase;

        StartCameraShakeFromSource(ShakeClass: $Nullable<Class>, SourceComponent: $Nullable<CameraShakeSourceComponent>, Scale?: number /* = 1.000000 */, PlaySpace?: ECameraShakePlaySpace /* = CameraLocal */, UserPlaySpaceRot?: Rotator /* =  */): CameraShakeBase;

        StartMatineeCameraShake(ShakeClass: $Nullable<Class>, Scale?: number /* = 1.000000 */, PlaySpace?: ECameraShakePlaySpace /* = CameraLocal */, UserPlaySpaceRot?: Rotator /* =  */): MatineeCameraShake;

        StartMatineeCameraShakeFromSource(ShakeClass: $Nullable<Class>, SourceComponent: $Nullable<CameraShakeSourceComponent>, Scale?: number /* = 1.000000 */, PlaySpace?: ECameraShakePlaySpace /* = CameraLocal */, UserPlaySpaceRot?: Rotator /* =  */): MatineeCameraShake;

        StopAllCameraAnims(bImmediate?: boolean /* = false */): void;

        StopAllCameraShakes(bImmediately?: boolean /* = true */): void;

        StopAllCameraShakesFromSource(SourceComponent: $Nullable<CameraShakeSourceComponent>, bImmediately?: boolean /* = true */): void;

        StopAllInstancesOfCameraAnim(Anim: $Nullable<CameraAnim>, bImmediate?: boolean /* = false */): void;

        StopAllInstancesOfCameraShake(Shake: $Nullable<Class>, bImmediately?: boolean /* = true */): void;

        StopAllInstancesOfCameraShakeFromSource(Shake: $Nullable<Class>, SourceComponent: $Nullable<CameraShakeSourceComponent>, bImmediately?: boolean /* = true */): void;

        StopCameraAnimInst(AnimInst: $Nullable<CameraAnimInst>, bImmediate?: boolean /* = false */): void;

        StopCameraFade(): void;

        StopCameraShake(ShakeInstance: $Nullable<CameraShakeBase>, bImmediately?: boolean /* = true */): void;

        SwapPendingViewTargetWhenUsingClientSideCameraUpdates(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlayerCameraManager;

        static Load(InName: string): PlayerCameraManager;
    }

    export class DrawFrustumComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FrustumColor: Color;
        FrustumAngle: number;
        FrustumAspectRatio: number;
        FrustumStartDist: number;
        FrustumEndDist: number;
        Texture: Texture;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DrawFrustumComponent;

        static Load(InName: string): DrawFrustumComponent;
    }

    export class DebugCameraController extends PlayerController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bShowSelectedInfo: boolean;
        bIsFrozenRendering: boolean;
        bIsOrbitingSelectedActor: boolean;
        bOrbitPivotUseCenter: boolean;
        bEnableBufferVisualization: boolean;
        bEnableBufferVisualizationFullMode: boolean;
        bIsBufferVisualizationInputSetup: boolean;
        bLastDisplayEnabled: boolean;
        DrawFrustum: DrawFrustumComponent;
        SelectedActor: Actor;
        SelectedComponent: PrimitiveComponent;
        SelectedHitPoint: HitResult;
        OriginalControllerRef: PlayerController;
        OriginalPlayer: Player;
        SpeedScale: number;
        InitialMaxSpeed: number;
        InitialAccel: number;
        InitialDecel: number;

        GetSelectedActor(): Actor;

        ReceiveOnActivate(OriginalPC: $Nullable<PlayerController>): void;

        ReceiveOnActorSelected(NewSelectedActor: $Nullable<Actor>, SelectHitLocation: Vector, SelectHitNormal: Vector, Hit: HitResult): void;

        ReceiveOnDeactivate(RestoredPC: $Nullable<PlayerController>): void;

        SetPawnMovementSpeedScale(NewSpeedScale: number): void;

        ShowDebugSelectedInfo(): void;

        ToggleDisplay(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DebugCameraController;

        static Load(InName: string): DebugCameraController;
    }

    export class CheatManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DebugCameraControllerRef: DebugCameraController;
        DebugCameraControllerClass: Class;

        BugIt(ScreenShotDescription?: string /* = "" */): void;

        BugItGo(X: number, Y: number, Z: number, Pitch: number, Yaw: number, Roll: number): void;

        BugItStringCreator(ViewLocation: Vector, ViewRotation: Rotator, GoString: $Ref<string>, LocString: $Ref<string>): void;

        ChangeSize(F: number): void;

        CheatScript(ScriptName: string): void;

        DamageTarget(DamageAmount: number): void;

        DebugCapsuleSweep(): void;

        DebugCapsuleSweepCapture(): void;

        DebugCapsuleSweepChannel(Channel: ECollisionChannel): void;

        DebugCapsuleSweepClear(): void;

        DebugCapsuleSweepComplex(bTraceComplex: boolean): void;

        DebugCapsuleSweepPawn(): void;

        DebugCapsuleSweepSize(HalfHeight: number, Radius: number): void;

        DestroyAll(aClass: $Nullable<Class>): void;

        DestroyAllPawnsExceptTarget(): void;

        DestroyPawns(aClass: $Nullable<Class>): void;

        DestroyServerStatReplicator(): void;

        DestroyTarget(): void;

        DisableDebugCamera(): void;

        DumpChatState(): void;

        DumpOnlineSessionState(): void;

        DumpPartyState(): void;

        DumpVoiceMutingState(): void;

        EnableDebugCamera(): void;

        FlushLog(): void;

        Fly(): void;

        FreezeFrame(Delay: number): void;

        Ghost(): void;

        God(): void;

        InvertMouse(): void;

        LogLoc(): void;

        OnlyLoadLevel(PackageName: string): void;

        PlayersOnly(): void;

        ReceiveEndPlay(): void;

        ReceiveInitCheatManager(): void;

        ServerToggleAILogging(): void;

        SetMouseSensitivityToDefault(): void;

        SetWorldOrigin(): void;

        Slomo(NewTimeDilation: number): void;

        SpawnServerStatReplicator(): void;

        StreamLevelIn(PackageName: string): void;

        StreamLevelOut(PackageName: string): void;

        Summon(ClassName: string): void;

        Teleport(): void;

        TestCollisionDistance(): void;

        ToggleAILogging(): void;

        ToggleDebugCamera(): void;

        ToggleServerStatReplicatorClientOverwrite(): void;

        ToggleServerStatReplicatorUpdateStatNet(): void;

        UpdateSafeArea(): void;

        ViewActor(ActorName: string): void;

        ViewClass(DesiredClass: $Nullable<Class>): void;

        ViewPlayer(S: string): void;

        ViewSelf(): void;

        Walk(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CheatManager;

        static Load(InName: string): CheatManager;
    }

    export class KeyBind {
        constructor();
        constructor(Key: Key, Command: string, Control: boolean, Shift: boolean, Alt: boolean, Cmd: boolean, bIgnoreCtrl: boolean, bIgnoreShift: boolean, bIgnoreAlt: boolean, bIgnoreCmd: boolean, bDisabled: boolean);

        Key: Key;
        Command: string;
        Control: boolean;
        Shift: boolean;
        Alt: boolean;
        Cmd: boolean;
        bIgnoreCtrl: boolean;
        bIgnoreShift: boolean;
        bIgnoreAlt: boolean;
        bIgnoreCmd: boolean;
        bDisabled: boolean;

        static StaticClass(): Class;
    }

    export class PlayerInput extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DebugExecBindings: TArray<KeyBind>;
        InvertedAxis: TArray<string>;

        ClearSmoothing(): void;

        InvertAxis(AxisName: string): void;

        InvertAxisKey(AxisKey: Key): void;

        SetBind(BindName: string, Command: string): void;

        SetMouseSensitivity(Sensitivity: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlayerInput;

        static Load(InName: string): PlayerInput;
    }

    export class RuntimeFloatCurve {
        constructor();
        constructor(EditorCurveData: RichCurve, ExternalCurve: CurveFloat);

        EditorCurveData: RichCurve;
        ExternalCurve: CurveFloat;

        static StaticClass(): Class;
    }

    export class ForceFeedbackChannelDetails {
        constructor();
        constructor(bAffectsLeftLarge: boolean, bAffectsLeftSmall: boolean, bAffectsRightLarge: boolean, bAffectsRightSmall: boolean, Curve: RuntimeFloatCurve);

        bAffectsLeftLarge: boolean;
        bAffectsLeftSmall: boolean;
        bAffectsRightLarge: boolean;
        bAffectsRightSmall: boolean;
        Curve: RuntimeFloatCurve;

        static StaticClass(): Class;
    }

    export class ForceFeedbackEffect extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChannelDetails: TArray<ForceFeedbackChannelDetails>;
        Duration: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ForceFeedbackEffect;

        static Load(InName: string): ForceFeedbackEffect;
    }

    export class ActiveForceFeedbackEffect {
        constructor();
        constructor(ForceFeedbackEffect: ForceFeedbackEffect);

        ForceFeedbackEffect: ForceFeedbackEffect;

        static StaticClass(): Class;
    }

    export class ChildConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Parent: NetConnection;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChildConnection;

        static Load(InName: string): ChildConnection;
    }

    export class LayerActorStats {
        constructor();
        constructor(Type: Class, Total: number);

        Type: Class;
        Total: number;

        static StaticClass(): Class;
    }

    export class Layer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LayerName: string;
        bIsVisible: boolean;
        ActorStats: TArray<LayerActorStats>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Layer;

        static Load(InName: string): Layer;
    }

    export class ModelComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ModelBodySetup: BodySetup;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ModelComponent;

        static Load(InName: string): ModelComponent;
    }

    export class LevelActorContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Actors: TArray<Actor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelActorContainer;

        static Load(InName: string): LevelActorContainer;
    }

    export class LevelScriptBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FriendlyName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelScriptBlueprint;

        static Load(InName: string): LevelScriptBlueprint;
    }

    export class LevelScriptActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bInputEnabled: boolean;

        LevelReset(): void;

        RemoteEvent(EventName: string): boolean;

        SetCinematicMode(bCinematicMode: boolean, bHidePlayer?: boolean /* = true */, bAffectsHUD?: boolean /* = true */, bAffectsMovement?: boolean /* = false */, bAffectsTurning?: boolean /* = false */): void;

        WorldOriginLocationChanged(OldOriginLocation: IntVector, NewOriginLocation: IntVector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelScriptActor;

        static Load(InName: string): LevelScriptActor;
    }

    export class NavigationObjectBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CapsuleComponent: CapsuleComponent;
        GoodSprite: BillboardComponent;
        BadSprite: BillboardComponent;
        bIsPIEPlayerStart: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationObjectBase;

        static Load(InName: string): NavigationObjectBase;
    }

    export class NavigationDataChunk extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NavigationDataName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationDataChunk;

        static Load(InName: string): NavigationDataChunk;
    }

    export enum ELightingBuildQuality { Quality_Preview, Quality_Medium, Quality_High, Quality_Production, Quality_MAX }

    export class MapBuildDataRegistry extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LevelLightingQuality: ELightingBuildQuality;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MapBuildDataRegistry;

        static Load(InName: string): MapBuildDataRegistry;
    }

    export enum ETextureSizingType {
        TextureSizingType_UseSingleTextureSize,
        TextureSizingType_UseAutomaticBiasedSizes,
        TextureSizingType_UseManualOverrideTextureSize,
        TextureSizingType_UseSimplygonAutomaticSizing,
        TextureSizingType_MAX
    }

    export enum EMaterialMergeType { MaterialMergeType_Default, MaterialMergeType_Simplygon, MaterialMergeType_MAX }

    export class MaterialProxySettings {
        constructor();
        constructor(TextureSize: IntPoint, GutterSpace: number, MetallicConstant: number, RoughnessConstant: number, AnisotropyConstant: number, SpecularConstant: number, OpacityConstant: number, OpacityMaskConstant: number, AmbientOcclusionConstant: number, TextureSizingType: ETextureSizingType, MaterialMergeType: EMaterialMergeType, BlendMode: EBlendMode, bAllowTwoSidedMaterial: boolean, bNormalMap: boolean, bTangentMap: boolean, bMetallicMap: boolean, bRoughnessMap: boolean, bAnisotropyMap: boolean, bSpecularMap: boolean, bEmissiveMap: boolean, bOpacityMap: boolean, bOpacityMaskMap: boolean, bAmbientOcclusionMap: boolean, DiffuseTextureSize: IntPoint, NormalTextureSize: IntPoint, TangentTextureSize: IntPoint, MetallicTextureSize: IntPoint, RoughnessTextureSize: IntPoint, AnisotropyTextureSize: IntPoint, SpecularTextureSize: IntPoint, EmissiveTextureSize: IntPoint, OpacityTextureSize: IntPoint, OpacityMaskTextureSize: IntPoint, AmbientOcclusionTextureSize: IntPoint);

        TextureSize: IntPoint;
        GutterSpace: number;
        MetallicConstant: number;
        RoughnessConstant: number;
        AnisotropyConstant: number;
        SpecularConstant: number;
        OpacityConstant: number;
        OpacityMaskConstant: number;
        AmbientOcclusionConstant: number;
        TextureSizingType: ETextureSizingType;
        MaterialMergeType: EMaterialMergeType;
        BlendMode: EBlendMode;
        bAllowTwoSidedMaterial: boolean;
        bNormalMap: boolean;
        bTangentMap: boolean;
        bMetallicMap: boolean;
        bRoughnessMap: boolean;
        bAnisotropyMap: boolean;
        bSpecularMap: boolean;
        bEmissiveMap: boolean;
        bOpacityMap: boolean;
        bOpacityMaskMap: boolean;
        bAmbientOcclusionMap: boolean;
        DiffuseTextureSize: IntPoint;
        NormalTextureSize: IntPoint;
        TangentTextureSize: IntPoint;
        MetallicTextureSize: IntPoint;
        RoughnessTextureSize: IntPoint;
        AnisotropyTextureSize: IntPoint;
        SpecularTextureSize: IntPoint;
        EmissiveTextureSize: IntPoint;
        OpacityTextureSize: IntPoint;
        OpacityMaskTextureSize: IntPoint;
        AmbientOcclusionTextureSize: IntPoint;

        static StaticClass(): Class;
    }

    export class LevelSimplificationDetails {
        constructor();
        constructor(bCreatePackagePerAsset: boolean, DetailsPercentage: number, StaticMeshMaterialSettings: MaterialProxySettings, bOverrideLandscapeExportLOD: boolean, LandscapeExportLOD: number, LandscapeMaterialSettings: MaterialProxySettings, bBakeFoliageToLandscape: boolean, bBakeGrassToLandscape: boolean, bGenerateMeshNormalMap: boolean, bGenerateMeshMetallicMap: boolean, bGenerateMeshRoughnessMap: boolean, bGenerateMeshSpecularMap: boolean, bGenerateLandscapeNormalMap: boolean, bGenerateLandscapeMetallicMap: boolean, bGenerateLandscapeRoughnessMap: boolean, bGenerateLandscapeSpecularMap: boolean);

        bCreatePackagePerAsset: boolean;
        DetailsPercentage: number;
        StaticMeshMaterialSettings: MaterialProxySettings;
        bOverrideLandscapeExportLOD: boolean;
        LandscapeExportLOD: number;
        LandscapeMaterialSettings: MaterialProxySettings;
        bBakeFoliageToLandscape: boolean;
        bBakeGrassToLandscape: boolean;
        bGenerateMeshNormalMap: boolean;
        bGenerateMeshMetallicMap: boolean;
        bGenerateMeshRoughnessMap: boolean;
        bGenerateMeshSpecularMap: boolean;
        bGenerateLandscapeNormalMap: boolean;
        bGenerateLandscapeMetallicMap: boolean;
        bGenerateLandscapeRoughnessMap: boolean;
        bGenerateLandscapeSpecularMap: boolean;

        static StaticClass(): Class;
    }

    export enum EVisibilityAggressiveness {
        VIS_LeastAggressive,
        VIS_ModeratelyAggressive,
        VIS_MostAggressive,
        VIS_Max,
        VIS_MAX
    }

    export class NavAgentSelector {
        constructor();
        constructor(bSupportsAgent0: boolean, bSupportsAgent1: boolean, bSupportsAgent2: boolean, bSupportsAgent3: boolean, bSupportsAgent4: boolean, bSupportsAgent5: boolean, bSupportsAgent6: boolean, bSupportsAgent7: boolean, bSupportsAgent8: boolean, bSupportsAgent9: boolean, bSupportsAgent10: boolean, bSupportsAgent11: boolean, bSupportsAgent12: boolean, bSupportsAgent13: boolean, bSupportsAgent14: boolean, bSupportsAgent15: boolean);

        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;

        static StaticClass(): Class;
    }

    export class NavigationSystemConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NavigationSystemClass: SoftClassPath;
        SupportedAgentsMask: NavAgentSelector;
        DefaultAgentName: string;
        bIsOverriden: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationSystemConfig;

        static Load(InName: string): NavigationSystemConfig;
    }

    export enum EVolumeLightingMethod { VLM_VolumetricLightmap, VLM_SparseVolumeLightingSamples, VLM_MAX }

    export class LightmassWorldInfoSettings {
        constructor();
        constructor(StaticLightingLevelScale: number, NumIndirectLightingBounces: number, NumSkyLightingBounces: number, IndirectLightingQuality: number, IndirectLightingSmoothness: number, EnvironmentColor: Color, EnvironmentIntensity: number, EmissiveBoost: number, DiffuseBoost: number, VolumeLightingMethod: EVolumeLightingMethod, bUseAmbientOcclusion: boolean, bGenerateAmbientOcclusionMaterialMask: boolean, bVisualizeMaterialDiffuse: boolean, bVisualizeAmbientOcclusion: boolean, bCompressLightmaps: boolean, VolumetricLightmapDetailCellSize: number, VolumetricLightmapMaximumBrickMemoryMb: number, VolumetricLightmapSphericalHarmonicSmoothing: number, VolumeLightSamplePlacementScale: number, DirectIlluminationOcclusionFraction: number, IndirectIlluminationOcclusionFraction: number, OcclusionExponent: number, FullyOccludedSamplesFraction: number, MaxOcclusionDistance: number);

        StaticLightingLevelScale: number;
        NumIndirectLightingBounces: number;
        NumSkyLightingBounces: number;
        IndirectLightingQuality: number;
        IndirectLightingSmoothness: number;
        EnvironmentColor: Color;
        EnvironmentIntensity: number;
        EmissiveBoost: number;
        DiffuseBoost: number;
        VolumeLightingMethod: EVolumeLightingMethod;
        bUseAmbientOcclusion: boolean;
        bGenerateAmbientOcclusionMaterialMask: boolean;
        bVisualizeMaterialDiffuse: boolean;
        bVisualizeAmbientOcclusion: boolean;
        bCompressLightmaps: boolean;
        VolumetricLightmapDetailCellSize: number;
        VolumetricLightmapMaximumBrickMemoryMb: number;
        VolumetricLightmapSphericalHarmonicSmoothing: number;
        VolumeLightSamplePlacementScale: number;
        DirectIlluminationOcclusionFraction: number;
        IndirectIlluminationOcclusionFraction: number;
        OcclusionExponent: number;
        FullyOccludedSamplesFraction: number;
        MaxOcclusionDistance: number;

        static StaticClass(): Class;
    }

    export enum ReverbPreset {
        REVERB_Default,
        REVERB_Bathroom,
        REVERB_StoneRoom,
        REVERB_Auditorium,
        REVERB_ConcertHall,
        REVERB_Cave,
        REVERB_Hallway,
        REVERB_StoneCorridor,
        REVERB_Alley,
        REVERB_Forest,
        REVERB_City,
        REVERB_Mountains,
        REVERB_Quarry,
        REVERB_Plain,
        REVERB_ParkingLot,
        REVERB_SewerPipe,
        REVERB_Underwater,
        REVERB_SmallRoom,
        REVERB_MediumRoom,
        REVERB_LargeRoom,
        REVERB_MediumHall,
        REVERB_LargeHall,
        REVERB_Plate,
        REVERB_MAX
    }

    export class ReverbEffect extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bBypassEarlyReflections: boolean;
        ReflectionsDelay: number;
        GainHF: number;
        ReflectionsGain: number;
        bBypassLateReflections: boolean;
        LateDelay: number;
        DecayTime: number;
        Density: number;
        Diffusion: number;
        AirAbsorptionGainHF: number;
        DecayHFRatio: number;
        LateGain: number;
        Gain: number;
        RoomRolloffFactor: number;
        bChanged: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReverbEffect;

        static Load(InName: string): ReverbEffect;
    }

    export class SoundEffectPreset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundEffectPreset;

        static Load(InName: string): SoundEffectPreset;
    }

    export class SoundEffectSubmixPreset extends SoundEffectPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundEffectSubmixPreset;

        static Load(InName: string): SoundEffectSubmixPreset;
    }

    export class ReverbSettings {
        constructor();
        constructor(bApplyReverb: boolean, ReverbType: ReverbPreset, ReverbEffect: ReverbEffect, ReverbPluginEffect: SoundEffectSubmixPreset, Volume: number, FadeTime: number);

        bApplyReverb: boolean;
        ReverbType: ReverbPreset;
        ReverbEffect: ReverbEffect;
        ReverbPluginEffect: SoundEffectSubmixPreset;
        Volume: number;
        FadeTime: number;

        static StaticClass(): Class;
    }

    export class InteriorSettings {
        constructor();
        constructor(bIsWorldSettings: boolean, ExteriorVolume: number, ExteriorTime: number, ExteriorLPF: number, ExteriorLPFTime: number, InteriorVolume: number, InteriorTime: number, InteriorLPF: number, InteriorLPFTime: number);

        bIsWorldSettings: boolean;
        ExteriorVolume: number;
        ExteriorTime: number;
        ExteriorLPF: number;
        ExteriorLPFTime: number;
        InteriorVolume: number;
        InteriorTime: number;
        InteriorLPF: number;
        InteriorLPFTime: number;

        static StaticClass(): Class;
    }

    export class AudioEffectParameters {
        constructor();

        static StaticClass(): Class;
    }

    export class AudioEQEffect extends AudioEffectParameters {
        constructor();
        constructor(FrequencyCenter0: number, Gain0: number, Bandwidth0: number, FrequencyCenter1: number, Gain1: number, Bandwidth1: number, FrequencyCenter2: number, Gain2: number, Bandwidth2: number, FrequencyCenter3: number, Gain3: number, Bandwidth3: number);

        FrequencyCenter0: number;
        Gain0: number;
        Bandwidth0: number;
        FrequencyCenter1: number;
        Gain1: number;
        Bandwidth1: number;
        FrequencyCenter2: number;
        Gain2: number;
        Bandwidth2: number;
        FrequencyCenter3: number;
        Gain3: number;
        Bandwidth3: number;

        static StaticClass(): Class;
    }

    export class SoundModulatorBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundModulatorBase;

        static Load(InName: string): SoundModulatorBase;
    }

    export class SoundModulationDestinationSettings {
        constructor();
        constructor(Value: number, bEnableModulation: boolean, Modulator: SoundModulatorBase);

        Value: number;
        bEnableModulation: boolean;
        Modulator: SoundModulatorBase;

        static StaticClass(): Class;
    }

    export class SoundModulationDefaultSettings {
        constructor();
        constructor(VolumeModulationDestination: SoundModulationDestinationSettings, PitchModulationDestination: SoundModulationDestinationSettings, HighpassModulationDestination: SoundModulationDestinationSettings, LowpassModulationDestination: SoundModulationDestinationSettings);

        VolumeModulationDestination: SoundModulationDestinationSettings;
        PitchModulationDestination: SoundModulationDestinationSettings;
        HighpassModulationDestination: SoundModulationDestinationSettings;
        LowpassModulationDestination: SoundModulationDestinationSettings;

        static StaticClass(): Class;
    }

    export enum EAudioOutputTarget { Speaker, Controller, ControllerFallbackToSpeaker, EAudioOutputTarget_MAX }

    export enum ESoundWaveLoadingBehavior {
        Inherited,
        RetainOnLoad,
        PrimeOnLoad,
        LoadOnDemand,
        ForceInline,
        Uninitialized,
        ESoundWaveLoadingBehavior_MAX
    }

    export class SoundSubmixBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChildSubmixes: TArray<SoundSubmixBase>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSubmixBase;

        static Load(InName: string): SoundSubmixBase;
    }

    export class SoundSubmixWithParentBase extends SoundSubmixBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParentSubmix: SoundSubmixBase;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSubmixWithParentBase;

        static Load(InName: string): SoundSubmixWithParentBase;
    }

    export class SoundfieldEncodingSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundfieldEncodingSettingsBase;

        static Load(InName: string): SoundfieldEncodingSettingsBase;
    }

    export enum EGainParamMode { Linear, Decibels, EGainParamMode_MAX }

    export enum EVirtualizationMode { Disabled, PlayWhenSilent, Restart, EVirtualizationMode_MAX }

    export enum EMaxConcurrentResolutionRule {
        PreventNew,
        StopOldest,
        StopFarthestThenPreventNew,
        StopFarthestThenOldest,
        StopLowestPriority,
        StopQuietest,
        StopLowestPriorityThenPreventNew,
        Count,
        EMaxConcurrentResolutionRule_MAX
    }

    export enum EConcurrencyVolumeScaleMode { Default, Distance, Priority, EConcurrencyVolumeScaleMode_MAX }

    export class SoundConcurrencySettings {
        constructor();
        constructor(MaxCount: number, bLimitToOwner: boolean, ResolutionRule: EMaxConcurrentResolutionRule, RetriggerTime: number, VolumeScale: number, VolumeScaleMode: EConcurrencyVolumeScaleMode, VolumeScaleAttackTime: number, bVolumeScaleCanRelease: boolean, VolumeScaleReleaseTime: number, VoiceStealReleaseTime: number);

        MaxCount: number;
        bLimitToOwner: boolean;
        ResolutionRule: EMaxConcurrentResolutionRule;
        RetriggerTime: number;
        VolumeScale: number;
        VolumeScaleMode: EConcurrencyVolumeScaleMode;
        VolumeScaleAttackTime: number;
        bVolumeScaleCanRelease: boolean;
        VolumeScaleReleaseTime: number;
        VoiceStealReleaseTime: number;

        static StaticClass(): Class;
    }

    export class SoundConcurrency extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Concurrency: SoundConcurrencySettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundConcurrency;

        static Load(InName: string): SoundConcurrency;
    }

    export enum EAttenuationDistanceModel {
        Linear,
        Logarithmic,
        Inverse,
        LogReverse,
        NaturalSound,
        Custom,
        EAttenuationDistanceModel_MAX
    }

    export enum EAttenuationShape { Sphere, Capsule, Box, Cone, EAttenuationShape_MAX }

    export enum ENaturalSoundFalloffMode { Continues, Silent, Hold, ENaturalSoundFalloffMode_MAX }

    export class BaseAttenuationSettings {
        constructor();
        constructor(DistanceAlgorithm: EAttenuationDistanceModel, AttenuationShape: EAttenuationShape, dBAttenuationAtMax: number, FalloffMode: ENaturalSoundFalloffMode, AttenuationShapeExtents: Vector, ConeOffset: number, FalloffDistance: number, CustomAttenuationCurve: RuntimeFloatCurve);

        DistanceAlgorithm: EAttenuationDistanceModel;
        AttenuationShape: EAttenuationShape;
        dBAttenuationAtMax: number;
        FalloffMode: ENaturalSoundFalloffMode;
        AttenuationShapeExtents: Vector;
        ConeOffset: number;
        FalloffDistance: number;
        CustomAttenuationCurve: RuntimeFloatCurve;

        static StaticClass(): Class;
    }

    export enum ESoundSpatializationAlgorithm { SPATIALIZATION_Default, SPATIALIZATION_HRTF, SPATIALIZATION_MAX }

    export enum EAirAbsorptionMethod { Linear, CustomCurve, EAirAbsorptionMethod_MAX }

    export enum EReverbSendMethod { Linear, CustomCurve, Manual, EReverbSendMethod_MAX }

    export enum EPriorityAttenuationMethod { Linear, CustomCurve, Manual, EPriorityAttenuationMethod_MAX }

    export enum ESoundDistanceCalc {
        SOUNDDISTANCE_Normal,
        SOUNDDISTANCE_InfiniteXYPlane,
        SOUNDDISTANCE_InfiniteXZPlane,
        SOUNDDISTANCE_InfiniteYZPlane,
        SOUNDDISTANCE_MAX
    }

    export class SpatializationPluginSourceSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpatializationPluginSourceSettingsBase;

        static Load(InName: string): SpatializationPluginSourceSettingsBase;
    }

    export class OcclusionPluginSourceSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OcclusionPluginSourceSettingsBase;

        static Load(InName: string): OcclusionPluginSourceSettingsBase;
    }

    export class ReverbPluginSourceSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReverbPluginSourceSettingsBase;

        static Load(InName: string): ReverbPluginSourceSettingsBase;
    }

    export enum ESubmixSendMethod { Linear, CustomCurve, Manual, ESubmixSendMethod_MAX }

    export class AttenuationSubmixSendSettings {
        constructor();
        constructor(Submix: SoundSubmixBase, SubmixSendMethod: ESubmixSendMethod, SubmixSendLevelMin: number, SubmixSendLevelMax: number, SubmixSendDistanceMin: number, SubmixSendDistanceMax: number, ManualSubmixSendLevel: number, CustomSubmixSendCurve: RuntimeFloatCurve);

        Submix: SoundSubmixBase;
        SubmixSendMethod: ESubmixSendMethod;
        SubmixSendLevelMin: number;
        SubmixSendLevelMax: number;
        SubmixSendDistanceMin: number;
        SubmixSendDistanceMax: number;
        ManualSubmixSendLevel: number;
        CustomSubmixSendCurve: RuntimeFloatCurve;

        static StaticClass(): Class;
    }

    export class SoundAttenuationPluginSettings {
        constructor();
        constructor(SpatializationPluginSettingsArray: TArray<SpatializationPluginSourceSettingsBase>, OcclusionPluginSettingsArray: TArray<OcclusionPluginSourceSettingsBase>, ReverbPluginSettingsArray: TArray<ReverbPluginSourceSettingsBase>);

        SpatializationPluginSettingsArray: TArray<SpatializationPluginSourceSettingsBase>;
        OcclusionPluginSettingsArray: TArray<OcclusionPluginSourceSettingsBase>;
        ReverbPluginSettingsArray: TArray<ReverbPluginSourceSettingsBase>;

        static StaticClass(): Class;
    }

    export class SoundAttenuationSettings extends BaseAttenuationSettings {
        constructor();
        constructor(bAttenuate: boolean, bSpatialize: boolean, bAttenuateWithLPF: boolean, bEnableListenerFocus: boolean, bEnableFocusInterpolation: boolean, bEnableOcclusion: boolean, bUseComplexCollisionForOcclusion: boolean, bEnableReverbSend: boolean, bEnablePriorityAttenuation: boolean, bApplyNormalizationToStereoSounds: boolean, bEnableLogFrequencyScaling: boolean, bEnableSubmixSends: boolean, SpatializationAlgorithm: ESoundSpatializationAlgorithm, BinauralRadius: number, AbsorptionMethod: EAirAbsorptionMethod, OcclusionTraceChannel: ECollisionChannel, ReverbSendMethod: EReverbSendMethod, PriorityAttenuationMethod: EPriorityAttenuationMethod, DistanceType: ESoundDistanceCalc, OmniRadius: number, StereoSpread: number, SpatializationPluginSettings: SpatializationPluginSourceSettingsBase, RadiusMin: number, RadiusMax: number, LPFRadiusMin: number, LPFRadiusMax: number, CustomLowpassAirAbsorptionCurve: RuntimeFloatCurve, CustomHighpassAirAbsorptionCurve: RuntimeFloatCurve, LPFFrequencyAtMin: number, LPFFrequencyAtMax: number, HPFFrequencyAtMin: number, HPFFrequencyAtMax: number, FocusAzimuth: number, NonFocusAzimuth: number, FocusDistanceScale: number, NonFocusDistanceScale: number, FocusPriorityScale: number, NonFocusPriorityScale: number, FocusVolumeAttenuation: number, NonFocusVolumeAttenuation: number, FocusAttackInterpSpeed: number, FocusReleaseInterpSpeed: number, OcclusionLowPassFilterFrequency: number, OcclusionVolumeAttenuation: number, OcclusionInterpolationTime: number, OcclusionPluginSettings: OcclusionPluginSourceSettingsBase, ReverbPluginSettings: ReverbPluginSourceSettingsBase, ReverbWetLevelMin: number, ReverbWetLevelMax: number, ReverbDistanceMin: number, ReverbDistanceMax: number, ManualReverbSendLevel: number, CustomReverbSendCurve: RuntimeFloatCurve, SubmixSendSettings: TArray<AttenuationSubmixSendSettings>, PriorityAttenuationMin: number, PriorityAttenuationMax: number, PriorityAttenuationDistanceMin: number, PriorityAttenuationDistanceMax: number, ManualPriorityAttenuation: number, CustomPriorityAttenuationCurve: RuntimeFloatCurve, PluginSettings: SoundAttenuationPluginSettings);

        bAttenuate: boolean;
        bSpatialize: boolean;
        bAttenuateWithLPF: boolean;
        bEnableListenerFocus: boolean;
        bEnableFocusInterpolation: boolean;
        bEnableOcclusion: boolean;
        bUseComplexCollisionForOcclusion: boolean;
        bEnableReverbSend: boolean;
        bEnablePriorityAttenuation: boolean;
        bApplyNormalizationToStereoSounds: boolean;
        bEnableLogFrequencyScaling: boolean;
        bEnableSubmixSends: boolean;
        SpatializationAlgorithm: ESoundSpatializationAlgorithm;
        BinauralRadius: number;
        AbsorptionMethod: EAirAbsorptionMethod;
        OcclusionTraceChannel: ECollisionChannel;
        ReverbSendMethod: EReverbSendMethod;
        PriorityAttenuationMethod: EPriorityAttenuationMethod;
        DistanceType: ESoundDistanceCalc;
        OmniRadius: number;
        StereoSpread: number;
        SpatializationPluginSettings: SpatializationPluginSourceSettingsBase;
        RadiusMin: number;
        RadiusMax: number;
        LPFRadiusMin: number;
        LPFRadiusMax: number;
        CustomLowpassAirAbsorptionCurve: RuntimeFloatCurve;
        CustomHighpassAirAbsorptionCurve: RuntimeFloatCurve;
        LPFFrequencyAtMin: number;
        LPFFrequencyAtMax: number;
        HPFFrequencyAtMin: number;
        HPFFrequencyAtMax: number;
        FocusAzimuth: number;
        NonFocusAzimuth: number;
        FocusDistanceScale: number;
        NonFocusDistanceScale: number;
        FocusPriorityScale: number;
        NonFocusPriorityScale: number;
        FocusVolumeAttenuation: number;
        NonFocusVolumeAttenuation: number;
        FocusAttackInterpSpeed: number;
        FocusReleaseInterpSpeed: number;
        OcclusionLowPassFilterFrequency: number;
        OcclusionVolumeAttenuation: number;
        OcclusionInterpolationTime: number;
        OcclusionPluginSettings: OcclusionPluginSourceSettingsBase;
        ReverbPluginSettings: ReverbPluginSourceSettingsBase;
        ReverbWetLevelMin: number;
        ReverbWetLevelMax: number;
        ReverbDistanceMin: number;
        ReverbDistanceMax: number;
        ManualReverbSendLevel: number;
        CustomReverbSendCurve: RuntimeFloatCurve;
        SubmixSendSettings: TArray<AttenuationSubmixSendSettings>;
        PriorityAttenuationMin: number;
        PriorityAttenuationMax: number;
        PriorityAttenuationDistanceMin: number;
        PriorityAttenuationDistanceMax: number;
        ManualPriorityAttenuation: number;
        CustomPriorityAttenuationCurve: RuntimeFloatCurve;
        PluginSettings: SoundAttenuationPluginSettings;

        static StaticClass(): Class;
    }

    export class SoundAttenuation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Attenuation: SoundAttenuationSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundAttenuation;

        static Load(InName: string): SoundAttenuation;
    }

    export enum EModulationRouting { Disable, Inherit, Override, EModulationRouting_MAX }

    export class SoundModulationDefaultRoutingSettings extends SoundModulationDefaultSettings {
        constructor();
        constructor(VolumeRouting: EModulationRouting, PitchRouting: EModulationRouting, HighpassRouting: EModulationRouting, LowpassRouting: EModulationRouting);

        VolumeRouting: EModulationRouting;
        PitchRouting: EModulationRouting;
        HighpassRouting: EModulationRouting;
        LowpassRouting: EModulationRouting;

        static StaticClass(): Class;
    }

    export enum ESendLevelControlMethod { Linear, CustomCurve, Manual, ESendLevelControlMethod_MAX }

    export enum ESubmixSendStage { PostDistanceAttenuation, PreDistanceAttenuation, ESubmixSendStage_MAX }

    export class SoundSubmixSendInfo {
        constructor();
        constructor(SendLevelControlMethod: ESendLevelControlMethod, SendStage: ESubmixSendStage, SoundSubmix: SoundSubmixBase, SendLevel: number, MinSendLevel: number, MaxSendLevel: number, MinSendDistance: number, MaxSendDistance: number, CustomSendLevelCurve: RuntimeFloatCurve);

        SendLevelControlMethod: ESendLevelControlMethod;
        SendStage: ESubmixSendStage;
        SoundSubmix: SoundSubmixBase;
        SendLevel: number;
        MinSendLevel: number;
        MaxSendLevel: number;
        MinSendDistance: number;
        MaxSendDistance: number;
        CustomSendLevelCurve: RuntimeFloatCurve;

        static StaticClass(): Class;
    }

    export class SoundEffectSourcePreset extends SoundEffectPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundEffectSourcePreset;

        static Load(InName: string): SoundEffectSourcePreset;
    }

    export class SourceEffectChainEntry {
        constructor();
        constructor(Preset: SoundEffectSourcePreset, bBypass: boolean);

        Preset: SoundEffectSourcePreset;
        bBypass: boolean;

        static StaticClass(): Class;
    }

    export class SoundEffectSourcePresetChain extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Chain: TArray<SourceEffectChainEntry>;
        bPlayEffectChainTails: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundEffectSourcePresetChain;

        static Load(InName: string): SoundEffectSourcePresetChain;
    }

    export enum ESourceBusSendLevelControlMethod { Linear, CustomCurve, Manual, ESourceBusSendLevelControlMethod_MAX }

    export enum ESourceBusChannels { Mono, Stereo, ESourceBusChannels_MAX }

    export enum EAudioBusChannels { Mono, Stereo, EAudioBusChannels_MAX }

    export class AudioBus extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AudioBusChannels: EAudioBusChannels;
        bIsAutomatic: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioBus;

        static Load(InName: string): AudioBus;
    }

    export class SoundSourceBus extends SoundWave {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceBusChannels: ESourceBusChannels;
        SourceBusDuration: number;
        AudioBus: AudioBus;
        bAutoDeactivateWhenSilent: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSourceBus;

        static Load(InName: string): SoundSourceBus;
    }

    export class SoundSourceBusSendInfo {
        constructor();
        constructor(SourceBusSendLevelControlMethod: ESourceBusSendLevelControlMethod, SoundSourceBus: SoundSourceBus, AudioBus: AudioBus, SendLevel: number, MinSendLevel: number, MaxSendLevel: number, MinSendDistance: number, MaxSendDistance: number, CustomSendLevelCurve: RuntimeFloatCurve);

        SourceBusSendLevelControlMethod: ESourceBusSendLevelControlMethod;
        SoundSourceBus: SoundSourceBus;
        AudioBus: AudioBus;
        SendLevel: number;
        MinSendLevel: number;
        MaxSendLevel: number;
        MinSendDistance: number;
        MaxSendDistance: number;
        CustomSendLevelCurve: RuntimeFloatCurve;

        static StaticClass(): Class;
    }

    export class SoundBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundClassObject: SoundClass;
        bDebug: boolean;
        bOverrideConcurrency: boolean;
        bOutputToBusOnly: boolean;
        bHasDelayNode: boolean;
        bHasConcatenatorNode: boolean;
        bHasVirtualizeWhenSilent: boolean;
        bBypassVolumeScaleForPriority: boolean;
        VirtualizationMode: EVirtualizationMode;
        MaxConcurrentResolutionRule: EMaxConcurrentResolutionRule;
        SoundConcurrencySettings: SoundConcurrency;
        ConcurrencySet: TSet<SoundConcurrency>;
        ConcurrencyOverrides: SoundConcurrencySettings;
        MaxConcurrentPlayCount: number;
        Duration: number;
        MaxDistance: number;
        TotalSamples: number;
        Priority: number;
        AttenuationSettings: SoundAttenuation;
        ModulationSettings: SoundModulationDefaultRoutingSettings;
        SoundSubmixObject: SoundSubmixBase;
        SoundSubmixSends: TArray<SoundSubmixSendInfo>;
        SourceEffectChain: SoundEffectSourcePresetChain;
        BusSends: TArray<SoundSourceBusSendInfo>;
        PreEffectBusSends: TArray<SoundSourceBusSendInfo>;
        AssetUserData: TArray<AssetUserData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundBase;

        static Load(InName: string): SoundBase;
    }

    export enum ESoundwaveSampleRateSettings {
        Max,
        High,
        Medium,
        Low,
        Min,
        MatchDevice,
        ESoundwaveSampleRateSettings_MAX
    }

    export enum ESoundGroup {
        SOUNDGROUP_Default,
        SOUNDGROUP_Effects,
        SOUNDGROUP_UI,
        SOUNDGROUP_Music,
        SOUNDGROUP_Voice,
        SOUNDGROUP_GameSoundGroup1,
        SOUNDGROUP_GameSoundGroup2,
        SOUNDGROUP_GameSoundGroup3,
        SOUNDGROUP_GameSoundGroup4,
        SOUNDGROUP_GameSoundGroup5,
        SOUNDGROUP_GameSoundGroup6,
        SOUNDGROUP_GameSoundGroup7,
        SOUNDGROUP_GameSoundGroup8,
        SOUNDGROUP_GameSoundGroup9,
        SOUNDGROUP_GameSoundGroup10,
        SOUNDGROUP_GameSoundGroup11,
        SOUNDGROUP_GameSoundGroup12,
        SOUNDGROUP_GameSoundGroup13,
        SOUNDGROUP_GameSoundGroup14,
        SOUNDGROUP_GameSoundGroup15,
        SOUNDGROUP_GameSoundGroup16,
        SOUNDGROUP_GameSoundGroup17,
        SOUNDGROUP_GameSoundGroup18,
        SOUNDGROUP_GameSoundGroup19,
        SOUNDGROUP_GameSoundGroup20,
        SOUNDGROUP_MAX
    }

    export enum ESoundWaveFFTSize {
        VerySmall_64,
        Small_256,
        Medium_512,
        Large_1024,
        VeryLarge_2048,
        ESoundWaveFFTSize_MAX
    }

    export class SoundWaveSpectralDataEntry {
        constructor();
        constructor(Magnitude: number, NormalizedMagnitude: number);

        Magnitude: number;
        NormalizedMagnitude: number;

        static StaticClass(): Class;
    }

    export class SoundWaveSpectralTimeData {
        constructor();
        constructor(Data: TArray<SoundWaveSpectralDataEntry>, TimeSec: number);

        Data: TArray<SoundWaveSpectralDataEntry>;
        TimeSec: number;

        static StaticClass(): Class;
    }

    export class SoundWaveEnvelopeTimeData {
        constructor();
        constructor(Amplitude: number, TimeSec: number);

        Amplitude: number;
        TimeSec: number;

        static StaticClass(): Class;
    }

    export class SubtitleCue {
        constructor();
        constructor(Text: string, Time: number);

        Text: string;
        Time: number;

        static StaticClass(): Class;
    }

    export class CurveTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssetImportData: AssetImportData;
        ImportPath: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveTable;

        static Load(InName: string): CurveTable;
    }

    export class SoundWave extends SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CompressionQuality: number;
        StreamingPriority: number;
        SampleRateQuality: ESoundwaveSampleRateSettings;
        SoundGroup: ESoundGroup;
        bLooping: boolean;
        bStreaming: boolean;
        bSeekableStreaming: boolean;
        LoadingBehavior: ESoundWaveLoadingBehavior;
        bMature: boolean;
        bManualWordWrap: boolean;
        bSingleLine: boolean;
        bVirtualizeWhenSilent: boolean;
        bIsAmbisonics: boolean;
        OverrideSoundToUseForAnalysis: SoundWave;
        TreatFileAsLoopingForAnalysis: boolean;
        bEnableBakedFFTAnalysis: boolean;
        bEnableAmplitudeEnvelopeAnalysis: boolean;
        FFTSize: ESoundWaveFFTSize;
        FFTAnalysisFrameSize: number;
        FFTAnalysisAttackTime: number;
        FFTAnalysisReleaseTime: number;
        EnvelopeFollowerFrameSize: number;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        FrequenciesToAnalyze: TArray<number>;
        CookedSpectralTimeData: TArray<SoundWaveSpectralTimeData>;
        CookedEnvelopeTimeData: TArray<SoundWaveEnvelopeTimeData>;
        InitialChunkSize: number;
        SpokenText: string;
        SubtitlePriority: number;
        Volume: number;
        Pitch: number;
        NumChannels: number;
        ChannelOffsets: TArray<number>;
        ChannelSizes: TArray<number>;
        SampleRate: number;
        Subtitles: TArray<SubtitleCue>;
        Comment: string;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        AssetImportData: AssetImportData;
        Curves: CurveTable;
        InternalCurves: CurveTable;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundWave;

        static Load(InName: string): SoundWave;
    }

    export enum EAudioRecordingExportType { SoundWave, WavFile, EAudioRecordingExportType_MAX }

    export enum EFFTSize { DefaultSize, Min, Small, Medium, Large, VeryLarge, Max, EFFTSize_MAX }

    export enum EFFTPeakInterpolationMethod {
        NearestNeighbor,
        Linear,
        Quadratic,
        ConstantQ,
        EFFTPeakInterpolationMethod_MAX
    }

    export enum EFFTWindowType { None, Hamming, Hann, Blackman, EFFTWindowType_MAX }

    export enum EAudioSpectrumType { MagnitudeSpectrum, PowerSpectrum, Decibel, EAudioSpectrumType_MAX }

    export class SoundSubmixSpectralAnalysisBandSettings {
        constructor();
        constructor(BandFrequency: number, AttackTimeMsec: number, ReleaseTimeMsec: number, QFactor: number);

        BandFrequency: number;
        AttackTimeMsec: number;
        ReleaseTimeMsec: number;
        QFactor: number;

        static StaticClass(): Class;
    }

    export class SoundSubmix extends SoundSubmixWithParentBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bMuteWhenBackgrounded: boolean;
        SubmixEffectChain: TArray<SoundEffectSubmixPreset>;
        AmbisonicsPluginSettings: SoundfieldEncodingSettingsBase;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        GainMode: EGainParamMode;
        OutputVolume: number;
        WetLevel: number;
        DryLevel: number;
        OutputVolumeDB: number;
        WetLevelDB: number;
        DryLevelDB: number;
        OnSubmixRecordedFileDone: $MulticastDelegate<(ResultingSoundWave: $Nullable<SoundWave>) => void>;

        AddEnvelopeFollowerDelegate(WorldContextObject: $Nullable<Object>, OnSubmixEnvelopeBP: $Delegate<(Envelope: TArray<number>) => void>): void;

        AddSpectralAnalysisDelegate(WorldContextObject: $Nullable<Object>, InBandSettings: TArray<SoundSubmixSpectralAnalysisBandSettings>, OnSubmixSpectralAnalysisBP: $Delegate<(Magnitude: TArray<number>) => void>, UpdateRate?: number /* = 10.000000 */, DecibelNoiseFloor?: number /* = -40.000000 */, bDoNormalize?: boolean /* = true */, bDoAutoRange?: boolean /* = false */, AutoRangeAttackTime?: number /* = 0.100000 */, AutoRangeReleaseTime?: number /* = 60.000000 */): void;

        RemoveSpectralAnalysisDelegate(WorldContextObject: $Nullable<Object>, OnSubmixSpectralAnalysisBP: $Delegate<(Magnitude: TArray<number>) => void>): void;

        SetSubmixOutputVolume(WorldContextObject: $Nullable<Object>, InOutputVolume: number): void;

        StartEnvelopeFollowing(WorldContextObject: $Nullable<Object>): void;

        StartRecordingOutput(WorldContextObject: $Nullable<Object>, ExpectedDuration: number): void;

        StartSpectralAnalysis(WorldContextObject: $Nullable<Object>, FFTSize?: EFFTSize /* = DefaultSize */, InterpolationMethod?: EFFTPeakInterpolationMethod /* = Linear */, WindowType?: EFFTWindowType /* = Hann */, HopSize?: number /* = 0.000000 */, SpectrumType?: EAudioSpectrumType /* = MagnitudeSpectrum */): void;

        StopEnvelopeFollowing(WorldContextObject: $Nullable<Object>): void;

        StopRecordingOutput(WorldContextObject: $Nullable<Object>, ExportType: EAudioRecordingExportType, Name: string, Path: string, ExistingSoundWaveToOverwrite?: SoundWave /* = None */): void;

        StopSpectralAnalysis(WorldContextObject: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSubmix;

        static Load(InName: string): SoundSubmix;
    }

    export class SoundClassProperties {
        constructor();
        constructor(Volume: number, Pitch: number, LowPassFilterFrequency: number, AttenuationDistanceScale: number, StereoBleed: number, LFEBleed: number, VoiceCenterChannelVolume: number, RadioFilterVolume: number, RadioFilterVolumeThreshold: number, bApplyEffects: boolean, bAlwaysPlay: boolean, bIsUISound: boolean, bIsMusic: boolean, bCenterChannelOnly: boolean, bApplyAmbientVolumes: boolean, bReverb: boolean, Default2DReverbSendAmount: number, ModulationSettings: SoundModulationDefaultSettings, OutputTarget: EAudioOutputTarget, LoadingBehavior: ESoundWaveLoadingBehavior, DefaultSubmix: SoundSubmix);

        Volume: number;
        Pitch: number;
        LowPassFilterFrequency: number;
        AttenuationDistanceScale: number;
        StereoBleed: number;
        LFEBleed: number;
        VoiceCenterChannelVolume: number;
        RadioFilterVolume: number;
        RadioFilterVolumeThreshold: number;
        bApplyEffects: boolean;
        bAlwaysPlay: boolean;
        bIsUISound: boolean;
        bIsMusic: boolean;
        bCenterChannelOnly: boolean;
        bApplyAmbientVolumes: boolean;
        bReverb: boolean;
        Default2DReverbSendAmount: number;
        ModulationSettings: SoundModulationDefaultSettings;
        OutputTarget: EAudioOutputTarget;
        LoadingBehavior: ESoundWaveLoadingBehavior;
        DefaultSubmix: SoundSubmix;

        static StaticClass(): Class;
    }

    export class PassiveSoundMixModifier {
        constructor();
        constructor(SoundMix: SoundMix, MinVolumeThreshold: number, MaxVolumeThreshold: number);

        SoundMix: SoundMix;
        MinVolumeThreshold: number;
        MaxVolumeThreshold: number;

        static StaticClass(): Class;
    }

    export class SoundClass extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Properties: SoundClassProperties;
        ChildClasses: TArray<SoundClass>;
        PassiveSoundMixModifiers: TArray<PassiveSoundMixModifier>;
        ParentClass: SoundClass;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundClass;

        static Load(InName: string): SoundClass;
    }

    export class SoundClassAdjuster {
        constructor();
        constructor(SoundClassObject: SoundClass, VolumeAdjuster: number, PitchAdjuster: number, LowPassFilterFrequency: number, bApplyToChildren: boolean, VoiceCenterChannelVolumeAdjuster: number);

        SoundClassObject: SoundClass;
        VolumeAdjuster: number;
        PitchAdjuster: number;
        LowPassFilterFrequency: number;
        bApplyToChildren: boolean;
        VoiceCenterChannelVolumeAdjuster: number;

        static StaticClass(): Class;
    }

    export class SoundMix extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bApplyEQ: boolean;
        EQPriority: number;
        EQSettings: AudioEQEffect;
        SoundClassEffects: TArray<SoundClassAdjuster>;
        InitialDelay: number;
        FadeInTime: number;
        Duration: number;
        FadeOutTime: number;
        bChanged: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundMix;

        static Load(InName: string): SoundMix;
    }

    export enum EProxyNormalComputationMethod {
        AngleWeighted,
        AreaWeighted,
        EqualWeighted,
        EProxyNormalComputationMethod_MAX
    }

    export enum ELandscapeCullingPrecision { High, Medium, Low, ELandscapeCullingPrecision_MAX }

    export class MeshProxySettings {
        constructor();
        constructor(ScreenSize: number, VoxelSize: number, MaterialSettings: MaterialProxySettings, TextureWidth: number, TextureHeight: number, bExportNormalMap: boolean, bExportMetallicMap: boolean, bExportRoughnessMap: boolean, bExportSpecularMap: boolean, bBakeVertexData: boolean, MergeDistance: number, UnresolvedGeometryColor: Color, MaxRayCastDist: number, HardAngleThreshold: number, LightMapResolution: number, NormalCalculationMethod: EProxyNormalComputationMethod, LandscapeCullingPrecision: ELandscapeCullingPrecision, bCalculateCorrectLODModel: boolean, bOverrideVoxelSize: boolean, bOverrideTransferDistance: boolean, bUseHardAngleThreshold: boolean, bComputeLightMapResolution: boolean, bRecalculateNormals: boolean, bUseLandscapeCulling: boolean, bAllowAdjacency: boolean, bAllowDistanceField: boolean, bReuseMeshLightmapUVs: boolean, bCreateCollision: boolean, bAllowVertexColors: boolean, bGenerateLightmapUVs: boolean);

        ScreenSize: number;
        VoxelSize: number;
        MaterialSettings: MaterialProxySettings;
        TextureWidth: number;
        TextureHeight: number;
        bExportNormalMap: boolean;
        bExportMetallicMap: boolean;
        bExportRoughnessMap: boolean;
        bExportSpecularMap: boolean;
        bBakeVertexData: boolean;
        MergeDistance: number;
        UnresolvedGeometryColor: Color;
        MaxRayCastDist: number;
        HardAngleThreshold: number;
        LightMapResolution: number;
        NormalCalculationMethod: EProxyNormalComputationMethod;
        LandscapeCullingPrecision: ELandscapeCullingPrecision;
        bCalculateCorrectLODModel: boolean;
        bOverrideVoxelSize: boolean;
        bOverrideTransferDistance: boolean;
        bUseHardAngleThreshold: boolean;
        bComputeLightMapResolution: boolean;
        bRecalculateNormals: boolean;
        bUseLandscapeCulling: boolean;
        bAllowAdjacency: boolean;
        bAllowDistanceField: boolean;
        bReuseMeshLightmapUVs: boolean;
        bCreateCollision: boolean;
        bAllowVertexColors: boolean;
        bGenerateLightmapUVs: boolean;

        static StaticClass(): Class;
    }

    export enum EUVOutput { DoNotOutputChannel, OutputChannel, EUVOutput_MAX }

    export enum EMeshLODSelectionType { AllLODs, SpecificLOD, CalculateLOD, LowestDetailLOD, EMeshLODSelectionType_MAX }

    export class MeshMergingSettings {
        constructor();
        constructor(TargetLightMapResolution: number, OutputUVs: FixSizeArray<EUVOutput>, MaterialSettings: MaterialProxySettings, GutterSize: number, SpecificLOD: number, LODSelectionType: EMeshLODSelectionType, bGenerateLightMapUV: boolean, bComputedLightMapResolution: boolean, bPivotPointAtZero: boolean, bMergePhysicsData: boolean, bMergeMaterials: boolean, bCreateMergedMaterial: boolean, bBakeVertexDataToMesh: boolean, bUseVertexDataForBakingMaterial: boolean, bUseTextureBinning: boolean, bReuseMeshLightmapUVs: boolean, bMergeEquivalentMaterials: boolean, bUseLandscapeCulling: boolean, bIncludeImposters: boolean, bAllowDistanceField: boolean, bImportVertexColors: boolean, bCalculateCorrectLODModel: boolean, bExportNormalMap: boolean, bExportMetallicMap: boolean, bExportRoughnessMap: boolean, bExportSpecularMap: boolean, MergedMaterialAtlasResolution: number, ExportSpecificLOD: number);

        TargetLightMapResolution: number;
        OutputUVs: FixSizeArray<EUVOutput>;
        MaterialSettings: MaterialProxySettings;
        GutterSize: number;
        SpecificLOD: number;
        LODSelectionType: EMeshLODSelectionType;
        bGenerateLightMapUV: boolean;
        bComputedLightMapResolution: boolean;
        bPivotPointAtZero: boolean;
        bMergePhysicsData: boolean;
        bMergeMaterials: boolean;
        bCreateMergedMaterial: boolean;
        bBakeVertexDataToMesh: boolean;
        bUseVertexDataForBakingMaterial: boolean;
        bUseTextureBinning: boolean;
        bReuseMeshLightmapUVs: boolean;
        bMergeEquivalentMaterials: boolean;
        bUseLandscapeCulling: boolean;
        bIncludeImposters: boolean;
        bAllowDistanceField: boolean;
        bImportVertexColors: boolean;
        bCalculateCorrectLODModel: boolean;
        bExportNormalMap: boolean;
        bExportMetallicMap: boolean;
        bExportRoughnessMap: boolean;
        bExportSpecularMap: boolean;
        MergedMaterialAtlasResolution: number;
        ExportSpecificLOD: number;

        static StaticClass(): Class;
    }

    export class HierarchicalSimplification {
        constructor();
        constructor(TransitionScreenSize: number, OverrideDrawDistance: number, bUseOverrideDrawDistance: boolean, bAllowSpecificExclusion: boolean, bSimplifyMesh: boolean, bOnlyGenerateClustersForVolumes: boolean, bReusePreviousLevelClusters: boolean, ProxySetting: MeshProxySettings, MergeSetting: MeshMergingSettings, DesiredBoundRadius: number, DesiredFillingPercentage: number, MinNumberOfActorsToBuild: number);

        TransitionScreenSize: number;
        OverrideDrawDistance: number;
        bUseOverrideDrawDistance: boolean;
        bAllowSpecificExclusion: boolean;
        bSimplifyMesh: boolean;
        bOnlyGenerateClustersForVolumes: boolean;
        bReusePreviousLevelClusters: boolean;
        ProxySetting: MeshProxySettings;
        MergeSetting: MeshMergingSettings;
        DesiredBoundRadius: number;
        DesiredFillingPercentage: number;
        MinNumberOfActorsToBuild: number;

        static StaticClass(): Class;
    }

    export class BookmarkBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BookmarkBase;

        static Load(InName: string): BookmarkBase;
    }

    export class BookMark extends BookmarkBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Location: Vector;
        Rotation: Rotator;
        HiddenLevels: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BookMark;

        static Load(InName: string): BookMark;
    }

    export class BroadphaseSettings {
        constructor();
        constructor(bUseMBPOnClient: boolean, bUseMBPOnServer: boolean, bUseMBPOuterBounds: boolean, MBPBounds: Box, MBPOuterBounds: Box, MBPNumSubdivs: number);

        bUseMBPOnClient: boolean;
        bUseMBPOnServer: boolean;
        bUseMBPOuterBounds: boolean;
        MBPBounds: Box;
        MBPOuterBounds: Box;
        MBPNumSubdivs: number;

        static StaticClass(): Class;
    }

    export class NetViewer {
        constructor();
        constructor(Connection: NetConnection, InViewer: Actor, ViewTarget: Actor, ViewLocation: Vector, ViewDir: Vector);

        Connection: NetConnection;
        InViewer: Actor;
        ViewTarget: Actor;
        ViewLocation: Vector;
        ViewDir: Vector;

        static StaticClass(): Class;
    }

    export class WorldSettings extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VisibilityCellSize: number;
        VisibilityAggressiveness: EVisibilityAggressiveness;
        bPrecomputeVisibility: boolean;
        bPlaceCellsOnlyAlongCameraTracks: boolean;
        bEnableWorldBoundsChecks: boolean;
        bEnableNavigationSystem: boolean;
        bEnableAISystem: boolean;
        bEnableWorldComposition: boolean;
        bUseClientSideLevelStreamingVolumes: boolean;
        bEnableWorldOriginRebasing: boolean;
        bWorldGravitySet: boolean;
        bGlobalGravitySet: boolean;
        bMinimizeBSPSections: boolean;
        bForceNoPrecomputedLighting: boolean;
        bHighPriorityLoading: boolean;
        bHighPriorityLoadingLocal: boolean;
        bOverrideDefaultBroadphaseSettings: boolean;
        NavigationSystemConfig: NavigationSystemConfig;
        NavigationSystemConfigOverride: NavigationSystemConfig;
        WorldToMeters: number;
        KillZ: number;
        KillZDamageType: Class;
        WorldGravityZ: number;
        GlobalGravityZ: number;
        DefaultPhysicsVolumeClass: Class;
        PhysicsCollisionHandlerClass: Class;
        DefaultGameMode: Class;
        GameNetworkManagerClass: Class;
        PackedLightAndShadowMapTextureSize: number;
        DefaultColorScale: Vector;
        DefaultMaxDistanceFieldOcclusionDistance: number;
        GlobalDistanceFieldViewDistance: number;
        DynamicIndirectShadowsSelfShadowingIntensity: number;
        LightmassSettings: LightmassWorldInfoSettings;
        DefaultReverbSettings: ReverbSettings;
        DefaultAmbientZoneSettings: InteriorSettings;
        MonoCullingDistance: number;
        DefaultBaseSoundMix: SoundMix;
        bEnableHierarchicalLODSystem: boolean;
        HLODSetupAsset: TSoftClassPtr<HierarchicalLODSetup>;
        OverrideBaseMaterial: TSoftObjectPtr<MaterialInterface>;
        HierarchicalLODSetup: TArray<HierarchicalSimplification>;
        NumHLODLevels: number;
        bGenerateSingleClusterForLevel: boolean;
        BookMarks: FixSizeArray<BookMark>;
        TimeDilation: number;
        MatineeTimeDilation: number;
        DemoPlayTimeDilation: number;
        MinGlobalTimeDilation: number;
        MaxGlobalTimeDilation: number;
        MinUndilatedFrameTime: number;
        MaxUndilatedFrameTime: number;
        BroadphaseSettings: BroadphaseSettings;
        Pauser: PlayerState;
        ReplicationViewers: TArray<NetViewer>;
        AssetUserData: TArray<AssetUserData>;
        PauserPlayerState: PlayerState;
        MaxNumberOfBookmarks: number;
        DefaultBookmarkClass: Class;
        BookmarkArray: TArray<BookmarkBase>;
        LastBookmarkClass: Class;

        OnRep_WorldGravityZ(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WorldSettings;

        static Load(InName: string): WorldSettings;
    }

    export class ReplicatedStaticActorDestructionInfo {
        constructor();
        constructor(ObjClass: Class);

        ObjClass: Class;

        static StaticClass(): Class;
    }

    export class LevelPartitionInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelPartitionInterface;

        static Load(InName: string): LevelPartitionInterface;
    }

    export class Level extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwningWorld: World;
        Model: Model;
        ModelComponents: TArray<ModelComponent>;
        ActorCluster: LevelActorContainer;
        LevelScriptBlueprint: LevelScriptBlueprint;
        TextureStreamingResourceGuids: TArray<Guid>;
        NumTextureStreamingUnbuiltComponents: number;
        NumTextureStreamingDirtyResources: number;
        LevelScriptActor: LevelScriptActor;
        NavListStart: NavigationObjectBase;
        NavListEnd: NavigationObjectBase;
        NavDataChunks: TArray<NavigationDataChunk>;
        LightmapTotalSize: number;
        ShadowmapTotalSize: number;
        StaticNavigableGeometry: TArray<Vector>;
        StreamingTextureGuids: TArray<Guid>;
        LevelBuildDataId: Guid;
        MapBuildData: MapBuildDataRegistry;
        LightBuildLevelOffset: IntVector;
        bIsLightingScenario: boolean;
        bTextureStreamingRotationChanged: boolean;
        bStaticComponentsRegisteredInStreamingManager: boolean;
        bIsVisible: boolean;
        bLocked: boolean;
        LevelSimplification: FixSizeArray<LevelSimplificationDetails>;
        LevelColor: LinearColor;
        bLevelOkayForPlacementWhileCheckedIn: boolean;
        bUseExternalActors: boolean;
        WorldSettings: WorldSettings;
        AssetUserData: TArray<AssetUserData>;
        DestroyedReplicatedStaticActors: TArray<ReplicatedStaticActorDestructionInfo>;
        LevelPartition: LevelPartitionInterface;
        OwnerLevelPartition: TSoftObjectPtr<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Level;

        static Load(InName: string): Level;
    }

    export class LineBatchComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LineBatchComponent;

        static Load(InName: string): LineBatchComponent;
    }

    export class GameNetworkManager extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BadPacketLossThreshold: number;
        SeverePacketLossThreshold: number;
        BadPingThreshold: number;
        SeverePingThreshold: number;
        AdjustedNetSpeed: number;
        LastNetSpeedUpdateTime: number;
        TotalNetBandwidth: number;
        MinDynamicBandwidth: number;
        MaxDynamicBandwidth: number;
        bIsStandbyCheckingEnabled: boolean;
        bHasStandbyCheatTriggered: boolean;
        StandbyRxCheatTime: number;
        StandbyTxCheatTime: number;
        PercentMissingForRxStandby: number;
        PercentMissingForTxStandby: number;
        PercentForBadPing: number;
        JoinInProgressStandbyWaitTime: number;
        MoveRepSize: number;
        MAXPOSITIONERRORSQUARED: number;
        MAXNEARZEROVELOCITYSQUARED: number;
        CLIENTADJUSTUPDATECOST: number;
        MAXCLIENTUPDATEINTERVAL: number;
        MaxClientForcedUpdateDuration: number;
        ServerForcedUpdateHitchThreshold: number;
        ServerForcedUpdateHitchCooldown: number;
        MaxMoveDeltaTime: number;
        MaxClientSmoothingDeltaTime: number;
        ClientNetSendMoveDeltaTime: number;
        ClientNetSendMoveDeltaTimeThrottled: number;
        ClientNetSendMoveDeltaTimeStationary: number;
        ClientNetSendMoveThrottleAtNetSpeed: number;
        ClientNetSendMoveThrottleOverPlayerCount: number;
        ClientAuthorativePosition: boolean;
        ClientErrorUpdateRateLimit: number;
        ClientNetCamUpdateDeltaTime: number;
        ClientNetCamUpdatePositionLimit: number;
        bMovementTimeDiscrepancyDetection: boolean;
        bMovementTimeDiscrepancyResolution: boolean;
        MovementTimeDiscrepancyMaxTimeMargin: number;
        MovementTimeDiscrepancyMinTimeMargin: number;
        MovementTimeDiscrepancyResolutionRate: number;
        MovementTimeDiscrepancyDriftAllowance: number;
        bMovementTimeDiscrepancyForceCorrectionsDuringResolution: boolean;
        bUseDistanceBasedRelevancy: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameNetworkManager;

        static Load(InName: string): GameNetworkManager;
    }

    export class PhysicsCollisionHandler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImpactThreshold: number;
        ImpactReFireDelay: number;
        DefaultImpactSound: SoundBase;
        LastImpactSoundTime: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsCollisionHandler;

        static Load(InName: string): PhysicsCollisionHandler;
    }

    export enum EStreamingVolumeUsage {
        SVB_Loading,
        SVB_LoadingAndVisibility,
        SVB_VisibilityBlockingOnLoad,
        SVB_BlockingOnLoad,
        SVB_LoadingNotVisible,
        SVB_MAX
    }

    export class LevelStreamingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StreamingLevelNames: TArray<string>;
        bEditorPreVisOnly: boolean;
        bDisabled: boolean;
        StreamingUsage: EStreamingVolumeUsage;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelStreamingVolume;

        static Load(InName: string): LevelStreamingVolume;
    }

    export class LevelStreaming extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PackageName: string;
        WorldAsset: TSoftObjectPtr<World>;
        PackageNameToLoad: string;
        LODPackageNames: TArray<string>;
        LevelTransform: Transform;
        LevelLODIndex: number;
        StreamingPriority: number;
        bShouldBeVisibleInEditor: boolean;
        bShouldBeVisible: boolean;
        bShouldBeLoaded: boolean;
        bLocked: boolean;
        bIsStatic: boolean;
        bShouldBlockOnLoad: boolean;
        bShouldBlockOnUnload: boolean;
        bDisableDistanceStreaming: boolean;
        bDrawOnLevelStatusMap: boolean;
        DrawColor: Color;
        LevelColor: LinearColor;
        EditorStreamingVolumes: TArray<LevelStreamingVolume>;
        MinTimeBetweenVolumeUnloadRequests: number;
        Keywords: TArray<string>;
        OnLevelLoaded: $MulticastDelegate<() => void>;
        OnLevelUnloaded: $MulticastDelegate<() => void>;
        OnLevelShown: $MulticastDelegate<() => void>;
        OnLevelHidden: $MulticastDelegate<() => void>;
        LoadedLevel: Level;
        PendingUnloadLevel: Level;
        FolderPath: string;

        CreateInstance(UniqueInstanceName: string): LevelStreaming;

        GetIsRequestingUnloadAndRemoval(): boolean;

        GetLevelScriptActor(): LevelScriptActor;

        GetLoadedLevel(): Level;

        GetWorldAssetPackageFName(): string;

        IsLevelLoaded(): boolean;

        IsLevelVisible(): boolean;

        IsStreamingStatePending(): boolean;

        SetIsRequestingUnloadAndRemoval(bInIsRequestingUnloadAndRemoval: boolean): void;

        SetLevelLODIndex(LODIndex: number): void;

        SetPriority(NewPriority: number): void;

        SetShouldBeLoaded(bInShouldBeLoaded: boolean): void;

        SetShouldBeVisible(bInShouldBeVisible: boolean): void;

        ShouldBeLoaded(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelStreaming;

        static Load(InName: string): LevelStreaming;
    }

    export class StreamingLevelsToConsider {
        constructor();
        constructor(StreamingLevels: TArray<LevelStreaming>);

        StreamingLevels: TArray<LevelStreaming>;

        static StaticClass(): Class;
    }

    export class RollbackNetStartupActorInfo {
        constructor();
        constructor(Archetype: Object, Level: Level, ObjReferences: TArray<Object>);

        Archetype: Object;
        Level: Level;
        ObjReferences: TArray<Object>;

        static StaticClass(): Class;
    }

    export class MulticastRecordOptions {
        constructor();
        constructor(FuncPathName: string, bServerSkip: boolean, bClientSkip: boolean);

        FuncPathName: string;
        bServerSkip: boolean;
        bClientSkip: boolean;

        static StaticClass(): Class;
    }

    export class DemoNetDriver extends NetDriver {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RollbackNetStartupActors: TMap<string, RollbackNetStartupActorInfo>;
        CheckpointSaveMaxMSPerFrame: number;
        MulticastRecordOptions: TArray<MulticastRecordOptions>;
        bIsLocalReplay: boolean;
        SpectatorControllers: TArray<PlayerController>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DemoNetDriver;

        static Load(InName: string): DemoNetDriver;
    }

    export class ParticleEventManager extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleEventManager;

        static Load(InName: string): ParticleEventManager;
    }

    export class NavigationSystemBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationSystemBase;

        static Load(InName: string): NavigationSystemBase;
    }

    export class GameSession extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxSpectators: number;
        MaxPlayers: number;
        MaxPartySize: number;
        MaxSplitscreensPerConnection: number;
        bRequiresPushToTalk: boolean;
        SessionName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameSession;

        static Load(InName: string): GameSession;
    }

    export class GameStateBase extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GameModeClass: Class;
        AuthorityGameMode: GameModeBase;
        SpectatorClass: Class;
        PlayerArray: TArray<PlayerState>;
        bReplicatedHasBegunPlay: boolean;
        ReplicatedWorldTimeSeconds: number;
        ServerWorldTimeSecondsDelta: number;
        ServerWorldTimeSecondsUpdateFrequency: number;

        GetPlayerRespawnDelay(Controller: $Nullable<Controller>): number;

        GetPlayerStartTime(Controller: $Nullable<Controller>): number;

        GetServerWorldTimeSeconds(): number;

        HasBegunPlay(): boolean;

        HasMatchEnded(): boolean;

        HasMatchStarted(): boolean;

        OnRep_GameModeClass(): void;

        OnRep_ReplicatedHasBegunPlay(): void;

        OnRep_ReplicatedWorldTimeSeconds(): void;

        OnRep_SpectatorClass(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameStateBase;

        static Load(InName: string): GameStateBase;
    }

    export class ServerStatReplicator extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUpdateStatNet: boolean;
        bOverwriteClientStats: boolean;
        Channels: number;
        InRate: number;
        OutRate: number;
        MaxPacketOverhead: number;
        InRateClientMax: number;
        InRateClientMin: number;
        InRateClientAvg: number;
        InPacketsClientMax: number;
        InPacketsClientMin: number;
        InPacketsClientAvg: number;
        OutRateClientMax: number;
        OutRateClientMin: number;
        OutRateClientAvg: number;
        OutPacketsClientMax: number;
        OutPacketsClientMin: number;
        OutPacketsClientAvg: number;
        NetNumClients: number;
        InPackets: number;
        OutPackets: number;
        InBunches: number;
        OutBunches: number;
        OutLoss: number;
        InLoss: number;
        VoiceBytesSent: number;
        VoiceBytesRecv: number;
        VoicePacketsSent: number;
        VoicePacketsRecv: number;
        PercentInVoice: number;
        PercentOutVoice: number;
        NumActorChannels: number;
        NumConsideredActors: number;
        PrioritizedActors: number;
        NumRelevantActors: number;
        NumRelevantDeletedActors: number;
        NumReplicatedActorAttempts: number;
        NumReplicatedActors: number;
        NumActors: number;
        NumNetActors: number;
        NumDormantActors: number;
        NumInitiallyDormantActors: number;
        NumNetGUIDsAckd: number;
        NumNetGUIDsPending: number;
        NumNetGUIDsUnAckd: number;
        ObjPathBytes: number;
        NetGUIDOutRate: number;
        NetGUIDInRate: number;
        NetSaturated: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ServerStatReplicator;

        static Load(InName: string): ServerStatReplicator;
    }

    export class GameModeBase extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OptionsString: string;
        GameSessionClass: Class;
        GameStateClass: Class;
        PlayerControllerClass: Class;
        PlayerStateClass: Class;
        HUDClass: Class;
        DefaultPawnClass: Class;
        SpectatorClass: Class;
        ReplaySpectatorPlayerControllerClass: Class;
        ServerStatReplicatorClass: Class;
        GameSession: GameSession;
        GameState: GameStateBase;
        ServerStatReplicator: ServerStatReplicator;
        DefaultPlayerName: string;
        bUseSeamlessTravel: boolean;
        bStartPlayersAsSpectators: boolean;
        bPauseable: boolean;

        CanSpectate(Viewer: $Nullable<PlayerController>, ViewTarget: $Nullable<PlayerState>): boolean;

        ChangeName(Controller: $Nullable<Controller>, NewName: string, bNameChange: boolean): void;

        ChoosePlayerStart(Player: $Nullable<Controller>): Actor;

        FindPlayerStart(Player: $Nullable<Controller>, IncomingName: string): Actor;

        GetDefaultPawnClassForController(InController: $Nullable<Controller>): Class;

        GetNumPlayers(): number;

        GetNumSpectators(): number;

        HandleStartingNewPlayer(NewPlayer: $Nullable<PlayerController>): void;

        HasMatchEnded(): boolean;

        HasMatchStarted(): boolean;

        InitializeHUDForPlayer(NewPlayer: $Nullable<PlayerController>): void;

        InitStartSpot(StartSpot: $Nullable<Actor>, NewPlayer: $Nullable<Controller>): void;

        K2_FindPlayerStart(Player: $Nullable<Controller>, IncomingName?: string /* = "" */): Actor;

        K2_OnChangeName(Other: $Nullable<Controller>, NewName: string, bNameChange: boolean): void;

        K2_OnLogout(ExitingController: $Nullable<Controller>): void;

        K2_OnRestartPlayer(NewPlayer: $Nullable<Controller>): void;

        K2_OnSwapPlayerControllers(OldPC: $Nullable<PlayerController>, NewPC: $Nullable<PlayerController>): void;

        K2_PostLogin(NewPlayer: $Nullable<PlayerController>): void;

        MustSpectate(NewPlayerController: $Nullable<PlayerController>): boolean;

        PlayerCanRestart(Player: $Nullable<PlayerController>): boolean;

        ResetLevel(): void;

        RestartPlayer(NewPlayer: $Nullable<Controller>): void;

        RestartPlayerAtPlayerStart(NewPlayer: $Nullable<Controller>, StartSpot: $Nullable<Actor>): void;

        RestartPlayerAtTransform(NewPlayer: $Nullable<Controller>, SpawnTransform: Transform): void;

        ReturnToMainMenuHost(): void;

        ShouldReset(ActorToReset: $Nullable<Actor>): boolean;

        SpawnDefaultPawnAtTransform(NewPlayer: $Nullable<Controller>, SpawnTransform: Transform): Pawn;

        SpawnDefaultPawnFor(NewPlayer: $Nullable<Controller>, StartSpot: $Nullable<Actor>): Pawn;

        StartPlay(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameModeBase;

        static Load(InName: string): GameModeBase;
    }

    export class AISystemBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AISystemClassName: SoftClassPath;
        AISystemModuleName: string;
        bInstantiateAISystemOnClient: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISystemBase;

        static Load(InName: string): AISystemBase;
    }

    export class AvoidanceManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultTimeToLive: number;
        LockTimeAfterAvoid: number;
        LockTimeAfterClean: number;
        DeltaTimeToPredict: number;
        ArtificialRadiusExpansion: number;
        TestHeightDifference: number;
        HeightCheckMargin: number;

        GetAvoidanceVelocityForComponent(MovementComp: $Nullable<MovementComponent>): Vector;

        GetNewAvoidanceUID(): number;

        GetObjectCount(): number;

        RegisterMovementComponent(MovementComp: $Nullable<MovementComponent>, AvoidanceWeight?: number /* = 0.500000 */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AvoidanceManager;

        static Load(InName: string): AvoidanceManager;
    }

    export class LevelCollection {
        constructor();
        constructor(GameState: GameStateBase, NetDriver: NetDriver, DemoNetDriver: DemoNetDriver, PersistentLevel: Level, Levels: TSet<Level>);

        GameState: GameStateBase;
        NetDriver: NetDriver;
        DemoNetDriver: DemoNetDriver;
        PersistentLevel: Level;
        Levels: TSet<Level>;

        static StaticClass(): Class;
    }

    export class ScriptViewportClient extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScriptViewportClient;

        static Load(InName: string): ScriptViewportClient;
    }

    export class Console extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConsoleTargetPlayer: LocalPlayer;
        DefaultTexture_Black: Texture2D;
        DefaultTexture_White: Texture2D;
        HistoryBuffer: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Console;

        static Load(InName: string): Console;
    }

    export class DebugDisplayProperty {
        constructor();
        constructor(Obj: Object, WithinClass: Class);

        Obj: Object;
        WithinClass: Class;

        static StaticClass(): Class;
    }

    export class GameViewportClient extends ScriptViewportClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ViewportConsole: Console;
        DebugProperties: TArray<DebugDisplayProperty>;
        MaxSplitscreenPlayers: number;
        World: World;
        GameInstance: GameInstance;

        SetConsoleTarget(PlayerIndex: number): void;

        ShowTitleSafeArea(): void;

        SSSwapControllers(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameViewportClient;

        static Load(InName: string): GameViewportClient;
    }

    export enum EAspectRatioAxisConstraint {
        AspectRatio_MaintainYFOV,
        AspectRatio_MaintainXFOV,
        AspectRatio_MajorAxisFOV,
        AspectRatio_MAX
    }

    export class LocalPlayer extends Player {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ViewportClient: GameViewportClient;
        AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
        PendingLevelPlayerControllerClass: Class;
        bSentSplitJoin: boolean;
        ControllerId: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalPlayer;

        static Load(InName: string): LocalPlayer;
    }

    export class OnlineSession extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineSession;

        static Load(InName: string): OnlineSession;
    }

    export enum ETravelFailure {
        NoLevel,
        LoadMapFailure,
        InvalidURL,
        PackageMissing,
        PackageVersion,
        NoDownload,
        TravelFailure,
        CheatCommands,
        PendingNetGameCreateFailure,
        CloudSaveFailure,
        ServerTravelFailure,
        ClientTravelFailure,
        ETravelFailure_MAX
    }

    export enum ENetworkFailure {
        NetDriverAlreadyExists,
        NetDriverCreateFailure,
        NetDriverListenFailure,
        ConnectionLost,
        ConnectionTimeout,
        FailureReceived,
        OutdatedClient,
        OutdatedServer,
        PendingConnectionFailure,
        NetGuidMismatch,
        NetChecksumMismatch,
        ENetworkFailure_MAX
    }

    export class GameInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LocalPlayers: TArray<LocalPlayer>;
        OnlineSession: OnlineSession;
        ReferencedObjects: TArray<Object>;
        OnPawnControllerChangedDelegates: $MulticastDelegate<(Pawn: $Nullable<Pawn>, Controller: $Nullable<Controller>) => void>;

        DebugCreatePlayer(ControllerId: number): void;

        DebugRemovePlayer(ControllerId: number): void;

        HandleNetworkError(FailureType: ENetworkFailure, bIsServer: boolean): void;

        HandleTravelError(FailureType: ETravelFailure): void;

        ReceiveInit(): void;

        ReceiveShutdown(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameInstance;

        static Load(InName: string): GameInstance;
    }

    export class MaterialParameterCollectionInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Collection: MaterialParameterCollection;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollectionInstance;

        static Load(InName: string): MaterialParameterCollectionInstance;
    }

    export class LevelViewportInfo {
        constructor();
        constructor(CamPosition: Vector, CamRotation: Rotator, CamOrthoZoom: number, CamUpdated: boolean);

        CamPosition: Vector;
        CamRotation: Rotator;
        CamOrthoZoom: number;
        CamUpdated: boolean;

        static StaticClass(): Class;
    }

    export class WorldComposition extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TilesStreaming: TArray<LevelStreaming>;
        TilesStreamingTimeThreshold: number;
        bLoadAllTilesDuringCinematic: boolean;
        bRebaseOriginIn3DSpace: boolean;
        bLockTilesLocation: boolean;
        RebaseOriginDistance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WorldComposition;

        static Load(InName: string): WorldComposition;
    }

    export class PSCPoolElem {
        constructor();
        constructor(PSC: ParticleSystemComponent);

        PSC: ParticleSystemComponent;

        static StaticClass(): Class;
    }

    export class PSCPool {
        constructor();
        constructor(FreeElements: TArray<PSCPoolElem>, InUseComponents_Auto: TArray<ParticleSystemComponent>, InUseComponents_Manual: TArray<ParticleSystemComponent>);

        FreeElements: TArray<PSCPoolElem>;
        InUseComponents_Auto: TArray<ParticleSystemComponent>;
        InUseComponents_Manual: TArray<ParticleSystemComponent>;

        static StaticClass(): Class;
    }

    export class WorldPSCPool {
        constructor();
        constructor(WorldParticleSystemPools: TMap<ParticleSystem, PSCPool>);

        WorldParticleSystemPools: TMap<ParticleSystem, PSCPool>;

        static StaticClass(): Class;
    }

    export enum ESpawnActorCollisionHandlingMethod {
        Undefined,
        AlwaysSpawn,
        AdjustIfPossibleButAlwaysSpawn,
        AdjustIfPossibleButDontSpawnIfColliding,
        DontSpawnIfColliding,
        ESpawnActorCollisionHandlingMethod_MAX
    }

    export class World extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Layers: TArray<Layer>;
        ActiveGroupActors: TArray<Actor>;
        ThumbnailInfo: ThumbnailInfo;
        PersistentLevel: Level;
        NetDriver: NetDriver;
        LineBatcher: LineBatchComponent;
        PersistentLineBatcher: LineBatchComponent;
        ForegroundLineBatcher: LineBatchComponent;
        NetworkManager: GameNetworkManager;
        PhysicsCollisionHandler: PhysicsCollisionHandler;
        ExtraReferencedObjects: TArray<Object>;
        PerModuleDataObjects: TArray<Object>;
        StreamingLevels: TArray<LevelStreaming>;
        StreamingLevelsToConsider: StreamingLevelsToConsider;
        StreamingLevelsPrefix: string;
        CurrentLevelPendingVisibility: Level;
        CurrentLevelPendingInvisibility: Level;
        DemoNetDriver: DemoNetDriver;
        MyParticleEventManager: ParticleEventManager;
        DefaultPhysicsVolume: PhysicsVolume;
        bAreConstraintsDirty: boolean;
        NavigationSystem: NavigationSystemBase;
        AuthorityGameMode: GameModeBase;
        GameState: GameStateBase;
        AISystem: AISystemBase;
        AvoidanceManager: AvoidanceManager;
        Levels: TArray<Level>;
        LevelCollections: TArray<LevelCollection>;
        CurrentLevel: Level;
        OwningGameInstance: GameInstance;
        ParameterCollectionInstances: TArray<MaterialParameterCollectionInstance>;
        CanvasForRenderingToTarget: Canvas;
        CanvasForDrawMaterialToRenderTarget: Canvas;
        EditorViews: TArray<LevelViewportInfo>;
        ComponentsThatNeedPreEndOfFrameSync: TSet<ActorComponent>;
        ComponentsThatNeedEndOfFrameUpdate: TArray<ActorComponent>;
        ComponentsThatNeedEndOfFrameUpdate_OnGameThread: TArray<ActorComponent>;
        SelectedLevels: TArray<Level>;
        WorldComposition: WorldComposition;
        PSCPool: WorldPSCPool;

        GetFirstPlayerController(): PlayerController;

        GetGameViewportSize(): Vector2D;

        GetMousePosition(): Vector2D;

        HandleTimelineScrubbed(): void;

        K2_GetWorldSettings(): WorldSettings;

        SpawnActor(Class: $Nullable<Class>, Transform: Transform, SpawnCollisionHandlingOverride: ESpawnActorCollisionHandlingMethod, Owner: $Nullable<Actor>, Instigator: $Nullable<Pawn>): Actor;

        SpawnActorAndAttach(Class: $Nullable<Class>, Owner: $Nullable<Actor>): Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): World;

        static Load(InName: string): World;
    }

    export class Package extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Package;

        static Load(InName: string): Package;
    }

    export class ChannelDefinition {
        constructor();
        constructor(ChannelName: string, ClassName: string, ChannelClass: Class, StaticChannelIndex: number, bTickOnCreate: boolean, bServerOpen: boolean, bClientOpen: boolean, bInitialServer: boolean, bInitialClient: boolean);

        ChannelName: string;
        ClassName: string;
        ChannelClass: Class;
        StaticChannelIndex: number;
        bTickOnCreate: boolean;
        bServerOpen: boolean;
        bClientOpen: boolean;
        bInitialServer: boolean;
        bInitialClient: boolean;

        static StaticClass(): Class;
    }

    export class Channel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Connection: NetConnection;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Channel;

        static Load(InName: string): Channel;
    }

    export class ReplicationDriver extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReplicationDriver;

        static Load(InName: string): ReplicationDriver;
    }

    export class NetDriver extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NetConnectionClassName: string;
        ReplicationDriverClassName: string;
        MaxDownloadSize: number;
        bClampListenServerTickRate: boolean;
        NetServerMaxTickRate: number;
        MaxNetTickRate: number;
        MaxInternetClientRate: number;
        MaxClientRate: number;
        ServerTravelPause: number;
        SpawnPrioritySeconds: number;
        RelevantTimeout: number;
        KeepAliveTime: number;
        InitialConnectTimeout: number;
        ConnectionTimeout: number;
        TimeoutMultiplierForUnoptimizedBuilds: number;
        bNoTimeouts: boolean;
        bNeverApplyNetworkEmulationSettings: boolean;
        ServerConnection: NetConnection;
        ClientConnections: TArray<NetConnection>;
        RecentlyDisconnectedTrackingTime: number;
        World: World;
        WorldPackage: Package;
        NetConnectionClass: Class;
        ReplicationDriverClass: Class;
        NetDriverName: string;
        ChannelDefinitions: TArray<ChannelDefinition>;
        ChannelDefinitionMap: TMap<string, ChannelDefinition>;
        ActorChannelPool: TArray<Channel>;
        Time: number;
        ReplicationDriver: ReplicationDriver;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NetDriver;

        static Load(InName: string): NetDriver;
    }

    export class PackageMap extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PackageMap;

        static Load(InName: string): PackageMap;
    }

    export class NetConnection extends Player {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Children: TArray<ChildConnection>;
        Driver: NetDriver;
        PackageMapClass: Class;
        PackageMap: PackageMap;
        OpenChannels: TArray<Channel>;
        SentTemporaries: TArray<Actor>;
        ViewTarget: Actor;
        OwningActor: Actor;
        MaxPacket: number;
        InternalAck: boolean;
        PlayerId: UniqueNetIdRepl;
        LastReceiveTime: number;
        ChannelsToTick: TArray<Channel>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NetConnection;

        static Load(InName: string): NetConnection;
    }

    export enum EMouseCursor {
        None,
        Default,
        TextEditBeam,
        ResizeLeftRight,
        ResizeUpDown,
        ResizeSouthEast,
        ResizeSouthWest,
        CardinalCross,
        Crosshairs,
        Hand,
        GrabHand,
        GrabHandClosed,
        SlashedCircle,
        EyeDropper,
        EMouseCursor_MAX
    }

    export class CachedKeyToActionInfo {
        constructor();
        constructor(PlayerInput: PlayerInput);

        PlayerInput: PlayerInput;

        static StaticClass(): Class;
    }

    export enum EControllerAnalogStick { CAS_LeftStick, CAS_RightStick, CAS_MAX }

    export class InputComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CachedKeyToActionInfo: TArray<CachedKeyToActionInfo>;

        GetControllerAnalogKeyState(Key: Key): number;

        GetControllerAnalogStickState(WhichStick: EControllerAnalogStick, StickX: $Ref<number>, StickY: $Ref<number>): void;

        GetControllerKeyTimeDown(Key: Key): number;

        GetControllerMouseDelta(DeltaX: $Ref<number>, DeltaY: $Ref<number>): void;

        GetControllerVectorKeyState(Key: Key): Vector;

        GetTouchState(FingerIndex: number, LocationX: $Ref<number>, LocationY: $Ref<number>, bIsCurrentlyPressed: $Ref<boolean>): void;

        IsControllerKeyDown(Key: Key): boolean;

        WasControllerKeyJustPressed(Key: Key): boolean;

        WasControllerKeyJustReleased(Key: Key): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputComponent;

        static Load(InName: string): InputComponent;
    }

    export class TouchInputControl {
        constructor();
        constructor(Image1: Texture2D, Image2: Texture2D, Center: Vector2D, VisualSize: Vector2D, ThumbSize: Vector2D, InteractionSize: Vector2D, InputScale: Vector2D, MainInputKey: Key, AltInputKey: Key);

        Image1: Texture2D;
        Image2: Texture2D;
        Center: Vector2D;
        VisualSize: Vector2D;
        ThumbSize: Vector2D;
        InteractionSize: Vector2D;
        InputScale: Vector2D;
        MainInputKey: Key;
        AltInputKey: Key;

        static StaticClass(): Class;
    }

    export class TouchInterface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Controls: TArray<TouchInputControl>;
        ActiveOpacity: number;
        InactiveOpacity: number;
        TimeUntilDeactive: number;
        TimeUntilReset: number;
        ActivationDelay: number;
        bPreventRecenter: boolean;
        StartupDelay: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TouchInterface;

        static Load(InName: string): TouchInterface;
    }

    export class SphereComponent extends ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SphereRadius: number;

        GetScaledSphereRadius(): number;

        GetShapeScale(): number;

        GetUnscaledSphereRadius(): number;

        SetSphereRadius(InSphereRadius: number, bUpdateOverlaps?: boolean /* = true */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SphereComponent;

        static Load(InName: string): SphereComponent;
    }

    export class StaticMeshComponentLODInfo {
        constructor();

        static StaticClass(): Class;
    }

    export class StreamingTextureBuildInfo {
        constructor();
        constructor(PackedRelativeBox: number, TextureLevelIndex: number, TexelFactor: number);

        PackedRelativeBox: number;
        TextureLevelIndex: number;
        TexelFactor: number;

        static StaticClass(): Class;
    }

    export class LightmassPrimitiveSettings {
        constructor();
        constructor(bUseTwoSidedLighting: boolean, bShadowIndirectOnly: boolean, bUseEmissiveForStaticLighting: boolean, bUseVertexNormalForHemisphereGather: boolean, EmissiveLightFalloffExponent: number, EmissiveLightExplicitInfluenceRadius: number, EmissiveBoost: number, DiffuseBoost: number, FullyOccludedSamplesFraction: number);

        bUseTwoSidedLighting: boolean;
        bShadowIndirectOnly: boolean;
        bUseEmissiveForStaticLighting: boolean;
        bUseVertexNormalForHemisphereGather: boolean;
        EmissiveLightFalloffExponent: number;
        EmissiveLightExplicitInfluenceRadius: number;
        EmissiveBoost: number;
        DiffuseBoost: number;
        FullyOccludedSamplesFraction: number;

        static StaticClass(): Class;
    }

    export class StaticMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ForcedLodModel: number;
        PreviousLODLevel: number;
        MinLOD: number;
        ShadowLODBias: number;
        SubDivisionStepSize: number;
        StaticMesh: StaticMesh;
        SpecifyPassIndex: number;
        UnifyPassMaterialParams: MultiPassMeshMaterialParam;
        OutlineMaterialType: EOutlineMaterialType;
        PassArray: TArray<MultiPassMeshParam>;
        OutlinePassIndex: number;
        WireframeColorOverride: Color;
        bEvaluateWorldPositionOffset: boolean;
        SelectedEditorSection: number;
        SelectedEditorMaterial: number;
        SectionIndexPreview: number;
        MaterialIndexPreview: number;
        StaticMeshImportVersion: number;
        bOverrideWireframeColor: boolean;
        bOverrideMinLOD: boolean;
        bOverrideShadowLODBias: boolean;
        bOverrideNavigationExport: boolean;
        bForceNavigationObstacle: boolean;
        bDisallowMeshPaintPerInstance: boolean;
        bIgnoreInstanceForTextureStreaming: boolean;
        bOverrideLightMapRes: boolean;
        bCastDistanceFieldIndirectShadow: boolean;
        bOverrideDistanceFieldSelfShadowBias: boolean;
        bUseSubDivisions: boolean;
        bUseDefaultCollision: boolean;
        bCustomOverrideVertexColorPerLOD: boolean;
        bDisplayVertexColors: boolean;
        bDisplayPhysicalMaterialMasks: boolean;
        bReverseCulling: boolean;
        OverriddenLightMapRes: number;
        DistanceFieldIndirectShadowMinVisibility: number;
        DistanceFieldSelfShadowBias: number;
        StreamingDistanceMultiplier: number;
        IrrelevantLights: TArray<Guid>;
        LODData: TArray<StaticMeshComponentLODInfo>;
        StreamingTextureData: TArray<StreamingTextureBuildInfo>;
        StaticMeshDerivedDataKey: string;
        MaterialStreamingRelativeBoxes: TArray<number>;
        LightmassSettings: LightmassPrimitiveSettings;

        GetLocalBounds(Min: $Ref<Vector>, Max: $Ref<Vector>): void;

        OnRep_StaticMesh(OldStaticMesh: $Nullable<StaticMesh>): void;

        OutlineEffectAdd(): void;

        OutlineEffectRemove(): void;

        SetDistanceFieldSelfShadowBias(NewValue: number): void;

        SetEvaluateWorldPositionOffsetInRayTracing(NewValue: boolean): void;

        SetForcedLodModel(NewForcedLodModel: number): void;

        SetReverseCulling(ReverseCulling: boolean): void;

        SetStaticMesh(NewMesh: $Nullable<StaticMesh>): boolean;

        UnifySpecifyPassWithOutlineMaterialType(): void;

        UnifySpecifyPassWithPassMaterialParams(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshComponent;

        static Load(InName: string): StaticMeshComponent;
    }

    export class DefaultPawn extends Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BaseTurnRate: number;
        BaseLookUpRate: number;
        MovementComponent: PawnMovementComponent;
        CollisionComponent: SphereComponent;
        MeshComponent: StaticMeshComponent;
        bAddDefaultMovementBindings: boolean;

        LookUpAtRate(Rate: number): void;

        MoveForward(Val: number): void;

        MoveRight(Val: number): void;

        MoveUp_World(Val: number): void;

        TurnAtRate(Rate: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DefaultPawn;

        static Load(InName: string): DefaultPawn;
    }

    export class SpectatorPawn extends DefaultPawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpectatorPawn;

        static Load(InName: string): SpectatorPawn;
    }

    export enum EControllerHand {
        Left,
        Right,
        AnyHand,
        Pad,
        ExternalCamera,
        Gun,
        Special_1,
        Special_2,
        Special_3,
        Special_4,
        Special_5,
        Special_6,
        Special_7,
        Special_8,
        Special_9,
        Special_10,
        Special_11,
        ControllerHand_Count,
        EControllerHand_MAX
    }

    export enum EViewTargetBlendFunction {
        VTBlend_Linear,
        VTBlend_Cubic,
        VTBlend_EaseIn,
        VTBlend_EaseOut,
        VTBlend_EaseInOut,
        VTBlend_MAX
    }

    export class Visual extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Visual;

        static Load(InName: string): Visual;
    }

    export class PanelWidget extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Slots: TArray<PanelSlot>;

        AddChild(Content: $Nullable<Widget>): PanelSlot;

        ClearChildren(): void;

        GetAllChildren(): TArray<Widget>;

        GetChildAt(Index: number): Widget;

        GetChildIndex(Content: $Nullable<Widget>): number;

        GetChildrenCount(): number;

        HasAnyChildren(): boolean;

        HasChild(Content: $Nullable<Widget>): boolean;

        RemoveChild(Content: $Nullable<Widget>): boolean;

        RemoveChildAt(Index: number): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PanelWidget;

        static Load(InName: string): PanelWidget;
    }

    export class PanelSlot extends Visual {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Parent: PanelWidget;
        Content: Widget;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PanelSlot;

        static Load(InName: string): PanelSlot;
    }

    export enum ESlateVisibility {
        Visible,
        Collapsed,
        Hidden,
        HitTestInvisible,
        SelfHitTestInvisible,
        ESlateVisibility_MAX
    }

    export class WidgetTransform {
        constructor();
        constructor(Translation: Vector2D, Scale: Vector2D, Shear: Vector2D, Angle: number);

        Translation: Vector2D;
        Scale: Vector2D;
        Shear: Vector2D;
        Angle: number;

        static StaticClass(): Class;
    }

    export enum ESlateAccessibleBehavior { NotAccessible, Auto, Summary, Custom, ToolTip, ESlateAccessibleBehavior_MAX }

    export class SlateAccessibleWidgetData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCanChildrenBeAccessible: boolean;
        AccessibleBehavior: ESlateAccessibleBehavior;
        AccessibleSummaryBehavior: ESlateAccessibleBehavior;
        AccessibleText: string;
        AccessibleTextDelegate: $Delegate<() => string>;
        AccessibleSummaryText: string;
        AccessibleSummaryTextDelegate: $Delegate<() => string>;

        GetText__DelegateSignature(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateAccessibleWidgetData;

        static Load(InName: string): SlateAccessibleWidgetData;
    }

    export enum EWidgetClipping {
        Inherit,
        ClipToBounds,
        ClipToBoundsWithoutIntersecting,
        ClipToBoundsAlways,
        OnDemand,
        EWidgetClipping_MAX
    }

    export enum EUINavigation { Left, Right, Up, Down, Next, Previous, Num, Invalid, EUINavigation_MAX }

    export enum EUINavigationRule {
        Escape,
        Explicit,
        Wrap,
        Stop,
        Custom,
        CustomBoundary,
        Invalid,
        EUINavigationRule_MAX
    }

    export class WidgetNavigationData {
        constructor();
        constructor(Rule: EUINavigationRule, WidgetToFocus: string, Widget: TWeakObjectPtr<Widget>, CustomDelegate: $Delegate<(Navigation: EUINavigation) => Widget>);

        Rule: EUINavigationRule;
        WidgetToFocus: string;
        Widget: TWeakObjectPtr<Widget>;
        CustomDelegate: $Delegate<(Navigation: EUINavigation) => Widget>;

        static StaticClass(): Class;
    }

    export class WidgetNavigation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Up: WidgetNavigationData;
        Down: WidgetNavigationData;
        Left: WidgetNavigationData;
        Right: WidgetNavigationData;
        Next: WidgetNavigationData;
        Previous: WidgetNavigationData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetNavigation;

        static Load(InName: string): WidgetNavigation;
    }

    export enum EFlowDirectionPreference { Inherit, Culture, LeftToRight, RightToLeft, EFlowDirectionPreference_MAX }

    export class PropertyPathSegment {
        constructor();
        constructor(Name: string, ArrayIndex: number, Struct: Struct);

        Name: string;
        ArrayIndex: number;
        Struct: Struct;

        static StaticClass(): Class;
    }

    export class CachedPropertyPath {
        constructor();
        constructor(Segments: TArray<PropertyPathSegment>, CachedFunction: Function);

        Segments: TArray<PropertyPathSegment>;
        CachedFunction: Function;

        static StaticClass(): Class;
    }

    export class DynamicPropertyPath extends CachedPropertyPath {
        constructor();

        static StaticClass(): Class;
    }

    export class PropertyBinding extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceObject: TWeakObjectPtr<Object>;
        SourcePath: DynamicPropertyPath;
        DestinationProperty: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyBinding;

        static Load(InName: string): PropertyBinding;
    }

    export class EventReply {
        constructor();

        static StaticClass(): Class;
    }

    export class Geometry {
        constructor();

        static StaticClass(): Class;
    }

    export class InputEvent {
        constructor();

        static StaticClass(): Class;
    }

    export class PointerEvent extends InputEvent {
        constructor();

        static StaticClass(): Class;
    }

    export enum ESlateColorStylingMode {
        UseColor_Specified,
        UseColor_Specified_Link,
        UseColor_Foreground,
        UseColor_Foreground_Subdued,
        UseColor_MAX
    }

    export class SlateColor {
        constructor();
        constructor(SpecifiedColor: LinearColor, ColorUseRule: ESlateColorStylingMode);

        SpecifiedColor: LinearColor;
        ColorUseRule: ESlateColorStylingMode;

        static StaticClass(): Class;
    }

    export class Margin {
        constructor();
        constructor(Left: number, Top: number, Right: number, Bottom: number);

        Left: number;
        Top: number;
        Right: number;
        Bottom: number;

        static StaticClass(): Class;
    }

    export enum ESlateBrushDrawType { NoDrawType, Box, Border, Image, ESlateBrushDrawType_MAX }

    export enum ESlateBrushTileType { NoTile, Horizontal, Vertical, Both, ESlateBrushTileType_MAX }

    export enum ESlateBrushMirrorType { NoMirror, Horizontal, Vertical, Both, ESlateBrushMirrorType_MAX }

    export enum ESlateBrushImageType { NoImage, FullColor, Linear, ESlateBrushImageType_MAX }

    export class SlateBrush {
        constructor();
        constructor(ImageSize: Vector2D, Margin: Margin, Tint: LinearColor, TintColor: SlateColor, ResourceObject: Object, ResourceName: string, UVRegion: Box2D, DrawAs: ESlateBrushDrawType, Tiling: ESlateBrushTileType, Mirroring: ESlateBrushMirrorType, ImageType: ESlateBrushImageType, bIsDynamicallyLoaded: boolean, bHasUObject: boolean);

        ImageSize: Vector2D;
        Margin: Margin;
        Tint: LinearColor;
        TintColor: SlateColor;
        ResourceObject: Object;
        ResourceName: string;
        UVRegion: Box2D;
        DrawAs: ESlateBrushDrawType;
        Tiling: ESlateBrushTileType;
        Mirroring: ESlateBrushMirrorType;
        ImageType: ESlateBrushImageType;
        bIsDynamicallyLoaded: boolean;
        bHasUObject: boolean;

        static StaticClass(): Class;
    }

    export enum ECheckBoxState { Unchecked, Checked, Undetermined, ECheckBoxState_MAX }

    export class Widget extends Visual {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Slot: PanelSlot;
        bIsEnabledDelegate: $Delegate<() => boolean>;
        ToolTipText: string;
        ToolTipTextDelegate: $Delegate<() => string>;
        ToolTipWidget: Widget;
        ToolTipWidgetDelegate: $Delegate<() => Widget>;
        VisibilityDelegate: $Delegate<() => ESlateVisibility>;
        RenderTransform: WidgetTransform;
        RenderTransformPivot: Vector2D;
        bIsVariable: boolean;
        bCreatedByConstructionScript: boolean;
        bIsEnabled: boolean;
        bOverride_Cursor: boolean;
        bOverrideAccessibleDefaults: boolean;
        bCanChildrenBeAccessible: boolean;
        AccessibleBehavior: ESlateAccessibleBehavior;
        AccessibleSummaryBehavior: ESlateAccessibleBehavior;
        AccessibleText: string;
        AccessibleTextDelegate: $Delegate<() => string>;
        AccessibleSummaryText: string;
        AccessibleSummaryTextDelegate: $Delegate<() => string>;
        AccessibleWidgetData: SlateAccessibleWidgetData;
        bIsVolatile: boolean;
        bHiddenInDesigner: boolean;
        bExpandedInDesigner: boolean;
        bLockedInDesigner: boolean;
        Cursor: EMouseCursor;
        Clipping: EWidgetClipping;
        Visibility: ESlateVisibility;
        RenderOpacity: number;
        Navigation: WidgetNavigation;
        FlowDirectionPreference: EFlowDirectionPreference;
        NativeBindings: TArray<PropertyBinding>;
        DesignerFlags: number;
        DisplayLabel: string;
        CategoryName: string;

        ForceLayoutPrepass(): void;

        ForceVolatile(bForce: boolean): void;

        GenerateWidgetForObject__DelegateSignature(Item: $Nullable<Object>): Widget;

        GenerateWidgetForString__DelegateSignature(Item: string): Widget;

        GetAccessibleSummaryText(): string;

        GetAccessibleText(): string;

        GetBool__DelegateSignature(): boolean;

        GetCachedGeometry(): Geometry;

        GetCheckBoxState__DelegateSignature(): ECheckBoxState;

        GetClipping(): EWidgetClipping;

        GetDesiredSize(): Vector2D;

        GetFloat__DelegateSignature(): number;

        GetGameInstance(): GameInstance;

        GetInt32__DelegateSignature(): number;

        GetIsEnabled(): boolean;

        GetLinearColor__DelegateSignature(): LinearColor;

        GetMouseCursor__DelegateSignature(): EMouseCursor;

        GetOwningLocalPlayer(): LocalPlayer;

        GetOwningPlayer(): PlayerController;

        GetPaintSpaceGeometry(): Geometry;

        GetParent(): PanelWidget;

        GetRenderOpacity(): number;

        GetRenderTransformAngle(): number;

        GetSlateBrush__DelegateSignature(): SlateBrush;

        GetSlateColor__DelegateSignature(): SlateColor;

        GetSlateVisibility__DelegateSignature(): ESlateVisibility;

        GetText__DelegateSignature(): string;

        GetTickSpaceGeometry(): Geometry;

        GetVisibility(): ESlateVisibility;

        GetWidget__DelegateSignature(): Widget;

        HasAnyUserFocus(): boolean;

        HasFocusedDescendants(): boolean;

        HasKeyboardFocus(): boolean;

        HasMouseCapture(): boolean;

        HasMouseCaptureByUser(UserIndex: number, PointerIndex?: number /* = -1 */): boolean;

        HasUserFocus(PlayerController: $Nullable<PlayerController>): boolean;

        HasUserFocusedDescendants(PlayerController: $Nullable<PlayerController>): boolean;

        InvalidateLayoutAndVolatility(): void;

        IsHovered(): boolean;

        IsVisible(): boolean;

        OnPointerEvent__DelegateSignature(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;

        OnReply__DelegateSignature(): EventReply;

        RemoveFromParent(): void;

        ResetCursor(): void;

        SetAllNavigationRules(Rule: EUINavigationRule, WidgetToFocus: string): void;

        SetClipping(InClipping: EWidgetClipping): void;

        SetCursor(InCursor: EMouseCursor): void;

        SetFocus(): void;

        SetIsEnabled(bInIsEnabled: boolean): void;

        SetKeyboardFocus(): void;

        SetNavigationRule(Direction: EUINavigation, Rule: EUINavigationRule, WidgetToFocus: string): void;

        SetNavigationRuleBase(Direction: EUINavigation, Rule: EUINavigationRule): void;

        SetNavigationRuleCustom(Direction: EUINavigation, InCustomDelegate: $Delegate<(Navigation: EUINavigation) => Widget>): void;

        SetNavigationRuleCustomBoundary(Direction: EUINavigation, InCustomDelegate: $Delegate<(Navigation: EUINavigation) => Widget>): void;

        SetNavigationRuleExplicit(Direction: EUINavigation, InWidget: $Nullable<Widget>): void;

        SetRenderOpacity(InOpacity: number): void;

        SetRenderScale(Scale: Vector2D): void;

        SetRenderShear(Shear: Vector2D): void;

        SetRenderTransform(InTransform: WidgetTransform): void;

        SetRenderTransformAngle(Angle: number): void;

        SetRenderTransformPivot(Pivot: Vector2D): void;

        SetRenderTranslation(Translation: Vector2D): void;

        SetToolTip(Widget: $Nullable<Widget>): void;

        SetToolTipText(InToolTipText: string): void;

        SetUserFocus(PlayerController: $Nullable<PlayerController>): void;

        SetVisibility(InVisibility: ESlateVisibility): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Widget;

        static Load(InName: string): Widget;
    }

    export class MovieSceneSignedObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Signature: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSignedObject;

        static Load(InName: string): MovieSceneSignedObject;
    }

    export class MovieSceneTrackIdentifier {
        constructor();
        constructor(Value: number);

        Value: number;

        static StaticClass(): Class;
    }

    export enum EEvaluationMethod { Static, Swept, EEvaluationMethod_MAX }

    export class MovieSceneTrackEvalOptions {
        constructor();
        constructor(bCanEvaluateNearestSection: boolean, bEvalNearestSection: boolean, bEvaluateInPreroll: boolean, bEvaluateInPostroll: boolean, bEvaluateNearestSection: boolean);

        bCanEvaluateNearestSection: boolean;
        bEvalNearestSection: boolean;
        bEvaluateInPreroll: boolean;
        bEvaluateInPostroll: boolean;
        bEvaluateNearestSection: boolean;

        static StaticClass(): Class;
    }

    export class MovieSceneTrackDisplayOptions {
        constructor();
        constructor(bShowVerticalFrames: boolean);

        bShowVerticalFrames: boolean;

        static StaticClass(): Class;
    }

    export enum EMovieSceneCompletionMode { KeepState, RestoreState, ProjectDefault, EMovieSceneCompletionMode_MAX }

    export class MovieSceneSectionEvalOptions {
        constructor();
        constructor(bCanEditCompletionMode: boolean, CompletionMode: EMovieSceneCompletionMode);

        bCanEditCompletionMode: boolean;
        CompletionMode: EMovieSceneCompletionMode;

        static StaticClass(): Class;
    }

    export class MovieSceneEasingFunction extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnEvaluate(Interp: number): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEasingFunction;

        static Load(InName: string): MovieSceneEasingFunction;
    }

    export class MovieSceneEasingSettings {
        constructor();
        constructor(AutoEaseInDuration: number, AutoEaseOutDuration: number, EaseIn: MovieSceneEasingFunction, bManualEaseIn: boolean, ManualEaseInDuration: number, EaseOut: MovieSceneEasingFunction, bManualEaseOut: boolean, ManualEaseOutDuration: number, AutoEaseInTime: number, AutoEaseOutTime: number, ManualEaseInTime: number, ManualEaseOutTime: number);

        AutoEaseInDuration: number;
        AutoEaseOutDuration: number;
        EaseIn: MovieSceneEasingFunction;
        bManualEaseIn: boolean;
        ManualEaseInDuration: number;
        EaseOut: MovieSceneEasingFunction;
        bManualEaseOut: boolean;
        ManualEaseOutDuration: number;
        AutoEaseInTime: number;
        AutoEaseOutTime: number;
        ManualEaseInTime: number;
        ManualEaseOutTime: number;

        static StaticClass(): Class;
    }

    export class MovieSceneFrameRange {
        constructor();

        static StaticClass(): Class;
    }

    export class Timecode {
        constructor();
        constructor(Hours: number, Minutes: number, Seconds: number, Frames: number, bDropFrameFormat: boolean);

        Hours: number;
        Minutes: number;
        Seconds: number;
        Frames: number;
        bDropFrameFormat: boolean;

        static StaticClass(): Class;
    }

    export class FrameNumber {
        constructor();
        constructor(Value: number);

        Value: number;

        static StaticClass(): Class;
    }

    export class MovieSceneTimecodeSource {
        constructor();
        constructor(Timecode: Timecode, DeltaFrame: FrameNumber);

        Timecode: Timecode;
        DeltaFrame: FrameNumber;

        static StaticClass(): Class;
    }

    export enum EMovieSceneBlendType {
        Invalid,
        Absolute,
        Additive,
        Relative,
        AdditiveFromBase,
        EMovieSceneBlendType_MAX
    }

    export class OptionalMovieSceneBlendType {
        constructor();
        constructor(BlendType: EMovieSceneBlendType, bIsValid: boolean);

        BlendType: EMovieSceneBlendType;
        bIsValid: boolean;

        static StaticClass(): Class;
    }

    export class MovieSceneSection extends MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EvalOptions: MovieSceneSectionEvalOptions;
        Easing: MovieSceneEasingSettings;
        SectionRange: MovieSceneFrameRange;
        TimecodeSource: MovieSceneTimecodeSource;
        PreRollFrames: FrameNumber;
        PostRollFrames: FrameNumber;
        RowIndex: number;
        OverlapPriority: number;
        bIsActive: boolean;
        bIsLocked: boolean;
        StartTime: number;
        EndTime: number;
        PreRollTime: number;
        PostRollTime: number;
        bIsInfinite: boolean;
        bSupportsInfiniteRange: boolean;
        BlendType: OptionalMovieSceneBlendType;

        GetBlendType(): OptionalMovieSceneBlendType;

        GetCompletionMode(): EMovieSceneCompletionMode;

        GetOverlapPriority(): number;

        GetPostRollFrames(): number;

        GetPreRollFrames(): number;

        GetRowIndex(): number;

        IsActive(): boolean;

        IsLocked(): boolean;

        SetBlendType(InBlendType: EMovieSceneBlendType): void;

        SetCompletionMode(InCompletionMode: EMovieSceneCompletionMode): void;

        SetIsActive(bInIsActive: boolean): void;

        SetIsLocked(bInIsLocked: boolean): void;

        SetOverlapPriority(NewPriority: number): void;

        SetPostRollFrames(InPostRollFrames: number): void;

        SetPreRollFrames(InPreRollFrames: number): void;

        SetRowIndex(NewRowIndex: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSection;

        static Load(InName: string): MovieSceneSection;
    }

    export class FrameNumberRangeBound {
        constructor();
        constructor(Type: ERangeBoundTypes, Value: FrameNumber);

        Type: ERangeBoundTypes;
        Value: FrameNumber;

        static StaticClass(): Class;
    }

    export class FrameNumberRange {
        constructor();
        constructor(LowerBound: FrameNumberRangeBound, UpperBound: FrameNumberRangeBound);

        LowerBound: FrameNumberRangeBound;
        UpperBound: FrameNumberRangeBound;

        static StaticClass(): Class;
    }

    export enum ESectionEvaluationFlags { None, PreRoll, PostRoll, ESectionEvaluationFlags_MAX }

    export class MovieSceneTrackEvaluationFieldEntry {
        constructor();
        constructor(Section: MovieSceneSection, Range: FrameNumberRange, ForcedTime: FrameNumber, Flags: ESectionEvaluationFlags, LegacySortOrder: number);

        Section: MovieSceneSection;
        Range: FrameNumberRange;
        ForcedTime: FrameNumber;
        Flags: ESectionEvaluationFlags;
        LegacySortOrder: number;

        static StaticClass(): Class;
    }

    export class MovieSceneTrackEvaluationField {
        constructor();
        constructor(Entries: TArray<MovieSceneTrackEvaluationFieldEntry>);

        Entries: TArray<MovieSceneTrackEvaluationFieldEntry>;

        static StaticClass(): Class;
    }

    export class MovieSceneTrack extends MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EvalOptions: MovieSceneTrackEvalOptions;
        DisplayOptions: MovieSceneTrackDisplayOptions;
        bIsEvalDisabled: boolean;
        EvaluationFieldGuid: Guid;
        EvaluationFieldVersion: number;
        EvaluationField: MovieSceneTrackEvaluationField;
        ObjectBindingID: Guid;
        TrackTint: Color;
        SortingOrder: number;
        bSupportsDefaultSections: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneTrack;

        static Load(InName: string): MovieSceneTrack;
    }

    export class MovieSceneEvalTemplatePtr {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneTrackImplementationPtr {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationTrack {
        constructor();
        constructor(ObjectBindingID: Guid, EvaluationPriority: number, EvaluationMethod: EEvaluationMethod, SourceTrack: TWeakObjectPtr<MovieSceneTrack>, ChildTemplates: TArray<MovieSceneEvalTemplatePtr>, TrackTemplate: MovieSceneTrackImplementationPtr, EvaluationGroup: string, bEvaluateInPreroll: boolean, bEvaluateInPostroll: boolean, bTearDownPriority: boolean);

        ObjectBindingID: Guid;
        EvaluationPriority: number;
        EvaluationMethod: EEvaluationMethod;
        SourceTrack: TWeakObjectPtr<MovieSceneTrack>;
        ChildTemplates: TArray<MovieSceneEvalTemplatePtr>;
        TrackTemplate: MovieSceneTrackImplementationPtr;
        EvaluationGroup: string;
        bEvaluateInPreroll: boolean;
        bEvaluateInPostroll: boolean;
        bTearDownPriority: boolean;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationTemplateSerialNumber {
        constructor();
        constructor(Value: number);

        Value: number;

        static StaticClass(): Class;
    }

    export class MovieSceneTemplateGenerationLedger {
        constructor();
        constructor(LastTrackIdentifier: MovieSceneTrackIdentifier, TrackSignatureToTrackIdentifier: TMap<Guid, MovieSceneTrackIdentifier>, SubSectionRanges: TMap<Guid, MovieSceneFrameRange>);

        LastTrackIdentifier: MovieSceneTrackIdentifier;
        TrackSignatureToTrackIdentifier: TMap<Guid, MovieSceneTrackIdentifier>;
        SubSectionRanges: TMap<Guid, MovieSceneFrameRange>;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationTemplate {
        constructor();
        constructor(Tracks: TMap<MovieSceneTrackIdentifier, MovieSceneEvaluationTrack>, SequenceSignature: Guid, TemplateSerialNumber: MovieSceneEvaluationTemplateSerialNumber, TemplateLedger: MovieSceneTemplateGenerationLedger);

        Tracks: TMap<MovieSceneTrackIdentifier, MovieSceneEvaluationTrack>;
        SequenceSignature: Guid;
        TemplateSerialNumber: MovieSceneEvaluationTemplateSerialNumber;
        TemplateLedger: MovieSceneTemplateGenerationLedger;

        static StaticClass(): Class;
    }

    export class MovieSceneSequenceID {
        constructor();
        constructor(Value: number);

        Value: number;

        static StaticClass(): Class;
    }

    export class MovieSceneSequenceHierarchyNode {
        constructor();
        constructor(ParentID: MovieSceneSequenceID, Children: TArray<MovieSceneSequenceID>);

        ParentID: MovieSceneSequenceID;
        Children: TArray<MovieSceneSequenceID>;

        static StaticClass(): Class;
    }

    export class MovieSceneSubSequenceTree {
        constructor();

        static StaticClass(): Class;
    }

    export class FrameTime {
        constructor();
        constructor(FrameNumber: FrameNumber, SubFrame: number);

        FrameNumber: FrameNumber;
        SubFrame: number;

        static StaticClass(): Class;
    }

    export class MovieSceneTimeTransform {
        constructor();
        constructor(TimeScale: number, Offset: FrameTime);

        TimeScale: number;
        Offset: FrameTime;

        static StaticClass(): Class;
    }

    export class MovieSceneTimeWarping {
        constructor();
        constructor(Start: FrameNumber, End: FrameNumber);

        Start: FrameNumber;
        End: FrameNumber;

        static StaticClass(): Class;
    }

    export class MovieSceneNestedSequenceTransform {
        constructor();
        constructor(LinearTransform: MovieSceneTimeTransform, Warping: MovieSceneTimeWarping);

        LinearTransform: MovieSceneTimeTransform;
        Warping: MovieSceneTimeWarping;

        static StaticClass(): Class;
    }

    export class MovieSceneSequenceTransform {
        constructor();
        constructor(LinearTransform: MovieSceneTimeTransform, NestedTransforms: TArray<MovieSceneNestedSequenceTransform>);

        LinearTransform: MovieSceneTimeTransform;
        NestedTransforms: TArray<MovieSceneNestedSequenceTransform>;

        static StaticClass(): Class;
    }

    export class FrameRate {
        constructor();
        constructor(Numerator: number, Denominator: number);

        Numerator: number;
        Denominator: number;

        static StaticClass(): Class;
    }

    export class MovieSceneSequenceInstanceDataPtr {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneSubSequenceData {
        constructor();
        constructor(Sequence: SoftObjectPath, RootToSequenceTransform: MovieSceneSequenceTransform, TickResolution: FrameRate, DeterministicSequenceID: MovieSceneSequenceID, PlayRange: MovieSceneFrameRange, FullPlayRange: MovieSceneFrameRange, UnwarpedPlayRange: MovieSceneFrameRange, PreRollRange: MovieSceneFrameRange, PostRollRange: MovieSceneFrameRange, HierarchicalBias: number, bHasHierarchicalEasing: boolean, InstanceData: MovieSceneSequenceInstanceDataPtr, SectionPath: string, SubSectionSignature: Guid, OuterToInnerTransform: MovieSceneSequenceTransform);

        Sequence: SoftObjectPath;
        RootToSequenceTransform: MovieSceneSequenceTransform;
        TickResolution: FrameRate;
        DeterministicSequenceID: MovieSceneSequenceID;
        PlayRange: MovieSceneFrameRange;
        FullPlayRange: MovieSceneFrameRange;
        UnwarpedPlayRange: MovieSceneFrameRange;
        PreRollRange: MovieSceneFrameRange;
        PostRollRange: MovieSceneFrameRange;
        HierarchicalBias: number;
        bHasHierarchicalEasing: boolean;
        InstanceData: MovieSceneSequenceInstanceDataPtr;
        SectionPath: string;
        SubSectionSignature: Guid;
        OuterToInnerTransform: MovieSceneSequenceTransform;

        static StaticClass(): Class;
    }

    export class MovieSceneSequenceHierarchy {
        constructor();
        constructor(RootNode: MovieSceneSequenceHierarchyNode, Tree: MovieSceneSubSequenceTree, SubSequences: TMap<MovieSceneSequenceID, MovieSceneSubSequenceData>, Hierarchy: TMap<MovieSceneSequenceID, MovieSceneSequenceHierarchyNode>);

        RootNode: MovieSceneSequenceHierarchyNode;
        Tree: MovieSceneSubSequenceTree;
        SubSequences: TMap<MovieSceneSequenceID, MovieSceneSubSequenceData>;
        Hierarchy: TMap<MovieSceneSequenceID, MovieSceneSequenceHierarchyNode>;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationFieldEntityTree {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationFieldEntityKey {
        constructor();
        constructor(EntityOwner: TWeakObjectPtr<Object>, EntityID: number);

        EntityOwner: TWeakObjectPtr<Object>;
        EntityID: number;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationFieldEntity {
        constructor();
        constructor(Key: MovieSceneEvaluationFieldEntityKey, SharedMetaDataIndex: number);

        Key: MovieSceneEvaluationFieldEntityKey;
        SharedMetaDataIndex: number;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationFieldEntityMetaData {
        constructor();
        constructor(ForcedTime: FrameNumber, Flags: ESectionEvaluationFlags, bEvaluateInSequencePreRoll: boolean, bEvaluateInSequencePostRoll: boolean);

        ForcedTime: FrameNumber;
        Flags: ESectionEvaluationFlags;
        bEvaluateInSequencePreRoll: boolean;
        bEvaluateInSequencePostRoll: boolean;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationFieldSharedEntityMetaData {
        constructor();
        constructor(ObjectBindingID: Guid);

        ObjectBindingID: Guid;

        static StaticClass(): Class;
    }

    export class MovieSceneEntityComponentField {
        constructor();
        constructor(PersistentEntityTree: MovieSceneEvaluationFieldEntityTree, OneShotEntityTree: MovieSceneEvaluationFieldEntityTree, Entities: TArray<MovieSceneEvaluationFieldEntity>, EntityMetaData: TArray<MovieSceneEvaluationFieldEntityMetaData>, SharedMetaData: TArray<MovieSceneEvaluationFieldSharedEntityMetaData>);

        PersistentEntityTree: MovieSceneEvaluationFieldEntityTree;
        OneShotEntityTree: MovieSceneEvaluationFieldEntityTree;
        Entities: TArray<MovieSceneEvaluationFieldEntity>;
        EntityMetaData: TArray<MovieSceneEvaluationFieldEntityMetaData>;
        SharedMetaData: TArray<MovieSceneEvaluationFieldSharedEntityMetaData>;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationGroupLUTIndex {
        constructor();
        constructor(NumInitPtrs: number, NumEvalPtrs: number);

        NumInitPtrs: number;
        NumEvalPtrs: number;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationFieldTrackPtr {
        constructor();
        constructor(SequenceID: MovieSceneSequenceID, TrackIdentifier: MovieSceneTrackIdentifier);

        SequenceID: MovieSceneSequenceID;
        TrackIdentifier: MovieSceneTrackIdentifier;

        static StaticClass(): Class;
    }

    export class MovieSceneFieldEntry_EvaluationTrack {
        constructor();
        constructor(TrackPtr: MovieSceneEvaluationFieldTrackPtr, NumChildren: number);

        TrackPtr: MovieSceneEvaluationFieldTrackPtr;
        NumChildren: number;

        static StaticClass(): Class;
    }

    export class MovieSceneFieldEntry_ChildTemplate {
        constructor();
        constructor(ChildIndex: number, Flags: ESectionEvaluationFlags, ForcedTime: FrameNumber);

        ChildIndex: number;
        Flags: ESectionEvaluationFlags;
        ForcedTime: FrameNumber;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationGroup {
        constructor();
        constructor(LUTIndices: TArray<MovieSceneEvaluationGroupLUTIndex>, TrackLUT: TArray<MovieSceneFieldEntry_EvaluationTrack>, SectionLUT: TArray<MovieSceneFieldEntry_ChildTemplate>);

        LUTIndices: TArray<MovieSceneEvaluationGroupLUTIndex>;
        TrackLUT: TArray<MovieSceneFieldEntry_EvaluationTrack>;
        SectionLUT: TArray<MovieSceneFieldEntry_ChildTemplate>;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationKey {
        constructor();
        constructor(SequenceID: MovieSceneSequenceID, TrackIdentifier: MovieSceneTrackIdentifier, SectionIndex: number);

        SequenceID: MovieSceneSequenceID;
        TrackIdentifier: MovieSceneTrackIdentifier;
        SectionIndex: number;

        static StaticClass(): Class;
    }

    export class MovieSceneOrderedEvaluationKey {
        constructor();
        constructor(Key: MovieSceneEvaluationKey, SetupIndex: number, TearDownIndex: number);

        Key: MovieSceneEvaluationKey;
        SetupIndex: number;
        TearDownIndex: number;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationMetaData {
        constructor();
        constructor(ActiveSequences: TArray<MovieSceneSequenceID>, ActiveEntities: TArray<MovieSceneOrderedEvaluationKey>);

        ActiveSequences: TArray<MovieSceneSequenceID>;
        ActiveEntities: TArray<MovieSceneOrderedEvaluationKey>;

        static StaticClass(): Class;
    }

    export class MovieSceneEvaluationField {
        constructor();
        constructor(Signature: Guid, Ranges: TArray<MovieSceneFrameRange>, Groups: TArray<MovieSceneEvaluationGroup>, MetaData: TArray<MovieSceneEvaluationMetaData>);

        Signature: Guid;
        Ranges: TArray<MovieSceneFrameRange>;
        Groups: TArray<MovieSceneEvaluationGroup>;
        MetaData: TArray<MovieSceneEvaluationMetaData>;

        static StaticClass(): Class;
    }

    export class MovieSceneSequenceCompilerMaskStruct {
        constructor();
        constructor(bHierarchy: boolean, bEvaluationTemplate: boolean, bEvaluationTemplateField: boolean, bEntityComponentField: boolean);

        bHierarchy: boolean;
        bEvaluationTemplate: boolean;
        bEvaluationTemplateField: boolean;
        bEntityComponentField: boolean;

        static StaticClass(): Class;
    }

    export enum EMovieSceneSequenceFlags {
        None,
        Volatile,
        BlockingEvaluation,
        InheritedFlags,
        EMovieSceneSequenceFlags_MAX
    }

    export class MovieSceneCompiledData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EvaluationTemplate: MovieSceneEvaluationTemplate;
        Hierarchy: MovieSceneSequenceHierarchy;
        EntityComponentField: MovieSceneEntityComponentField;
        TrackTemplateField: MovieSceneEvaluationField;
        DeterminismFences: TArray<FrameTime>;
        CompiledSignature: Guid;
        CompilerVersion: Guid;
        AccumulatedMask: MovieSceneSequenceCompilerMaskStruct;
        AllocatedMask: MovieSceneSequenceCompilerMaskStruct;
        AccumulatedFlags: EMovieSceneSequenceFlags;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCompiledData;

        static Load(InName: string): MovieSceneCompiledData;
    }

    export enum EMovieSceneObjectBindingSpace { Local, Root, EMovieSceneObjectBindingSpace_MAX }

    export class MovieSceneObjectBindingID {
        constructor();
        constructor(SequenceID: number, Space: EMovieSceneObjectBindingSpace, Guid: Guid);

        SequenceID: number;
        Space: EMovieSceneObjectBindingSpace;
        Guid: Guid;

        static StaticClass(): Class;
    }

    export class MovieSceneSequence extends MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CompiledData: MovieSceneCompiledData;
        DefaultCompletionMode: EMovieSceneCompletionMode;
        bParentContextsAreSignificant: boolean;
        bPlayableDirectly: boolean;
        SequenceFlags: EMovieSceneSequenceFlags;

        FindBindingByTag(InBindingName: string): MovieSceneObjectBindingID;

        FindBindingsByTag(InBindingName: string): TArray<MovieSceneObjectBindingID>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSequence;

        static Load(InName: string): MovieSceneSequence;
    }

    export enum ESpawnOwnership { InnerSequence, MasterSequence, External, ESpawnOwnership_MAX }

    export class MovieSceneSpawnable {
        constructor();
        constructor(SpawnTransform: Transform, Tags: TArray<string>, bContinuouslyRespawn: boolean, bEvaluateTracksWhenNotSpawned: boolean, Guid: Guid, Name: string, ObjectTemplate: Object, ChildPossessables: TArray<Guid>, Ownership: ESpawnOwnership, GeneratedClass: Class, LevelName: string);

        SpawnTransform: Transform;
        Tags: TArray<string>;
        bContinuouslyRespawn: boolean;
        bEvaluateTracksWhenNotSpawned: boolean;
        Guid: Guid;
        Name: string;
        ObjectTemplate: Object;
        ChildPossessables: TArray<Guid>;
        Ownership: ESpawnOwnership;
        GeneratedClass: Class;
        LevelName: string;

        static StaticClass(): Class;
    }

    export class MovieScenePossessable {
        constructor();
        constructor(Tags: TArray<string>, Guid: Guid, Name: string, PossessedObjectClass: Class, ParentGuid: Guid);

        Tags: TArray<string>;
        Guid: Guid;
        Name: string;
        PossessedObjectClass: Class;
        ParentGuid: Guid;

        static StaticClass(): Class;
    }

    export class MovieSceneBinding {
        constructor();
        constructor(ObjectGuid: Guid, BindingName: string, Tracks: TArray<MovieSceneTrack>, SortingOrder: number);

        ObjectGuid: Guid;
        BindingName: string;
        Tracks: TArray<MovieSceneTrack>;
        SortingOrder: number;

        static StaticClass(): Class;
    }

    export class MovieSceneObjectBindingIDs {
        constructor();
        constructor(IDs: TArray<MovieSceneObjectBindingID>);

        IDs: TArray<MovieSceneObjectBindingID>;

        static StaticClass(): Class;
    }

    export enum EMovieSceneEvaluationType { FrameLocked, WithSubFrames, EMovieSceneEvaluationType_MAX }

    export enum EUpdateClockSource { Tick, Platform, Audio, RelativeTimecode, Timecode, Custom, EUpdateClockSource_MAX }

    export class MovieSceneMarkedFrame {
        constructor();
        constructor(FrameNumber: FrameNumber, Label: string, Color: LinearColor);

        FrameNumber: FrameNumber;
        Label: string;
        Color: LinearColor;

        static StaticClass(): Class;
    }

    export class MovieSceneTrackLabels {
        constructor();
        constructor(Strings: TArray<string>);

        Strings: TArray<string>;

        static StaticClass(): Class;
    }

    export class MovieSceneExpansionState {
        constructor();
        constructor(bExpanded: boolean);

        bExpanded: boolean;

        static StaticClass(): Class;
    }

    export class FloatRangeBound {
        constructor();
        constructor(Type: ERangeBoundTypes, Value: number);

        Type: ERangeBoundTypes;
        Value: number;

        static StaticClass(): Class;
    }

    export class FloatRange {
        constructor();
        constructor(LowerBound: FloatRangeBound, UpperBound: FloatRangeBound);

        LowerBound: FloatRangeBound;
        UpperBound: FloatRangeBound;

        static StaticClass(): Class;
    }

    export class MovieSceneEditorData {
        constructor();
        constructor(ExpansionStates: TMap<string, MovieSceneExpansionState>, PinnedNodes: TArray<string>, ViewStart: number, ViewEnd: number, WorkStart: number, WorkEnd: number, MarkedFrames: TSet<FrameNumber>, WorkingRange: FloatRange, ViewRange: FloatRange);

        ExpansionStates: TMap<string, MovieSceneExpansionState>;
        PinnedNodes: TArray<string>;
        ViewStart: number;
        ViewEnd: number;
        WorkStart: number;
        WorkEnd: number;
        MarkedFrames: TSet<FrameNumber>;
        WorkingRange: FloatRange;
        ViewRange: FloatRange;

        static StaticClass(): Class;
    }

    export class MovieSceneFolder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FolderName: string;
        ChildFolders: TArray<MovieSceneFolder>;
        ChildMasterTracks: TArray<MovieSceneTrack>;
        ChildObjectBindingStrings: TArray<string>;
        FolderColor: Color;
        SortingOrder: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneFolder;

        static Load(InName: string): MovieSceneFolder;
    }

    export class MovieSceneSectionGroup {
        constructor();
        constructor(Sections: TArray<TWeakObjectPtr<MovieSceneSection>>);

        Sections: TArray<TWeakObjectPtr<MovieSceneSection>>;

        static StaticClass(): Class;
    }

    export class MovieSceneNodeGroup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Name: string;
        Nodes: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNodeGroup;

        static Load(InName: string): MovieSceneNodeGroup;
    }

    export class MovieSceneNodeGroupCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NodeGroups: TArray<MovieSceneNodeGroup>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNodeGroupCollection;

        static Load(InName: string): MovieSceneNodeGroupCollection;
    }

    export class MovieScene extends MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TimecodeSource: MovieSceneTimecodeSource;
        Spawnables: TArray<MovieSceneSpawnable>;
        Possessables: TArray<MovieScenePossessable>;
        ObjectBindings: TArray<MovieSceneBinding>;
        BindingGroups: TMap<string, MovieSceneObjectBindingIDs>;
        MasterTracks: TArray<MovieSceneTrack>;
        CameraCutTrack: MovieSceneTrack;
        SelectionRange: MovieSceneFrameRange;
        PlaybackRange: MovieSceneFrameRange;
        TickResolution: FrameRate;
        DisplayRate: FrameRate;
        EvaluationType: EMovieSceneEvaluationType;
        ClockSource: EUpdateClockSource;
        CustomClockSourcePath: SoftObjectPath;
        MarkedFrames: TArray<MovieSceneMarkedFrame>;
        bReadOnly: boolean;
        bPlaybackRangeLocked: boolean;
        ObjectsToDisplayNames: TMap<string, string>;
        ObjectsToLabels: TMap<string, MovieSceneTrackLabels>;
        EditorData: MovieSceneEditorData;
        RootFolders: TArray<MovieSceneFolder>;
        SoloNodes: TArray<string>;
        MuteNodes: TArray<string>;
        SectionGroups: TArray<MovieSceneSectionGroup>;
        NodeGroupCollection: MovieSceneNodeGroupCollection;
        InTime: number;
        OutTime: number;
        StartTime: number;
        EndTime: number;
        bForceFixedFrameIntervalPlayback: boolean;
        FixedFrameInterval: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene;

        static Load(InName: string): MovieScene;
    }

    export class WidgetAnimationBinding {
        constructor();
        constructor(WidgetName: string, SlotWidgetName: string, AnimationGuid: Guid, bIsRootWidget: boolean);

        WidgetName: string;
        SlotWidgetName: string;
        AnimationGuid: Guid;
        bIsRootWidget: boolean;

        static StaticClass(): Class;
    }

    export class WidgetAnimation extends MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnAnimationStarted: $MulticastDelegate<() => void>;
        OnAnimationFinished: $MulticastDelegate<() => void>;
        MovieScene: MovieScene;
        AnimationBindings: TArray<WidgetAnimationBinding>;
        bLegacyFinishOnStop: boolean;
        DisplayLabel: string;

        BindToAnimationFinished(Widget: $Nullable<UserWidget>, Delegate: $Delegate<() => void>): void;

        BindToAnimationStarted(Widget: $Nullable<UserWidget>, Delegate: $Delegate<() => void>): void;

        GetEndTime(): number;

        GetStartTime(): number;

        UnbindAllFromAnimationFinished(Widget: $Nullable<UserWidget>): void;

        UnbindAllFromAnimationStarted(Widget: $Nullable<UserWidget>): void;

        UnbindFromAnimationFinished(Widget: $Nullable<UserWidget>, Delegate: $Delegate<() => void>): void;

        UnbindFromAnimationStarted(Widget: $Nullable<UserWidget>, Delegate: $Delegate<() => void>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetAnimation;

        static Load(InName: string): WidgetAnimation;
    }

    export class MovieSceneCompiledDataManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Hierarchies: TMap<number, MovieSceneSequenceHierarchy>;
        TrackTemplates: TMap<number, MovieSceneEvaluationTemplate>;
        TrackTemplateFields: TMap<number, MovieSceneEvaluationField>;
        EntityComponentFields: TMap<number, MovieSceneEntityComponentField>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCompiledDataManager;

        static Load(InName: string): MovieSceneCompiledDataManager;
    }

    export class MovieSceneEntitySystemGraphNodes {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneEntitySystemGraph {
        constructor();
        constructor(Nodes: MovieSceneEntitySystemGraphNodes);

        Nodes: MovieSceneEntitySystemGraphNodes;

        static StaticClass(): Class;
    }

    export class MovieSceneEntitySystemLinker extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SystemGraph: MovieSceneEntitySystemGraph;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEntitySystemLinker;

        static Load(InName: string): MovieSceneEntitySystemLinker;
    }

    export class MovieSceneRootEvaluationTemplateInstance {
        constructor();
        constructor(WeakRootSequence: TWeakObjectPtr<MovieSceneSequence>, CompiledDataManager: MovieSceneCompiledDataManager, EntitySystemLinker: MovieSceneEntitySystemLinker, DirectorInstances: TMap<MovieSceneSequenceID, Object>);

        WeakRootSequence: TWeakObjectPtr<MovieSceneSequence>;
        CompiledDataManager: MovieSceneCompiledDataManager;
        EntitySystemLinker: MovieSceneEntitySystemLinker;
        DirectorInstances: TMap<MovieSceneSequenceID, Object>;

        static StaticClass(): Class;
    }

    export class UMGSequencePlayer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Animation: WidgetAnimation;
        RootTemplateInstance: MovieSceneRootEvaluationTemplateInstance;

        GetUserTag(): string;

        SetUserTag(InUserTag: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UMGSequencePlayer;

        static Load(InName: string): UMGSequencePlayer;
    }

    export class UMGSequenceTickManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WeakUserWidgets: TSet<TWeakObjectPtr<UserWidget>>;
        Linker: MovieSceneEntitySystemLinker;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UMGSequenceTickManager;

        static Load(InName: string): UMGSequenceTickManager;
    }

    export class NamedSlotBinding {
        constructor();
        constructor(Name: string, Content: Widget);

        Name: string;
        Content: Widget;

        static StaticClass(): Class;
    }

    export class WidgetTree extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootWidget: Widget;
        AllWidgets: TArray<Widget>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetTree;

        static Load(InName: string): WidgetTree;
    }

    export enum EDesignPreviewSizeMode {
        FillScreen,
        Custom,
        CustomOnScreen,
        Desired,
        DesiredOnScreen,
        EDesignPreviewSizeMode_MAX
    }

    export enum EWidgetTickFrequency { Never, Auto, EWidgetTickFrequency_MAX }

    export enum EWidgetAnimationEvent { Started, Finished, EWidgetAnimationEvent_MAX }

    export class AnimationEventBinding {
        constructor();
        constructor(Animation: WidgetAnimation, Delegate: $Delegate<() => void>, AnimationEvent: EWidgetAnimationEvent, UserTag: string);

        Animation: WidgetAnimation;
        Delegate: $Delegate<() => void>;
        AnimationEvent: EWidgetAnimationEvent;
        UserTag: string;

        static StaticClass(): Class;
    }

    export enum EInputEvent { IE_Pressed, IE_Released, IE_Repeat, IE_DoubleClick, IE_Axis, IE_MAX }

    export class Anchors {
        constructor();
        constructor(Minimum: Vector2D, Maximum: Vector2D);

        Minimum: Vector2D;
        Maximum: Vector2D;

        static StaticClass(): Class;
    }

    export enum EUMGSequencePlayMode { Forward, Reverse, PingPong, EUMGSequencePlayMode_MAX }

    export class FocusEvent {
        constructor();

        static StaticClass(): Class;
    }

    export class KeyEvent extends InputEvent {
        constructor();

        static StaticClass(): Class;
    }

    export class PaintContext {
        constructor();

        static StaticClass(): Class;
    }

    export class MotionEvent extends InputEvent {
        constructor();

        static StaticClass(): Class;
    }

    export class CharacterEvent extends InputEvent {
        constructor();

        static StaticClass(): Class;
    }

    export enum EDragPivot {
        MouseDown,
        TopLeft,
        TopCenter,
        TopRight,
        CenterLeft,
        CenterCenter,
        CenterRight,
        BottomLeft,
        BottomCenter,
        BottomRight,
        EDragPivot_MAX
    }

    export class DragDropOperation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Tag: string;
        Payload: Object;
        DefaultDragVisual: Widget;
        Pivot: EDragPivot;
        Offset: Vector2D;
        OnDrop: $MulticastDelegate<(Operation: $Nullable<DragDropOperation>) => void>;
        OnDragCancelled: $MulticastDelegate<(Operation: $Nullable<DragDropOperation>) => void>;
        OnDragged: $MulticastDelegate<(Operation: $Nullable<DragDropOperation>) => void>;

        DragCancelled(PointerEvent: PointerEvent): void;

        Dragged(PointerEvent: PointerEvent): void;

        Drop(PointerEvent: PointerEvent): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DragDropOperation;

        static Load(InName: string): DragDropOperation;
    }

    export class AnalogInputEvent extends KeyEvent {
        constructor();

        static StaticClass(): Class;
    }

    export class UserWidget extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ColorAndOpacity: LinearColor;
        ColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        ForegroundColor: SlateColor;
        ForegroundColorDelegate: $Delegate<() => SlateColor>;
        OnVisibilityChanged: $MulticastDelegate<(InVisibility: ESlateVisibility) => void>;
        Padding: Margin;
        ActiveSequencePlayers: TArray<UMGSequencePlayer>;
        AnimationTickManager: UMGSequenceTickManager;
        StoppedSequencePlayers: TArray<UMGSequencePlayer>;
        NamedSlotBindings: TArray<NamedSlotBinding>;
        WidgetTree: WidgetTree;
        DesignTimeSize: Vector2D;
        DesignSizeMode: EDesignPreviewSizeMode;
        PaletteCategory: string;
        PreviewBackground: Texture2D;
        Priority: number;
        bSupportsKeyboardFocus: boolean;
        bIsFocusable: boolean;
        bStopAction: boolean;
        bHasScriptImplementedTick: boolean;
        bHasScriptImplementedPaint: boolean;
        TickFrequency: EWidgetTickFrequency;
        InputComponent: InputComponent;
        AnimationCallbacks: TArray<AnimationEventBinding>;

        AddToPlayerScreen(ZOrder?: number /* = 0 */): boolean;

        AddToViewport(ZOrder?: number /* = 0 */): void;

        BindToAnimationEvent(Animation: $Nullable<WidgetAnimation>, Delegate: $Delegate<() => void>, AnimationEvent: EWidgetAnimationEvent, UserTag?: string /* = "None" */): void;

        BindToAnimationFinished(Animation: $Nullable<WidgetAnimation>, Delegate: $Delegate<() => void>): void;

        BindToAnimationStarted(Animation: $Nullable<WidgetAnimation>, Delegate: $Delegate<() => void>): void;

        CancelLatentActions(): void;

        Construct(): void;

        Destruct(): void;

        FlushAnimations(): void;

        GetAlignmentInViewport(): Vector2D;

        GetAnchorsInViewport(): Anchors;

        GetAnimationCurrentTime(InAnimation: $Nullable<WidgetAnimation>): number;

        GetIsVisible(): boolean;

        GetOwningPlayerCameraManager(): PlayerCameraManager;

        GetOwningPlayerPawn(): Pawn;

        GetWidgetFromName(Name: string): Widget;

        IsAnimationPlaying(InAnimation: $Nullable<WidgetAnimation>): boolean;

        IsAnimationPlayingForward(InAnimation: $Nullable<WidgetAnimation>): boolean;

        IsAnyAnimationPlaying(): boolean;

        IsInteractable(): boolean;

        IsInViewport(): boolean;

        IsListeningForInputAction(ActionName: string): boolean;

        IsPlayingAnimation(): boolean;

        ListenForInputAction(ActionName: string, EventType: EInputEvent, bConsume: boolean, Callback: $Delegate<() => void>): void;

        OnAddedToFocusPath(InFocusEvent: FocusEvent): void;

        OnAnalogValueChanged(MyGeometry: Geometry, InAnalogInputEvent: AnalogInputEvent): EventReply;

        OnAnimationFinished(Animation: $Nullable<WidgetAnimation>): void;

        OnAnimationStarted(Animation: $Nullable<WidgetAnimation>): void;

        OnDragCancelled(PointerEvent: PointerEvent, Operation: $Nullable<DragDropOperation>): void;

        OnDragDetected(MyGeometry: Geometry, PointerEvent: PointerEvent, Operation: $Ref<DragDropOperation>): void;

        OnDragEnter(MyGeometry: Geometry, PointerEvent: PointerEvent, Operation: $Nullable<DragDropOperation>): void;

        OnDragLeave(PointerEvent: PointerEvent, Operation: $Nullable<DragDropOperation>): void;

        OnDragOver(MyGeometry: Geometry, PointerEvent: PointerEvent, Operation: $Nullable<DragDropOperation>): boolean;

        OnDrop(MyGeometry: Geometry, PointerEvent: PointerEvent, Operation: $Nullable<DragDropOperation>): boolean;

        OnFocusLost(InFocusEvent: FocusEvent): void;

        OnFocusReceived(MyGeometry: Geometry, InFocusEvent: FocusEvent): EventReply;

        OnInitialized(): void;

        OnKeyChar(MyGeometry: Geometry, InCharacterEvent: CharacterEvent): EventReply;

        OnKeyDown(MyGeometry: Geometry, InKeyEvent: KeyEvent): EventReply;

        OnKeyUp(MyGeometry: Geometry, InKeyEvent: KeyEvent): EventReply;

        OnMotionDetected(MyGeometry: Geometry, InMotionEvent: MotionEvent): EventReply;

        OnMouseButtonDoubleClick(InMyGeometry: Geometry, InMouseEvent: PointerEvent): EventReply;

        OnMouseButtonDown(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;

        OnMouseButtonUp(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;

        OnMouseCaptureLost(): void;

        OnMouseEnter(MyGeometry: Geometry, MouseEvent: PointerEvent): void;

        OnMouseLeave(MouseEvent: PointerEvent): void;

        OnMouseMove(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;

        OnMouseWheel(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;

        OnPaint(Context: $Ref<PaintContext>): void;

        OnPreviewKeyDown(MyGeometry: Geometry, InKeyEvent: KeyEvent): EventReply;

        OnPreviewMouseButtonDown(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;

        OnRemovedFromFocusPath(InFocusEvent: FocusEvent): void;

        OnTouchEnded(MyGeometry: Geometry, InTouchEvent: PointerEvent): EventReply;

        OnTouchForceChanged(MyGeometry: Geometry, InTouchEvent: PointerEvent): EventReply;

        OnTouchGesture(MyGeometry: Geometry, GestureEvent: PointerEvent): EventReply;

        OnTouchMoved(MyGeometry: Geometry, InTouchEvent: PointerEvent): EventReply;

        OnTouchStarted(MyGeometry: Geometry, InTouchEvent: PointerEvent): EventReply;

        PauseAnimation(InAnimation: $Nullable<WidgetAnimation>): number;

        PlayAnimation(InAnimation: $Nullable<WidgetAnimation>, StartAtTime?: number /* = 0.000000 */, NumLoopsToPlay?: number /* = 1 */, PlayMode?: EUMGSequencePlayMode /* = Forward */, PlaybackSpeed?: number /* = 1.000000 */, bRestoreState?: boolean /* = false */): UMGSequencePlayer;

        PlayAnimationForward(InAnimation: $Nullable<WidgetAnimation>, PlaybackSpeed?: number /* = 1.000000 */, bRestoreState?: boolean /* = false */): UMGSequencePlayer;

        PlayAnimationReverse(InAnimation: $Nullable<WidgetAnimation>, PlaybackSpeed?: number /* = 1.000000 */, bRestoreState?: boolean /* = false */): UMGSequencePlayer;

        PlayAnimationTimeRange(InAnimation: $Nullable<WidgetAnimation>, StartAtTime?: number /* = 0.000000 */, EndAtTime?: number /* = 0.000000 */, NumLoopsToPlay?: number /* = 1 */, PlayMode?: EUMGSequencePlayMode /* = Forward */, PlaybackSpeed?: number /* = 1.000000 */, bRestoreState?: boolean /* = false */): UMGSequencePlayer;

        PlaySound(SoundToPlay: $Nullable<SoundBase>): void;

        PreConstruct(IsDesignTime: boolean): void;

        RegisterInputComponent(): void;

        RemoveFromViewport(): void;

        ReverseAnimation(InAnimation: $Nullable<WidgetAnimation>): void;

        SetAlignmentInViewport(Alignment: Vector2D): void;

        SetAnchorsInViewport(Anchors: Anchors): void;

        SetAnimationCurrentTime(InAnimation: $Nullable<WidgetAnimation>, InTime: number): void;

        SetColorAndOpacity(InColorAndOpacity: LinearColor): void;

        SetDesiredSizeInViewport(Size: Vector2D): void;

        SetForegroundColor(InForegroundColor: SlateColor): void;

        SetInputActionBlocking(bShouldBlock: boolean): void;

        SetInputActionPriority(NewPriority: number): void;

        SetNumLoopsToPlay(InAnimation: $Nullable<WidgetAnimation>, NumLoopsToPlay: number): void;

        SetOwningPlayer(LocalPlayerController: $Nullable<PlayerController>): void;

        SetPadding(InPadding: Margin): void;

        SetPlaybackSpeed(InAnimation: $Nullable<WidgetAnimation>, PlaybackSpeed?: number /* = 1.000000 */): void;

        SetPositionInViewport(Position: Vector2D, bRemoveDPIScale?: boolean /* = true */): void;

        StopAllAnimations(): void;

        StopAnimation(InAnimation: $Nullable<WidgetAnimation>): void;

        StopAnimationsAndLatentActions(): void;

        StopListeningForAllInputActions(): void;

        StopListeningForInputAction(ActionName: string, EventType: EInputEvent): void;

        Tick(MyGeometry: Geometry, InDeltaTime: number): void;

        UnbindAllFromAnimationFinished(Animation: $Nullable<WidgetAnimation>): void;

        UnbindAllFromAnimationStarted(Animation: $Nullable<WidgetAnimation>): void;

        UnbindFromAnimationFinished(Animation: $Nullable<WidgetAnimation>, Delegate: $Delegate<() => void>): void;

        UnbindFromAnimationStarted(Animation: $Nullable<WidgetAnimation>, Delegate: $Delegate<() => void>): void;

        UnregisterInputComponent(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserWidget;

        static Load(InName: string): UserWidget;
    }

    export class ViewTargetTransitionParams {
        constructor();
        constructor(BlendTime: number, BlendFunction: EViewTargetBlendFunction, BlendExp: number, bLockOutgoing: boolean);

        BlendTime: number;
        BlendFunction: EViewTargetBlendFunction;
        BlendExp: number;
        bLockOutgoing: boolean;

        static StaticClass(): Class;
    }

    export class UpdateLevelVisibilityLevelInfo {
        constructor();
        constructor(PackageName: string, FileName: string, bIsVisible: boolean);

        PackageName: string;
        FileName: string;
        bIsVisible: boolean;

        static StaticClass(): Class;
    }

    export class HapticFeedbackEffect_Base extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Base;

        static Load(InName: string): HapticFeedbackEffect_Base;
    }

    export enum EDynamicForceFeedbackAction { Start, Update, Stop, EDynamicForceFeedbackAction_MAX }

    export class LatentActionInfo {
        constructor();
        constructor(Linkage: number, UUID: number, ExecutionFunction: string, CallbackTarget: Object);

        Linkage: number;
        UUID: number;
        ExecutionFunction: string;
        CallbackTarget: Object;

        static StaticClass(): Class;
    }

    export enum EObjectTypeQuery {
        ObjectTypeQuery1,
        ObjectTypeQuery2,
        ObjectTypeQuery3,
        ObjectTypeQuery4,
        ObjectTypeQuery5,
        ObjectTypeQuery6,
        ObjectTypeQuery7,
        ObjectTypeQuery8,
        ObjectTypeQuery9,
        ObjectTypeQuery10,
        ObjectTypeQuery11,
        ObjectTypeQuery12,
        ObjectTypeQuery13,
        ObjectTypeQuery14,
        ObjectTypeQuery15,
        ObjectTypeQuery16,
        ObjectTypeQuery17,
        ObjectTypeQuery18,
        ObjectTypeQuery19,
        ObjectTypeQuery20,
        ObjectTypeQuery21,
        ObjectTypeQuery22,
        ObjectTypeQuery23,
        ObjectTypeQuery24,
        ObjectTypeQuery25,
        ObjectTypeQuery26,
        ObjectTypeQuery27,
        ObjectTypeQuery28,
        ObjectTypeQuery29,
        ObjectTypeQuery30,
        ObjectTypeQuery31,
        ObjectTypeQuery32,
        ObjectTypeQuery_MAX,
        EObjectTypeQuery_MAX,
        WorldStatic = 0,
        WorldDynamic = 1,
        Pawn = 2,
        PhysicsBody = 3,
        Vehicle = 4,
        Destructible = 5,
        WHCShape = 6,
        VRModePawn = 7,
        BlockingArea = 8
    }

    export enum ETraceTypeQuery {
        TraceTypeQuery1,
        TraceTypeQuery2,
        TraceTypeQuery3,
        TraceTypeQuery4,
        TraceTypeQuery5,
        TraceTypeQuery6,
        TraceTypeQuery7,
        TraceTypeQuery8,
        TraceTypeQuery9,
        TraceTypeQuery10,
        TraceTypeQuery11,
        TraceTypeQuery12,
        TraceTypeQuery13,
        TraceTypeQuery14,
        TraceTypeQuery15,
        TraceTypeQuery16,
        TraceTypeQuery17,
        TraceTypeQuery18,
        TraceTypeQuery19,
        TraceTypeQuery20,
        TraceTypeQuery21,
        TraceTypeQuery22,
        TraceTypeQuery23,
        TraceTypeQuery24,
        TraceTypeQuery25,
        TraceTypeQuery26,
        TraceTypeQuery27,
        TraceTypeQuery28,
        TraceTypeQuery29,
        TraceTypeQuery30,
        TraceTypeQuery31,
        TraceTypeQuery32,
        TraceTypeQuery_MAX,
        ETraceTypeQuery_MAX,
        Visibility = 0,
        Camera = 1,
        WHCShapeChannel = 2,
        CameraFadeChannel = 3
    }

    export class UpdateLevelStreamingLevelStatus {
        constructor();
        constructor(PackageName: string, LODIndex: number, bNewShouldBeLoaded: boolean, bNewShouldBeVisible: boolean, bNewShouldBlockOnLoad: boolean);

        PackageName: string;
        LODIndex: number;
        bNewShouldBeLoaded: boolean;
        bNewShouldBeVisible: boolean;
        bNewShouldBlockOnLoad: boolean;

        static StaticClass(): Class;
    }

    export enum ETravelType { TRAVEL_Absolute, TRAVEL_Partial, TRAVEL_Relative, TRAVEL_MAX }

    export class ForceFeedbackParameters {
        constructor();
        constructor(Tag: string, bLooping: boolean, bIgnoreTimeDilation: boolean, bPlayWhilePaused: boolean);

        Tag: string;
        bLooping: boolean;
        bIgnoreTimeDilation: boolean;
        bPlayWhilePaused: boolean;

        static StaticClass(): Class;
    }

    export class PlayerController extends Controller {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Player: Player;
        AcknowledgedPawn: Pawn;
        ControllingDirTrackInst: InterpTrackInstDirector;
        MyHUD: HUD;
        PlayerCameraManager: PlayerCameraManager;
        PlayerCameraManagerClass: Class;
        bAutoManageActiveCameraTarget: boolean;
        TargetViewRotation: Rotator;
        SmoothTargetViewRotationSpeed: number;
        HiddenActors: TArray<Actor>;
        HiddenPrimitiveComponents: TArray<TWeakObjectPtr<PrimitiveComponent>>;
        LastSpectatorStateSynchTime: number;
        LastSpectatorSyncLocation: Vector;
        LastSpectatorSyncRotation: Rotator;
        ClientCap: number;
        CheatManager: CheatManager;
        CheatClass: Class;
        PlayerInput: PlayerInput;
        ActiveForceFeedbackEffects: TArray<ActiveForceFeedbackEffect>;
        bPlayerIsWaiting: boolean;
        NetPlayerIndex: number;
        PendingSwapConnection: NetConnection;
        NetConnection: NetConnection;
        InputYawScale: number;
        InputPitchScale: number;
        InputRollScale: number;
        bShowMouseCursor: boolean;
        bEnableClickEvents: boolean;
        bEnableTouchEvents: boolean;
        bEnableMouseOverEvents: boolean;
        bEnableTouchOverEvents: boolean;
        bForceFeedbackEnabled: boolean;
        ForceFeedbackScale: number;
        ClickEventKeys: TArray<Key>;
        DefaultMouseCursor: EMouseCursor;
        CurrentMouseCursor: EMouseCursor;
        DefaultClickTraceChannel: ECollisionChannel;
        CurrentClickTraceChannel: ECollisionChannel;
        HitResultTraceDistance: number;
        SeamlessTravelCount: number;
        LastCompletedSeamlessTravelCount: number;
        InactiveStateInputComponent: InputComponent;
        bShouldPerformFullTickWhenPaused: boolean;
        CurrentTouchInterface: TouchInterface;
        SpectatorPawn: SpectatorPawn;
        bIsLocalPlayerController: boolean;
        SpawnLocation: Vector;

        ActivateTouchInterface(NewTouchInterface: $Nullable<TouchInterface>): void;

        AddPitchInput(Val: number): void;

        AddRollInput(Val: number): void;

        AddYawInput(Val: number): void;

        Camera(NewMode: string): void;

        CanRestartPlayer(): boolean;

        ClearAudioListenerAttenuationOverride(): void;

        ClearAudioListenerOverride(): void;

        ClientAddTextureStreamingLoc(InLoc: Vector, Duration: number, bOverrideLocation: boolean): void;

        ClientCancelPendingMapChange(): void;

        ClientCapBandwidth(Cap: number): void;

        ClientClearCameraLensEffects(): void;

        ClientCommitMapChange(): void;

        ClientEnableNetworkVoice(bEnable: boolean): void;

        ClientEndOnlineSession(): void;

        ClientFlushLevelStreaming(): void;

        ClientForceGarbageCollection(): void;

        ClientGameEnded(EndGameFocus: $Nullable<Actor>, bIsWinner: boolean): void;

        ClientGotoState(NewState: string): void;

        ClientIgnoreLookInput(bIgnore: boolean): void;

        ClientIgnoreMoveInput(bIgnore: boolean): void;

        ClientMessage(S: string, Type: string, MsgLifeTime: number): void;

        ClientMutePlayer(PlayerId: UniqueNetIdRepl): void;

        ClientPlayCameraAnim(AnimToPlay: $Nullable<CameraAnim>, Scale?: number /* = 1.000000 */, Rate?: number /* = 1.000000 */, BlendInTime?: number /* = 0.000000 */, BlendOutTime?: number /* = 0.000000 */, bLoop?: boolean /* = false */, bRandomStartTime?: boolean /* = false */, Space?: ECameraShakePlaySpace /* = CameraLocal */, CustomPlaySpace?: Rotator /* =  */): void;

        ClientPlayForceFeedback_Internal(ForceFeedbackEffect: $Nullable<ForceFeedbackEffect>, Params: ForceFeedbackParameters): void;

        ClientPlaySound(Sound: $Nullable<SoundBase>, VolumeMultiplier: number, PitchMultiplier: number): void;

        ClientPlaySoundAtLocation(Sound: $Nullable<SoundBase>, Location: Vector, VolumeMultiplier: number, PitchMultiplier: number): void;

        ClientPrepareMapChange(LevelName: string, bFirst: boolean, bLast: boolean): void;

        ClientPrestreamTextures(ForcedActor: $Nullable<Actor>, ForceDuration: number, bEnableStreaming: boolean, CinematicTextureGroups: number): void;

        ClientReceiveLocalizedMessage(Message: $Nullable<Class>, Switch: number, RelatedPlayerState_1: $Nullable<PlayerState>, RelatedPlayerState_2: $Nullable<PlayerState>, OptionalObject: $Nullable<Object>): void;

        ClientRepObjRef(Object: $Nullable<Object>): void;

        ClientReset(): void;

        ClientRestart(NewPawn: $Nullable<Pawn>): void;

        ClientRetryClientRestart(NewPawn: $Nullable<Pawn>): void;

        ClientReturnToMainMenu(ReturnReason: string): void;

        ClientReturnToMainMenuWithTextReason(ReturnReason: string): void;

        ClientSetBlockOnAsyncLoading(): void;

        ClientSetCameraFade(bEnableFading: boolean, FadeColor: Color, FadeAlpha: Vector2D, FadeTime: number, bFadeAudio: boolean, bHoldWhenFinished: boolean): void;

        ClientSetCameraMode(NewCamMode: string): void;

        ClientSetCinematicMode(bInCinematicMode: boolean, bAffectsMovement: boolean, bAffectsTurning: boolean, bAffectsHUD: boolean): void;

        ClientSetForceMipLevelsToBeResident(Material: $Nullable<MaterialInterface>, ForceDuration: number, CinematicTextureGroups: number): void;

        ClientSetHUD(NewHUDClass: $Nullable<Class>): void;

        ClientSetSpectatorWaiting(bWaiting: boolean): void;

        ClientSetViewTarget(A: $Nullable<Actor>, TransitionParams: ViewTargetTransitionParams): void;

        ClientSpawnCameraLensEffect(LensEffectEmitterClass: $Nullable<Class>): void;

        ClientStartCameraShake(Shake: $Nullable<Class>, Scale?: number /* = 1.000000 */, PlaySpace?: ECameraShakePlaySpace /* = CameraLocal */, UserPlaySpaceRot?: Rotator /* =  */): void;

        ClientStartCameraShakeFromSource(Shake: $Nullable<Class>, SourceComponent: $Nullable<CameraShakeSourceComponent>): void;

        ClientStartOnlineSession(): void;

        ClientStopCameraAnim(AnimToStop: $Nullable<CameraAnim>): void;

        ClientStopCameraShake(Shake: $Nullable<Class>, bImmediately?: boolean /* = true */): void;

        ClientStopCameraShakesFromSource(SourceComponent: $Nullable<CameraShakeSourceComponent>, bImmediately?: boolean /* = true */): void;

        ClientStopForceFeedback(ForceFeedbackEffect: $Nullable<ForceFeedbackEffect>, Tag: string): void;

        ClientTeamMessage(SenderPlayerState: $Nullable<PlayerState>, S: string, Type: string, MsgLifeTime: number): void;

        ClientTravel(URL: string, TravelType: ETravelType, bSeamless: boolean, MapPackageGuid: Guid): void;

        ClientTravelInternal(URL: string, TravelType: ETravelType, bSeamless: boolean, MapPackageGuid: Guid): void;

        ClientUnmutePlayer(PlayerId: UniqueNetIdRepl): void;

        ClientUpdateLevelStreamingStatus(PackageName: string, bNewShouldBeLoaded: boolean, bNewShouldBeVisible: boolean, bNewShouldBlockOnLoad: boolean, LODIndex: number): void;

        ClientUpdateMultipleLevelsStreamingStatus(LevelStatuses: TArray<UpdateLevelStreamingLevelStatus>): void;

        ClientVoiceHandshakeComplete(): void;

        ClientWasKicked(KickReason: string): void;

        ConsoleKey(Key: Key): void;

        DeprojectMousePositionToWorld(WorldLocation: $Ref<Vector>, WorldDirection: $Ref<Vector>): boolean;

        DeprojectScreenPositionToWorld(ScreenX: number, ScreenY: number, WorldLocation: $Ref<Vector>, WorldDirection: $Ref<Vector>): boolean;

        EnableCheats(): void;

        FOV(NewFOV: number): void;

        GetFocalLocation(): Vector;

        GetHitResultUnderCursor(TraceChannel: ECollisionChannel, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;

        GetHitResultUnderCursorByChannel(TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;

        GetHitResultUnderCursorForObjects(ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;

        GetHitResultUnderFinger(FingerIndex: ETouchIndex, TraceChannel: ECollisionChannel, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;

        GetHitResultUnderFingerByChannel(FingerIndex: ETouchIndex, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;

        GetHitResultUnderFingerForObjects(FingerIndex: ETouchIndex, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;

        GetHUD(): HUD;

        GetInputAnalogKeyState(Key: Key): number;

        GetInputAnalogStickState(WhichStick: EControllerAnalogStick, StickX: $Ref<number>, StickY: $Ref<number>): void;

        GetInputKeyTimeDown(Key: Key): number;

        GetInputMotionState(Tilt: $Ref<Vector>, RotationRate: $Ref<Vector>, Gravity: $Ref<Vector>, Acceleration: $Ref<Vector>): void;

        GetInputMouseDelta(DeltaX: $Ref<number>, DeltaY: $Ref<number>): void;

        GetInputTouchState(FingerIndex: ETouchIndex, LocationX: $Ref<number>, LocationY: $Ref<number>, bIsCurrentlyPressed: $Ref<boolean>): void;

        GetInputVectorKeyState(Key: Key): Vector;

        GetMousePosition(LocationX: $Ref<number>, LocationY: $Ref<number>): boolean;

        GetSpectatorPawn(): SpectatorPawn;

        GetViewportSize(SizeX: $Ref<number>, SizeY: $Ref<number>): void;

        IsInputKeyDown(Key: Key): boolean;

        K2_ClientPlayForceFeedback(ForceFeedbackEffect: $Nullable<ForceFeedbackEffect>, Tag: string, bLooping: boolean, bIgnoreTimeDilation: boolean, bPlayWhilePaused: boolean): void;

        LocalTravel(URL: string): void;

        OnServerStartedVisualLogger(bIsLogging: boolean): void;

        Pause(): void;

        PlayDynamicForceFeedback(Intensity: number, Duration: number, bAffectsLeftLarge: boolean, bAffectsLeftSmall: boolean, bAffectsRightLarge: boolean, bAffectsRightSmall: boolean, Action: EDynamicForceFeedbackAction, LatentInfo: LatentActionInfo): void;

        PlayHapticEffect(HapticEffect: $Nullable<HapticFeedbackEffect_Base>, Hand: EControllerHand, Scale?: number /* = 1.000000 */, bLoop?: boolean /* = false */): void;

        ProjectWorldLocationToScreen(WorldLocation: Vector, ScreenLocation: $Ref<Vector2D>, bPlayerViewportRelative?: boolean /* = false */): boolean;

        ResetControllerLightColor(): void;

        RestartLevel(): void;

        SendToConsole(Command: string): void;

        ServerAcknowledgePossession(P: $Nullable<Pawn>): void;

        ServerCamera(NewMode: string): void;

        ServerChangeName(S: string): void;

        ServerCheckClientPossession(): void;

        ServerCheckClientPossessionReliable(): void;

        ServerExec(Msg: string): void;

        ServerExecRPC(Msg: string): void;

        ServerMutePlayer(PlayerId: UniqueNetIdRepl): void;

        ServerNotifyLoadedWorld(WorldPackageName: string): void;

        ServerPause(): void;

        ServerRestartPlayer(): void;

        ServerSetSpectatorLocation(NewLoc: Vector, NewRot: Rotator): void;

        ServerSetSpectatorWaiting(bWaiting: boolean): void;

        ServerShortTimeout(): void;

        ServerToggleAILogging(): void;

        ServerUnmutePlayer(PlayerId: UniqueNetIdRepl): void;

        ServerUpdateCamera(CamLoc: Vector_NetQuantize, CamPitchAndYaw: number): void;

        ServerUpdateLevelVisibility(LevelVisibility: UpdateLevelVisibilityLevelInfo): void;

        ServerUpdateMultipleLevelsVisibility(LevelVisibilities: TArray<UpdateLevelVisibilityLevelInfo>): void;

        ServerVerifyViewTarget(): void;

        ServerViewNextPlayer(): void;

        ServerViewPrevPlayer(): void;

        ServerViewSelf(TransitionParams: ViewTargetTransitionParams): void;

        SetAudioListenerAttenuationOverride(AttachToComponent: $Nullable<SceneComponent>, AttenuationLocationOVerride: Vector): void;

        SetAudioListenerOverride(AttachToComponent: $Nullable<SceneComponent>, Location: Vector, Rotation: Rotator): void;

        SetCinematicMode(bInCinematicMode: boolean, bHidePlayer: boolean, bAffectsHUD: boolean, bAffectsMovement: boolean, bAffectsTurning: boolean): void;

        SetControllerLightColor(Color: Color): void;

        SetDisableHaptics(bNewDisabled: boolean): void;

        SetHapticsByValue(Frequency: number, Amplitude: number, Hand: EControllerHand): void;

        SetMouseCursorWidget(Cursor: EMouseCursor, CursorWidget: $Nullable<UserWidget>): void;

        SetMouseLocation(X: number, Y: number): void;

        SetName(S: string): void;

        SetViewTargetWithBlend(NewViewTarget: $Nullable<Actor>, BlendTime?: number /* = 0.000000 */, BlendFunc?: EViewTargetBlendFunction /* = VTBlend_Linear */, BlendExp?: number /* = 0.000000 */, bLockOutgoing?: boolean /* = false */): void;

        SetVirtualJoystickVisibility(bVisible: boolean): void;

        StartFire(FireModeNum?: number /* = 0 */): void;

        StopHapticEffect(Hand: EControllerHand): void;

        SwitchLevel(URL: string): void;

        TestServerLevelVisibilityChange(PackageName: string, FileName: string): void;

        ToggleSpeaking(bInSpeaking: boolean): void;

        WasInputKeyJustPressed(Key: Key): boolean;

        WasInputKeyJustReleased(Key: Key): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlayerController;

        static Load(InName: string): PlayerController;
    }

    export class Controller extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerState: PlayerState;
        OnInstigatedAnyDamage: $MulticastDelegate<(Damage: number, DamageType: $Nullable<DamageType>, DamagedActor: $Nullable<Actor>, DamageCauser: $Nullable<Actor>) => void>;
        StateName: string;
        Pawn: Pawn;
        Character: Character;
        TransformComponent: SceneComponent;
        ControlRotation: Rotator;
        bAttachToPawn: boolean;

        CastToPlayerController(): PlayerController;

        ClientSetLocation(NewLocation: Vector, NewRotation: Rotator): void;

        ClientSetRotation(NewRotation: Rotator, bResetCamera: boolean): void;

        GetControlRotation(): Rotator;

        GetDesiredRotation(): Rotator;

        GetViewTarget(): Actor;

        IsLocalController(): boolean;

        IsLocalPlayerController(): boolean;

        IsLookInputIgnored(): boolean;

        IsMoveInputIgnored(): boolean;

        IsPlayerController(): boolean;

        K2_GetPawn(): Pawn;

        LineOfSightTo(Other: $Nullable<Actor>, ViewPoint?: Vector /* =  */, bAlternateChecks?: boolean /* = false */): boolean;

        OnRep_Pawn(): void;

        OnRep_PlayerState(): void;

        Possess(InPawn: $Nullable<Pawn>): void;

        ReceiveInstigatedAnyDamage(Damage: number, DamageType: $Nullable<DamageType>, DamagedActor: $Nullable<Actor>, DamageCauser: $Nullable<Actor>): void;

        ReceivePossess(PossessedPawn: $Nullable<Pawn>): void;

        ReceiveUnPossess(UnpossessedPawn: $Nullable<Pawn>): void;

        ResetIgnoreInputFlags(): void;

        ResetIgnoreLookInput(): void;

        ResetIgnoreMoveInput(): void;

        SetControlRotation(NewRotation: Rotator): void;

        SetIgnoreLookInput(bNewLookInput: boolean): void;

        SetIgnoreMoveInput(bNewMoveInput: boolean): void;

        SetInitialLocationAndRotation(NewLocation: Vector, NewRotation: Rotator): void;

        StopMovement(): void;

        UnPossess(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Controller;

        static Load(InName: string): Controller;
    }

    export class Pawn extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseControllerRotationPitch: boolean;
        bUseControllerRotationYaw: boolean;
        bUseControllerRotationRoll: boolean;
        bCanAffectNavigationGeneration: boolean;
        BaseEyeHeight: number;
        AutoPossessPlayer: EAutoReceiveInput;
        AutoPossessAI: EAutoPossessAI;
        RemoteViewPitch: number;
        AIControllerClass: Class;
        PlayerState: PlayerState;
        LastHitBy: Controller;
        Controller: Controller;
        ControlInputVector: Vector;
        LastControlInputVector: Vector;

        AddControllerPitchInput(Val: number): void;

        AddControllerRollInput(Val: number): void;

        AddControllerYawInput(Val: number): void;

        AddMovementInput(WorldDirection: Vector, ScaleValue?: number /* = 1.000000 */, bForce?: boolean /* = false */): void;

        ConsumeMovementInputVector(): Vector;

        DetachFromControllerPendingDestroy(): void;

        GetBaseAimRotation(): Rotator;

        GetController(): Controller;

        GetControlRotation(): Rotator;

        GetLastMovementInputVector(): Vector;

        GetMovementComponent(): PawnMovementComponent;

        GetNavAgentLocation(): Vector;

        GetPendingMovementInputVector(): Vector;

        IsBotControlled(): boolean;

        IsControlled(): boolean;

        IsLocallyControlled(): boolean;

        IsMoveInputIgnored(): boolean;

        IsPawnControlled(): boolean;

        IsPlayerControlled(): boolean;

        K2_GetMovementInputVector(): Vector;

        LaunchPawn(LaunchVelocity: Vector, bXYOverride: boolean, bZOverride: boolean): void;

        OnRep_Controller(): void;

        OnRep_PlayerState(): void;

        PawnMakeNoise(Loudness: number, NoiseLocation: Vector, bUseNoiseMakerLocation?: boolean /* = true */, NoiseMaker?: Actor /* = None */): void;

        ReceivePossessed(NewController: $Nullable<Controller>): void;

        ReceiveUnpossessed(OldController: $Nullable<Controller>): void;

        SetCanAffectNavigationGeneration(bNewValue: boolean, bForceUpdate?: boolean /* = false */): void;

        SpawnDefaultController(): void;

        static GetMovementBaseActor(Pawn: $Nullable<Pawn>): Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Pawn;

        static Load(InName: string): Pawn;
    }

    export enum ERadialImpulseFalloff { RIF_Constant, RIF_Linear, RIF_MAX }

    export class PrimitiveComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MinDrawDistance: number;
        LDMaxDrawDistance: number;
        CachedMaxDrawDistance: number;
        DepthPriorityGroup: ESceneDepthPriorityGroup;
        ViewOwnerDepthPriorityGroup: ESceneDepthPriorityGroup;
        IndirectLightingCacheQuality: EIndirectLightingCacheQuality;
        LightmapType: ELightmapType;
        ExcludeForSpecificHLODLevels: TArray<number>;
        bEnableAutoLODGeneration: boolean;
        bUseMaxLODAsImposter: boolean;
        bBatchImpostersAsInstances: boolean;
        bNeverDistanceCull: boolean;
        bAlwaysCreatePhysicsState: boolean;
        bGenerateOverlapEvents: boolean;
        bMultiBodyOverlap: boolean;
        bTraceComplexOnMove: boolean;
        bReturnMaterialOnMove: boolean;
        bUseViewOwnerDepthPriorityGroup: boolean;
        bAllowCullDistanceVolume: boolean;
        bHasMotionBlurVelocityMeshes: boolean;
        bVisibleInReflectionCaptures: boolean;
        bVisibleInRealTimeSkyCaptures: boolean;
        bVisibleInRayTracing: boolean;
        bRenderInMainPass: boolean;
        bRenderInDepthPass: boolean;
        bReceivesDecals: boolean;
        bOwnerNoSee: boolean;
        bOnlyOwnerSee: boolean;
        bTreatAsBackgroundForOcclusion: boolean;
        bUseAsOccluder: boolean;
        bSelectable: boolean;
        bForceMipStreaming: boolean;
        bHasPerInstanceHitProxies: boolean;
        CastShadow: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bAffectDistanceFieldLighting: boolean;
        bCastDynamicShadow: boolean;
        bCastStaticShadow: boolean;
        bCastVolumetricTranslucentShadow: boolean;
        bCastContactShadow: boolean;
        bSelfShadowOnly: boolean;
        bCastFarShadow: boolean;
        bCastInsetShadow: boolean;
        bCastCinematicShadow: boolean;
        bCastHiddenShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bLightAsIfStatic: boolean;
        bLightAttachmentsAsGroup: boolean;
        bExcludeFromLightAttachmentGroup: boolean;
        bReceiveMobileCSMShadows: boolean;
        bSingleSampleShadowFromStationaryLights: boolean;
        bIgnoreRadialImpulse: boolean;
        bIgnoreRadialForce: boolean;
        bApplyImpulseOnDamage: boolean;
        bReplicatePhysicsToAutonomousProxy: boolean;
        bFillCollisionUnderneathForNavmesh: boolean;
        AlwaysLoadOnClient: boolean;
        AlwaysLoadOnServer: boolean;
        bUseEditorCompositing: boolean;
        bRenderCustomDepth: boolean;
        bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
        HitProxyPriority: EHitProxyPriority;
        CanBeCharacterBase: ECanBeCharacterBase;
        CanCharacterStepUpOn: ECanBeCharacterBase;
        LightingChannels: LightingChannels;
        CustomDepthStencilWriteMask: ERendererStencilMask;
        CustomDepthStencilValue: number;
        CustomPrimitiveData: CustomPrimitiveData;
        CustomPrimitiveDataInternal: CustomPrimitiveData;
        TranslucencySortPriority: number;
        VisibilityId: number;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMinCoverage: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        LpvBiasMultiplier: number;
        BoundsScale: number;
        MoveIgnoreActors: TArray<Actor>;
        MoveIgnoreComponents: TArray<PrimitiveComponent>;
        BodyInstance: BodyInstance;
        OnComponentHit: $MulticastDelegate<(HitComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, NormalImpulse: Vector, Hit: HitResult) => void>;
        OnComponentBeginOverlap: $MulticastDelegate<(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
        OnComponentEndOverlap: $MulticastDelegate<(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number) => void>;
        OnComponentWake: $MulticastDelegate<(WakingComponent: $Nullable<PrimitiveComponent>, BoneName: string) => void>;
        OnComponentSleep: $MulticastDelegate<(SleepingComponent: $Nullable<PrimitiveComponent>, BoneName: string) => void>;
        OnBeginCursorOver: $MulticastDelegate<(TouchedComponent: $Nullable<PrimitiveComponent>) => void>;
        OnEndCursorOver: $MulticastDelegate<(TouchedComponent: $Nullable<PrimitiveComponent>) => void>;
        OnClicked: $MulticastDelegate<(TouchedComponent: $Nullable<PrimitiveComponent>, ButtonPressed: Key) => void>;
        OnReleased: $MulticastDelegate<(TouchedComponent: $Nullable<PrimitiveComponent>, ButtonReleased: Key) => void>;
        OnInputTouchBegin: $MulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: $Nullable<PrimitiveComponent>) => void>;
        OnInputTouchEnd: $MulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: $Nullable<PrimitiveComponent>) => void>;
        OnInputTouchEnter: $MulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: $Nullable<PrimitiveComponent>) => void>;
        OnInputTouchLeave: $MulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: $Nullable<PrimitiveComponent>) => void>;
        LODParentPrimitive: PrimitiveComponent;

        AddAngularImpulse(Impulse: Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */): void;

        AddAngularImpulseInDegrees(Impulse: Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */): void;

        AddAngularImpulseInRadians(Impulse: Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */): void;

        AddForce(Force: Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */): void;

        AddForceAtLocation(Force: Vector, Location: Vector, BoneName?: string /* = "None" */): void;

        AddForceAtLocationLocal(Force: Vector, Location: Vector, BoneName?: string /* = "None" */): void;

        AddImpulse(Impulse: Vector, BoneName?: string /* = "None" */, bVelChange?: boolean /* = false */): void;

        AddImpulseAtLocation(Impulse: Vector, Location: Vector, BoneName?: string /* = "None" */): void;

        AddRadialForce(Origin: Vector, Radius: number, Strength: number, Falloff: ERadialImpulseFalloff, bAccelChange?: boolean /* = false */): void;

        AddRadialImpulse(Origin: Vector, Radius: number, Strength: number, Falloff: ERadialImpulseFalloff, bVelChange?: boolean /* = false */): void;

        AddTorque(Torque: Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */): void;

        AddTorqueInDegrees(Torque: Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */): void;

        AddTorqueInRadians(Torque: Vector, BoneName?: string /* = "None" */, bAccelChange?: boolean /* = false */): void;

        CanCharacterStepUp(Pawn: $Nullable<Pawn>): boolean;

        ClearMoveIgnoreActors(): void;

        ClearMoveIgnoreComponents(): void;

        CopyArrayOfMoveIgnoreActors(): TArray<Actor>;

        CopyArrayOfMoveIgnoreComponents(): TArray<PrimitiveComponent>;

        CreateAndSetMaterialInstanceDynamic(ElementIndex: number): MaterialInstanceDynamic;

        CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex: number, Parent: $Nullable<MaterialInterface>): MaterialInstanceDynamic;

        CreateDynamicMaterialInstance(ElementIndex: number, SourceMaterial?: MaterialInterface /* = None */, OptionalName?: string /* = "None" */): MaterialInstanceDynamic;

        GetAngularDamping(): number;

        GetCenterOfMass(BoneName?: string /* = "None" */): Vector;

        GetClosestPointOnCollision(Point: Vector, OutPointOnBody: $Ref<Vector>, BoneName?: string /* = "None" */): number;

        GetCollisionEnabled(): ECollisionEnabled;

        GetCollisionObjectType(): ECollisionChannel;

        GetCollisionProfileName(): string;

        GetCollisionResponseToChannel(Channel: ECollisionChannel): ECollisionResponse;

        GetGenerateOverlapEvents(): boolean;

        GetInertiaTensor(BoneName?: string /* = "None" */): Vector;

        GetLinearDamping(): number;

        GetMass(): number;

        GetMassScale(BoneName?: string /* = "None" */): number;

        GetMaterial(ElementIndex: number): MaterialInterface;

        GetMaterialFromCollisionFaceIndex(FaceIndex: number, SectionIndex: $Ref<number>): MaterialInterface;

        GetNumMaterials(): number;

        GetOverlappingActors(OverlappingActors: $Ref<TArray<Actor>>, ClassFilter?: Class /* = None */): void;

        GetOverlappingComponents(OutOverlappingComponents: $Ref<TArray<PrimitiveComponent>>): void;

        GetPhysicsAngularVelocity(BoneName?: string /* = "None" */): Vector;

        GetPhysicsAngularVelocityInDegrees(BoneName?: string /* = "None" */): Vector;

        GetPhysicsAngularVelocityInRadians(BoneName?: string /* = "None" */): Vector;

        GetPhysicsLinearVelocity(BoneName?: string /* = "None" */): Vector;

        GetPhysicsLinearVelocityAtPoint(Point: Vector, BoneName?: string /* = "None" */): Vector;

        GetWalkableSlopeOverride(): WalkableSlopeOverride;

        IgnoreActorWhenMoving(Actor: $Nullable<Actor>, bShouldIgnore: boolean): void;

        IgnoreComponentWhenMoving(Component: $Nullable<PrimitiveComponent>, bShouldIgnore: boolean): void;

        IsAnyRigidBodyAwake(): boolean;

        IsGravityEnabled(): boolean;

        IsOverlappingActor(Other: $Nullable<Actor>): boolean;

        IsOverlappingComponent(OtherComp: $Nullable<PrimitiveComponent>): boolean;

        K2_BoxOverlapComponent(InBoxCentre: Vector, InBox: Box, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<Vector>, HitNormal: $Ref<Vector>, BoneName: $Ref<string>, OutHit: $Ref<HitResult>): boolean;

        K2_IsCollisionEnabled(): boolean;

        K2_IsPhysicsCollisionEnabled(): boolean;

        K2_IsQueryCollisionEnabled(): boolean;

        K2_LineTraceComponent(TraceStart: Vector, TraceEnd: Vector, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<Vector>, HitNormal: $Ref<Vector>, BoneName: $Ref<string>, OutHit: $Ref<HitResult>): boolean;

        K2_SphereOverlapComponent(InSphereCentre: Vector, InSphereRadius: number, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<Vector>, HitNormal: $Ref<Vector>, BoneName: $Ref<string>, OutHit: $Ref<HitResult>): boolean;

        K2_SphereTraceComponent(TraceStart: Vector, TraceEnd: Vector, SphereRadius: number, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<Vector>, HitNormal: $Ref<Vector>, BoneName: $Ref<string>, OutHit: $Ref<HitResult>): boolean;

        PutRigidBodyToSleep(BoneName?: string /* = "None" */): void;

        ScaleByMomentOfInertia(InputVector: Vector, BoneName?: string /* = "None" */): Vector;

        SetAllMassScale(InMassScale?: number /* = 1.000000 */): void;

        SetAllPhysicsAngularVelocityInDegrees(NewAngVel: Vector, bAddToCurrent?: boolean /* = false */): void;

        SetAllPhysicsAngularVelocityInRadians(NewAngVel: Vector, bAddToCurrent?: boolean /* = false */): void;

        SetAllPhysicsLinearVelocity(NewVel: Vector, bAddToCurrent?: boolean /* = false */): void;

        SetAllUseCCD(InUseCCD: boolean): void;

        SetAngularDamping(InDamping: number): void;

        SetBoundsScale(NewBoundsScale?: number /* = 1.000000 */): void;

        SetCastInsetShadow(bInCastInsetShadow: boolean): void;

        SetCastShadow(NewCastShadow: boolean): void;

        SetCenterOfMass(CenterOfMassOffset: Vector, BoneName?: string /* = "None" */): void;

        SetCollisionEnabled(NewType: ECollisionEnabled): void;

        SetCollisionObjectType(Channel: ECollisionChannel): void;

        SetCollisionProfileName(InCollisionProfileName: string, bUpdateOverlaps?: boolean /* = true */): void;

        SetCollisionResponseToAllChannels(NewResponse: ECollisionResponse): void;

        SetCollisionResponseToChannel(Channel: ECollisionChannel, NewResponse: ECollisionResponse): void;

        SetConstraintMode(ConstraintMode: EDOFMode): void;

        SetCullDistance(NewCullDistance: number): void;

        SetCustomDepthStencilValue(Value: number): void;

        SetCustomDepthStencilWriteMask(WriteMaskBit: ERendererStencilMask): void;

        SetCustomPrimitiveDataFloat(DataIndex: number, Value: number): void;

        SetCustomPrimitiveDataVector2(DataIndex: number, Value: Vector2D): void;

        SetCustomPrimitiveDataVector3(DataIndex: number, Value: Vector): void;

        SetCustomPrimitiveDataVector4(DataIndex: number, Value: Vector4): void;

        SetDefaultCustomPrimitiveDataFloat(DataIndex: number, Value: number): void;

        SetDefaultCustomPrimitiveDataVector2(DataIndex: number, Value: Vector2D): void;

        SetDefaultCustomPrimitiveDataVector3(DataIndex: number, Value: Vector): void;

        SetDefaultCustomPrimitiveDataVector4(DataIndex: number, Value: Vector4): void;

        SetEnableGravity(bGravityEnabled: boolean): void;

        SetExcludeFromLightAttachmentGroup(bInExcludeFromLightAttachmentGroup: boolean): void;

        SetGenerateOverlapEvents(bInGenerateOverlapEvents: boolean): void;

        SetLightAttachmentsAsGroup(bInLightAttachmentsAsGroup: boolean): void;

        SetLightingChannels(bChannel0: boolean, bChannel1: boolean, bChannel2: boolean): void;

        SetLinearDamping(InDamping: number): void;

        SetMassOverrideInKg(BoneName?: string /* = "None" */, MassInKg?: number /* = 1.000000 */, bOverrideMass?: boolean /* = true */): void;

        SetMassScale(BoneName?: string /* = "None" */, InMassScale?: number /* = 1.000000 */): void;

        SetMaterial(ElementIndex: number, Material: $Nullable<MaterialInterface>): void;

        SetMaterialByName(MaterialSlotName: string, Material: $Nullable<MaterialInterface>): void;

        SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;

        SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;

        SetOwnerNoSee(bNewOwnerNoSee: boolean): void;

        SetPhysicsAngularVelocity(NewAngVel: Vector, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */): void;

        SetPhysicsAngularVelocityInDegrees(NewAngVel: Vector, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */): void;

        SetPhysicsAngularVelocityInRadians(NewAngVel: Vector, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */): void;

        SetPhysicsLinearVelocity(NewVel: Vector, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */): void;

        SetPhysicsMaxAngularVelocity(NewMaxAngVel: number, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */): void;

        SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel: number, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */): void;

        SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel: number, bAddToCurrent?: boolean /* = false */, BoneName?: string /* = "None" */): void;

        SetPhysMaterialOverride(NewPhysMaterial: $Nullable<PhysicalMaterial>): void;

        SetReceivesDecals(bNewReceivesDecals: boolean): void;

        SetRenderCustomDepth(bValue: boolean): void;

        SetRenderInMainPass(bValue: boolean): void;

        SetSimulatePhysics(bSimulate: boolean): void;

        SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights: boolean): void;

        SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;

        SetUseCCD(InUseCCD: boolean, BoneName?: string /* = "None" */): void;

        SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;

        WakeAllRigidBodies(): void;

        WakeRigidBody(BoneName?: string /* = "None" */): void;

        WasRecentlyRendered(Tolerance?: number /* = 0.200000 */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PrimitiveComponent;

        static Load(InName: string): PrimitiveComponent;
    }

    export class BrushComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Brush: Model;
        BrushBodySetup: BodySetup;
        PrePivot: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushComponent;

        static Load(InName: string): BrushComponent;
    }

    export class BuilderPoly {
        constructor();
        constructor(VertexIndices: TArray<number>, Direction: number, ItemName: string, PolyFlags: number);

        VertexIndices: TArray<number>;
        Direction: number;
        ItemName: string;
        PolyFlags: number;

        static StaticClass(): Class;
    }

    export class BrushBuilder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BitmapFilename: string;
        ToolTip: string;
        NotifyBadParams: boolean;
        Vertices: TArray<Vector>;
        Polys: TArray<BuilderPoly>;
        Layer: string;
        MergeCoplanars: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushBuilder;

        static Load(InName: string): BrushBuilder;
    }

    export class GeomSelection {
        constructor();
        constructor(Type: number, Index: number, SelectionIndex: number);

        Type: number;
        Index: number;
        SelectionIndex: number;

        static StaticClass(): Class;
    }

    export class Brush extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BrushType: EBrushType;
        BrushColor: Color;
        PolyFlags: number;
        bColored: boolean;
        bSolidWhenSelected: boolean;
        bPlaceableFromClassBrowser: boolean;
        bNotForClientOrServer: boolean;
        Brush: Model;
        BrushComponent: BrushComponent;
        BrushBuilder: BrushBuilder;
        bInManipulation: boolean;
        SavedSelections: TArray<GeomSelection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Brush;

        static Load(InName: string): Brush;
    }

    export class Volume extends Brush {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Volume;

        static Load(InName: string): Volume;
    }

    export class PhysicsVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TerminalVelocity: number;
        Priority: number;
        FluidFriction: number;
        bWaterVolume: boolean;
        bPhysicsOnContact: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsVolume;

        static Load(InName: string): PhysicsVolume;
    }

    export enum EComponentMobility { Static, Stationary, Movable, EComponentMobility_MAX }

    export enum EDetachmentRule { KeepRelative, KeepWorld, EDetachmentRule_MAX }

    export enum ERelativeTransformSpace { RTS_World, RTS_Actor, RTS_Component, RTS_ParentBoneSpace, RTS_MAX }

    export class SceneComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicsVolume: TWeakObjectPtr<PhysicsVolume>;
        AttachParent: SceneComponent;
        AttachSocketName: string;
        AttachChildren: TArray<SceneComponent>;
        ClientAttachedChildren: TArray<SceneComponent>;
        RelativeLocation: Vector;
        RelativeRotation: Rotator;
        RelativeScale3D: Vector;
        ComponentVelocity: Vector;
        bComponentToWorldUpdated: boolean;
        bAbsoluteLocation: boolean;
        bAbsoluteRotation: boolean;
        bAbsoluteScale: boolean;
        bVisible: boolean;
        bShouldBeAttached: boolean;
        bShouldSnapLocationWhenAttached: boolean;
        bShouldSnapRotationWhenAttached: boolean;
        bShouldUpdatePhysicsVolume: boolean;
        bHiddenInGame: boolean;
        bBoundsChangeTriggersStreamingDataRebuild: boolean;
        bUseAttachParentBound: boolean;
        bVisualizeComponent: boolean;
        Mobility: EComponentMobility;
        DetailMode: EDetailMode;
        PhysicsVolumeChangedDelegate: $MulticastDelegate<(NewVolume: $Nullable<PhysicsVolume>) => void>;

        DetachFromParent(bMaintainWorldPosition?: boolean /* = false */, bCallModify?: boolean /* = true */): void;

        DoesSocketExist(InSocketName: string): boolean;

        GetAllSocketNames(): TArray<string>;

        GetAttachParent(): SceneComponent;

        GetAttachSocketName(): string;

        GetChildComponent(ChildIndex: number): SceneComponent;

        GetChildrenComponents(bIncludeAllDescendants: boolean, Children: $Ref<TArray<SceneComponent>>): void;

        GetComponentVelocity(): Vector;

        GetForwardVector(): Vector;

        GetNumChildrenComponents(): number;

        GetParentComponents(Parents: $Ref<TArray<SceneComponent>>): void;

        GetPhysicsVolume(): PhysicsVolume;

        GetRelativeTransform(): Transform;

        GetRightVector(): Vector;

        GetShouldUpdatePhysicsVolume(): boolean;

        GetSocketLocation(InSocketName: string): Vector;

        GetSocketQuaternion(InSocketName: string): Quat;

        GetSocketRotation(InSocketName: string): Rotator;

        GetSocketTransform(InSocketName: string, TransformSpace?: ERelativeTransformSpace /* = RTS_World */): Transform;

        GetUpVector(): Vector;

        IsAnySimulatingPhysics(): boolean;

        IsSimulatingPhysics(BoneName?: string /* = "None" */): boolean;

        IsVisible(): boolean;

        K2_AddLocalOffset(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddLocalRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddLocalTransform(DeltaTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddRelativeLocation(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddRelativeRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddWorldOffset(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddWorldRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddWorldTransform(DeltaTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddWorldTransformKeepScale(DeltaTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AttachTo(InParent: $Nullable<SceneComponent>, InSocketName?: string /* = "None" */, AttachType?: EAttachLocation /* = KeepRelativeOffset */, bWeldSimulatedBodies?: boolean /* = true */): boolean;

        K2_AttachToComponent(Parent: $Nullable<SceneComponent>, SocketName: string, LocationRule: EAttachmentRule, RotationRule: EAttachmentRule, ScaleRule: EAttachmentRule, bWeldSimulatedBodies: boolean): boolean;

        K2_DetachFromComponent(LocationRule?: EDetachmentRule /* = KeepRelative */, RotationRule?: EDetachmentRule /* = KeepRelative */, ScaleRule?: EDetachmentRule /* = KeepRelative */, bCallModify?: boolean /* = true */): void;

        K2_GetComponentLocation(): Vector;

        K2_GetComponentRotation(): Rotator;

        K2_GetComponentScale(): Vector;

        K2_GetComponentToWorld(): Transform;

        K2_SetRelativeLocation(NewLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetRelativeLocationAndRotation(NewLocation: Vector, NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetRelativeRotation(NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetRelativeTransform(NewTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetWorldLocation(NewLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetWorldLocationAndRotation(NewLocation: Vector, NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetWorldRotation(NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetWorldTransform(NewTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        OnRep_AttachChildren(): void;

        OnRep_AttachParent(): void;

        OnRep_AttachSocketName(): void;

        OnRep_Transform(): void;

        OnRep_Visibility(OldValue: boolean): void;

        ResetRelativeTransform(): void;

        SetAbsolute(bNewAbsoluteLocation?: boolean /* = false */, bNewAbsoluteRotation?: boolean /* = false */, bNewAbsoluteScale?: boolean /* = false */): void;

        SetHiddenInGame(NewHidden: boolean, bPropagateToChildren?: boolean /* = false */): void;

        SetMobility(NewMobility: EComponentMobility): void;

        SetRelativeScale3D(NewScale3D: Vector): void;

        SetShouldUpdatePhysicsVolume(bInShouldUpdatePhysicsVolume: boolean): void;

        SetupAttachment(p0: $Nullable<SceneComponent>, p1: string): void;

        SetVisibility(bNewVisibility: boolean, bPropagateToChildren?: boolean /* = false */): void;

        SetWorldScale3D(NewScale: Vector): void;

        SnapTo(InParent: $Nullable<SceneComponent>, InSocketName?: string /* = "None" */): boolean;

        ToggleVisibility(bPropagateToChildren?: boolean /* = false */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneComponent;

        static Load(InName: string): SceneComponent;
    }

    export class RepAttachment {
        constructor();
        constructor(AttachParent: Actor, LocationOffset: Vector_NetQuantize100, RelativeScale3D: Vector_NetQuantize100, RotationOffset: Rotator, AttachSocket: string, AttachComponent: SceneComponent);

        AttachParent: Actor;
        LocationOffset: Vector_NetQuantize100;
        RelativeScale3D: Vector_NetQuantize100;
        RotationOffset: Rotator;
        AttachSocket: string;
        AttachComponent: SceneComponent;

        static StaticClass(): Class;
    }

    export enum ENetDormancy { DORM_Never, DORM_Awake, DORM_DormantAll, DORM_DormantPartial, DORM_Initial, DORM_MAX }

    export class InterpFilter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Caption: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpFilter;

        static Load(InName: string): InterpFilter;
    }

    export class InterpGroupDirector extends InterpGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpGroupDirector;

        static Load(InName: string): InterpGroupDirector;
    }

    export class InterpData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InterpLength: number;
        PathBuildTime: number;
        InterpGroups: TArray<InterpGroup>;
        CurveEdSetup: InterpCurveEdSetup;
        InterpFilters: TArray<InterpFilter>;
        SelectedFilter: InterpFilter;
        DefaultFilters: TArray<InterpFilter>;
        EdSectionStart: number;
        EdSectionEnd: number;
        bShouldBakeAndPrune: boolean;
        CachedDirectorGroup: InterpGroupDirector;
        AllEventNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpData;

        static Load(InName: string): InterpData;
    }

    export class InterpGroupActorInfo {
        constructor();
        constructor(ObjectName: string, Actors: TArray<Actor>);

        ObjectName: string;
        Actors: TArray<Actor>;

        static StaticClass(): Class;
    }

    export class CameraCutInfo {
        constructor();
        constructor(Location: Vector, TimeStamp: number);

        Location: Vector;
        TimeStamp: number;

        static StaticClass(): Class;
    }

    export class MatineeActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MatineeData: InterpData;
        MatineeControllerName: string;
        PlayRate: number;
        bPlayOnLevelLoad: boolean;
        bForceStartPos: boolean;
        ForceStartPosition: number;
        bLooping: boolean;
        bRewindOnPlay: boolean;
        bNoResetOnRewind: boolean;
        bRewindIfAlreadyPlaying: boolean;
        bDisableRadioFilter: boolean;
        bClientSideOnly: boolean;
        bSkipUpdateIfNotVisible: boolean;
        bIsSkippable: boolean;
        PreferredSplitScreenNum: number;
        bDisableMovementInput: boolean;
        bDisableLookAtInput: boolean;
        bHidePlayer: boolean;
        bHideHud: boolean;
        GroupActorInfos: TArray<InterpGroupActorInfo>;
        bShouldShowGore: boolean;
        GroupInst: TArray<InterpGroupInst>;
        CameraCuts: TArray<CameraCutInfo>;
        SpriteComponent: BillboardComponent;
        bIsBeingEdited: boolean;
        bIsScrubbing: boolean;
        bIsPlaying: boolean;
        bReversePlayback: boolean;
        bPaused: boolean;
        bPendingStop: boolean;
        InterpPosition: number;
        ReplicationForceIsPlaying: number;
        OnPlay: $MulticastDelegate<() => void>;
        OnStop: $MulticastDelegate<() => void>;
        OnPause: $MulticastDelegate<() => void>;

        ChangePlaybackDirection(): void;

        EnableGroupByName(GroupName: string, bEnable: boolean): void;

        Pause(): void;

        Play(): void;

        Reverse(): void;

        SetLoopingState(bNewLooping: boolean): void;

        SetPosition(NewPosition: number, bJump?: boolean /* = false */): void;

        Stop(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MatineeActor;

        static Load(InName: string): MatineeActor;
    }

    export enum EChildActorComponentTreeViewVisualizationMode {
        UseDefault,
        ComponentOnly,
        ComponentWithChildActor,
        ChildActorOnly,
        EChildActorComponentTreeViewVisualizationMode_MAX
    }

    export class ChildActorComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChildActorClass: Class;
        ChildActor: Actor;
        ChildActorTemplate: Actor;
        EditorTreeViewVisualizationMode: EChildActorComponentTreeViewVisualizationMode;

        SetChildActorClass(InClass: $Nullable<Class>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChildActorComponent;

        static Load(InName: string): ChildActorComponent;
    }

    export class Actor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PrimaryActorTick: ActorTickFunction;
        bNetTemporary: boolean;
        bNetStartup: boolean;
        bOnlyRelevantToOwner: boolean;
        bAlwaysRelevant: boolean;
        bReplicateMovement: boolean;
        bHidden: boolean;
        bTearOff: boolean;
        bExchangedRoles: boolean;
        bNetLoadOnClient: boolean;
        bNetUseOwnerRelevancy: boolean;
        bRelevantForNetworkReplays: boolean;
        bRelevantForLevelBounds: boolean;
        bReplayRewindable: boolean;
        bAllowTickBeforeBeginPlay: boolean;
        bAutoDestroyWhenFinished: boolean;
        bCanBeDamaged: boolean;
        bBlockInput: boolean;
        bCollideWhenPlacing: boolean;
        bFindCameraComponentWhenViewTarget: boolean;
        bGenerateOverlapEventsDuringLevelStreaming: boolean;
        bIgnoresOriginShifting: boolean;
        bEnableAutoLODGeneration: boolean;
        bIsEditorOnlyActor: boolean;
        bActorSeamlessTraveled: boolean;
        bReplicates: boolean;
        bCanBeInCluster: boolean;
        bAllowReceiveTickEventOnDedicatedServer: boolean;
        bActorEnableCollision: boolean;
        bActorIsBeingDestroyed: boolean;
        UpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
        DefaultUpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
        RemoteRole: ENetRole;
        ReplicatedMovement: RepMovement;
        InitialLifeSpan: number;
        CustomTimeDilation: number;
        AttachmentReplication: RepAttachment;
        Owner: Actor;
        NetDriverName: string;
        Role: ENetRole;
        NetDormancy: ENetDormancy;
        SpawnCollisionHandlingMethod: ESpawnActorCollisionHandlingMethod;
        AutoReceiveInput: EAutoReceiveInput;
        InputPriority: number;
        InputComponent: InputComponent;
        NetCullDistanceSquared: number;
        NetTag: number;
        NetUpdateFrequency: number;
        MinNetUpdateFrequency: number;
        NetPriority: number;
        Instigator: Pawn;
        Children: TArray<Actor>;
        RootComponent: SceneComponent;
        PivotOffset: Vector;
        ControllingMatineeActors: TArray<MatineeActor>;
        Layers: TArray<string>;
        ParentComponentActor: TWeakObjectPtr<Actor>;
        ParentComponent: TWeakObjectPtr<ChildActorComponent>;
        ActorGuid: Guid;
        GroupActor: Actor;
        SpriteScale: number;
        HiddenEditorViews: bigint;
        ActorLabel: string;
        FolderPath: string;
        bHiddenEd: boolean;
        bIsEditorPreviewActor: boolean;
        bHiddenEdLayer: boolean;
        bHiddenEdLevel: boolean;
        bLockLocation: boolean;
        bActorLabelEditable: boolean;
        bEditable: boolean;
        bListedInSceneOutliner: boolean;
        bOptimizeBPComponentData: boolean;
        bHiddenEdTemporary: boolean;
        Tags: TArray<string>;
        OnTakeAnyDamage: $MulticastDelegate<(DamagedActor: $Nullable<Actor>, Damage: number, DamageType: $Nullable<DamageType>, InstigatedBy: $Nullable<Controller>, DamageCauser: $Nullable<Actor>) => void>;
        OnTakePointDamage: $MulticastDelegate<(DamagedActor: $Nullable<Actor>, Damage: number, InstigatedBy: $Nullable<Controller>, HitLocation: Vector, FHitComponent: $Nullable<PrimitiveComponent>, BoneName: string, ShotFromDirection: Vector, DamageType: $Nullable<DamageType>, DamageCauser: $Nullable<Actor>) => void>;
        OnTakeRadialDamage: $MulticastDelegate<(DamagedActor: $Nullable<Actor>, Damage: number, DamageType: $Nullable<DamageType>, Origin: Vector, HitInfo: HitResult, InstigatedBy: $Nullable<Controller>, DamageCauser: $Nullable<Actor>) => void>;
        OnActorBeginOverlap: $MulticastDelegate<(OverlappedActor: $Nullable<Actor>, OtherActor: $Nullable<Actor>) => void>;
        OnActorEndOverlap: $MulticastDelegate<(OverlappedActor: $Nullable<Actor>, OtherActor: $Nullable<Actor>) => void>;
        OnBeginCursorOver: $MulticastDelegate<(TouchedActor: $Nullable<Actor>) => void>;
        OnEndCursorOver: $MulticastDelegate<(TouchedActor: $Nullable<Actor>) => void>;
        OnClicked: $MulticastDelegate<(TouchedActor: $Nullable<Actor>, ButtonPressed: Key) => void>;
        OnReleased: $MulticastDelegate<(TouchedActor: $Nullable<Actor>, ButtonReleased: Key) => void>;
        OnInputTouchBegin: $MulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: $Nullable<Actor>) => void>;
        OnInputTouchEnd: $MulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: $Nullable<Actor>) => void>;
        OnInputTouchEnter: $MulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: $Nullable<Actor>) => void>;
        OnInputTouchLeave: $MulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: $Nullable<Actor>) => void>;
        OnActorHit: $MulticastDelegate<(SelfActor: $Nullable<Actor>, OtherActor: $Nullable<Actor>, NormalImpulse: Vector, Hit: HitResult) => void>;
        OnDestroyed: $MulticastDelegate<(DestroyedActor: $Nullable<Actor>) => void>;
        OnEndPlay: $MulticastDelegate<(Actor: $Nullable<Actor>, EndPlayReason: EEndPlayReason) => void>;
        InstanceComponents: TArray<ActorComponent>;
        BlueprintCreatedComponents: TArray<ActorComponent>;

        ActorHasTag(Tag: string): boolean;

        AddComponent(TemplateName: string, bManualAttachment: boolean, RelativeTransform: Transform, ComponentTemplateContext: $Nullable<Object>, bDeferredFinish?: boolean /* = false */): ActorComponent;

        AddComponentByClass(Class: $Nullable<Class>, bManualAttachment: boolean, RelativeTransform: Transform, bDeferredFinish: boolean): ActorComponent;

        AddTickPrerequisiteActor(PrerequisiteActor: $Nullable<Actor>): void;

        AddTickPrerequisiteComponent(PrerequisiteComponent: $Nullable<ActorComponent>): void;

        DetachRootComponentFromParent(bMaintainWorldPosition?: boolean /* = true */): void;

        DisableInput(PlayerController: $Nullable<PlayerController>): void;

        EnableInput(PlayerController: $Nullable<PlayerController>): void;

        FinishAddComponent(Component: $Nullable<ActorComponent>, bManualAttachment: boolean, RelativeTransform: Transform): void;

        FlushNetDormancy(): void;

        ForceNetUpdate(): void;

        GetActorBounds(bOnlyCollidingComponents: boolean, Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>, bIncludeFromChildActors?: boolean /* = false */): void;

        GetActorEnableCollision(): boolean;

        GetActorEyesViewPoint(OutLocation: $Ref<Vector>, OutRotation: $Ref<Rotator>): void;

        GetActorForwardVector(): Vector;

        GetActorLabel(): string;

        GetActorRelativeScale3D(): Vector;

        GetActorRightVector(): Vector;

        GetActorScale3D(): Vector;

        GetActorTickInterval(): number;

        GetActorTimeDilation(): number;

        GetActorUpVector(): Vector;

        GetAllChildActors(ChildActors: $Ref<TArray<Actor>>, bIncludeDescendants?: boolean /* = true */): void;

        GetAttachedActors(OutActors: $Ref<TArray<Actor>>, bResetArray?: boolean /* = true */): void;

        GetAttachParentActor(): Actor;

        GetAttachParentSocketName(): string;

        GetComponentByClass(ComponentClass: $Nullable<Class>): ActorComponent;

        GetComponentsByInterface(Interface: $Nullable<Class>): TArray<ActorComponent>;

        GetComponentsByTag(ComponentClass: $Nullable<Class>, Tag: string): TArray<ActorComponent>;

        GetDistanceTo(OtherActor: $Nullable<Actor>): number;

        GetDotProductTo(OtherActor: $Nullable<Actor>): number;

        GetFolderPath(): string;

        GetGameTimeSinceCreation(): number;

        GetHorizontalDistanceTo(OtherActor: $Nullable<Actor>): number;

        GetHorizontalDotProductTo(OtherActor: $Nullable<Actor>): number;

        GetInputAxisKeyValue(InputAxisKey: Key): number;

        GetInputAxisValue(InputAxisName: string): number;

        GetInputVectorAxisValue(InputAxisKey: Key): Vector;

        GetInstigator(): Pawn;

        GetInstigatorController(): Controller;

        GetLifeSpan(): number;

        GetLocalRole(): ENetRole;

        GetOverlappingActors(OverlappingActors: $Ref<TArray<Actor>>, ClassFilter?: Class /* = None */): void;

        GetOverlappingComponents(OverlappingComponents: $Ref<TArray<PrimitiveComponent>>): void;

        GetOwner(): Actor;

        GetParentActor(): Actor;

        GetParentComponent(): ChildActorComponent;

        GetRemoteRole(): ENetRole;

        GetSquaredDistanceTo(OtherActor: $Nullable<Actor>): number;

        GetTickableWhenPaused(): boolean;

        GetTransform(): Transform;

        GetVelocity(): Vector;

        GetVerticalDistanceTo(OtherActor: $Nullable<Actor>): number;

        HasAuthority(): boolean;

        IsActorBeingDestroyed(): boolean;

        IsActorTickEnabled(): boolean;

        IsChildActor(): boolean;

        IsEditable(): boolean;

        IsHiddenEd(): boolean;

        IsHiddenEdAtStartup(): boolean;

        IsOverlappingActor(Other: $Nullable<Actor>): boolean;

        IsSelectable(): boolean;

        IsTemporarilyHiddenInEditor(bIncludeParent?: boolean /* = false */): boolean;

        K2_AddActorLocalOffset(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddActorLocalRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddActorLocalTransform(NewTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddActorWorldOffset(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddActorWorldRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddActorWorldTransform(DeltaTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AddActorWorldTransformKeepScale(DeltaTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_AttachRootComponentTo(InParent: $Nullable<SceneComponent>, InSocketName?: string /* = "None" */, AttachLocationType?: EAttachLocation /* = KeepRelativeOffset */, bWeldSimulatedBodies?: boolean /* = true */): void;

        K2_AttachRootComponentToActor(InParentActor: $Nullable<Actor>, InSocketName?: string /* = "None" */, AttachLocationType?: EAttachLocation /* = KeepRelativeOffset */, bWeldSimulatedBodies?: boolean /* = true */): void;

        K2_AttachToActor(ParentActor: $Nullable<Actor>, SocketName: string, LocationRule: EAttachmentRule, RotationRule: EAttachmentRule, ScaleRule: EAttachmentRule, bWeldSimulatedBodies: boolean): void;

        K2_AttachToComponent(Parent: $Nullable<SceneComponent>, SocketName: string, LocationRule: EAttachmentRule, RotationRule: EAttachmentRule, ScaleRule: EAttachmentRule, bWeldSimulatedBodies: boolean): void;

        K2_DestroyActor(): void;

        K2_DestroyComponent(Component: $Nullable<ActorComponent>): void;

        K2_DetachFromActor(LocationRule?: EDetachmentRule /* = KeepRelative */, RotationRule?: EDetachmentRule /* = KeepRelative */, ScaleRule?: EDetachmentRule /* = KeepRelative */): void;

        K2_GetActorLocation(): Vector;

        K2_GetActorRotation(): Rotator;

        K2_GetComponentsByClass(ComponentClass: $Nullable<Class>): TArray<ActorComponent>;

        K2_GetRootComponent(): SceneComponent;

        K2_OnBecomeViewTarget(PC: $Nullable<PlayerController>): void;

        K2_OnEndViewTarget(PC: $Nullable<PlayerController>): void;

        K2_OnReset(): void;

        K2_SetActorLocation(NewLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): boolean;

        K2_SetActorLocationAndRotation(NewLocation: Vector, NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): boolean;

        K2_SetActorRelativeLocation(NewRelativeLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetActorRelativeRotation(NewRelativeRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetActorRelativeTransform(NewRelativeTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;

        K2_SetActorRotation(NewRotation: Rotator, bTeleportPhysics: boolean): boolean;

        K2_SetActorTransform(NewTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): boolean;

        K2_TeleportTo(DestLocation: Vector, DestRotation: Rotator): boolean;

        MakeMIDForMaterial(Parent: $Nullable<MaterialInterface>): MaterialInstanceDynamic;

        MakeNoise(Loudness?: number /* = 1.000000 */, NoiseInstigator?: Pawn /* = None */, NoiseLocation?: Vector /* =  */, MaxRange?: number /* = 0.000000 */, Tag?: string /* = "None" */): void;

        OnRep_AttachmentReplication(): void;

        OnRep_Instigator(): void;

        OnRep_Owner(): void;

        OnRep_ReplicatedMovement(): void;

        OnRep_ReplicateMovement(): void;

        PrestreamTextures(Seconds: number, bEnableStreaming: boolean, CinematicTextureGroups?: number /* = 0 */): void;

        ReceiveActorBeginCursorOver(): void;

        ReceiveActorBeginOverlap(OtherActor: $Nullable<Actor>): void;

        ReceiveActorEndCursorOver(): void;

        ReceiveActorEndOverlap(OtherActor: $Nullable<Actor>): void;

        ReceiveActorOnClicked(ButtonPressed: Key): void;

        ReceiveActorOnInputTouchBegin(FingerIndex: ETouchIndex): void;

        ReceiveActorOnInputTouchEnd(FingerIndex: ETouchIndex): void;

        ReceiveActorOnInputTouchEnter(FingerIndex: ETouchIndex): void;

        ReceiveActorOnInputTouchLeave(FingerIndex: ETouchIndex): void;

        ReceiveActorOnReleased(ButtonReleased: Key): void;

        ReceiveAnyDamage(Damage: number, DamageType: $Nullable<DamageType>, InstigatedBy: $Nullable<Controller>, DamageCauser: $Nullable<Actor>): void;

        ReceiveBeginPlay(): void;

        ReceiveDestroyed(): void;

        ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;

        ReceiveHit(MyComp: $Nullable<PrimitiveComponent>, Other: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, bSelfMoved: boolean, HitLocation: Vector, HitNormal: Vector, NormalImpulse: Vector, Hit: HitResult): void;

        ReceivePointDamage(Damage: number, DamageType: $Nullable<DamageType>, HitLocation: Vector, HitNormal: Vector, HitComponent: $Nullable<PrimitiveComponent>, BoneName: string, ShotFromDirection: Vector, InstigatedBy: $Nullable<Controller>, DamageCauser: $Nullable<Actor>, HitInfo: HitResult): void;

        ReceiveRadialDamage(DamageReceived: number, DamageType: $Nullable<DamageType>, Origin: Vector, HitInfo: HitResult, InstigatedBy: $Nullable<Controller>, DamageCauser: $Nullable<Actor>): void;

        ReceiveTick(DeltaSeconds: number): void;

        RemoveTickPrerequisiteActor(PrerequisiteActor: $Nullable<Actor>): void;

        RemoveTickPrerequisiteComponent(PrerequisiteComponent: $Nullable<ActorComponent>): void;

        SetActorEnableCollision(bNewActorEnableCollision: boolean): void;

        SetActorHiddenInGame(bNewHidden: boolean): void;

        SetActorLabel(NewActorLabel: string, bMarkDirty?: boolean /* = true */): void;

        SetActorRelativeScale3D(NewRelativeScale: Vector): void;

        SetActorScale3D(NewScale3D: Vector): void;

        SetActorTickEnabled(bEnabled: boolean): void;

        SetActorTickInterval(TickInterval: number): void;

        SetAutoDestroyWhenFinished(bVal: boolean): void;

        SetFolderPath(NewFolderPath: string): void;

        SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;

        SetLifeSpan(InLifespan: number): void;

        SetNetDormancy(NewDormancy: ENetDormancy): void;

        SetOwner(NewOwner: $Nullable<Actor>): void;

        SetReplicateMovement(bInReplicateMovement: boolean): void;

        SetReplicates(bInReplicates: boolean): void;

        SetTickableWhenPaused(bTickableWhenPaused: boolean): void;

        SetTickGroup(NewTickGroup: ETickingGroup): void;

        SnapRootComponentTo(InParentActor: $Nullable<Actor>, InSocketName: string): void;

        TearOff(): void;

        UserConstructionScript(): void;

        WasRecentlyRendered(Tolerance?: number /* = 0.200000 */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Actor;

        static Load(InName: string): Actor;
    }

    export class GameplayTag {
        constructor();
        constructor(TagName: string);

        TagName: string;

        static StaticClass(): Class;
    }

    export class GameplayEffectContextHandle {
        constructor();

        static StaticClass(): Class;
    }

    export class GameplayTagContainer {
        constructor();
        constructor(GameplayTags: TArray<GameplayTag>, ParentTags: TArray<GameplayTag>);

        GameplayTags: TArray<GameplayTag>;
        ParentTags: TArray<GameplayTag>;

        static StaticClass(): Class;
    }

    export class GameplayEventData {
        constructor();
        constructor(EventTag: GameplayTag, Instigator: Actor, Target: Actor, OptionalObject: Object, OptionalObject2: Object, ContextHandle: GameplayEffectContextHandle, InstigatorTags: GameplayTagContainer, TargetTags: GameplayTagContainer, EventMagnitude: number, TargetData: GameplayAbilityTargetDataHandle);

        EventTag: GameplayTag;
        Instigator: Actor;
        Target: Actor;
        OptionalObject: Object;
        OptionalObject2: Object;
        ContextHandle: GameplayEffectContextHandle;
        InstigatorTags: GameplayTagContainer;
        TargetTags: GameplayTagContainer;
        EventMagnitude: number;
        TargetData: GameplayAbilityTargetDataHandle;

        static StaticClass(): Class;
    }

    export class GameplayAttribute {
        AttributeName: string;
        AttributeOwner: Struct;

        static StaticClass(): Class;
    }

    export enum EGameplayEffectDurationType { Instant, Infinite, HasDuration, EGameplayEffectDurationType_MAX }

    export enum EGameplayEffectMagnitudeCalculation {
        ScalableFloat,
        AttributeBased,
        CustomCalculationClass,
        SetByCaller,
        EGameplayEffectMagnitudeCalculation_MAX
    }

    export class CurveTableRowHandle {
        constructor();
        constructor(CurveTable: CurveTable, RowName: string);

        CurveTable: CurveTable;
        RowName: string;

        static StaticClass(): Class;
    }

    export class ScalableFloat {
        constructor();
        constructor(Value: number, Curve: CurveTableRowHandle);

        Value: number;
        Curve: CurveTableRowHandle;

        static StaticClass(): Class;
    }

    export enum EGameplayEffectAttributeCaptureSource { Source, Target, EGameplayEffectAttributeCaptureSource_MAX }

    export class GameplayEffectAttributeCaptureDefinition {
        constructor();
        constructor(AttributeToCapture: GameplayAttribute, AttributeSource: EGameplayEffectAttributeCaptureSource, bSnapshot: boolean);

        AttributeToCapture: GameplayAttribute;
        AttributeSource: EGameplayEffectAttributeCaptureSource;
        bSnapshot: boolean;

        static StaticClass(): Class;
    }

    export enum EAttributeBasedFloatCalculationType {
        AttributeMagnitude,
        AttributeBaseValue,
        AttributeBonusMagnitude,
        AttributeMagnitudeEvaluatedUpToChannel,
        EAttributeBasedFloatCalculationType_MAX
    }

    export enum EGameplayModEvaluationChannel {
        Channel0,
        Channel1,
        Channel2,
        Channel3,
        Channel4,
        Channel5,
        Channel6,
        Channel7,
        Channel8,
        Channel9,
        Channel_MAX,
        EGameplayModEvaluationChannel_MAX
    }

    export class AttributeBasedFloat {
        constructor();
        constructor(Coefficient: ScalableFloat, PreMultiplyAdditiveValue: ScalableFloat, PostMultiplyAdditiveValue: ScalableFloat, BackingAttribute: GameplayEffectAttributeCaptureDefinition, AttributeCurve: CurveTableRowHandle, AttributeCalculationType: EAttributeBasedFloatCalculationType, FinalChannel: EGameplayModEvaluationChannel, SourceTagFilter: GameplayTagContainer, TargetTagFilter: GameplayTagContainer);

        Coefficient: ScalableFloat;
        PreMultiplyAdditiveValue: ScalableFloat;
        PostMultiplyAdditiveValue: ScalableFloat;
        BackingAttribute: GameplayEffectAttributeCaptureDefinition;
        AttributeCurve: CurveTableRowHandle;
        AttributeCalculationType: EAttributeBasedFloatCalculationType;
        FinalChannel: EGameplayModEvaluationChannel;
        SourceTagFilter: GameplayTagContainer;
        TargetTagFilter: GameplayTagContainer;

        static StaticClass(): Class;
    }

    export class CustomCalculationBasedFloat {
        constructor();
        constructor(CalculationClassMagnitude: Class, Coefficient: ScalableFloat, PreMultiplyAdditiveValue: ScalableFloat, PostMultiplyAdditiveValue: ScalableFloat, FinalLookupCurve: CurveTableRowHandle);

        CalculationClassMagnitude: Class;
        Coefficient: ScalableFloat;
        PreMultiplyAdditiveValue: ScalableFloat;
        PostMultiplyAdditiveValue: ScalableFloat;
        FinalLookupCurve: CurveTableRowHandle;

        static StaticClass(): Class;
    }

    export class SetByCallerFloat {
        constructor();
        constructor(DataName: string, DataTag: GameplayTag);

        DataName: string;
        DataTag: GameplayTag;

        static StaticClass(): Class;
    }

    export class GameplayEffectModifierMagnitude {
        constructor();
        constructor(MagnitudeCalculationType: EGameplayEffectMagnitudeCalculation, ScalableFloatMagnitude: ScalableFloat, AttributeBasedMagnitude: AttributeBasedFloat, CustomMagnitude: CustomCalculationBasedFloat, SetByCallerMagnitude: SetByCallerFloat);

        MagnitudeCalculationType: EGameplayEffectMagnitudeCalculation;
        ScalableFloatMagnitude: ScalableFloat;
        AttributeBasedMagnitude: AttributeBasedFloat;
        CustomMagnitude: CustomCalculationBasedFloat;
        SetByCallerMagnitude: SetByCallerFloat;

        static StaticClass(): Class;
    }

    export enum EGameplayEffectPeriodInhibitionRemovedPolicy {
        NeverReset,
        ResetPeriod,
        ExecuteAndResetPeriod,
        EGameplayEffectPeriodInhibitionRemovedPolicy_MAX
    }

    export enum EGameplayModOp { Additive, Multiplicitive, Division, Override, Max, EGameplayModOp_MAX }

    export class GameplayModEvaluationChannelSettings {
        constructor();
        constructor(Channel: EGameplayModEvaluationChannel);

        Channel: EGameplayModEvaluationChannel;

        static StaticClass(): Class;
    }

    export class GameplayTagRequirements {
        constructor();
        constructor(RequireTags: GameplayTagContainer, IgnoreTags: GameplayTagContainer);

        RequireTags: GameplayTagContainer;
        IgnoreTags: GameplayTagContainer;

        static StaticClass(): Class;
    }

    export class GameplayModifierInfo {
        constructor();
        constructor(Attribute: GameplayAttribute, ModifierOp: EGameplayModOp, Magnitude: ScalableFloat, ModifierMagnitude: GameplayEffectModifierMagnitude, EvaluationChannelSettings: GameplayModEvaluationChannelSettings, SourceTags: GameplayTagRequirements, TargetTags: GameplayTagRequirements);

        Attribute: GameplayAttribute;
        ModifierOp: EGameplayModOp;
        Magnitude: ScalableFloat;
        ModifierMagnitude: GameplayEffectModifierMagnitude;
        EvaluationChannelSettings: GameplayModEvaluationChannelSettings;
        SourceTags: GameplayTagRequirements;
        TargetTags: GameplayTagRequirements;

        static StaticClass(): Class;
    }

    export enum EGameplayEffectScopedModifierAggregatorType {
        CapturedAttributeBacked,
        Transient,
        EGameplayEffectScopedModifierAggregatorType_MAX
    }

    export class GameplayEffectExecutionScopedModifierInfo {
        constructor();
        constructor(CapturedAttribute: GameplayEffectAttributeCaptureDefinition, TransientAggregatorIdentifier: GameplayTag, AggregatorType: EGameplayEffectScopedModifierAggregatorType, ModifierOp: EGameplayModOp, ModifierMagnitude: GameplayEffectModifierMagnitude, EvaluationChannelSettings: GameplayModEvaluationChannelSettings, SourceTags: GameplayTagRequirements, TargetTags: GameplayTagRequirements);

        CapturedAttribute: GameplayEffectAttributeCaptureDefinition;
        TransientAggregatorIdentifier: GameplayTag;
        AggregatorType: EGameplayEffectScopedModifierAggregatorType;
        ModifierOp: EGameplayModOp;
        ModifierMagnitude: GameplayEffectModifierMagnitude;
        EvaluationChannelSettings: GameplayModEvaluationChannelSettings;
        SourceTags: GameplayTagRequirements;
        TargetTags: GameplayTagRequirements;

        static StaticClass(): Class;
    }

    export class ConditionalGameplayEffect {
        constructor();
        constructor(EffectClass: Class, RequiredSourceTags: GameplayTagContainer);

        EffectClass: Class;
        RequiredSourceTags: GameplayTagContainer;

        static StaticClass(): Class;
    }

    export class GameplayEffectExecutionDefinition {
        constructor();
        constructor(CalculationClass: Class, PassedInTags: GameplayTagContainer, CalculationModifiers: TArray<GameplayEffectExecutionScopedModifierInfo>, ConditionalGameplayEffectClasses: TArray<Class>, ConditionalGameplayEffects: TArray<ConditionalGameplayEffect>);

        CalculationClass: Class;
        PassedInTags: GameplayTagContainer;
        CalculationModifiers: TArray<GameplayEffectExecutionScopedModifierInfo>;
        ConditionalGameplayEffectClasses: TArray<Class>;
        ConditionalGameplayEffects: TArray<ConditionalGameplayEffect>;

        static StaticClass(): Class;
    }

    export class GameplayEffectCue {
        constructor();
        constructor(MagnitudeAttribute: GameplayAttribute, MinLevel: number, MaxLevel: number, GameplayCueTags: GameplayTagContainer);

        MagnitudeAttribute: GameplayAttribute;
        MinLevel: number;
        MaxLevel: number;
        GameplayCueTags: GameplayTagContainer;

        static StaticClass(): Class;
    }

    export class GameplayEffectUIData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayEffectUIData;

        static Load(InName: string): GameplayEffectUIData;
    }

    export class InheritedTagContainer {
        constructor();
        constructor(CombinedTags: GameplayTagContainer, Added: GameplayTagContainer, Removed: GameplayTagContainer);

        CombinedTags: GameplayTagContainer;
        Added: GameplayTagContainer;
        Removed: GameplayTagContainer;

        static StaticClass(): Class;
    }

    export class FastArraySerializerItem {
        constructor();
        constructor(ReplicationID: number, ReplicationKey: number, MostRecentArrayReplicationKey: number);

        ReplicationID: number;
        ReplicationKey: number;
        MostRecentArrayReplicationKey: number;

        static StaticClass(): Class;
    }

    export class GameplayEffectModifiedAttribute {
        constructor();
        constructor(Attribute: GameplayAttribute, TotalMagnitude: number);

        Attribute: GameplayAttribute;
        TotalMagnitude: number;

        static StaticClass(): Class;
    }

    export class GameplayEffectAttributeCaptureSpec {
        constructor();
        constructor(BackingDefinition: GameplayEffectAttributeCaptureDefinition);

        BackingDefinition: GameplayEffectAttributeCaptureDefinition;

        static StaticClass(): Class;
    }

    export class GameplayEffectAttributeCaptureSpecContainer {
        constructor();
        constructor(SourceAttributes: TArray<GameplayEffectAttributeCaptureSpec>, TargetAttributes: TArray<GameplayEffectAttributeCaptureSpec>, bHasNonSnapshottedAttributes: boolean);

        SourceAttributes: TArray<GameplayEffectAttributeCaptureSpec>;
        TargetAttributes: TArray<GameplayEffectAttributeCaptureSpec>;
        bHasNonSnapshottedAttributes: boolean;

        static StaticClass(): Class;
    }

    export class TagContainerAggregator {
        constructor();
        constructor(CapturedActorTags: GameplayTagContainer, CapturedSpecTags: GameplayTagContainer, ScopedTags: GameplayTagContainer);

        CapturedActorTags: GameplayTagContainer;
        CapturedSpecTags: GameplayTagContainer;
        ScopedTags: GameplayTagContainer;

        static StaticClass(): Class;
    }

    export class ModifierSpec {
        constructor();
        constructor(EvaluatedMagnitude: number);

        EvaluatedMagnitude: number;

        static StaticClass(): Class;
    }

    export enum EGameplayEffectGrantedAbilityRemovePolicy {
        CancelAbilityImmediately,
        RemoveAbilityOnEnd,
        DoNothing,
        EGameplayEffectGrantedAbilityRemovePolicy_MAX
    }

    export class GameplayAbilitySpecHandle {
        constructor();
        constructor(Handle: number);

        Handle: number;

        static StaticClass(): Class;
    }

    export class GameplayAbilitySpecDef {
        constructor();
        constructor(Ability: Class, LevelScalableFloat: ScalableFloat, InputID: number, RemovalPolicy: EGameplayEffectGrantedAbilityRemovePolicy, SourceObject: Object, AssignedHandle: GameplayAbilitySpecHandle);

        Ability: Class;
        LevelScalableFloat: ScalableFloat;
        InputID: number;
        RemovalPolicy: EGameplayEffectGrantedAbilityRemovePolicy;
        SourceObject: Object;
        AssignedHandle: GameplayAbilitySpecHandle;

        static StaticClass(): Class;
    }

    export class GameplayEffectSpec {
        constructor();
        constructor(Def: GameplayEffect, ModifiedAttributes: TArray<GameplayEffectModifiedAttribute>, CapturedRelevantAttributes: GameplayEffectAttributeCaptureSpecContainer, Duration: number, Period: number, ChanceToApplyToTarget: number, CapturedSourceTags: TagContainerAggregator, CapturedTargetTags: TagContainerAggregator, DynamicGrantedTags: GameplayTagContainer, DynamicAssetTags: GameplayTagContainer, Modifiers: TArray<ModifierSpec>, StackCount: number, bCompletedSourceAttributeCapture: boolean, bCompletedTargetAttributeCapture: boolean, bDurationLocked: boolean, GrantedAbilitySpecs: TArray<GameplayAbilitySpecDef>, EffectContext: GameplayEffectContextHandle, Level: number);

        Def: GameplayEffect;
        ModifiedAttributes: TArray<GameplayEffectModifiedAttribute>;
        CapturedRelevantAttributes: GameplayEffectAttributeCaptureSpecContainer;
        Duration: number;
        Period: number;
        ChanceToApplyToTarget: number;
        CapturedSourceTags: TagContainerAggregator;
        CapturedTargetTags: TagContainerAggregator;
        DynamicGrantedTags: GameplayTagContainer;
        DynamicAssetTags: GameplayTagContainer;
        Modifiers: TArray<ModifierSpec>;
        StackCount: number;
        bCompletedSourceAttributeCapture: boolean;
        bCompletedTargetAttributeCapture: boolean;
        bDurationLocked: boolean;
        GrantedAbilitySpecs: TArray<GameplayAbilitySpecDef>;
        EffectContext: GameplayEffectContextHandle;
        Level: number;

        static StaticClass(): Class;
    }

    export class PredictionKey {
        constructor();
        constructor(PredictiveConnection: PackageMap, Current: number, Base: number, bIsStale: boolean, bIsServerInitiated: boolean);

        PredictiveConnection: PackageMap;
        Current: number;
        Base: number;
        bIsStale: boolean;
        bIsServerInitiated: boolean;

        static StaticClass(): Class;
    }

    export class ActiveGameplayEffect extends FastArraySerializerItem {
        constructor();
        constructor(Spec: GameplayEffectSpec, PredictionKey: PredictionKey, StartServerWorldTime: number, CachedStartServerWorldTime: number, StartWorldTime: number, bIsInhibited: boolean);

        Spec: GameplayEffectSpec;
        PredictionKey: PredictionKey;
        StartServerWorldTime: number;
        CachedStartServerWorldTime: number;
        StartWorldTime: number;
        bIsInhibited: boolean;

        static StaticClass(): Class;
    }

    export class GameplayTagQuery {
        constructor();
        constructor(TokenStreamVersion: number, TagDictionary: TArray<GameplayTag>, QueryTokenStream: TArray<number>, UserDescription: string, AutoDescription: string);

        TokenStreamVersion: number;
        TagDictionary: TArray<GameplayTag>;
        QueryTokenStream: TArray<number>;
        UserDescription: string;
        AutoDescription: string;

        static StaticClass(): Class;
    }

    export class GameplayEffectQuery {
        constructor();
        constructor(CustomMatchDelegate_BP: $Delegate<(Effect: ActiveGameplayEffect, bMatches: $Ref<boolean>) => void>, OwningTagQuery: GameplayTagQuery, EffectTagQuery: GameplayTagQuery, SourceTagQuery: GameplayTagQuery, ModifyingAttribute: GameplayAttribute, EffectSource: Object, EffectDefinition: Class);

        CustomMatchDelegate_BP: $Delegate<(Effect: ActiveGameplayEffect, bMatches: $Ref<boolean>) => void>;
        OwningTagQuery: GameplayTagQuery;
        EffectTagQuery: GameplayTagQuery;
        SourceTagQuery: GameplayTagQuery;
        ModifyingAttribute: GameplayAttribute;
        EffectSource: Object;
        EffectDefinition: Class;

        static StaticClass(): Class;
    }

    export enum EGameplayEffectStackingType {
        None,
        AggregateBySource,
        AggregateByTarget,
        EGameplayEffectStackingType_MAX
    }

    export enum EGameplayEffectStackingDurationPolicy {
        RefreshOnSuccessfulApplication,
        NeverRefresh,
        EGameplayEffectStackingDurationPolicy_MAX
    }

    export enum EGameplayEffectStackingPeriodPolicy {
        ResetOnSuccessfulApplication,
        NeverReset,
        EGameplayEffectStackingPeriodPolicy_MAX
    }

    export enum EGameplayEffectStackingExpirationPolicy {
        ClearEntireStack,
        RemoveSingleStackAndRefreshDuration,
        RefreshDuration,
        EGameplayEffectStackingExpirationPolicy_MAX
    }

    export class GameplayEffect extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DurationPolicy: EGameplayEffectDurationType;
        DurationMagnitude: GameplayEffectModifierMagnitude;
        Period: ScalableFloat;
        bExecutePeriodicEffectOnApplication: boolean;
        PeriodicInhibitionPolicy: EGameplayEffectPeriodInhibitionRemovedPolicy;
        Modifiers: TArray<GameplayModifierInfo>;
        Executions: TArray<GameplayEffectExecutionDefinition>;
        ChanceToApplyToTarget: ScalableFloat;
        ApplicationRequirements: TArray<Class>;
        TargetEffectClasses: TArray<Class>;
        ConditionalGameplayEffects: TArray<ConditionalGameplayEffect>;
        OverflowEffects: TArray<Class>;
        bDenyOverflowApplication: boolean;
        bClearStackOnOverflow: boolean;
        PrematureExpirationEffectClasses: TArray<Class>;
        RoutineExpirationEffectClasses: TArray<Class>;
        bRequireModifierSuccessToTriggerCues: boolean;
        bSuppressStackingCues: boolean;
        GameplayCues: TArray<GameplayEffectCue>;
        UIData: GameplayEffectUIData;
        InheritableGameplayEffectTags: InheritedTagContainer;
        InheritableOwnedTagsContainer: InheritedTagContainer;
        OngoingTagRequirements: GameplayTagRequirements;
        ApplicationTagRequirements: GameplayTagRequirements;
        RemovalTagRequirements: GameplayTagRequirements;
        RemoveGameplayEffectsWithTags: InheritedTagContainer;
        GrantedApplicationImmunityTags: GameplayTagRequirements;
        GrantedApplicationImmunityQuery: GameplayEffectQuery;
        RemoveGameplayEffectQuery: GameplayEffectQuery;
        StackingType: EGameplayEffectStackingType;
        StackLimitCount: number;
        StackDurationRefreshPolicy: EGameplayEffectStackingDurationPolicy;
        StackPeriodResetPolicy: EGameplayEffectStackingPeriodPolicy;
        StackExpirationPolicy: EGameplayEffectStackingExpirationPolicy;
        GrantedAbilities: TArray<GameplayAbilitySpecDef>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayEffect;

        static Load(InName: string): GameplayEffect;
    }

    export class GameplayCueParameters {
        constructor();
        constructor(NormalizedMagnitude: number, RawMagnitude: number, EffectContext: GameplayEffectContextHandle, MatchedTagName: GameplayTag, OriginalTag: GameplayTag, AggregatedSourceTags: GameplayTagContainer, AggregatedTargetTags: GameplayTagContainer, Location: Vector_NetQuantize10, Normal: Vector_NetQuantizeNormal, Instigator: TWeakObjectPtr<Actor>, EffectCauser: TWeakObjectPtr<Actor>, SourceObject: TWeakObjectPtr<Object>, PhysicalMaterial: TWeakObjectPtr<PhysicalMaterial>, GameplayEffectLevel: number, AbilityLevel: number, TargetAttachComponent: TWeakObjectPtr<SceneComponent>);

        NormalizedMagnitude: number;
        RawMagnitude: number;
        EffectContext: GameplayEffectContextHandle;
        MatchedTagName: GameplayTag;
        OriginalTag: GameplayTag;
        AggregatedSourceTags: GameplayTagContainer;
        AggregatedTargetTags: GameplayTagContainer;
        Location: Vector_NetQuantize10;
        Normal: Vector_NetQuantizeNormal;
        Instigator: TWeakObjectPtr<Actor>;
        EffectCauser: TWeakObjectPtr<Actor>;
        SourceObject: TWeakObjectPtr<Object>;
        PhysicalMaterial: TWeakObjectPtr<PhysicalMaterial>;
        GameplayEffectLevel: number;
        AbilityLevel: number;
        TargetAttachComponent: TWeakObjectPtr<SceneComponent>;

        static StaticClass(): Class;
    }

    export enum ETargetDataFilterSelf { TDFS_Any, TDFS_NoSelf, TDFS_NoOthers, TDFS_MAX }

    export class GameplayTargetDataFilter {
        constructor();
        constructor(SelfActor: Actor, RequiredActorClass: Class, SelfFilter: ETargetDataFilterSelf, bReverseFilter: boolean);

        SelfActor: Actor;
        RequiredActorClass: Class;
        SelfFilter: ETargetDataFilterSelf;
        bReverseFilter: boolean;

        static StaticClass(): Class;
    }

    export class GameplayTargetDataFilterHandle {
        constructor();

        static StaticClass(): Class;
    }

    export enum ETaskResourceOverlapPolicy { StartOnTop, StartAtEnd, ETaskResourceOverlapPolicy_MAX }

    export class GameplayTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InstanceName: string;
        ResourceOverlapPolicy: ETaskResourceOverlapPolicy;
        ChildTask: GameplayTask;

        EndTask(): void;

        GenericGameplayTaskDelegate__DelegateSignature(): void;

        ReadyForActivation(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTask;

        static Load(InName: string): GameplayTask;
    }

    export class GameplayResourceSet {
        constructor();

        static StaticClass(): Class;
    }

    export class GameplayTaskOwnerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTaskOwnerInterface;

        static Load(InName: string): GameplayTaskOwnerInterface;
    }

    export enum EGameplayTaskRunResult {
        Error,
        Failed,
        Success_Paused,
        Success_Active,
        Success_Finished,
        EGameplayTaskRunResult_MAX
    }

    export class GameplayTasksComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsNetDirty: boolean;
        SimulatedTasks: TArray<GameplayTask>;
        TaskPriorityQueue: TArray<GameplayTask>;
        TickingTasks: TArray<GameplayTask>;
        KnownTasks: TArray<GameplayTask>;
        OnClaimedResourcesChange: $MulticastDelegate<(NewlyClaimed: GameplayResourceSet, FreshlyReleased: GameplayResourceSet) => void>;

        OnRep_SimulatedTasks(): void;

        static K2_RunGameplayTask(TaskOwner: GameplayTaskOwnerInterface, Task: $Nullable<GameplayTask>, Priority: number, AdditionalRequiredResources: TArray<Class>, AdditionalClaimedResources: TArray<Class>): EGameplayTaskRunResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTasksComponent;

        static Load(InName: string): GameplayTasksComponent;
    }

    export class ScriptStruct extends Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScriptStruct;

        static Load(InName: string): ScriptStruct;
    }

    export class DataTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RowStruct: ScriptStruct;
        bStripFromClientBuilds: boolean;
        bIgnoreExtraFields: boolean;
        bIgnoreMissingFields: boolean;
        ImportKeyField: string;
        AssetImportData: AssetImportData;
        ImportPath: string;
        RowStructName: string;
        RowsSerializedWithTags: TArray<number>;
        TemporarilyReferencedObjects: TSet<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DataTable;

        static Load(InName: string): DataTable;
    }

    export class AttributeDefaults {
        constructor();
        constructor(Attributes: Class, DefaultStartingTable: DataTable);

        Attributes: Class;
        DefaultStartingTable: DataTable;

        static StaticClass(): Class;
    }

    export class AttributeSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AttributeSet;

        static Load(InName: string): AttributeSet;
    }

    export enum EGameplayAbilityTargetingLocationType {
        LiteralTransform,
        ActorTransform,
        SocketTransform,
        EGameplayAbilityTargetingLocationType_MAX
    }

    export enum EGameplayAbilityReplicationPolicy { ReplicateNo, ReplicateYes, EGameplayAbilityReplicationPolicy_MAX }

    export enum EGameplayAbilityInstancingPolicy {
        NonInstanced,
        InstancedPerActor,
        InstancedPerExecution,
        EGameplayAbilityInstancingPolicy_MAX
    }

    export enum EGameplayAbilityActivationMode {
        Authority,
        NonAuthority,
        Predicting,
        Confirmed,
        Rejected,
        EGameplayAbilityActivationMode_MAX
    }

    export class GameplayAbilityActivationInfo {
        constructor();
        constructor(ActivationMode: EGameplayAbilityActivationMode, bCanBeEndedByOtherInstance: boolean, PredictionKeyWhenActivated: PredictionKey);

        ActivationMode: EGameplayAbilityActivationMode;
        bCanBeEndedByOtherInstance: boolean;
        PredictionKeyWhenActivated: PredictionKey;

        static StaticClass(): Class;
    }

    export enum EGameplayAbilityNetExecutionPolicy {
        LocalPredicted,
        LocalOnly,
        ServerInitiated,
        ServerOnly,
        EGameplayAbilityNetExecutionPolicy_MAX
    }

    export enum EGameplayAbilityNetSecurityPolicy {
        ClientOrServer,
        ServerOnlyExecution,
        ServerOnlyTermination,
        ServerOnly,
        EGameplayAbilityNetSecurityPolicy_MAX
    }

    export enum EGameplayAbilityTriggerSource {
        GameplayEvent,
        OwnedTagAdded,
        OwnedTagPresent,
        EGameplayAbilityTriggerSource_MAX
    }

    export class AbilityTriggerData {
        constructor();
        constructor(TriggerTag: GameplayTag, TriggerSource: EGameplayAbilityTriggerSource);

        TriggerTag: GameplayTag;
        TriggerSource: EGameplayAbilityTriggerSource;

        static StaticClass(): Class;
    }

    export class GameplayAbilityActorInfo {
        constructor();
        constructor(OwnerActor: TWeakObjectPtr<Actor>, AvatarActor: TWeakObjectPtr<Actor>, PlayerController: TWeakObjectPtr<PlayerController>, AbilitySystemComponent: TWeakObjectPtr<AbilitySystemComponent>, SkeletalMeshComponent: TWeakObjectPtr<SkeletalMeshComponent>, AnimInstance: TWeakObjectPtr<AnimInstance>, MovementComponent: TWeakObjectPtr<MovementComponent>, AffectedAnimInstanceTag: string);

        OwnerActor: TWeakObjectPtr<Actor>;
        AvatarActor: TWeakObjectPtr<Actor>;
        PlayerController: TWeakObjectPtr<PlayerController>;
        AbilitySystemComponent: TWeakObjectPtr<AbilitySystemComponent>;
        SkeletalMeshComponent: TWeakObjectPtr<SkeletalMeshComponent>;
        AnimInstance: TWeakObjectPtr<AnimInstance>;
        MovementComponent: TWeakObjectPtr<MovementComponent>;
        AffectedAnimInstanceTag: string;

        static StaticClass(): Class;
    }

    export class ActiveGameplayEffectHandle {
        constructor();
        constructor(Handle: number, bPassedFiltersAndWasExecuted: boolean);

        Handle: number;
        bPassedFiltersAndWasExecuted: boolean;

        static StaticClass(): Class;
    }

    export class GameplayAbility extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AbilityTags: GameplayTagContainer;
        bReplicateInputDirectly: boolean;
        RemoteInstanceEnded: boolean;
        ReplicationPolicy: EGameplayAbilityReplicationPolicy;
        InstancingPolicy: EGameplayAbilityInstancingPolicy;
        bServerRespectsRemoteAbilityCancellation: boolean;
        bRetriggerInstancedAbility: boolean;
        CurrentActivationInfo: GameplayAbilityActivationInfo;
        CurrentEventData: GameplayEventData;
        NetExecutionPolicy: EGameplayAbilityNetExecutionPolicy;
        NetSecurityPolicy: EGameplayAbilityNetSecurityPolicy;
        CostGameplayEffectClass: Class;
        AbilityTriggers: TArray<AbilityTriggerData>;
        CooldownGameplayEffectClass: Class;
        CancelAbilitiesWithTag: GameplayTagContainer;
        BlockAbilitiesWithTag: GameplayTagContainer;
        ActivationOwnedTags: GameplayTagContainer;
        ActivationRequiredTags: GameplayTagContainer;
        ActivationBlockedTags: GameplayTagContainer;
        SourceRequiredTags: GameplayTagContainer;
        SourceBlockedTags: GameplayTagContainer;
        TargetRequiredTags: GameplayTagContainer;
        TargetBlockedTags: GameplayTagContainer;
        ActiveTasks: TArray<GameplayTask>;
        CurrentMontage: AnimMontage;
        bIsActive: boolean;
        bIsCancelable: boolean;
        bIsBlockingOtherAbilities: boolean;
        bMarkPendingKillOnAbilityEnd: boolean;

        BP_ApplyGameplayEffectToOwner(GameplayEffectClass: $Nullable<Class>, GameplayEffectLevel?: number /* = 1 */, Stacks?: number /* = 1 */): ActiveGameplayEffectHandle;

        BP_ApplyGameplayEffectToTarget(TargetData: GameplayAbilityTargetDataHandle, GameplayEffectClass: $Nullable<Class>, GameplayEffectLevel?: number /* = 1 */, Stacks?: number /* = 1 */): TArray<ActiveGameplayEffectHandle>;

        BP_RemoveGameplayEffectFromOwnerWithAssetTags(WithAssetTags: GameplayTagContainer, StacksToRemove?: number /* = -1 */): void;

        BP_RemoveGameplayEffectFromOwnerWithGrantedTags(WithGrantedTags: GameplayTagContainer, StacksToRemove?: number /* = -1 */): void;

        BP_RemoveGameplayEffectFromOwnerWithHandle(Handle: ActiveGameplayEffectHandle, StacksToRemove?: number /* = -1 */): void;

        CancelTaskByInstanceName(InstanceName: string): void;

        ConfirmTaskByInstanceName(InstanceName: string, bEndTask: boolean): void;

        EndAbilityState(OptionalStateNameToEnd: string): void;

        EndTaskByInstanceName(InstanceName: string): void;

        GetAbilityLevel(): number;

        GetAbilitySystemComponentFromActorInfo(): AbilitySystemComponent;

        GetActorInfo(): GameplayAbilityActorInfo;

        GetAvatarActorFromActorInfo(): Actor;

        GetContextFromOwner(OptionalTargetData: GameplayAbilityTargetDataHandle): GameplayEffectContextHandle;

        GetCooldownTimeRemaining(): number;

        GetCurrentMontage(): AnimMontage;

        GetCurrentSourceObject(): Object;

        GetGrantedByEffectContext(): GameplayEffectContextHandle;

        GetOwningActorFromActorInfo(): Actor;

        GetOwningComponentFromActorInfo(): SkeletalMeshComponent;

        InvalidateClientPredictionKey(): void;

        IsLocallyControlled(): boolean;

        K2_ActivateAbility(): void;

        K2_ActivateAbilityFromEvent(EventData: GameplayEventData): void;

        K2_AddGameplayCue(GameplayCueTag: GameplayTag, Context: GameplayEffectContextHandle, bRemoveOnAbilityEnd?: boolean /* = true */): void;

        K2_AddGameplayCueWithParams(GameplayCueTag: GameplayTag, GameplayCueParameter: GameplayCueParameters, bRemoveOnAbilityEnd?: boolean /* = true */): void;

        K2_ApplyGameplayEffectSpecToOwner(EffectSpecHandle: GameplayEffectSpecHandle): ActiveGameplayEffectHandle;

        K2_ApplyGameplayEffectSpecToTarget(EffectSpecHandle: GameplayEffectSpecHandle, TargetData: GameplayAbilityTargetDataHandle): TArray<ActiveGameplayEffectHandle>;

        K2_CanActivateAbility(ActorInfo: GameplayAbilityActorInfo, RelevantTags: $Ref<GameplayTagContainer>): boolean;

        K2_CancelAbility(): void;

        K2_CheckAbilityCooldown(): boolean;

        K2_CheckAbilityCost(): boolean;

        K2_CommitAbility(): boolean;

        K2_CommitAbilityCooldown(BroadcastCommitEvent?: boolean /* = false */, ForceCooldown?: boolean /* = false */): boolean;

        K2_CommitAbilityCost(BroadcastCommitEvent?: boolean /* = false */): boolean;

        K2_CommitExecute(): void;

        K2_EndAbility(): void;

        K2_ExecuteGameplayCue(GameplayCueTag: GameplayTag, Context: GameplayEffectContextHandle): void;

        K2_ExecuteGameplayCueWithParams(GameplayCueTag: GameplayTag, GameplayCueParameters: GameplayCueParameters): void;

        K2_HasAuthority(): boolean;

        K2_OnEndAbility(bWasCancelled: boolean): void;

        K2_RemoveGameplayCue(GameplayCueTag: GameplayTag): void;

        K2_ShouldAbilityRespondToEvent(ActorInfo: GameplayAbilityActorInfo, Payload: GameplayEventData): boolean;

        MakeOutgoingGameplayEffectSpec(GameplayEffectClass: $Nullable<Class>, Level?: number /* = 1.000000 */): GameplayEffectSpecHandle;

        MakeTargetLocationInfoFromOwnerActor(): GameplayAbilityTargetingLocationInfo;

        MakeTargetLocationInfoFromOwnerSkeletalMeshComponent(SocketName: string): GameplayAbilityTargetingLocationInfo;

        MontageJumpToSection(SectionName: string): void;

        MontageSetNextSectionName(FromSectionName: string, ToSectionName: string): void;

        MontageStop(OverrideBlendOutTime?: number /* = -1.000000 */): void;

        RemoveGrantedByEffect(): void;

        SendGameplayEvent(EventTag: GameplayTag, Payload: GameplayEventData): void;

        SetCanBeCanceled(bCanBeCanceled: boolean): void;

        SetShouldBlockOtherAbilities(bShouldBlockAbilities: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbility;

        static Load(InName: string): GameplayAbility;
    }

    export class GameplayAbilityTargetingLocationInfo {
        constructor();
        constructor(LocationType: EGameplayAbilityTargetingLocationType, LiteralTransform: Transform, SourceActor: Actor, SourceComponent: MeshComponent, SourceAbility: GameplayAbility, SourceSocketName: string);

        LocationType: EGameplayAbilityTargetingLocationType;
        LiteralTransform: Transform;
        SourceActor: Actor;
        SourceComponent: MeshComponent;
        SourceAbility: GameplayAbility;
        SourceSocketName: string;

        static StaticClass(): Class;
    }

    export class WorldReticleParameters {
        constructor();
        constructor(AOEScale: Vector);

        AOEScale: Vector;

        static StaticClass(): Class;
    }

    export class GameplayAbilityTargetActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShouldProduceTargetDataOnServer: boolean;
        StartLocation: GameplayAbilityTargetingLocationInfo;
        MasterPC: PlayerController;
        OwningAbility: GameplayAbility;
        bDestroyOnConfirmation: boolean;
        SourceActor: Actor;
        ReticleParams: WorldReticleParameters;
        ReticleClass: Class;
        Filter: GameplayTargetDataFilterHandle;
        bDebug: boolean;
        GenericDelegateBoundASC: AbilitySystemComponent;

        CancelTargeting(): void;

        ConfirmTargeting(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityTargetActor;

        static Load(InName: string): GameplayAbilityTargetActor;
    }

    export enum EFastArraySerializerDeltaFlags {
        None,
        HasBeenSerialized,
        HasDeltaBeenRequested,
        IsUsingDeltaSerialization,
        EFastArraySerializerDeltaFlags_MAX
    }

    export class FastArraySerializer {
        constructor();
        constructor(ArrayReplicationKey: number, DeltaFlags: EFastArraySerializerDeltaFlags);

        ArrayReplicationKey: number;
        DeltaFlags: EFastArraySerializerDeltaFlags;

        static StaticClass(): Class;
    }

    export class GameplayAbilitySpec extends FastArraySerializerItem {
        constructor();
        constructor(Handle: GameplayAbilitySpecHandle, Ability: GameplayAbility, Level: number, InputID: number, SourceObject: Object, ActiveCount: number, InputPressed: boolean, RemoveAfterActivation: boolean, PendingRemove: boolean, bActivateOnce: boolean, ActivationInfo: GameplayAbilityActivationInfo, DynamicAbilityTags: GameplayTagContainer, NonReplicatedInstances: TArray<GameplayAbility>, ReplicatedInstances: TArray<GameplayAbility>, GameplayEffectHandle: ActiveGameplayEffectHandle);

        Handle: GameplayAbilitySpecHandle;
        Ability: GameplayAbility;
        Level: number;
        InputID: number;
        SourceObject: Object;
        ActiveCount: number;
        InputPressed: boolean;
        RemoveAfterActivation: boolean;
        PendingRemove: boolean;
        bActivateOnce: boolean;
        ActivationInfo: GameplayAbilityActivationInfo;
        DynamicAbilityTags: GameplayTagContainer;
        NonReplicatedInstances: TArray<GameplayAbility>;
        ReplicatedInstances: TArray<GameplayAbility>;
        GameplayEffectHandle: ActiveGameplayEffectHandle;

        static StaticClass(): Class;
    }

    export class GameplayAbilitySpecContainer extends FastArraySerializer {
        constructor();
        constructor(Items: TArray<GameplayAbilitySpec>, Owner: AbilitySystemComponent);

        Items: TArray<GameplayAbilitySpec>;
        Owner: AbilitySystemComponent;

        static StaticClass(): Class;
    }

    export class GameplayAbilityRepAnimMontage {
        constructor();
        constructor(AnimMontage: AnimMontage, PlayRate: number, Position: number, BlendTime: number, NextSectionID: number, bRepPosition: boolean, IsStopped: boolean, ForcePlayBit: boolean, SkipPositionCorrection: boolean, bSkipPlayRate: boolean, PredictionKey: PredictionKey, SectionIdToPlay: number);

        AnimMontage: AnimMontage;
        PlayRate: number;
        Position: number;
        BlendTime: number;
        NextSectionID: number;
        bRepPosition: boolean;
        IsStopped: boolean;
        ForcePlayBit: boolean;
        SkipPositionCorrection: boolean;
        bSkipPlayRate: boolean;
        PredictionKey: PredictionKey;
        SectionIdToPlay: number;

        static StaticClass(): Class;
    }

    export class GameplayAbilityLocalAnimMontage {
        constructor();
        constructor(AnimMontage: AnimMontage, PlayBit: boolean, PredictionKey: PredictionKey, AnimatingAbility: GameplayAbility);

        AnimMontage: AnimMontage;
        PlayBit: boolean;
        PredictionKey: PredictionKey;
        AnimatingAbility: GameplayAbility;

        static StaticClass(): Class;
    }

    export class ActiveGameplayEffectsContainer extends FastArraySerializer {
        constructor();
        constructor(GameplayEffects_Internal: TArray<ActiveGameplayEffect>, ApplicationImmunityQueryEffects: TArray<GameplayEffect>);

        GameplayEffects_Internal: TArray<ActiveGameplayEffect>;
        ApplicationImmunityQueryEffects: TArray<GameplayEffect>;

        static StaticClass(): Class;
    }

    export class ActiveGameplayCue extends FastArraySerializerItem {
        constructor();
        constructor(GameplayCueTag: GameplayTag, PredictionKey: PredictionKey, Parameters: GameplayCueParameters, bPredictivelyRemoved: boolean);

        GameplayCueTag: GameplayTag;
        PredictionKey: PredictionKey;
        Parameters: GameplayCueParameters;
        bPredictivelyRemoved: boolean;

        static StaticClass(): Class;
    }

    export class ActiveGameplayCueContainer extends FastArraySerializer {
        constructor();
        constructor(GameplayCues: TArray<ActiveGameplayCue>, Owner: AbilitySystemComponent);

        GameplayCues: TArray<ActiveGameplayCue>;
        Owner: AbilitySystemComponent;

        static StaticClass(): Class;
    }

    export class MinimalReplicationTagCountMap {
        constructor();
        constructor(Owner: AbilitySystemComponent);

        Owner: AbilitySystemComponent;

        static StaticClass(): Class;
    }

    export class ReplicatedPredictionKeyItem extends FastArraySerializerItem {
        constructor();
        constructor(PredictionKey: PredictionKey);

        PredictionKey: PredictionKey;

        static StaticClass(): Class;
    }

    export class ReplicatedPredictionKeyMap extends FastArraySerializer {
        constructor();
        constructor(PredictionKeys: TArray<ReplicatedPredictionKeyItem>);

        PredictionKeys: TArray<ReplicatedPredictionKeyItem>;

        static StaticClass(): Class;
    }

    export enum EAbilityGenericReplicatedEvent {
        GenericConfirm,
        GenericCancel,
        InputPressed,
        InputReleased,
        GenericSignalFromClient,
        GenericSignalFromServer,
        GameCustom1,
        GameCustom2,
        GameCustom3,
        GameCustom4,
        GameCustom5,
        GameCustom6,
        MAX
    }

    export class ServerAbilityRPCBatch {
        constructor();
        constructor(AbilitySpecHandle: GameplayAbilitySpecHandle, PredictionKey: PredictionKey, TargetData: GameplayAbilityTargetDataHandle, InputPressed: boolean, Ended: boolean, Started: boolean);

        AbilitySpecHandle: GameplayAbilitySpecHandle;
        PredictionKey: PredictionKey;
        TargetData: GameplayAbilityTargetDataHandle;
        InputPressed: boolean;
        Ended: boolean;
        Started: boolean;

        static StaticClass(): Class;
    }

    export class GameplayEffectSpecForRPC {
        constructor();
        constructor(Def: GameplayEffect, ModifiedAttributes: TArray<GameplayEffectModifiedAttribute>, EffectContext: GameplayEffectContextHandle, AggregatedSourceTags: GameplayTagContainer, AggregatedTargetTags: GameplayTagContainer, Level: number, AbilityLevel: number);

        Def: GameplayEffect;
        ModifiedAttributes: TArray<GameplayEffectModifiedAttribute>;
        EffectContext: GameplayEffectContextHandle;
        AggregatedSourceTags: GameplayTagContainer;
        AggregatedTargetTags: GameplayTagContainer;
        Level: number;
        AbilityLevel: number;

        static StaticClass(): Class;
    }

    export class AbilitySystemComponent extends GameplayTasksComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultStartingData: TArray<AttributeDefaults>;
        SpawnedAttributes: TArray<AttributeSet>;
        AffectedAnimInstanceTag: string;
        OutgoingDuration: number;
        IncomingDuration: number;
        ClientDebugStrings: TArray<string>;
        ServerDebugStrings: TArray<string>;
        UserAbilityActivationInhibited: boolean;
        ReplicationProxyEnabled: boolean;
        bSuppressGrantAbility: boolean;
        bSuppressGameplayCues: boolean;
        SpawnedTargetActors: TArray<GameplayAbilityTargetActor>;
        OwnerActor: Actor;
        AvatarActor: Actor;
        ActivatableAbilities: GameplayAbilitySpecContainer;
        AllReplicatedInstancedAbilities: TArray<GameplayAbility>;
        RepAnimMontageInfo: GameplayAbilityRepAnimMontage;
        bCachedIsNetSimulated: boolean;
        bPendingMontageRep: boolean;
        LocalAnimMontageInfo: GameplayAbilityLocalAnimMontage;
        ActiveGameplayEffects: ActiveGameplayEffectsContainer;
        ActiveGameplayCues: ActiveGameplayCueContainer;
        MinimalReplicationGameplayCues: ActiveGameplayCueContainer;
        BlockedAbilityBindings: TArray<number>;
        MinimalReplicationTags: MinimalReplicationTagCountMap;
        ReplicatedPredictionKeyMap: ReplicatedPredictionKeyMap;

        AbilityAbilityKey__DelegateSignature(InputID: number): void;

        AbilityConfirmOrCancel__DelegateSignature(): void;

        BP_ApplyGameplayEffectSpecToSelf(SpecHandle: GameplayEffectSpecHandle): ActiveGameplayEffectHandle;

        BP_ApplyGameplayEffectSpecToTarget(SpecHandle: GameplayEffectSpecHandle, Target: $Nullable<AbilitySystemComponent>): ActiveGameplayEffectHandle;

        BP_ApplyGameplayEffectToSelf(GameplayEffectClass: $Nullable<Class>, Level: number, EffectContext: GameplayEffectContextHandle): ActiveGameplayEffectHandle;

        BP_ApplyGameplayEffectToTarget(GameplayEffectClass: $Nullable<Class>, Target: $Nullable<AbilitySystemComponent>, Level: number, Context: GameplayEffectContextHandle): ActiveGameplayEffectHandle;

        ClientActivateAbilityFailed(AbilityToActivate: GameplayAbilitySpecHandle, PredictionKey: number): void;

        ClientActivateAbilitySucceed(AbilityToActivate: GameplayAbilitySpecHandle, PredictionKey: PredictionKey): void;

        ClientActivateAbilitySucceedWithEventData(AbilityToActivate: GameplayAbilitySpecHandle, PredictionKey: PredictionKey, TriggerEventData: GameplayEventData): void;

        ClientCancelAbility(AbilityToCancel: GameplayAbilitySpecHandle, ActivationInfo: GameplayAbilityActivationInfo): void;

        ClientEndAbility(AbilityToEnd: GameplayAbilitySpecHandle, ActivationInfo: GameplayAbilityActivationInfo): void;

        ClientPrintDebug_Response(Strings: TArray<string>, GameFlags: number): void;

        ClientSetReplicatedEvent(EventType: EAbilityGenericReplicatedEvent, AbilityHandle: GameplayAbilitySpecHandle, AbilityOriginalPredictionKey: PredictionKey): void;

        ClientTryActivateAbility(AbilityToActivate: GameplayAbilitySpecHandle): void;

        GetActiveEffects(Query: GameplayEffectQuery): TArray<ActiveGameplayEffectHandle>;

        GetActiveEffectsWithAllTags(Tags: GameplayTagContainer): TArray<ActiveGameplayEffectHandle>;

        GetGameplayEffectCount(SourceGameplayEffect: $Nullable<Class>, OptionalInstigatorFilterComponent: $Nullable<AbilitySystemComponent>, bEnforceOnGoingCheck?: boolean /* = true */): number;

        GetGameplayEffectMagnitude(Handle: ActiveGameplayEffectHandle, Attribute: GameplayAttribute): number;

        GetUserAbilityActivationInhibited(): boolean;

        IsGameplayCueActive(GameplayCueTag: GameplayTag): boolean;

        K2_InitStats(Attributes: $Nullable<Class>, DataTable: $Nullable<DataTable>): void;

        MakeEffectContext(): GameplayEffectContextHandle;

        MakeOutgoingSpec(GameplayEffectClass: $Nullable<Class>, Level: number, Context: GameplayEffectContextHandle): GameplayEffectSpecHandle;

        NetMulticast_InvokeGameplayCueAdded(GameplayCueTag: GameplayTag, PredictionKey: PredictionKey, EffectContext: GameplayEffectContextHandle): void;

        NetMulticast_InvokeGameplayCueAdded_WithParams(GameplayCueTag: GameplayTag, PredictionKey: PredictionKey, Parameters: GameplayCueParameters): void;

        NetMulticast_InvokeGameplayCueAddedAndWhileActive_FromSpec(Spec: GameplayEffectSpecForRPC, PredictionKey: PredictionKey): void;

        NetMulticast_InvokeGameplayCueAddedAndWhileActive_WithParams(GameplayCueTag: GameplayTag, PredictionKey: PredictionKey, GameplayCueParameters: GameplayCueParameters): void;

        NetMulticast_InvokeGameplayCueExecuted(GameplayCueTag: GameplayTag, PredictionKey: PredictionKey, EffectContext: GameplayEffectContextHandle): void;

        NetMulticast_InvokeGameplayCueExecuted_FromSpec(Spec: GameplayEffectSpecForRPC, PredictionKey: PredictionKey): void;

        NetMulticast_InvokeGameplayCueExecuted_WithParams(GameplayCueTag: GameplayTag, PredictionKey: PredictionKey, GameplayCueParameters: GameplayCueParameters): void;

        NetMulticast_InvokeGameplayCuesAddedAndWhileActive_WithParams(GameplayCueTags: GameplayTagContainer, PredictionKey: PredictionKey, GameplayCueParameters: GameplayCueParameters): void;

        NetMulticast_InvokeGameplayCuesExecuted(GameplayCueTags: GameplayTagContainer, PredictionKey: PredictionKey, EffectContext: GameplayEffectContextHandle): void;

        NetMulticast_InvokeGameplayCuesExecuted_WithParams(GameplayCueTags: GameplayTagContainer, PredictionKey: PredictionKey, GameplayCueParameters: GameplayCueParameters): void;

        OnRep_ActivateAbilities(): void;

        OnRep_ClientDebugString(): void;

        OnRep_OwningActor(): void;

        OnRep_ReplicatedAnimMontage(): void;

        OnRep_ServerDebugString(): void;

        RemoveActiveEffectsWithAppliedTags(Tags: GameplayTagContainer): number;

        RemoveActiveEffectsWithGrantedTags(Tags: GameplayTagContainer): number;

        RemoveActiveEffectsWithSourceTags(Tags: GameplayTagContainer): number;

        RemoveActiveEffectsWithTags(Tags: GameplayTagContainer): number;

        RemoveActiveGameplayEffect(Handle: ActiveGameplayEffectHandle, StacksToRemove?: number /* = -1 */): boolean;

        RemoveActiveGameplayEffectBySourceEffect(GameplayEffect: $Nullable<Class>, InstigatorAbilitySystemComponent: $Nullable<AbilitySystemComponent>, StacksToRemove?: number /* = -1 */): void;

        ServerAbilityRPCBatch(BatchInfo: ServerAbilityRPCBatch): void;

        ServerCancelAbility(AbilityToCancel: GameplayAbilitySpecHandle, ActivationInfo: GameplayAbilityActivationInfo): void;

        ServerCurrentMontageJumpToSectionName(ClientAnimMontage: $Nullable<AnimMontage>, SectionName: string): void;

        ServerCurrentMontageSetNextSectionName(ClientAnimMontage: $Nullable<AnimMontage>, ClientPosition: number, SectionName: string, NextSectionName: string): void;

        ServerCurrentMontageSetPlayRate(ClientAnimMontage: $Nullable<AnimMontage>, InPlayRate: number): void;

        ServerEndAbility(AbilityToEnd: GameplayAbilitySpecHandle, ActivationInfo: GameplayAbilityActivationInfo, PredictionKey: PredictionKey): void;

        ServerPrintDebug_Request(): void;

        ServerPrintDebug_RequestWithStrings(Strings: TArray<string>): void;

        ServerSetInputPressed(AbilityHandle: GameplayAbilitySpecHandle): void;

        ServerSetInputReleased(AbilityHandle: GameplayAbilitySpecHandle): void;

        ServerSetReplicatedEvent(EventType: EAbilityGenericReplicatedEvent, AbilityHandle: GameplayAbilitySpecHandle, AbilityOriginalPredictionKey: PredictionKey, CurrentPredictionKey: PredictionKey): void;

        ServerSetReplicatedEventWithPayload(EventType: EAbilityGenericReplicatedEvent, AbilityHandle: GameplayAbilitySpecHandle, AbilityOriginalPredictionKey: PredictionKey, CurrentPredictionKey: PredictionKey, VectorPayload: Vector_NetQuantize100): void;

        ServerSetReplicatedTargetData(AbilityHandle: GameplayAbilitySpecHandle, AbilityOriginalPredictionKey: PredictionKey, ReplicatedTargetDataHandle: GameplayAbilityTargetDataHandle, ApplicationTag: GameplayTag, CurrentPredictionKey: PredictionKey): void;

        ServerSetReplicatedTargetDataCancelled(AbilityHandle: GameplayAbilitySpecHandle, AbilityOriginalPredictionKey: PredictionKey, CurrentPredictionKey: PredictionKey): void;

        ServerTryActivateAbility(AbilityToActivate: GameplayAbilitySpecHandle, InputPressed: boolean, PredictionKey: PredictionKey): void;

        ServerTryActivateAbilityWithEventData(AbilityToActivate: GameplayAbilitySpecHandle, InputPressed: boolean, PredictionKey: PredictionKey, TriggerEventData: GameplayEventData): void;

        SetActiveGameplayEffectLevel(ActiveHandle: ActiveGameplayEffectHandle, NewLevel: number): void;

        SetActiveGameplayEffectLevelUsingQuery(Query: GameplayEffectQuery, NewLevel: number): void;

        SetUserAbilityActivationInhibited(NewInhibit: boolean): void;

        TargetCancel(): void;

        TargetConfirm(): void;

        TryActivateAbilitiesByTag(GameplayTagContainer: GameplayTagContainer, bAllowRemoteActivation?: boolean /* = true */): boolean;

        TryActivateAbilityByClass(InAbilityToActivate: $Nullable<Class>, bAllowRemoteActivation?: boolean /* = true */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilitySystemComponent;

        static Load(InName: string): AbilitySystemComponent;
    }

    export enum EGameplayCueEvent { OnActive, WhileActive, Executed, Removed, EGameplayCueEvent_MAX }

    export class GameplayCueInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlueprintCustomHandler(EventType: EGameplayCueEvent, Parameters: GameplayCueParameters): void;

        ForwardGameplayCueToParent(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayCueInterface;

        static Load(InName: string): GameplayCueInterface;
    }

    export class AbilitySystemBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AbilityTargetDataFromActor(Actor: $Nullable<Actor>): GameplayAbilityTargetDataHandle;

        static AbilityTargetDataFromActorArray(ActorArray: TArray<Actor>, OneTargetPerHandle: boolean): GameplayAbilityTargetDataHandle;

        static AbilityTargetDataFromHitResult(HitResult: HitResult): GameplayAbilityTargetDataHandle;

        static AbilityTargetDataFromLocations(SourceLocation: GameplayAbilityTargetingLocationInfo, TargetLocation: GameplayAbilityTargetingLocationInfo): GameplayAbilityTargetDataHandle;

        static AddAssetTag(SpecHandle: GameplayEffectSpecHandle, NewGameplayTag: GameplayTag): GameplayEffectSpecHandle;

        static AddAssetTags(SpecHandle: GameplayEffectSpecHandle, NewGameplayTags: GameplayTagContainer): GameplayEffectSpecHandle;

        static AddGrantedTag(SpecHandle: GameplayEffectSpecHandle, NewGameplayTag: GameplayTag): GameplayEffectSpecHandle;

        static AddGrantedTags(SpecHandle: GameplayEffectSpecHandle, NewGameplayTags: GameplayTagContainer): GameplayEffectSpecHandle;

        static AddLinkedGameplayEffect(SpecHandle: GameplayEffectSpecHandle, LinkedGameplayEffect: $Nullable<Class>): GameplayEffectSpecHandle;

        static AddLinkedGameplayEffectSpec(SpecHandle: GameplayEffectSpecHandle, LinkedGameplayEffectSpec: GameplayEffectSpecHandle): GameplayEffectSpecHandle;

        static AppendTargetDataHandle(TargetHandle: GameplayAbilityTargetDataHandle, HandleToAdd: GameplayAbilityTargetDataHandle): GameplayAbilityTargetDataHandle;

        static AssignSetByCallerMagnitude(SpecHandle: GameplayEffectSpecHandle, DataName: string, Magnitude: number): GameplayEffectSpecHandle;

        static AssignTagSetByCallerMagnitude(SpecHandle: GameplayEffectSpecHandle, DataTag: GameplayTag, Magnitude: number): GameplayEffectSpecHandle;

        static BreakGameplayCueParameters(Parameters: GameplayCueParameters, NormalizedMagnitude: $Ref<number>, RawMagnitude: $Ref<number>, EffectContext: $Ref<GameplayEffectContextHandle>, MatchedTagName: $Ref<GameplayTag>, OriginalTag: $Ref<GameplayTag>, AggregatedSourceTags: $Ref<GameplayTagContainer>, AggregatedTargetTags: $Ref<GameplayTagContainer>, Location: $Ref<Vector>, Normal: $Ref<Vector>, Instigator: $Ref<Actor>, EffectCauser: $Ref<Actor>, SourceObject: $Ref<Object>, PhysicalMaterial: $Ref<PhysicalMaterial>, GameplayEffectLevel: $Ref<number>, AbilityLevel: $Ref<number>, TargetAttachComponent: $Ref<SceneComponent>): void;

        static CloneSpecHandle(InNewInstigator: $Nullable<Actor>, InEffectCauser: $Nullable<Actor>, GameplayEffectSpecHandle_Clone: GameplayEffectSpecHandle): GameplayEffectSpecHandle;

        static DoesGameplayCueMeetTagRequirements(Parameters: GameplayCueParameters, SourceTagReqs: GameplayTagRequirements, TargetTagReqs: GameplayTagRequirements): boolean;

        static DoesTargetDataContainActor(TargetData: GameplayAbilityTargetDataHandle, Index: number, Actor: $Nullable<Actor>): boolean;

        static EffectContextAddHitResult(EffectContext: GameplayEffectContextHandle, HitResult: HitResult, bReset: boolean): void;

        static EffectContextGetEffectCauser(EffectContext: GameplayEffectContextHandle): Actor;

        static EffectContextGetHitResult(EffectContext: GameplayEffectContextHandle): HitResult;

        static EffectContextGetInstigatorActor(EffectContext: GameplayEffectContextHandle): Actor;

        static EffectContextGetOrigin(EffectContext: GameplayEffectContextHandle): Vector;

        static EffectContextGetOriginalInstigatorActor(EffectContext: GameplayEffectContextHandle): Actor;

        static EffectContextGetSourceObject(EffectContext: GameplayEffectContextHandle): Object;

        static EffectContextHasHitResult(EffectContext: GameplayEffectContextHandle): boolean;

        static EffectContextIsInstigatorLocallyControlled(EffectContext: GameplayEffectContextHandle): boolean;

        static EffectContextIsValid(EffectContext: GameplayEffectContextHandle): boolean;

        static EffectContextSetOrigin(EffectContext: GameplayEffectContextHandle, Origin: Vector): void;

        static EqualEqual_GameplayAttributeGameplayAttribute(AttributeA: GameplayAttribute, AttributeB: GameplayAttribute): boolean;

        static EvaluateAttributeValueWithTags(AbilitySystem: $Nullable<AbilitySystemComponent>, Attribute: GameplayAttribute, SourceTags: GameplayTagContainer, TargetTags: GameplayTagContainer, bSuccess: $Ref<boolean>): number;

        static EvaluateAttributeValueWithTagsAndBase(AbilitySystem: $Nullable<AbilitySystemComponent>, Attribute: GameplayAttribute, SourceTags: GameplayTagContainer, TargetTags: GameplayTagContainer, BaseValue: number, bSuccess: $Ref<boolean>): number;

        static FilterTargetData(TargetDataHandle: GameplayAbilityTargetDataHandle, ActorFilterClass: GameplayTargetDataFilterHandle): GameplayAbilityTargetDataHandle;

        static ForwardGameplayCueToTarget(TargetCueInterface: GameplayCueInterface, EventType: EGameplayCueEvent, Parameters: GameplayCueParameters): void;

        static GetAbilitySystemComponent(Actor: $Nullable<Actor>): AbilitySystemComponent;

        static GetActiveGameplayEffectDebugString(ActiveHandle: ActiveGameplayEffectHandle): string;

        static GetActiveGameplayEffectExpectedEndTime(ActiveHandle: ActiveGameplayEffectHandle): number;

        static GetActiveGameplayEffectRemainingDuration(WorldContextObject: $Nullable<Object>, ActiveHandle: ActiveGameplayEffectHandle): number;

        static GetActiveGameplayEffectStackCount(ActiveHandle: ActiveGameplayEffectHandle): number;

        static GetActiveGameplayEffectStackLimitCount(ActiveHandle: ActiveGameplayEffectHandle): number;

        static GetActiveGameplayEffectStartTime(ActiveHandle: ActiveGameplayEffectHandle): number;

        static GetActiveGameplayEffectTotalDuration(ActiveHandle: ActiveGameplayEffectHandle): number;

        static GetActorByIndex(Parameters: GameplayCueParameters, Index: number): Actor;

        static GetActorCount(Parameters: GameplayCueParameters): number;

        static GetActorsFromTargetData(TargetData: GameplayAbilityTargetDataHandle, Index: number): TArray<Actor>;

        static GetAllActorsFromTargetData(TargetData: GameplayAbilityTargetDataHandle): TArray<Actor>;

        static GetAllLinkedGameplayEffectSpecHandles(SpecHandle: GameplayEffectSpecHandle): TArray<GameplayEffectSpecHandle>;

        static GetDataCountFromTargetData(TargetData: GameplayAbilityTargetDataHandle): number;

        static GetEffectContext(SpecHandle: GameplayEffectSpecHandle): GameplayEffectContextHandle;

        static GetFloatAttribute(Actor: $Nullable<Actor>, Attribute: GameplayAttribute, bSuccessfullyFoundAttribute: $Ref<boolean>): number;

        static GetFloatAttributeBase(Actor: $Nullable<Actor>, Attribute: GameplayAttribute, bSuccessfullyFoundAttribute: $Ref<boolean>): number;

        static GetFloatAttributeBaseFromAbilitySystemComponent(AbilitySystemComponent: $Nullable<AbilitySystemComponent>, Attribute: GameplayAttribute, bSuccessfullyFoundAttribute: $Ref<boolean>): number;

        static GetFloatAttributeFromAbilitySystemComponent(AbilitySystem: $Nullable<AbilitySystemComponent>, Attribute: GameplayAttribute, bSuccessfullyFoundAttribute: $Ref<boolean>): number;

        static GetGameplayCueDirection(TargetActor: $Nullable<Actor>, Parameters: GameplayCueParameters, Direction: $Ref<Vector>): boolean;

        static GetGameplayCueEndLocationAndNormal(TargetActor: $Nullable<Actor>, Parameters: GameplayCueParameters, Location: $Ref<Vector>, Normal: $Ref<Vector>): boolean;

        static GetHitResult(Parameters: GameplayCueParameters): HitResult;

        static GetHitResultFromTargetData(HitResult: GameplayAbilityTargetDataHandle, Index: number): HitResult;

        static GetInstigatorActor(Parameters: GameplayCueParameters): Actor;

        static GetInstigatorTransform(Parameters: GameplayCueParameters): Transform;

        static GetModifiedAttributeMagnitude(SpecHandle: GameplayEffectSpecHandle, Attribute: GameplayAttribute): number;

        static GetOrigin(Parameters: GameplayCueParameters): Vector;

        static GetTargetDataEndPoint(TargetData: GameplayAbilityTargetDataHandle, Index: number): Vector;

        static GetTargetDataEndPointTransform(TargetData: GameplayAbilityTargetDataHandle, Index: number): Transform;

        static GetTargetDataOrigin(TargetData: GameplayAbilityTargetDataHandle, Index: number): Transform;

        static HasHitResult(Parameters: GameplayCueParameters): boolean;

        static IsInstigatorLocallyControlled(Parameters: GameplayCueParameters): boolean;

        static IsInstigatorLocallyControlledPlayer(Parameters: GameplayCueParameters): boolean;

        static IsValid(Attribute: GameplayAttribute): boolean;

        static MakeFilterHandle(Filter: GameplayTargetDataFilter, FilterActor: $Nullable<Actor>): GameplayTargetDataFilterHandle;

        static MakeGameplayCueParameters(NormalizedMagnitude: number, RawMagnitude: number, EffectContext: GameplayEffectContextHandle, MatchedTagName: GameplayTag, OriginalTag: GameplayTag, AggregatedSourceTags: GameplayTagContainer, AggregatedTargetTags: GameplayTagContainer, Location: Vector, Normal: Vector, Instigator: $Nullable<Actor>, EffectCauser: $Nullable<Actor>, SourceObject: $Nullable<Object>, PhysicalMaterial: $Nullable<PhysicalMaterial>, GameplayEffectLevel: number, AbilityLevel: number, TargetAttachComponent: $Nullable<SceneComponent>): GameplayCueParameters;

        static MakeSpecHandle(InGameplayEffect: $Nullable<GameplayEffect>, InInstigator: $Nullable<Actor>, InEffectCauser: $Nullable<Actor>, InLevel?: number /* = 1.000000 */): GameplayEffectSpecHandle;

        static NotEqual_GameplayAttributeGameplayAttribute(AttributeA: GameplayAttribute, AttributeB: GameplayAttribute): boolean;

        static SendGameplayEventToActor(Actor: $Nullable<Actor>, EventTag: GameplayTag, Payload: GameplayEventData): void;

        static SetDuration(SpecHandle: GameplayEffectSpecHandle, Duration: number): GameplayEffectSpecHandle;

        static SetStackCount(SpecHandle: GameplayEffectSpecHandle, StackCount: number): GameplayEffectSpecHandle;

        static SetStackCountToMax(SpecHandle: GameplayEffectSpecHandle): GameplayEffectSpecHandle;

        static TargetDataHasActor(TargetData: GameplayAbilityTargetDataHandle, Index: number): boolean;

        static TargetDataHasEndPoint(TargetData: GameplayAbilityTargetDataHandle, Index: number): boolean;

        static TargetDataHasHitResult(HitResult: GameplayAbilityTargetDataHandle, Index: number): boolean;

        static TargetDataHasOrigin(TargetData: GameplayAbilityTargetDataHandle, Index: number): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilitySystemBlueprintLibrary;

        static Load(InName: string): AbilitySystemBlueprintLibrary;
    }

    export class AbilitySystemDebugHUD extends HUD {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilitySystemDebugHUD;

        static Load(InName: string): AbilitySystemDebugHUD;
    }

    export class NetSerializeScriptStructCache {
        constructor();
        constructor(ScriptStructs: TArray<ScriptStruct>);

        ScriptStructs: TArray<ScriptStruct>;

        static StaticClass(): Class;
    }

    export class GameplayTagReponsePair {
        constructor();
        constructor(Tag: GameplayTag, ResponseGameplayEffect: Class, ResponseGameplayEffects: TArray<Class>, SoftCountCap: number);

        Tag: GameplayTag;
        ResponseGameplayEffect: Class;
        ResponseGameplayEffects: TArray<Class>;
        SoftCountCap: number;

        static StaticClass(): Class;
    }

    export class GameplayTagResponseTableEntry {
        constructor();
        constructor(Positive: GameplayTagReponsePair, Negative: GameplayTagReponsePair);

        Positive: GameplayTagReponsePair;
        Negative: GameplayTagReponsePair;

        static StaticClass(): Class;
    }

    export class GameplayTagReponseTable extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Entries: TArray<GameplayTagResponseTableEntry>;

        TagResponseEvent(Tag: GameplayTag, NewCount: number, ASC: $Nullable<AbilitySystemComponent>, idx: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagReponseTable;

        static Load(InName: string): GameplayTagReponseTable;
    }

    export class ObjectLibrary extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ObjectBaseClass: Class;
        bHasBlueprintClasses: boolean;
        Objects: TArray<Object>;
        WeakObjects: TArray<TWeakObjectPtr<Object>>;
        bUseWeakReferences: boolean;
        bIsFullyLoaded: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ObjectLibrary;

        static Load(InName: string): ObjectLibrary;
    }

    export class GameplayCueNotifyData {
        constructor();
        constructor(GameplayCueTag: GameplayTag, GameplayCueNotifyObj: SoftObjectPath, LoadedGameplayCueClass: Class);

        GameplayCueTag: GameplayTag;
        GameplayCueNotifyObj: SoftObjectPath;
        LoadedGameplayCueClass: Class;

        static StaticClass(): Class;
    }

    export class GameplayCueSet extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GameplayCueData: TArray<GameplayCueNotifyData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayCueSet;

        static Load(InName: string): GameplayCueSet;
    }

    export class GameplayCueObjectLibrary {
        constructor();
        constructor(Paths: TArray<string>, ActorObjectLibrary: ObjectLibrary, StaticObjectLibrary: ObjectLibrary, CueSet: GameplayCueSet, bShouldSyncScan: boolean, bShouldAsyncLoad: boolean, bShouldSyncLoad: boolean, bHasBeenInitialized: boolean);

        Paths: TArray<string>;
        ActorObjectLibrary: ObjectLibrary;
        StaticObjectLibrary: ObjectLibrary;
        CueSet: GameplayCueSet;
        bShouldSyncScan: boolean;
        bShouldAsyncLoad: boolean;
        bShouldSyncLoad: boolean;
        bHasBeenInitialized: boolean;

        static StaticClass(): Class;
    }

    export enum EGameplayCuePayloadType { CueParameters, FromSpec, EGameplayCuePayloadType_MAX }

    export class GameplayCuePendingExecute {
        constructor();
        constructor(PredictionKey: PredictionKey, PayloadType: EGameplayCuePayloadType, OwningComponent: AbilitySystemComponent, FromSpec: GameplayEffectSpecForRPC, CueParameters: GameplayCueParameters);

        PredictionKey: PredictionKey;
        PayloadType: EGameplayCuePayloadType;
        OwningComponent: AbilitySystemComponent;
        FromSpec: GameplayEffectSpecForRPC;
        CueParameters: GameplayCueParameters;

        static StaticClass(): Class;
    }

    export class PreallocationInfo {
        constructor();
        constructor(ClassesNeedingPreallocation: TArray<Class>);

        ClassesNeedingPreallocation: TArray<Class>;

        static StaticClass(): Class;
    }

    export class GameplayCueManager extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RuntimeGameplayCueObjectLibrary: GameplayCueObjectLibrary;
        EditorGameplayCueObjectLibrary: GameplayCueObjectLibrary;
        LoadedGameplayCueNotifyClasses: TArray<Class>;
        GameplayCueClassesForPreallocation: TArray<Class>;
        PendingExecuteCues: TArray<GameplayCuePendingExecute>;
        GameplayCueSendContextCount: number;
        PreallocationInfoList_Internal: TArray<PreallocationInfo>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayCueManager;

        static Load(InName: string): GameplayCueManager;
    }

    export class AbilitySystemGlobals extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AbilitySystemGlobalsClassName: SoftClassPath;
        ActivateFailIsDeadTag: GameplayTag;
        ActivateFailIsDeadName: string;
        ActivateFailCooldownTag: GameplayTag;
        ActivateFailCooldownName: string;
        ActivateFailCostTag: GameplayTag;
        ActivateFailCostName: string;
        ActivateFailTagsBlockedTag: GameplayTag;
        ActivateFailTagsBlockedName: string;
        ActivateFailTagsMissingTag: GameplayTag;
        ActivateFailTagsMissingName: string;
        ActivateFailNetworkingTag: GameplayTag;
        ActivateFailNetworkingName: string;
        MinimalReplicationTagCountBits: number;
        TargetDataStructCache: NetSerializeScriptStructCache;
        bAllowGameplayModEvaluationChannels: boolean;
        DefaultGameplayModEvaluationChannel: EGameplayModEvaluationChannel;
        GameplayModEvaluationChannelAliases: FixSizeArray<string>;
        GlobalCurveTableName: SoftObjectPath;
        GlobalCurveTable: CurveTable;
        GlobalAttributeMetaDataTableName: SoftObjectPath;
        GlobalAttributeMetaDataTable: DataTable;
        GlobalAttributeSetDefaultsTableName: SoftObjectPath;
        GlobalAttributeSetDefaultsTableNames: TArray<SoftObjectPath>;
        GlobalAttributeDefaultsTables: TArray<CurveTable>;
        GlobalGameplayCueManagerClass: SoftObjectPath;
        GlobalGameplayCueManagerName: SoftObjectPath;
        GameplayCueNotifyPaths: TArray<string>;
        GameplayTagResponseTableName: SoftObjectPath;
        GameplayTagResponseTable: GameplayTagReponseTable;
        PredictTargetGameplayEffects: boolean;
        GlobalGameplayCueManager: GameplayCueManager;

        ListPlayerAbilities(): void;

        ServerActivatePlayerAbility(AbilityNameMatch: string): void;

        ServerCancelPlayerAbility(AbilityNameMatch: string): void;

        ServerEndPlayerAbility(AbilityNameMatch: string): void;

        ToggleIgnoreAbilitySystemCooldowns(): void;

        ToggleIgnoreAbilitySystemCosts(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilitySystemGlobals;

        static Load(InName: string): AbilitySystemGlobals;
    }

    export class AbilitySystemInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilitySystemInterface;

        static Load(InName: string): AbilitySystemInterface;
    }

    export class AbilitySystemReplicationProxyInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilitySystemReplicationProxyInterface;

        static Load(InName: string): AbilitySystemReplicationProxyInterface;
    }

    export class AbilitySystemTestAttributeSet extends AttributeSet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxHealth: number;
        Health: number;
        Mana: number;
        MaxMana: number;
        Damage: number;
        SpellDamage: number;
        PhysicalDamage: number;
        CritChance: number;
        CritMultiplier: number;
        ArmorDamageReduction: number;
        DodgeChance: number;
        LifeSteal: number;
        Strength: number;
        StackingAttribute1: number;
        StackingAttribute2: number;
        NoStackAttribute: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilitySystemTestAttributeSet;

        static Load(InName: string): AbilitySystemTestAttributeSet;
    }

    export class AbilitySystemTestPawn extends DefaultPawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AbilitySystemComponent: AbilitySystemComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilitySystemTestPawn;

        static Load(InName: string): AbilitySystemTestPawn;
    }

    export class AbilityTask extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Ability: GameplayAbility;
        AbilitySystemComponent: AbilitySystemComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask;

        static Load(InName: string): AbilityTask;
    }

    export enum ERootMotionFinishVelocityMode {
        MaintainLastRootMotionVelocity,
        SetVelocity,
        ClampVelocity,
        ERootMotionFinishVelocityMode_MAX
    }

    export class AbilityTask_ApplyRootMotion_Base extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ForceName: string;
        FinishVelocityMode: ERootMotionFinishVelocityMode;
        FinishSetVelocity: Vector;
        FinishClampVelocity: number;
        MovementComponent: CharacterMovementComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_ApplyRootMotion_Base;

        static Load(InName: string): AbilityTask_ApplyRootMotion_Base;
    }

    export class AbilityTask_ApplyRootMotionConstantForce extends AbilityTask_ApplyRootMotion_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnFinish: $MulticastDelegate<() => void>;
        WorldDirection: Vector;
        Strength: number;
        Duration: number;
        bIsAdditive: boolean;
        StrengthOverTime: CurveFloat;
        bEnableGravity: boolean;

        static ApplyRootMotionConstantForce(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, WorldDirection: Vector, Strength: number, Duration: number, bIsAdditive: boolean, StrengthOverTime: $Nullable<CurveFloat>, VelocityOnFinishMode: ERootMotionFinishVelocityMode, SetVelocityOnFinish: Vector, ClampVelocityOnFinish: number, bEnableGravity: boolean): AbilityTask_ApplyRootMotionConstantForce;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_ApplyRootMotionConstantForce;

        static Load(InName: string): AbilityTask_ApplyRootMotionConstantForce;
    }

    export class AbilityTask_ApplyRootMotionJumpForce extends AbilityTask_ApplyRootMotion_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnFinish: $MulticastDelegate<() => void>;
        OnLanded: $MulticastDelegate<() => void>;
        Rotation: Rotator;
        Distance: number;
        Height: number;
        Duration: number;
        MinimumLandedTriggerTime: number;
        bFinishOnLanded: boolean;
        PathOffsetCurve: CurveVector;
        TimeMappingCurve: CurveFloat;

        Finish(): void;

        OnLandedCallback(Hit: HitResult): void;

        static ApplyRootMotionJumpForce(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, Rotation: Rotator, Distance: number, Height: number, Duration: number, MinimumLandedTriggerTime: number, bFinishOnLanded: boolean, VelocityOnFinishMode: ERootMotionFinishVelocityMode, SetVelocityOnFinish: Vector, ClampVelocityOnFinish: number, PathOffsetCurve: $Nullable<CurveVector>, TimeMappingCurve: $Nullable<CurveFloat>): AbilityTask_ApplyRootMotionJumpForce;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_ApplyRootMotionJumpForce;

        static Load(InName: string): AbilityTask_ApplyRootMotionJumpForce;
    }

    export enum ERootMotionMoveToActorTargetOffsetType {
        AlignFromTargetToSource,
        AlignToTargetForward,
        AlignToWorldSpace,
        ERootMotionMoveToActorTargetOffsetType_MAX
    }

    export class AbilityTask_ApplyRootMotionMoveToActorForce extends AbilityTask_ApplyRootMotion_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnFinished: $MulticastDelegate<(DestinationReached: boolean, TimedOut: boolean, FinalTargetLocation: Vector) => void>;
        StartLocation: Vector;
        TargetLocation: Vector;
        TargetActor: Actor;
        TargetLocationOffset: Vector;
        OffsetAlignment: ERootMotionMoveToActorTargetOffsetType;
        Duration: number;
        bDisableDestinationReachedInterrupt: boolean;
        bSetNewMovementMode: boolean;
        NewMovementMode: EMovementMode;
        bRestrictSpeedToExpected: boolean;
        PathOffsetCurve: CurveVector;
        TimeMappingCurve: CurveFloat;
        TargetLerpSpeedHorizontalCurve: CurveFloat;
        TargetLerpSpeedVerticalCurve: CurveFloat;

        OnRep_TargetLocation(): void;

        OnTargetActorSwapped(OriginalTarget: $Nullable<Actor>, NewTarget: $Nullable<Actor>): void;

        static ApplyRootMotionMoveToActorForce(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, TargetActor: $Nullable<Actor>, TargetLocationOffset: Vector, OffsetAlignment: ERootMotionMoveToActorTargetOffsetType, Duration: number, TargetLerpSpeedHorizontal: $Nullable<CurveFloat>, TargetLerpSpeedVertical: $Nullable<CurveFloat>, bSetNewMovementMode: boolean, MovementMode: EMovementMode, bRestrictSpeedToExpected: boolean, PathOffsetCurve: $Nullable<CurveVector>, TimeMappingCurve: $Nullable<CurveFloat>, VelocityOnFinishMode: ERootMotionFinishVelocityMode, SetVelocityOnFinish: Vector, ClampVelocityOnFinish: number, bDisableDestinationReachedInterrupt: boolean): AbilityTask_ApplyRootMotionMoveToActorForce;

        static ApplyRootMotionMoveToTargetDataActorForce(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, TargetDataHandle: GameplayAbilityTargetDataHandle, TargetDataIndex: number, TargetActorIndex: number, TargetLocationOffset: Vector, OffsetAlignment: ERootMotionMoveToActorTargetOffsetType, Duration: number, TargetLerpSpeedHorizontal: $Nullable<CurveFloat>, TargetLerpSpeedVertical: $Nullable<CurveFloat>, bSetNewMovementMode: boolean, MovementMode: EMovementMode, bRestrictSpeedToExpected: boolean, PathOffsetCurve: $Nullable<CurveVector>, TimeMappingCurve: $Nullable<CurveFloat>, VelocityOnFinishMode: ERootMotionFinishVelocityMode, SetVelocityOnFinish: Vector, ClampVelocityOnFinish: number, bDisableDestinationReachedInterrupt: boolean): AbilityTask_ApplyRootMotionMoveToActorForce;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_ApplyRootMotionMoveToActorForce;

        static Load(InName: string): AbilityTask_ApplyRootMotionMoveToActorForce;
    }

    export class AbilityTask_ApplyRootMotionMoveToForce extends AbilityTask_ApplyRootMotion_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnTimedOut: $MulticastDelegate<() => void>;
        OnTimedOutAndDestinationReached: $MulticastDelegate<() => void>;
        StartLocation: Vector;
        TargetLocation: Vector;
        Duration: number;
        bSetNewMovementMode: boolean;
        NewMovementMode: EMovementMode;
        bRestrictSpeedToExpected: boolean;
        PathOffsetCurve: CurveVector;

        static ApplyRootMotionMoveToForce(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, TargetLocation: Vector, Duration: number, bSetNewMovementMode: boolean, MovementMode: EMovementMode, bRestrictSpeedToExpected: boolean, PathOffsetCurve: $Nullable<CurveVector>, VelocityOnFinishMode: ERootMotionFinishVelocityMode, SetVelocityOnFinish: Vector, ClampVelocityOnFinish: number): AbilityTask_ApplyRootMotionMoveToForce;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_ApplyRootMotionMoveToForce;

        static Load(InName: string): AbilityTask_ApplyRootMotionMoveToForce;
    }

    export class AbilityTask_ApplyRootMotionRadialForce extends AbilityTask_ApplyRootMotion_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnFinish: $MulticastDelegate<() => void>;
        Location: Vector;
        LocationActor: Actor;
        Strength: number;
        Duration: number;
        Radius: number;
        bIsPush: boolean;
        bIsAdditive: boolean;
        bNoZForce: boolean;
        StrengthDistanceFalloff: CurveFloat;
        StrengthOverTime: CurveFloat;
        bUseFixedWorldDirection: boolean;
        FixedWorldDirection: Rotator;

        static ApplyRootMotionRadialForce(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, Location: Vector, LocationActor: $Nullable<Actor>, Strength: number, Duration: number, Radius: number, bIsPush: boolean, bIsAdditive: boolean, bNoZForce: boolean, StrengthDistanceFalloff: $Nullable<CurveFloat>, StrengthOverTime: $Nullable<CurveFloat>, bUseFixedWorldDirection: boolean, FixedWorldDirection: Rotator, VelocityOnFinishMode: ERootMotionFinishVelocityMode, SetVelocityOnFinish: Vector, ClampVelocityOnFinish: number): AbilityTask_ApplyRootMotionRadialForce;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_ApplyRootMotionRadialForce;

        static Load(InName: string): AbilityTask_ApplyRootMotionRadialForce;
    }

    export class AbilityTask_MoveToLocation extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnTargetLocationReached: $MulticastDelegate<() => void>;
        StartLocation: Vector;
        TargetLocation: Vector;
        DurationOfMovement: number;
        LerpCurve: CurveFloat;
        LerpCurveVector: CurveVector;

        static MoveToLocation(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, Location: Vector, Duration: number, OptionalInterpolationCurve: $Nullable<CurveFloat>, OptionalVectorInterpolationCurve: $Nullable<CurveVector>): AbilityTask_MoveToLocation;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_MoveToLocation;

        static Load(InName: string): AbilityTask_MoveToLocation;
    }

    export enum EAbilityTaskNetSyncType { BothWait, OnlyServerWait, OnlyClientWait, EAbilityTaskNetSyncType_MAX }

    export class AbilityTask_NetworkSyncPoint extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSync: $MulticastDelegate<() => void>;

        OnSignalCallback(): void;

        static WaitNetSync(OwningAbility: $Nullable<GameplayAbility>, SyncType: EAbilityTaskNetSyncType): AbilityTask_NetworkSyncPoint;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_NetworkSyncPoint;

        static Load(InName: string): AbilityTask_NetworkSyncPoint;
    }

    export class AbilityTask_PlayMontageAndWait extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnCompleted: $MulticastDelegate<() => void>;
        OnBlendOut: $MulticastDelegate<() => void>;
        OnInterrupted: $MulticastDelegate<() => void>;
        OnCancelled: $MulticastDelegate<() => void>;
        MontageToPlay: AnimMontage;
        Rate: number;
        StartSection: string;
        AnimRootMotionTranslationScale: number;
        StartTimeSeconds: number;
        bStopWhenAbilityEnds: boolean;

        OnMontageBlendingOut(Montage: $Nullable<AnimMontage>, bInterrupted: boolean): void;

        OnMontageEnded(Montage: $Nullable<AnimMontage>, bInterrupted: boolean): void;

        OnMontageInterrupted(): void;

        static CreatePlayMontageAndWaitProxy(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, MontageToPlay: $Nullable<AnimMontage>, Rate?: number /* = 1.000000 */, StartSection?: string /* = "None" */, bStopWhenAbilityEnds?: boolean /* = true */, AnimRootMotionTranslationScale?: number /* = 1.000000 */, StartTimeSeconds?: number /* = 0.000000 */): AbilityTask_PlayMontageAndWait;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_PlayMontageAndWait;

        static Load(InName: string): AbilityTask_PlayMontageAndWait;
    }

    export class AbilityTask_Repeat extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPerformAction: $MulticastDelegate<(ActionNumber: number) => void>;
        OnFinished: $MulticastDelegate<(ActionNumber: number) => void>;

        static RepeatAction(OwningAbility: $Nullable<GameplayAbility>, TimeBetweenActions: number, TotalActionCount: number): AbilityTask_Repeat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_Repeat;

        static Load(InName: string): AbilityTask_Repeat;
    }

    export class AbilityTask_SpawnActor extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Success: $MulticastDelegate<(SpawnedActor: $Nullable<Actor>) => void>;
        DidNotSpawn: $MulticastDelegate<(SpawnedActor: $Nullable<Actor>) => void>;

        BeginSpawningActor(OwningAbility: $Nullable<GameplayAbility>, TargetData: GameplayAbilityTargetDataHandle, Class: $Nullable<Class>, SpawnedActor: $Ref<Actor>): boolean;

        FinishSpawningActor(OwningAbility: $Nullable<GameplayAbility>, TargetData: GameplayAbilityTargetDataHandle, SpawnedActor: $Nullable<Actor>): void;

        static SpawnActor(OwningAbility: $Nullable<GameplayAbility>, TargetData: GameplayAbilityTargetDataHandle, Class: $Nullable<Class>): AbilityTask_SpawnActor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_SpawnActor;

        static Load(InName: string): AbilityTask_SpawnActor;
    }

    export class AbilityTask_StartAbilityState extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnStateEnded: $MulticastDelegate<() => void>;
        OnStateInterrupted: $MulticastDelegate<() => void>;

        static StartAbilityState(OwningAbility: $Nullable<GameplayAbility>, StateName: string, bEndCurrentState?: boolean /* = true */): AbilityTask_StartAbilityState;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_StartAbilityState;

        static Load(InName: string): AbilityTask_StartAbilityState;
    }

    export class AbilityTask_VisualizeTargeting extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TimeElapsed: $MulticastDelegate<() => void>;

        BeginSpawningActor(OwningAbility: $Nullable<GameplayAbility>, Class: $Nullable<Class>, SpawnedActor: $Ref<GameplayAbilityTargetActor>): boolean;

        FinishSpawningActor(OwningAbility: $Nullable<GameplayAbility>, SpawnedActor: $Nullable<GameplayAbilityTargetActor>): void;

        static VisualizeTargeting(OwningAbility: $Nullable<GameplayAbility>, Class: $Nullable<Class>, TaskInstanceName: string, Duration?: number /* = -1.000000 */): AbilityTask_VisualizeTargeting;

        static VisualizeTargetingUsingActor(OwningAbility: $Nullable<GameplayAbility>, TargetActor: $Nullable<GameplayAbilityTargetActor>, TaskInstanceName: string, Duration?: number /* = -1.000000 */): AbilityTask_VisualizeTargeting;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_VisualizeTargeting;

        static Load(InName: string): AbilityTask_VisualizeTargeting;
    }

    export class AbilityTask_WaitAbilityActivate extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnActivate: $MulticastDelegate<(ActivatedAbility: $Nullable<GameplayAbility>) => void>;

        OnAbilityActivate(ActivatedAbility: $Nullable<GameplayAbility>): void;

        static WaitForAbilityActivate(OwningAbility: $Nullable<GameplayAbility>, WithTag: GameplayTag, WithoutTag: GameplayTag, IncludeTriggeredAbilities?: boolean /* = false */, TriggerOnce?: boolean /* = true */): AbilityTask_WaitAbilityActivate;

        static WaitForAbilityActivate_Query(OwningAbility: $Nullable<GameplayAbility>, Query: GameplayTagQuery, IncludeTriggeredAbilities?: boolean /* = false */, TriggerOnce?: boolean /* = true */): AbilityTask_WaitAbilityActivate;

        static WaitForAbilityActivateWithTagRequirements(OwningAbility: $Nullable<GameplayAbility>, TagRequirements: GameplayTagRequirements, IncludeTriggeredAbilities?: boolean /* = false */, TriggerOnce?: boolean /* = true */): AbilityTask_WaitAbilityActivate;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitAbilityActivate;

        static Load(InName: string): AbilityTask_WaitAbilityActivate;
    }

    export class AbilityTask_WaitAbilityCommit extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnCommit: $MulticastDelegate<(ActivatedAbility: $Nullable<GameplayAbility>) => void>;

        OnAbilityCommit(ActivatedAbility: $Nullable<GameplayAbility>): void;

        static WaitForAbilityCommit(OwningAbility: $Nullable<GameplayAbility>, WithTag: GameplayTag, WithoutTage: GameplayTag, TriggerOnce?: boolean /* = true */): AbilityTask_WaitAbilityCommit;

        static WaitForAbilityCommit_Query(OwningAbility: $Nullable<GameplayAbility>, Query: GameplayTagQuery, TriggerOnce?: boolean /* = true */): AbilityTask_WaitAbilityCommit;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitAbilityCommit;

        static Load(InName: string): AbilityTask_WaitAbilityCommit;
    }

    export enum EWaitAttributeChangeComparison {
        None,
        GreaterThan,
        LessThan,
        GreaterThanOrEqualTo,
        LessThanOrEqualTo,
        NotEqualTo,
        ExactlyEqualTo,
        MAX
    }

    export class AbilityTask_WaitAttributeChange extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnChange: $MulticastDelegate<() => void>;
        ExternalOwner: AbilitySystemComponent;

        static WaitForAttributeChange(OwningAbility: $Nullable<GameplayAbility>, Attribute: GameplayAttribute, WithSrcTag: GameplayTag, WithoutSrcTag: GameplayTag, TriggerOnce?: boolean /* = true */, OptionalExternalOwner?: Actor /* = None */): AbilityTask_WaitAttributeChange;

        static WaitForAttributeChangeWithComparison(OwningAbility: $Nullable<GameplayAbility>, InAttribute: GameplayAttribute, InWithTag: GameplayTag, InWithoutTag: GameplayTag, InComparisonType: EWaitAttributeChangeComparison, InComparisonValue: number, TriggerOnce?: boolean /* = true */, OptionalExternalOwner?: Actor /* = None */): AbilityTask_WaitAttributeChange;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitAttributeChange;

        static Load(InName: string): AbilityTask_WaitAttributeChange;
    }

    export class AbilityTask_WaitAttributeChangeRatioThreshold extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnChange: $MulticastDelegate<(bMatchesComparison: boolean, CurrentRatio: number) => void>;
        ExternalOwner: AbilitySystemComponent;

        static WaitForAttributeChangeRatioThreshold(OwningAbility: $Nullable<GameplayAbility>, AttributeNumerator: GameplayAttribute, AttributeDenominator: GameplayAttribute, ComparisonType: EWaitAttributeChangeComparison, ComparisonValue: number, bTriggerOnce: boolean, OptionalExternalOwner?: Actor /* = None */): AbilityTask_WaitAttributeChangeRatioThreshold;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitAttributeChangeRatioThreshold;

        static Load(InName: string): AbilityTask_WaitAttributeChangeRatioThreshold;
    }

    export class AbilityTask_WaitAttributeChangeThreshold extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnChange: $MulticastDelegate<(bMatchesComparison: boolean, CurrentValue: number) => void>;
        ExternalOwner: AbilitySystemComponent;

        static WaitForAttributeChangeThreshold(OwningAbility: $Nullable<GameplayAbility>, Attribute: GameplayAttribute, ComparisonType: EWaitAttributeChangeComparison, ComparisonValue: number, bTriggerOnce: boolean, OptionalExternalOwner?: Actor /* = None */): AbilityTask_WaitAttributeChangeThreshold;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitAttributeChangeThreshold;

        static Load(InName: string): AbilityTask_WaitAttributeChangeThreshold;
    }

    export class AbilityTask_WaitCancel extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnCancel: $MulticastDelegate<() => void>;

        OnCancelCallback(): void;

        OnLocalCancelCallback(): void;

        static WaitCancel(OwningAbility: $Nullable<GameplayAbility>): AbilityTask_WaitCancel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitCancel;

        static Load(InName: string): AbilityTask_WaitCancel;
    }

    export class AbilityTask_WaitConfirm extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnConfirm: $MulticastDelegate<() => void>;

        OnConfirmCallback(InAbility: $Nullable<GameplayAbility>): void;

        static WaitConfirm(OwningAbility: $Nullable<GameplayAbility>): AbilityTask_WaitConfirm;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitConfirm;

        static Load(InName: string): AbilityTask_WaitConfirm;
    }

    export class AbilityTask_WaitConfirmCancel extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnConfirm: $MulticastDelegate<() => void>;
        OnCancel: $MulticastDelegate<() => void>;

        OnCancelCallback(): void;

        OnConfirmCallback(): void;

        OnLocalCancelCallback(): void;

        OnLocalConfirmCallback(): void;

        static WaitConfirmCancel(OwningAbility: $Nullable<GameplayAbility>): AbilityTask_WaitConfirmCancel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitConfirmCancel;

        static Load(InName: string): AbilityTask_WaitConfirmCancel;
    }

    export class AbilityTask_WaitDelay extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnFinish: $MulticastDelegate<() => void>;

        static WaitDelay(OwningAbility: $Nullable<GameplayAbility>, Time: number): AbilityTask_WaitDelay;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitDelay;

        static Load(InName: string): AbilityTask_WaitDelay;
    }

    export class AbilityTask_WaitGameplayEffectApplied extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ExternalOwner: AbilitySystemComponent;

        OnApplyGameplayEffectCallback(Target: $Nullable<AbilitySystemComponent>, SpecApplied: GameplayEffectSpec, ActiveHandle: ActiveGameplayEffectHandle): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayEffectApplied;

        static Load(InName: string): AbilityTask_WaitGameplayEffectApplied;
    }

    export class AbilityTask_WaitGameplayEffectApplied_Self extends AbilityTask_WaitGameplayEffectApplied {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnApplied: $MulticastDelegate<(Source: $Nullable<Actor>, SpecHandle: GameplayEffectSpecHandle, ActiveHandle: ActiveGameplayEffectHandle) => void>;

        static WaitGameplayEffectAppliedToSelf(OwningAbility: $Nullable<GameplayAbility>, SourceFilter: GameplayTargetDataFilterHandle, SourceTagRequirements: GameplayTagRequirements, TargetTagRequirements: GameplayTagRequirements, TriggerOnce?: boolean /* = false */, OptionalExternalOwner?: Actor /* = None */, ListenForPeriodicEffect?: boolean /* = false */): AbilityTask_WaitGameplayEffectApplied_Self;

        static WaitGameplayEffectAppliedToSelf_Query(OwningAbility: $Nullable<GameplayAbility>, SourceFilter: GameplayTargetDataFilterHandle, SourceTagQuery: GameplayTagQuery, TargetTagQuery: GameplayTagQuery, TriggerOnce?: boolean /* = false */, OptionalExternalOwner?: Actor /* = None */, ListenForPeriodicEffect?: boolean /* = false */): AbilityTask_WaitGameplayEffectApplied_Self;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayEffectApplied_Self;

        static Load(InName: string): AbilityTask_WaitGameplayEffectApplied_Self;
    }

    export class AbilityTask_WaitGameplayEffectApplied_Target extends AbilityTask_WaitGameplayEffectApplied {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnApplied: $MulticastDelegate<(Target: $Nullable<Actor>, SpecHandle: GameplayEffectSpecHandle, ActiveHandle: ActiveGameplayEffectHandle) => void>;

        static WaitGameplayEffectAppliedToTarget(OwningAbility: $Nullable<GameplayAbility>, TargetFilter: GameplayTargetDataFilterHandle, SourceTagRequirements: GameplayTagRequirements, TargetTagRequirements: GameplayTagRequirements, TriggerOnce?: boolean /* = false */, OptionalExternalOwner?: Actor /* = None */, ListenForPeriodicEffects?: boolean /* = false */): AbilityTask_WaitGameplayEffectApplied_Target;

        static WaitGameplayEffectAppliedToTarget_Query(OwningAbility: $Nullable<GameplayAbility>, SourceFilter: GameplayTargetDataFilterHandle, SourceTagQuery: GameplayTagQuery, TargetTagQuery: GameplayTagQuery, TriggerOnce?: boolean /* = false */, OptionalExternalOwner?: Actor /* = None */, ListenForPeriodicEffect?: boolean /* = false */): AbilityTask_WaitGameplayEffectApplied_Target;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayEffectApplied_Target;

        static Load(InName: string): AbilityTask_WaitGameplayEffectApplied_Target;
    }

    export class AbilityTask_WaitGameplayEffectBlockedImmunity extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Blocked: $MulticastDelegate<(BlockedSpec: GameplayEffectSpecHandle, ImmunityGameplayEffectHandle: ActiveGameplayEffectHandle) => void>;
        ExternalOwner: AbilitySystemComponent;

        static WaitGameplayEffectBlockedByImmunity(OwningAbility: $Nullable<GameplayAbility>, SourceTagRequirements: GameplayTagRequirements, TargetTagRequirements: GameplayTagRequirements, OptionalExternalTarget?: Actor /* = None */, OnlyTriggerOnce?: boolean /* = false */): AbilityTask_WaitGameplayEffectBlockedImmunity;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayEffectBlockedImmunity;

        static Load(InName: string): AbilityTask_WaitGameplayEffectBlockedImmunity;
    }

    export class GameplayEffectRemovalInfo {
        constructor();
        constructor(bPrematureRemoval: boolean, StackCount: number, EffectContext: GameplayEffectContextHandle);

        bPrematureRemoval: boolean;
        StackCount: number;
        EffectContext: GameplayEffectContextHandle;

        static StaticClass(): Class;
    }

    export class AbilityTask_WaitGameplayEffectRemoved extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnRemoved: $MulticastDelegate<(GameplayEffectRemovalInfo: GameplayEffectRemovalInfo) => void>;
        InvalidHandle: $MulticastDelegate<(GameplayEffectRemovalInfo: GameplayEffectRemovalInfo) => void>;

        OnGameplayEffectRemoved(InGameplayEffectRemovalInfo: GameplayEffectRemovalInfo): void;

        static WaitForGameplayEffectRemoved(OwningAbility: $Nullable<GameplayAbility>, Handle: ActiveGameplayEffectHandle): AbilityTask_WaitGameplayEffectRemoved;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayEffectRemoved;

        static Load(InName: string): AbilityTask_WaitGameplayEffectRemoved;
    }

    export class AbilityTask_WaitGameplayEffectStackChange extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnChange: $MulticastDelegate<(Handle: ActiveGameplayEffectHandle, NewCount: number, OldCount: number) => void>;
        InvalidHandle: $MulticastDelegate<(Handle: ActiveGameplayEffectHandle, NewCount: number, OldCount: number) => void>;

        OnGameplayEffectStackChange(Handle: ActiveGameplayEffectHandle, NewCount: number, OldCount: number): void;

        static WaitForGameplayEffectStackChange(OwningAbility: $Nullable<GameplayAbility>, Handle: ActiveGameplayEffectHandle): AbilityTask_WaitGameplayEffectStackChange;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayEffectStackChange;

        static Load(InName: string): AbilityTask_WaitGameplayEffectStackChange;
    }

    export class AbilityTask_WaitGameplayEvent extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventReceived: $MulticastDelegate<(Payload: GameplayEventData) => void>;
        OptionalExternalTarget: AbilitySystemComponent;

        static WaitGameplayEvent(OwningAbility: $Nullable<GameplayAbility>, EventTag: GameplayTag, OptionalExternalTarget?: Actor /* = None */, OnlyTriggerOnce?: boolean /* = false */, OnlyMatchExact?: boolean /* = true */): AbilityTask_WaitGameplayEvent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayEvent;

        static Load(InName: string): AbilityTask_WaitGameplayEvent;
    }

    export class AbilityTask_WaitGameplayTag extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OptionalExternalTarget: AbilitySystemComponent;

        GameplayTagCallback(Tag: GameplayTag, NewCount: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayTag;

        static Load(InName: string): AbilityTask_WaitGameplayTag;
    }

    export class AbilityTask_WaitGameplayTagAdded extends AbilityTask_WaitGameplayTag {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Added: $MulticastDelegate<() => void>;

        static WaitGameplayTagAdd(OwningAbility: $Nullable<GameplayAbility>, Tag: GameplayTag, InOptionalExternalTarget?: Actor /* = None */, OnlyTriggerOnce?: boolean /* = false */): AbilityTask_WaitGameplayTagAdded;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayTagAdded;

        static Load(InName: string): AbilityTask_WaitGameplayTagAdded;
    }

    export class AbilityTask_WaitGameplayTagRemoved extends AbilityTask_WaitGameplayTag {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Removed: $MulticastDelegate<() => void>;

        static WaitGameplayTagRemove(OwningAbility: $Nullable<GameplayAbility>, Tag: GameplayTag, InOptionalExternalTarget?: Actor /* = None */, OnlyTriggerOnce?: boolean /* = false */): AbilityTask_WaitGameplayTagRemoved;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitGameplayTagRemoved;

        static Load(InName: string): AbilityTask_WaitGameplayTagRemoved;
    }

    export class AbilityTask_WaitInputPress extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPress: $MulticastDelegate<(TimeWaited: number) => void>;

        OnPressCallback(): void;

        static WaitInputPress(OwningAbility: $Nullable<GameplayAbility>, bTestAlreadyPressed?: boolean /* = false */): AbilityTask_WaitInputPress;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitInputPress;

        static Load(InName: string): AbilityTask_WaitInputPress;
    }

    export class AbilityTask_WaitInputRelease extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnRelease: $MulticastDelegate<(TimeHeld: number) => void>;

        OnReleaseCallback(): void;

        static WaitInputRelease(OwningAbility: $Nullable<GameplayAbility>, bTestAlreadyReleased?: boolean /* = false */): AbilityTask_WaitInputRelease;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitInputRelease;

        static Load(InName: string): AbilityTask_WaitInputRelease;
    }

    export class AbilityTask_WaitMovementModeChange extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnChange: $MulticastDelegate<(NewMovementMode: EMovementMode) => void>;

        OnMovementModeChange(Character: $Nullable<Character>, PrevMovementMode: EMovementMode, PreviousCustomMode: number): void;

        static CreateWaitMovementModeChange(OwningAbility: $Nullable<GameplayAbility>, NewMode: EMovementMode): AbilityTask_WaitMovementModeChange;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitMovementModeChange;

        static Load(InName: string): AbilityTask_WaitMovementModeChange;
    }

    export class AbilityTask_WaitOverlap extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnOverlap: $MulticastDelegate<(TargetData: GameplayAbilityTargetDataHandle) => void>;

        OnHitCallback(HitComp: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, NormalImpulse: Vector, Hit: HitResult): void;

        static WaitForOverlap(OwningAbility: $Nullable<GameplayAbility>): AbilityTask_WaitOverlap;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitOverlap;

        static Load(InName: string): AbilityTask_WaitOverlap;
    }

    export enum EGameplayTargetingConfirmation {
        Instant,
        UserConfirmed,
        Custom,
        CustomMulti,
        EGameplayTargetingConfirmation_MAX
    }

    export class AbilityTask_WaitTargetData extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ValidData: $MulticastDelegate<(Data: GameplayAbilityTargetDataHandle) => void>;
        Cancelled: $MulticastDelegate<(Data: GameplayAbilityTargetDataHandle) => void>;
        TargetClass: Class;
        TargetActor: GameplayAbilityTargetActor;

        BeginSpawningActor(OwningAbility: $Nullable<GameplayAbility>, Class: $Nullable<Class>, SpawnedActor: $Ref<GameplayAbilityTargetActor>): boolean;

        FinishSpawningActor(OwningAbility: $Nullable<GameplayAbility>, SpawnedActor: $Nullable<GameplayAbilityTargetActor>): void;

        OnTargetDataCancelledCallback(Data: GameplayAbilityTargetDataHandle): void;

        OnTargetDataReadyCallback(Data: GameplayAbilityTargetDataHandle): void;

        OnTargetDataReplicatedCallback(Data: GameplayAbilityTargetDataHandle, ActivationTag: GameplayTag): void;

        OnTargetDataReplicatedCancelledCallback(): void;

        static WaitTargetData(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, ConfirmationType: EGameplayTargetingConfirmation, Class: $Nullable<Class>): AbilityTask_WaitTargetData;

        static WaitTargetDataUsingActor(OwningAbility: $Nullable<GameplayAbility>, TaskInstanceName: string, ConfirmationType: EGameplayTargetingConfirmation, TargetActor: $Nullable<GameplayAbilityTargetActor>): AbilityTask_WaitTargetData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitTargetData;

        static Load(InName: string): AbilityTask_WaitTargetData;
    }

    export class AbilityTask_WaitVelocityChange extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnVelocityChage: $MulticastDelegate<() => void>;
        CachedMovementComponent: MovementComponent;

        static CreateWaitVelocityChange(OwningAbility: $Nullable<GameplayAbility>, Direction: Vector, MinimumMagnitude: number): AbilityTask_WaitVelocityChange;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbilityTask_WaitVelocityChange;

        static Load(InName: string): AbilityTask_WaitVelocityChange;
    }

    export class NavDataConfig extends NavAgentProperties {
        constructor();
        constructor(Name: string, Color: Color, DefaultQueryExtent: Vector, NavigationDataClass: Class, NavDataClass: TSoftClassPtr<Actor>);

        Name: string;
        Color: Color;
        DefaultQueryExtent: Vector;
        NavigationDataClass: Class;
        NavDataClass: TSoftClassPtr<Actor>;

        static StaticClass(): Class;
    }

    export enum ERuntimeGenerationType {
        Static,
        DynamicModifiersOnly,
        Dynamic,
        LegacyGeneration,
        ERuntimeGenerationType_MAX
    }

    export class SupportedAreaData {
        constructor();
        constructor(AreaClassName: string, AreaID: number, AreaClass: Class);

        AreaClassName: string;
        AreaID: number;
        AreaClass: Class;

        static StaticClass(): Class;
    }

    export class NavigationData extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RenderingComp: PrimitiveComponent;
        NavDataConfig: NavDataConfig;
        bEnableDrawing: boolean;
        bForceRebuildOnLoad: boolean;
        bAutoDestroyWhenNoNavigation: boolean;
        bCanBeMainNavData: boolean;
        bCanSpawnOnRebuild: boolean;
        bRebuildAtRuntime: boolean;
        ObservedPathsTickInterval: number;
        RuntimeGeneration: ERuntimeGenerationType;
        DataVersion: number;
        SupportedAreas: TArray<SupportedAreaData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationData;

        static Load(InName: string): NavigationData;
    }

    export class AbstractNavData extends NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AbstractNavData;

        static Load(InName: string): AbstractNavData;
    }

    export class AchievementBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetCachedAchievementDescription(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, AchievementID: string, bFoundID: $Ref<boolean>, Title: $Ref<string>, LockedDescription: $Ref<string>, UnlockedDescription: $Ref<string>, bHidden: $Ref<boolean>): void;

        static GetCachedAchievementProgress(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, AchievementID: string, bFoundID: $Ref<boolean>, Progress: $Ref<number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AchievementBlueprintLibrary;

        static Load(InName: string): AchievementBlueprintLibrary;
    }

    export class BlueprintAsyncActionBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Activate(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintAsyncActionBase;

        static Load(InName: string): BlueprintAsyncActionBase;
    }

    export class OnlineBlueprintCallProxyBase extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineBlueprintCallProxyBase;

        static Load(InName: string): OnlineBlueprintCallProxyBase;
    }

    export class AchievementQueryCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;

        static CacheAchievementDescriptions(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>): AchievementQueryCallbackProxy;

        static CacheAchievements(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>): AchievementQueryCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AchievementQueryCallbackProxy;

        static Load(InName: string): AchievementQueryCallbackProxy;
    }

    export class AchievementWriteCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
        OnFailure: $MulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;

        static WriteAchievementProgress(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, AchievementName: string, Progress?: number /* = 100.000000 */, UserTag?: number /* = 0 */): AchievementWriteCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AchievementWriteCallbackProxy;

        static Load(InName: string): AchievementWriteCallbackProxy;
    }

    export class EditorUtilityObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Run(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityObject;

        static Load(InName: string): EditorUtilityObject;
    }

    export class ActorActionUtility extends EditorUtilityObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetSupportedClass(): Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorActionUtility;

        static Load(InName: string): ActorActionUtility;
    }

    export class ActorChannel extends Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Actor: Actor;
        CreateSubObjects: TArray<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorChannel;

        static Load(InName: string): ActorChannel;
    }

    export class ActorComponentInstanceDataTransientOuter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorComponentInstanceDataTransientOuter;

        static Load(InName: string): ActorComponentInstanceDataTransientOuter;
    }

    export class ActorFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DisplayName: string;
        MenuPriority: number;
        NewActorClassName: string;
        NewActorClass: Class;
        bShowInEditorQuickMenu: boolean;
        bUseSurfaceOrientation: boolean;
        SpawnPositionOffset: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactory;

        static Load(InName: string): ActorFactory;
    }

    export class ActorFactoryAmbientSound extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryAmbientSound;

        static Load(InName: string): ActorFactoryAmbientSound;
    }

    export class ActorFactorySkeletalMesh extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactorySkeletalMesh;

        static Load(InName: string): ActorFactorySkeletalMesh;
    }

    export class ActorFactoryAnimationAsset extends ActorFactorySkeletalMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryAnimationAsset;

        static Load(InName: string): ActorFactoryAnimationAsset;
    }

    export class ActorFactoryAtmosphericFog extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryAtmosphericFog;

        static Load(InName: string): ActorFactoryAtmosphericFog;
    }

    export class ActorFactoryStaticMesh extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryStaticMesh;

        static Load(InName: string): ActorFactoryStaticMesh;
    }

    export class ActorFactoryBasicShape extends ActorFactoryStaticMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryBasicShape;

        static Load(InName: string): ActorFactoryBasicShape;
    }

    export class ActorFactoryBlueprint extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryBlueprint;

        static Load(InName: string): ActorFactoryBlueprint;
    }

    export class ActorFactoryBoxReflectionCapture extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryBoxReflectionCapture;

        static Load(InName: string): ActorFactoryBoxReflectionCapture;
    }

    export class ActorFactoryVolume extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryVolume;

        static Load(InName: string): ActorFactoryVolume;
    }

    export class ActorFactoryBoxVolume extends ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryBoxVolume;

        static Load(InName: string): ActorFactoryBoxVolume;
    }

    export class ActorFactoryCameraActor extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryCameraActor;

        static Load(InName: string): ActorFactoryCameraActor;
    }

    export class ActorFactoryCharacter extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryCharacter;

        static Load(InName: string): ActorFactoryCharacter;
    }

    export class ActorFactoryClass extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryClass;

        static Load(InName: string): ActorFactoryClass;
    }

    export class ActorFactoryCylinderVolume extends ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryCylinderVolume;

        static Load(InName: string): ActorFactoryCylinderVolume;
    }

    export class ActorFactoryDeferredDecal extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryDeferredDecal;

        static Load(InName: string): ActorFactoryDeferredDecal;
    }

    export class ActorFactoryDirectionalLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryDirectionalLight;

        static Load(InName: string): ActorFactoryDirectionalLight;
    }

    export class ActorFactoryEmitter extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryEmitter;

        static Load(InName: string): ActorFactoryEmitter;
    }

    export class ActorFactoryEmptyActor extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bVisualizeActor: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryEmptyActor;

        static Load(InName: string): ActorFactoryEmptyActor;
    }

    export class ActorFactoryExponentialHeightFog extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryExponentialHeightFog;

        static Load(InName: string): ActorFactoryExponentialHeightFog;
    }

    export class ActorFactoryInteractiveFoliage extends ActorFactoryStaticMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryInteractiveFoliage;

        static Load(InName: string): ActorFactoryInteractiveFoliage;
    }

    export class ActorFactoryLandscape extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryLandscape;

        static Load(InName: string): ActorFactoryLandscape;
    }

    export class ActorFactoryMatineeActor extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryMatineeActor;

        static Load(InName: string): ActorFactoryMatineeActor;
    }

    export class ActorFactoryMovieScene extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryMovieScene;

        static Load(InName: string): ActorFactoryMovieScene;
    }

    export class ActorFactoryNiagara extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryNiagara;

        static Load(InName: string): ActorFactoryNiagara;
    }

    export class ActorFactoryNote extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryNote;

        static Load(InName: string): ActorFactoryNote;
    }

    export class ActorFactoryPawn extends ActorFactoryEmptyActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryPawn;

        static Load(InName: string): ActorFactoryPawn;
    }

    export class ActorFactoryPhysicsAsset extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryPhysicsAsset;

        static Load(InName: string): ActorFactoryPhysicsAsset;
    }

    export class ActorFactoryPlanarReflection extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlanarReflection;

        static Load(InName: string): ActorFactoryPlanarReflection;
    }

    export class ActorFactoryPlaneReflectionCapture extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlaneReflectionCapture;

        static Load(InName: string): ActorFactoryPlaneReflectionCapture;
    }

    export class ActorFactoryPlayerStart extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlayerStart;

        static Load(InName: string): ActorFactoryPlayerStart;
    }

    export class ActorFactoryPointLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryPointLight;

        static Load(InName: string): ActorFactoryPointLight;
    }

    export class ActorFactoryProceduralFoliage extends ActorFactoryBoxVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryProceduralFoliage;

        static Load(InName: string): ActorFactoryProceduralFoliage;
    }

    export class ActorFactoryRectLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryRectLight;

        static Load(InName: string): ActorFactoryRectLight;
    }

    export class ActorFactoryRuntimeVirtualTextureVolume extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryRuntimeVirtualTextureVolume;

        static Load(InName: string): ActorFactoryRuntimeVirtualTextureVolume;
    }

    export class ActorFactorySkyAtmosphere extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactorySkyAtmosphere;

        static Load(InName: string): ActorFactorySkyAtmosphere;
    }

    export class ActorFactorySkyLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactorySkyLight;

        static Load(InName: string): ActorFactorySkyLight;
    }

    export class ActorFactorySphereReflectionCapture extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactorySphereReflectionCapture;

        static Load(InName: string): ActorFactorySphereReflectionCapture;
    }

    export class ActorFactorySphereVolume extends ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactorySphereVolume;

        static Load(InName: string): ActorFactorySphereVolume;
    }

    export class ActorFactorySpotLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactorySpotLight;

        static Load(InName: string): ActorFactorySpotLight;
    }

    export class ActorFactoryTargetPoint extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryTargetPoint;

        static Load(InName: string): ActorFactoryTargetPoint;
    }

    export class ActorFactoryTextRender extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryTextRender;

        static Load(InName: string): ActorFactoryTextRender;
    }

    export class ActorFactoryTriggerBox extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerBox;

        static Load(InName: string): ActorFactoryTriggerBox;
    }

    export class ActorFactoryTriggerCapsule extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerCapsule;

        static Load(InName: string): ActorFactoryTriggerCapsule;
    }

    export class ActorFactoryTriggerSphere extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerSphere;

        static Load(InName: string): ActorFactoryTriggerSphere;
    }

    export class ActorFactoryVectorFieldVolume extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryVectorFieldVolume;

        static Load(InName: string): ActorFactoryVectorFieldVolume;
    }

    export class ActorFactoryVolumetricCloud extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorFactoryVolumetricCloud;

        static Load(InName: string): ActorFactoryVolumetricCloud;
    }

    export class ActorGroupingUtils extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddSelectedToGroup(): void;

        GroupActors(ActorsToGroup: TArray<Actor>): void;

        GroupSelected(): void;

        LockSelectedGroups(): void;

        RemoveSelectedFromGroup(): void;

        UngroupActors(ActorsToUngroup: TArray<Actor>): void;

        UngroupSelected(): void;

        UnlockSelectedGroups(): void;

        static Get(): ActorGroupingUtils;

        static IsGroupingActive(): boolean;

        static SetGroupingActive(bInGroupingActive: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorGroupingUtils;

        static Load(InName: string): ActorGroupingUtils;
    }

    export class SequenceRecordingBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequenceRecordingBase;

        static Load(InName: string): SequenceRecordingBase;
    }

    export class ActorRecordingSettings {
        constructor();
        constructor(Settings: TArray<Object>);

        Settings: TArray<Object>;

        static StaticClass(): Class;
    }

    export class LevelSequenceObjectReferenceMap {
        constructor();

        static StaticClass(): Class;
    }

    export class LevelSequenceBindingReference {
        constructor();
        constructor(PackageName: string, ExternalObjectPath: SoftObjectPath, ObjectPath: string);

        PackageName: string;
        ExternalObjectPath: SoftObjectPath;
        ObjectPath: string;

        static StaticClass(): Class;
    }

    export class LevelSequenceBindingReferenceArray {
        constructor();
        constructor(References: TArray<LevelSequenceBindingReference>);

        References: TArray<LevelSequenceBindingReference>;

        static StaticClass(): Class;
    }

    export class LevelSequenceBindingReferences {
        constructor();
        constructor(BindingIdToReferences: TMap<Guid, LevelSequenceBindingReferenceArray>, AnimSequenceInstances: TSet<Guid>);

        BindingIdToReferences: TMap<Guid, LevelSequenceBindingReferenceArray>;
        AnimSequenceInstances: TSet<Guid>;

        static StaticClass(): Class;
    }

    export class LevelSequenceObject {
        constructor();
        constructor(ObjectOrOwner: TLazyObjectPtr<Object>, ComponentName: string, CachedComponent: TWeakObjectPtr<Object>);

        ObjectOrOwner: TLazyObjectPtr<Object>;
        ComponentName: string;
        CachedComponent: TWeakObjectPtr<Object>;

        static StaticClass(): Class;
    }

    export class LevelSequence extends MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MovieScene: MovieScene;
        ObjectReferences: LevelSequenceObjectReferenceMap;
        BindingReferences: LevelSequenceBindingReferences;
        PossessedObjects: TMap<string, LevelSequenceObject>;
        DirectorBlueprint: Blueprint;
        DirectorClass: Class;
        MetaDataObjects: TArray<Object>;
        AssetUserData: TArray<AssetUserData>;

        CopyMetaData(InMetaData: $Nullable<Object>): Object;

        FindMetaDataByClass(InClass: $Nullable<Class>): Object;

        FindOrAddMetaDataByClass(InClass: $Nullable<Class>): Object;

        RemoveMetaDataByClass(InClass: $Nullable<Class>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequence;

        static Load(InName: string): LevelSequence;
    }

    export class AnimationRecordingSettings {
        constructor();
        constructor(bRecordInWorldSpace: boolean, bRemoveRootAnimation: boolean, bAutoSaveAsset: boolean, SampleRate: number, Length: number, InterpMode: ERichCurveInterpMode, TangentMode: ERichCurveTangentMode, bRecordTransforms: boolean, bRecordCurves: boolean);

        bRecordInWorldSpace: boolean;
        bRemoveRootAnimation: boolean;
        bAutoSaveAsset: boolean;
        SampleRate: number;
        Length: number;
        InterpMode: ERichCurveInterpMode;
        TangentMode: ERichCurveTangentMode;
        bRecordTransforms: boolean;
        bRecordCurves: boolean;

        static StaticClass(): Class;
    }

    export class ActorRecording extends SequenceRecordingBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActorSettings: ActorRecordingSettings;
        bActive: boolean;
        bCreateLevelSequence: boolean;
        TargetLevelSequence: LevelSequence;
        TargetName: string;
        TakeNumber: number;
        bSpecifyTargetAnimation: boolean;
        TargetAnimation: AnimSequence;
        AnimationSettings: AnimationRecordingSettings;
        bRecordToPossessable: boolean;
        ActorToRecord: TSoftObjectPtr<Actor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorRecording;

        static Load(InName: string): ActorRecording;
    }

    export class EditorWorldExtensionActorData {
        constructor();
        constructor(Actor: Actor, bValidForPIE: boolean);

        Actor: Actor;
        bValidForPIE: boolean;

        static StaticClass(): Class;
    }

    export class EditorWorldExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ExtensionActors: TArray<EditorWorldExtensionActorData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorWorldExtension;

        static Load(InName: string): EditorWorldExtension;
    }

    export class ViewportActionKeyInput {
        constructor();
        constructor(ActionType: string, Event: EInputEvent, bIsInputCaptured: boolean);

        ActionType: string;
        Event: EInputEvent;
        bIsInputCaptured: boolean;

        static StaticClass(): Class;
    }

    export enum EHitResultGizmoFilterMode { All, NoGizmos, GizmosOnly, EHitResultGizmoFilterMode_MAX }

    export enum EViewportInteractionDraggingMode {
        Nothing,
        TransformablesWithGizmo,
        TransformablesAtLaserImpact,
        AssistingDrag,
        TransformablesFreely,
        World,
        Interactable,
        Material,
        EViewportInteractionDraggingMode_MAX
    }

    export class ViewportInteractor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        KeyToActionMap: TMap<Key, ViewportActionKeyInput>;
        WorldInteraction: ViewportWorldInteraction;
        OtherInteractor: ViewportInteractor;

        CanCarry(): boolean;

        GetDraggingMode(): EViewportInteractionDraggingMode;

        GetHitResultGizmoFilterMode(): EHitResultGizmoFilterMode;

        GetHoverLocation(): Vector;

        GetLaserPointer(LaserPointerStart: $Ref<Vector>, LaserPointerEnd: $Ref<Vector>, bEvenIfBlocked?: boolean /* = false */, LaserLengthOverride?: number /* = 0.000000 */): boolean;

        GetLastRoomSpaceTransform(): Transform;

        GetLastTransform(): Transform;

        GetOtherInteractor(): ViewportInteractor;

        GetRoomSpaceTransform(): Transform;

        GetTransform(): Transform;

        GetTransformAndForwardVector(OutHandTransform: $Ref<Transform>, OutForwardVector: $Ref<Vector>): boolean;

        GetWorldInteraction(): ViewportWorldInteraction;

        HandleInputAxis_BP(Action: ViewportActionKeyInput, Key: Key, Delta: number, DeltaTime: number, bOutWasHandled: $Ref<boolean>): void;

        HandleInputKey_BP(Action: ViewportActionKeyInput, Key: Key, Event: EInputEvent, bOutWasHandled: $Ref<boolean>): void;

        IsHoveringOverGizmo(): boolean;

        SetCanCarry(bInCanCarry: boolean): void;

        SetDraggingMode(NewDraggingMode: EViewportInteractionDraggingMode): void;

        SetHitResultGizmoFilterMode(newFilter: EHitResultGizmoFilterMode): void;

        Shutdown(): void;

        Tick(DeltaTime: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewportInteractor;

        static Load(InName: string): ViewportInteractor;
    }

    export class GizmoHandle {
        constructor();

        static StaticClass(): Class;
    }

    export class ViewportDragOperation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewportDragOperation;

        static Load(InName: string): ViewportDragOperation;
    }

    export class ViewportDragOperationComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DragOperation: ViewportDragOperation;
        DragOperationSubclass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewportDragOperationComponent;

        static Load(InName: string): ViewportDragOperationComponent;
    }

    export class GizmoHandleGroup extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GizmoMaterial: MaterialInterface;
        TranslucentGizmoMaterial: MaterialInterface;
        Handles: TArray<GizmoHandle>;
        OwningTransformGizmoActor: BaseTransformGizmo;
        DragOperationComponent: ViewportDragOperationComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoHandleGroup;

        static Load(InName: string): GizmoHandleGroup;
    }

    export class BaseTransformGizmo extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SceneComponent: SceneComponent;
        AllHandleGroups: TArray<GizmoHandleGroup>;
        WorldInteraction: ViewportWorldInteraction;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BaseTransformGizmo;

        static Load(InName: string): BaseTransformGizmo;
    }

    export class MouseCursorInteractor extends ViewportInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MouseCursorInteractor;

        static Load(InName: string): MouseCursorInteractor;
    }

    export class ViewportInteractionAssetContainer extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GizmoHandleSelectedSound: SoundBase;
        GizmoHandleDropSound: SoundBase;
        SelectionChangeSound: SoundBase;
        SelectionDropSound: SoundBase;
        SelectionStartDragSound: SoundBase;
        GridSnapSound: SoundBase;
        ActorSnapSound: SoundBase;
        UndoSound: SoundBase;
        RedoSound: SoundBase;
        GridMesh: StaticMesh;
        TranslationHandleMesh: StaticMesh;
        UniformScaleHandleMesh: StaticMesh;
        ScaleHandleMesh: StaticMesh;
        PlaneTranslationHandleMesh: StaticMesh;
        RotationHandleMesh: StaticMesh;
        RotationHandleSelectedMesh: StaticMesh;
        StartRotationIndicatorMesh: StaticMesh;
        CurrentRotationIndicatorMesh: StaticMesh;
        FreeRotationHandleMesh: StaticMesh;
        GridMaterial: MaterialInterface;
        TransformGizmoMaterial: MaterialInterface;
        TranslucentTransformGizmoMaterial: MaterialInterface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewportInteractionAssetContainer;

        static Load(InName: string): ViewportInteractionAssetContainer;
    }

    export class ViewportWorldInteraction extends EditorWorldExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Interactors: TArray<ViewportInteractor>;
        ViewportTransformer: ViewportTransformer;
        TransformGizmoActor: BaseTransformGizmo;
        SnapGridActor: Actor;
        SnapGridMeshComponent: StaticMeshComponent;
        SnapGridMID: MaterialInstanceDynamic;
        DefaultMouseCursorInteractor: MouseCursorInteractor;
        ActorsToExcludeFromHitTest: TArray<TWeakObjectPtr<Actor>>;
        AssetContainer: ViewportInteractionAssetContainer;

        AddActorToExcludeFromHitTests(ActorToExcludeFromHitTests: $Nullable<Actor>): void;

        AddInteractor(Interactor: $Nullable<ViewportInteractor>): void;

        GetHeadTransform(): Transform;

        GetInteractors(): TArray<ViewportInteractor>;

        GetRoomSpaceHeadTransform(): Transform;

        GetRoomTransform(): Transform;

        GetTransformGizmoActor(): BaseTransformGizmo;

        GetWorldScaleFactor(): number;

        RemoveInteractor(Interactor: $Nullable<ViewportInteractor>): void;

        SetHeadTransform(NewHeadTransform: Transform): void;

        SetRoomTransformForNextFrame(NewRoomTransform: Transform): void;

        SetWorldToMetersScale(NewWorldToMetersScale: number, bCompensateRoomWorldScale?: boolean /* = false */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewportWorldInteraction;

        static Load(InName: string): ViewportWorldInteraction;
    }

    export class ViewportTransformer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ViewportWorldInteraction: ViewportWorldInteraction;

        CanAlignToActors(): boolean;

        Init(InitViewportWorldInteraction: $Nullable<ViewportWorldInteraction>): void;

        OnStartDragging(Interactor: $Nullable<ViewportInteractor>): void;

        OnStopDragging(Interactor: $Nullable<ViewportInteractor>): void;

        ShouldCenterTransformGizmoPivot(): boolean;

        Shutdown(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewportTransformer;

        static Load(InName: string): ViewportTransformer;
    }

    export class ActorTransformer extends ViewportTransformer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ActorTransformer;

        static Load(InName: string): ActorTransformer;
    }

    export class AdvancedCopyCustomization extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AdvancedCopyCustomization;

        static Load(InName: string): AdvancedCopyCustomization;
    }

    export enum EPathFollowingResult {
        Success,
        Blocked,
        OffPath,
        Aborted,
        Skipped_DEPRECATED,
        Invalid,
        EPathFollowingResult_MAX
    }

    export class AIRequestID {
        constructor();
        constructor(RequestID: number);

        RequestID: number;

        static StaticClass(): Class;
    }

    export class AIAsyncTaskBlueprintProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(MovementResult: EPathFollowingResult) => void>;
        OnFail: $MulticastDelegate<(MovementResult: EPathFollowingResult) => void>;

        OnMoveCompleted(RequestID: AIRequestID, MovementResult: EPathFollowingResult): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIAsyncTaskBlueprintProxy;

        static Load(InName: string): AIAsyncTaskBlueprintProxy;
    }

    export class BTNode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NodeName: string;
        TreeAsset: BehaviorTree;
        ParentNode: BTCompositeNode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTNode;

        static Load(InName: string): BTNode;
    }

    export class BTAuxiliaryNode extends BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTAuxiliaryNode;

        static Load(InName: string): BTAuxiliaryNode;
    }

    export class BTService extends BTAuxiliaryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Interval: number;
        RandomDeviation: number;
        bCallTickOnSearchStart: boolean;
        bRestartTimerOnEachActivation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTService;

        static Load(InName: string): BTService;
    }

    export class BTTaskNode extends BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Services: TArray<BTService>;
        bIgnoreRestartSelf: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTaskNode;

        static Load(InName: string): BTTaskNode;
    }

    export enum EBTFlowAbortMode { None, LowerPriority, Self, Both, EBTFlowAbortMode_MAX }

    export class BTDecorator extends BTAuxiliaryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bInverseCondition: boolean;
        FlowAbortMode: EBTFlowAbortMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator;

        static Load(InName: string): BTDecorator;
    }

    export enum EBTDecoratorLogic { Invalid, Test, And, Or, Not, EBTDecoratorLogic_MAX }

    export class BTDecoratorLogic {
        constructor();
        constructor(Operation: EBTDecoratorLogic, Number: number);

        Operation: EBTDecoratorLogic;
        Number: number;

        static StaticClass(): Class;
    }

    export class BTCompositeChild {
        constructor();
        constructor(ChildComposite: BTCompositeNode, ChildTask: BTTaskNode, Decorators: TArray<BTDecorator>, DecoratorOps: TArray<BTDecoratorLogic>);

        ChildComposite: BTCompositeNode;
        ChildTask: BTTaskNode;
        Decorators: TArray<BTDecorator>;
        DecoratorOps: TArray<BTDecoratorLogic>;

        static StaticClass(): Class;
    }

    export class BTCompositeNode extends BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Children: TArray<BTCompositeChild>;
        Services: TArray<BTService>;
        bApplyDecoratorScope: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTCompositeNode;

        static Load(InName: string): BTCompositeNode;
    }

    export class BlackboardKeyType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType;

        static Load(InName: string): BlackboardKeyType;
    }

    export class BlackboardEntry {
        constructor();
        constructor(EntryName: string, EntryDescription: string, KeyType: BlackboardKeyType, bInstanceSynced: boolean);

        EntryName: string;
        EntryDescription: string;
        KeyType: BlackboardKeyType;
        bInstanceSynced: boolean;

        static StaticClass(): Class;
    }

    export class BlackboardData extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Parent: BlackboardData;
        ParentKeys: TArray<BlackboardEntry>;
        Keys: TArray<BlackboardEntry>;
        bHasSynchronizedKeys: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardData;

        static Load(InName: string): BlackboardData;
    }

    export class BehaviorTree extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootNode: BTCompositeNode;
        BTGraph: EdGraph;
        LastEditedDocuments: TArray<EditedDocumentInfo>;
        BlackboardAsset: BlackboardData;
        RootDecorators: TArray<BTDecorator>;
        RootDecoratorOps: TArray<BTDecoratorLogic>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTree;

        static Load(InName: string): BehaviorTree;
    }

    export enum ENavPathEvent {
        Cleared,
        NewPath,
        UpdatedDueToGoalMoved,
        UpdatedDueToNavigationChanged,
        Invalidated,
        RePathFailed,
        MetaPathUpdate,
        Custom,
        ENavPathEvent_MAX
    }

    export enum ENavigationOptionFlag { Default, Enable, Disable, MAX }

    export class NavigationPath extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PathUpdatedNotifier: $MulticastDelegate<(AffectedPath: $Nullable<NavigationPath>, PathEvent: ENavPathEvent) => void>;
        PathPoints: TArray<Vector>;
        RecalculateOnInvalidation: ENavigationOptionFlag;

        EnableDebugDrawing(bShouldDrawDebugData: boolean, PathColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        EnableRecalculationOnInvalidation(DoRecalculation: ENavigationOptionFlag): void;

        GetDebugString(): string;

        GetPathCost(): number;

        GetPathLength(): number;

        IsPartial(): boolean;

        IsStringPulled(): boolean;

        IsValid(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationPath;

        static Load(InName: string): NavigationPath;
    }

    export enum EPathFollowingAction { Error, NoMove, DirectMove, PartialPath, PathToGoal, EPathFollowingAction_MAX }

    export class PathFollowingComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MovementComp: NavMovementComponent;
        MyNavData: NavigationData;

        GetPathActionType(): EPathFollowingAction;

        GetPathDestination(): Vector;

        OnActorBump(SelfActor: $Nullable<Actor>, OtherActor: $Nullable<Actor>, NormalImpulse: Vector, Hit: HitResult): void;

        OnNavDataRegistered(NavData: $Nullable<NavigationData>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PathFollowingComponent;

        static Load(InName: string): PathFollowingComponent;
    }

    export class AISenseConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DebugColor: Color;
        MaxAge: number;
        bStartsEnabled: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseConfig;

        static Load(InName: string): AISenseConfig;
    }

    export class AIStimulus {
        constructor();
        constructor(Age: number, ExpirationAge: number, Strength: number, StimulusLocation: Vector, ReceiverLocation: Vector, Tag: string, bSuccessfullySensed: boolean);

        Age: number;
        ExpirationAge: number;
        Strength: number;
        StimulusLocation: Vector;
        ReceiverLocation: Vector;
        Tag: string;
        bSuccessfullySensed: boolean;

        static StaticClass(): Class;
    }

    export class ActorPerceptionUpdateInfo {
        constructor();
        constructor(TargetId: number, Target: TWeakObjectPtr<Actor>, Stimulus: AIStimulus);

        TargetId: number;
        Target: TWeakObjectPtr<Actor>;
        Stimulus: AIStimulus;

        static StaticClass(): Class;
    }

    export class ActorPerceptionBlueprintInfo {
        constructor();
        constructor(Target: Actor, LastSensedStimuli: TArray<AIStimulus>, bIsHostile: boolean);

        Target: Actor;
        LastSensedStimuli: TArray<AIStimulus>;
        bIsHostile: boolean;

        static StaticClass(): Class;
    }

    export class AIPerceptionComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SensesConfig: TArray<AISenseConfig>;
        DominantSense: Class;
        AIOwner: AIController;
        OnPerceptionUpdated: $MulticastDelegate<(UpdatedActors: TArray<Actor>) => void>;
        OnTargetPerceptionUpdated: $MulticastDelegate<(Actor: $Nullable<Actor>, Stimulus: AIStimulus) => void>;
        OnTargetPerceptionInfoUpdated: $MulticastDelegate<(UpdateInfo: ActorPerceptionUpdateInfo) => void>;

        ForgetAll(): void;

        GetActorsPerception(Actor: $Nullable<Actor>, Info: $Ref<ActorPerceptionBlueprintInfo>): boolean;

        GetCurrentlyPerceivedActors(SenseToUse: $Nullable<Class>, OutActors: $Ref<TArray<Actor>>): void;

        GetKnownPerceivedActors(SenseToUse: $Nullable<Class>, OutActors: $Ref<TArray<Actor>>): void;

        GetPerceivedActors(SenseToUse: $Nullable<Class>, OutActors: $Ref<TArray<Actor>>): void;

        GetPerceivedHostileActors(OutActors: $Ref<TArray<Actor>>): void;

        GetPerceivedHostileActorsBySense(SenseToUse: $Nullable<Class>, OutActors: $Ref<TArray<Actor>>): void;

        OnOwnerEndPlay(Actor: $Nullable<Actor>, EndPlayReason: EEndPlayReason): void;

        RequestStimuliListenerUpdate(): void;

        SetSenseEnabled(SenseClass: $Nullable<Class>, bEnable: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIPerceptionComponent;

        static Load(InName: string): AIPerceptionComponent;
    }

    export enum EAIRequestPriority { SoftScript, Logic, HardScript, Reaction, Ultimate, MAX }

    export enum EPawnActionResult { NotStarted, InProgress, Success, Failed, Aborted, EPawnActionResult_MAX }

    export class PawnAction extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChildAction: PawnAction;
        ParentAction: PawnAction;
        OwnerComponent: PawnActionsComponent;
        Instigator: Object;
        BrainComp: BrainComponent;
        bAllowNewSameClassInstance: boolean;
        bReplaceActiveSameClassInstance: boolean;
        bShouldPauseMovement: boolean;
        bAlwaysNotifyOnFinished: boolean;

        Finish(WithResult: EPawnActionResult): void;

        GetActionPriority(): EAIRequestPriority;

        static CreateActionInstance(WorldContextObject: $Nullable<Object>, ActionClass: $Nullable<Class>): PawnAction;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnAction;

        static Load(InName: string): PawnAction;
    }

    export class PawnActionStack {
        constructor();
        constructor(TopAction: PawnAction);

        TopAction: PawnAction;

        static StaticClass(): Class;
    }

    export class PawnActionEvent {
        constructor();
        constructor(Action: PawnAction);

        Action: PawnAction;

        static StaticClass(): Class;
    }

    export enum EPawnActionAbortState {
        NeverStarted,
        NotBeingAborted,
        MarkPendingAbort,
        LatentAbortInProgress,
        AbortDone,
        MAX
    }

    export class PawnActionsComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ControlledPawn: Pawn;
        ActionStacks: TArray<PawnActionStack>;
        ActionEvents: TArray<PawnActionEvent>;
        CurrentAction: PawnAction;

        K2_AbortAction(ActionToAbort: $Nullable<PawnAction>): EPawnActionAbortState;

        K2_ForceAbortAction(ActionToAbort: $Nullable<PawnAction>): EPawnActionAbortState;

        K2_PushAction(NewAction: $Nullable<PawnAction>, Priority: EAIRequestPriority, Instigator?: Object /* = None */): boolean;

        static K2_PerformAction(Pawn: $Nullable<Pawn>, Action: $Nullable<PawnAction>, Priority?: EAIRequestPriority /* = HardScript */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnActionsComponent;

        static Load(InName: string): PawnActionsComponent;
    }

    export enum EPathFollowingRequestResult {
        Failed,
        AlreadyAtGoal,
        RequestSuccessful,
        EPathFollowingRequestResult_MAX
    }

    export enum EPathFollowingStatus { Idle, Waiting, Paused, Moving, EPathFollowingStatus_MAX }

    export class AIController extends Controller {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bStartAILogicOnPossess: boolean;
        bStopAILogicOnUnposses: boolean;
        bLOSflag: boolean;
        bSkipExtraLOSChecks: boolean;
        bAllowStrafe: boolean;
        bWantsPlayerState: boolean;
        bSetControlRotationFromPawnOrientation: boolean;
        PathFollowingComponent: PathFollowingComponent;
        BrainComponent: BrainComponent;
        PerceptionComponent: AIPerceptionComponent;
        ActionsComp: PawnActionsComponent;
        Blackboard: BlackboardComponent;
        CachedGameplayTasksComponent: GameplayTasksComponent;
        DefaultNavigationFilterClass: Class;
        ReceiveMoveCompleted: $MulticastDelegate<(RequestID: AIRequestID, Result: EPathFollowingResult) => void>;

        ClaimTaskResource(ResourceClass: $Nullable<Class>): void;

        GetAIPerceptionComponent(): AIPerceptionComponent;

        GetFocalPoint(): Vector;

        GetFocalPointOnActor(Actor: $Nullable<Actor>): Vector;

        GetFocusActor(): Actor;

        GetImmediateMoveDestination(): Vector;

        GetMoveStatus(): EPathFollowingStatus;

        GetPathFollowingComponent(): PathFollowingComponent;

        HasPartialPath(): boolean;

        K2_ClearFocus(): void;

        K2_SetFocalPoint(FP: Vector): void;

        K2_SetFocus(NewFocus: $Nullable<Actor>): void;

        MoveToActor(Goal: $Nullable<Actor>, AcceptanceRadius?: number /* = -1.000000 */, bStopOnOverlap?: boolean /* = true */, bUsePathfinding?: boolean /* = true */, bCanStrafe?: boolean /* = true */, FilterClass?: Class /* = None */, bAllowPartialPath?: boolean /* = true */): EPathFollowingRequestResult;

        MoveToLocation(Dest: Vector, AcceptanceRadius?: number /* = -1.000000 */, bStopOnOverlap?: boolean /* = true */, bUsePathfinding?: boolean /* = true */, bProjectDestinationToNavigation?: boolean /* = false */, bCanStrafe?: boolean /* = true */, FilterClass?: Class /* = None */, bAllowPartialPath?: boolean /* = true */): EPathFollowingRequestResult;

        OnGameplayTaskResourcesClaimed(NewlyClaimed: GameplayResourceSet, FreshlyReleased: GameplayResourceSet): void;

        OnUsingBlackBoard(BlackboardComp: $Nullable<BlackboardComponent>, BlackboardAsset: $Nullable<BlackboardData>): void;

        RunBehaviorTree(BTAsset: $Nullable<BehaviorTree>): boolean;

        SetMoveBlockDetection(bEnable: boolean): void;

        SetPathFollowingComponent(NewPFComponent: $Nullable<PathFollowingComponent>): void;

        UnclaimTaskResource(ResourceClass: $Nullable<Class>): void;

        UseBlackboard(BlackboardAsset: $Nullable<BlackboardData>, BlackboardComponent: $Ref<BlackboardComponent>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIController;

        static Load(InName: string): AIController;
    }

    export class BrainComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlackboardComp: BlackboardComponent;
        AIOwner: AIController;

        IsPaused(): boolean;

        IsRunning(): boolean;

        RestartLogic(): void;

        StartLogic(): void;

        StopLogic(Reason: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrainComponent;

        static Load(InName: string): BrainComponent;
    }

    export class BlackboardComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BrainComp: BrainComponent;
        DefaultBlackboardAsset: BlackboardData;
        BlackboardAsset: BlackboardData;
        KeyInstances: TArray<BlackboardKeyType>;

        ClearValue(KeyName: string): void;

        GetLocationFromEntry(KeyName: string, ResultLocation: $Ref<Vector>): boolean;

        GetRotationFromEntry(KeyName: string, ResultRotation: $Ref<Rotator>): boolean;

        GetValueAsBool(KeyName: string): boolean;

        GetValueAsClass(KeyName: string): Class;

        GetValueAsEnum(KeyName: string): number;

        GetValueAsFloat(KeyName: string): number;

        GetValueAsInt(KeyName: string): number;

        GetValueAsName(KeyName: string): string;

        GetValueAsObject(KeyName: string): Object;

        GetValueAsRotator(KeyName: string): Rotator;

        GetValueAsString(KeyName: string): string;

        GetValueAsVector(KeyName: string): Vector;

        IsVectorValueSet(KeyName: string): boolean;

        SetValueAsBool(KeyName: string, BoolValue: boolean): void;

        SetValueAsClass(KeyName: string, ClassValue: $Nullable<Class>): void;

        SetValueAsEnum(KeyName: string, EnumValue: number): void;

        SetValueAsFloat(KeyName: string, FloatValue: number): void;

        SetValueAsInt(KeyName: string, IntValue: number): void;

        SetValueAsName(KeyName: string, NameValue: string): void;

        SetValueAsObject(KeyName: string, ObjectValue: $Nullable<Object>): void;

        SetValueAsRotator(KeyName: string, VectorValue: Rotator): void;

        SetValueAsString(KeyName: string, StringValue: string): void;

        SetValueAsVector(KeyName: string, VectorValue: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardComponent;

        static Load(InName: string): BlackboardComponent;
    }

    export class AIBlueprintHelperLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateMoveToProxyObject(WorldContextObject: $Nullable<Object>, Pawn: $Nullable<Pawn>, Destination: Vector, TargetActor?: Actor /* = None */, AcceptanceRadius?: number /* = 5.000000 */, bStopOnOverlap?: boolean /* = false */): AIAsyncTaskBlueprintProxy;

        static GetAIController(ControlledActor: $Nullable<Actor>): AIController;

        static GetBlackboard(Target: $Nullable<Actor>): BlackboardComponent;

        static GetCurrentPath(Controller: $Nullable<Controller>): NavigationPath;

        static GetCurrentPathIndex(Controller: $Nullable<Controller>): number;

        static GetCurrentPathPoints(Controller: $Nullable<Controller>): TArray<Vector>;

        static GetNextNavLinkIndex(Controller: $Nullable<Controller>): number;

        static IsValidAIDirection(DirectionVector: Vector): boolean;

        static IsValidAILocation(Location: Vector): boolean;

        static IsValidAIRotation(Rotation: Rotator): boolean;

        static LockAIResourcesWithAnimation(AnimInstance: $Nullable<AnimInstance>, bLockMovement: boolean, LockAILogic: boolean): void;

        static SendAIMessage(Target: $Nullable<Pawn>, Message: string, MessageSource: $Nullable<Object>, bSuccess?: boolean /* = true */): void;

        static SimpleMoveToActor(Controller: $Nullable<Controller>, Goal: $Nullable<Actor>): void;

        static SimpleMoveToLocation(Controller: $Nullable<Controller>, Goal: Vector): void;

        static SpawnAIFromClass(WorldContextObject: $Nullable<Object>, PawnClass: $Nullable<Class>, BehaviorTree: $Nullable<BehaviorTree>, Location: Vector, Rotation?: Rotator /* =  */, bNoCollisionFail?: boolean /* = false */, Owner?: Actor /* = None */): Pawn;

        static UnlockAIResourcesWithAnimation(AnimInstance: $Nullable<AnimInstance>, bUnlockMovement: boolean, UnlockAILogic: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIBlueprintHelperLibrary;

        static Load(InName: string): AIBlueprintHelperLibrary;
    }

    export class AIDataProvider extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIDataProvider;

        static Load(InName: string): AIDataProvider;
    }

    export class AIDataProvider_QueryParams extends AIDataProvider {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParamName: string;
        FloatValue: number;
        IntValue: number;
        BoolValue: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIDataProvider_QueryParams;

        static Load(InName: string): AIDataProvider_QueryParams;
    }

    export class AIDataProvider_Random extends AIDataProvider_QueryParams {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: number;
        Max: number;
        bInteger: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIDataProvider_Random;

        static Load(InName: string): AIDataProvider_Random;
    }

    export class AIGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GraphVersion: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIGraph;

        static Load(InName: string): AIGraph;
    }

    export class GraphNodeClassData {
        constructor();
        constructor(AssetName: string, GeneratedClassPackage: string, ClassName: string, Category: string);

        AssetName: string;
        GeneratedClassPackage: string;
        ClassName: string;
        Category: string;

        static StaticClass(): Class;
    }

    export class AIGraphNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ClassData: GraphNodeClassData;
        NodeInstance: Object;
        ParentNode: AIGraphNode;
        SubNodes: TArray<AIGraphNode>;
        CopySubNodeIndex: number;
        bIsReadOnly: boolean;
        bIsSubNode: boolean;
        ErrorMessage: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIGraphNode;

        static Load(InName: string): AIGraphNode;
    }

    export class EdGraphSchema extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphSchema;

        static Load(InName: string): EdGraphSchema;
    }

    export class AIGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIGraphSchema;

        static Load(InName: string): AIGraphSchema;
    }

    export class AIHotSpotManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIHotSpotManager;

        static Load(InName: string): AIHotSpotManager;
    }

    export enum EFilterInterpolationType { BSIT_Average, BSIT_Linear, BSIT_Cubic, BSIT_MAX }

    export class InterpolationParameter {
        constructor();
        constructor(InterpolationTime: number, InterpolationType: EFilterInterpolationType);

        InterpolationTime: number;
        InterpolationType: EFilterInterpolationType;

        static StaticClass(): Class;
    }

    export enum ENotifyTriggerMode { AllAnimations, HighestWeightedAnimation, None, ENotifyTriggerMode_MAX }

    export class PerBoneInterpolation {
        constructor();
        constructor(BoneReference: BoneReference, InterpolationSpeedPerSec: number);

        BoneReference: BoneReference;
        InterpolationSpeedPerSec: number;

        static StaticClass(): Class;
    }

    export class BlendSample {
        constructor();
        constructor(Animation: AnimSequence, SampleValue: Vector, RateScale: number, bSnapToGrid: boolean, bIsValid: boolean);

        Animation: AnimSequence;
        SampleValue: Vector;
        RateScale: number;
        bSnapToGrid: boolean;
        bIsValid: boolean;

        static StaticClass(): Class;
    }

    export class EditorElement {
        constructor();
        constructor(Indices: FixSizeArray<number>, Weights: FixSizeArray<number>);

        Indices: FixSizeArray<number>;
        Weights: FixSizeArray<number>;

        static StaticClass(): Class;
    }

    export class BlendParameter {
        constructor();
        constructor(DisplayName: string, Min: number, Max: number, GridNum: number);

        DisplayName: string;
        Min: number;
        Max: number;
        GridNum: number;

        static StaticClass(): Class;
    }

    export class BlendSpaceBase extends AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bRotationBlendInMeshSpace: boolean;
        PreviewBasePose: AnimSequence;
        AnimLength: number;
        InterpolationParam: FixSizeArray<InterpolationParameter>;
        TargetWeightInterpolationSpeedPerSec: number;
        NotifyTriggerMode: ENotifyTriggerMode;
        PerBoneBlend: TArray<PerBoneInterpolation>;
        SampleIndexWithMarkers: number;
        SampleData: TArray<BlendSample>;
        GridSamples: TArray<EditorElement>;
        BlendParameters: FixSizeArray<BlendParameter>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlendSpaceBase;

        static Load(InName: string): BlendSpaceBase;
    }

    export enum EBlendSpaceAxis { BSA_None, BSA_X, BSA_Y, BSA_Max, BSA_MAX }

    export class BlendSpace extends BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisToScaleAnimation: EBlendSpaceAxis;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlendSpace;

        static Load(InName: string): BlendSpace;
    }

    export class AimOffsetBlendSpace extends BlendSpace {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpace;

        static Load(InName: string): AimOffsetBlendSpace;
    }

    export class BlendSpace1D extends BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDisplayEditorVertically: boolean;
        bScaleAnimation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlendSpace1D;

        static Load(InName: string): BlendSpace1D;
    }

    export class AimOffsetBlendSpace1D extends BlendSpace1D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpace1D;

        static Load(InName: string): AimOffsetBlendSpace1D;
    }

    export class AutomatedAssetImportData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GroupName: string;
        Filenames: TArray<string>;
        DestinationPath: string;
        FactoryName: string;
        bReplaceExisting: boolean;
        bSkipReadOnly: boolean;
        Factory: Factory;
        LevelToLoad: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutomatedAssetImportData;

        static Load(InName: string): AutomatedAssetImportData;
    }

    export class AssetImportTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Filename: string;
        DestinationPath: string;
        DestinationName: string;
        bReplaceExisting: boolean;
        bReplaceExistingSettings: boolean;
        bAutomated: boolean;
        bSave: boolean;
        Factory: Factory;
        Options: Object;
        ImportedObjectPaths: TArray<string>;
        Result: TArray<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetImportTask;

        static Load(InName: string): AssetImportTask;
    }

    export class Factory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCreateNew: boolean;
        SupportedClass: Class;
        ContextClass: Class;
        Formats: TArray<string>;
        bEditAfterNew: boolean;
        bEditorImport: boolean;
        bText: boolean;
        ImportPriority: number;
        AutomatedImportData: AutomatedAssetImportData;
        AssetImportTask: AssetImportTask;
        OverwriteYesOrNoToAllState: number;

        ScriptFactoryCanImport(Filename: string): boolean;

        ScriptFactoryCreateFile(InTask: $Nullable<AssetImportTask>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Factory;

        static Load(InName: string): Factory;
    }

    export class BlendSpaceFactory1D extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlendSpaceFactory1D;

        static Load(InName: string): BlendSpaceFactory1D;
    }

    export class AimOffsetBlendSpaceFactory1D extends BlendSpaceFactory1D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpaceFactory1D;

        static Load(InName: string): AimOffsetBlendSpaceFactory1D;
    }

    export class BlendSpaceFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlendSpaceFactoryNew;

        static Load(InName: string): BlendSpaceFactoryNew;
    }

    export class AimOffsetBlendSpaceFactoryNew extends BlendSpaceFactoryNew {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpaceFactoryNew;

        static Load(InName: string): AimOffsetBlendSpaceFactoryNew;
    }

    export class AIPerceptionListenerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIPerceptionListenerInterface;

        static Load(InName: string): AIPerceptionListenerInterface;
    }

    export class AIPerceptionStimuliSourceComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoRegisterAsSource: boolean;
        RegisterAsSourceForSenses: TArray<Class>;

        RegisterForSense(SenseClass: $Nullable<Class>): void;

        RegisterWithPerceptionSystem(): void;

        UnregisterFromPerceptionSystem(): void;

        UnregisterFromSense(SenseClass: $Nullable<Class>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIPerceptionStimuliSourceComponent;

        static Load(InName: string): AIPerceptionStimuliSourceComponent;
    }

    export class BehaviorTreeTemplateInfo {
        constructor();
        constructor(Asset: BehaviorTree, Template: BTCompositeNode);

        Asset: BehaviorTree;
        Template: BTCompositeNode;

        static StaticClass(): Class;
    }

    export class BehaviorTreeComponent extends BrainComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NodeInstances: TArray<BTNode>;
        DefaultBehaviorTreeAsset: BehaviorTree;

        AddCooldownTagDuration(CooldownTag: GameplayTag, CooldownDuration: number, bAddToExistingDuration: boolean): void;

        GetTagCooldownEndTime(CooldownTag: GameplayTag): number;

        SetDynamicSubtree(InjectTag: GameplayTag, BehaviorAsset: $Nullable<BehaviorTree>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeComponent;

        static Load(InName: string): BehaviorTreeComponent;
    }

    export class BehaviorTreeManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxDebuggerSteps: number;
        LoadedTemplates: TArray<BehaviorTreeTemplateInfo>;
        ActiveComponents: TArray<BehaviorTreeComponent>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeManager;

        static Load(InName: string): BehaviorTreeManager;
    }

    export class EnvQueryNode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VerNum: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryNode;

        static Load(InName: string): EnvQueryNode;
    }

    export class EnvQueryGenerator extends EnvQueryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OptionName: string;
        ItemType: Class;
        bAutoSortTests: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator;

        static Load(InName: string): EnvQueryGenerator;
    }

    export enum EEnvTestPurpose { Filter, Score, FilterAndScore, EEnvTestPurpose_MAX }

    export enum EEnvTestFilterOperator { AllPass, AnyPass, EEnvTestFilterOperator_MAX }

    export enum EEnvTestScoreOperator { AverageScore, MinScore, MaxScore, Multiply, EEnvTestScoreOperator_MAX }

    export enum EEnvTestFilterType { Minimum, Maximum, Range, Match, EEnvTestFilterType_MAX }

    export class AIDataProviderValue {
        constructor();
        constructor(DataBinding: AIDataProvider, DataField: string);

        DataBinding: AIDataProvider;
        DataField: string;

        static StaticClass(): Class;
    }

    export class AIDataProviderTypedValue extends AIDataProviderValue {
        constructor();
        constructor(PropertyType: Class);

        PropertyType: Class;

        static StaticClass(): Class;
    }

    export class AIDataProviderBoolValue extends AIDataProviderTypedValue {
        constructor();
        constructor(DefaultValue: boolean);

        DefaultValue: boolean;

        static StaticClass(): Class;
    }

    export class AIDataProviderFloatValue extends AIDataProviderTypedValue {
        constructor();
        constructor(DefaultValue: number);

        DefaultValue: number;

        static StaticClass(): Class;
    }

    export enum EEnvTestScoreEquation { Linear, Square, InverseLinear, SquareRoot, Constant, EEnvTestScoreEquation_MAX }

    export enum EEnvQueryTestClamping { None, SpecifiedValue, FilterThreshold, EEnvQueryTestClamping_MAX }

    export enum EEQSNormalizationType { Absolute, RelativeToScores, EEQSNormalizationType_MAX }

    export class EnvQueryTest extends EnvQueryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestOrder: number;
        TestPurpose: EEnvTestPurpose;
        TestComment: string;
        MultipleContextFilterOp: EEnvTestFilterOperator;
        MultipleContextScoreOp: EEnvTestScoreOperator;
        FilterType: EEnvTestFilterType;
        BoolValue: AIDataProviderBoolValue;
        FloatValueMin: AIDataProviderFloatValue;
        FloatValueMax: AIDataProviderFloatValue;
        ScoringEquation: EEnvTestScoreEquation;
        ClampMinType: EEnvQueryTestClamping;
        ClampMaxType: EEnvQueryTestClamping;
        NormalizationType: EEQSNormalizationType;
        ScoreClampMin: AIDataProviderFloatValue;
        ScoreClampMax: AIDataProviderFloatValue;
        ScoringFactor: AIDataProviderFloatValue;
        ReferenceValue: AIDataProviderFloatValue;
        bDefineReferenceValue: boolean;
        bWorkOnFloatValues: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest;

        static Load(InName: string): EnvQueryTest;
    }

    export class EnvQueryOption extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Generator: EnvQueryGenerator;
        Tests: TArray<EnvQueryTest>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryOption;

        static Load(InName: string): EnvQueryOption;
    }

    export class EnvQuery extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EdGraph: EdGraph;
        QueryName: string;
        Options: TArray<EnvQueryOption>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQuery;

        static Load(InName: string): EnvQuery;
    }

    export class EnvQueryInstanceCache {
        constructor();
        constructor(Template: EnvQuery);

        Template: EnvQuery;

        static StaticClass(): Class;
    }

    export class EnvQueryContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryContext;

        static Load(InName: string): EnvQueryContext;
    }

    export enum EEnvQueryStatus { Processing, Success, Failed, Aborted, OwnerLost, MissingParam, EEnvQueryStatus_MAX }

    export class EnvQueryInstanceBlueprintWrapper extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QueryID: number;
        ItemType: Class;
        OptionIndex: number;
        OnQueryFinishedEvent: $MulticastDelegate<(QueryInstance: $Nullable<EnvQueryInstanceBlueprintWrapper>, QueryStatus: EEnvQueryStatus) => void>;

        EQSQueryDoneSignature__DelegateSignature(QueryInstance: $Nullable<EnvQueryInstanceBlueprintWrapper>, QueryStatus: EEnvQueryStatus): void;

        GetItemScore(ItemIndex: number): number;

        GetQueryResultsAsActors(ResultActors: $Ref<TArray<Actor>>): boolean;

        GetQueryResultsAsLocations(ResultLocations: $Ref<TArray<Vector>>): boolean;

        GetResultsAsActors(): TArray<Actor>;

        GetResultsAsLocations(): TArray<Vector>;

        SetNamedParam(ParamName: string, Value: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryInstanceBlueprintWrapper;

        static Load(InName: string): EnvQueryInstanceBlueprintWrapper;
    }

    export enum EEnvQueryRunMode { SingleResult, RandomBest5Pct, RandomBest25Pct, AllMatching, EEnvQueryRunMode_MAX }

    export class EnvQueryManager extends AISubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InstanceCache: TArray<EnvQueryInstanceCache>;
        LocalContexts: TArray<EnvQueryContext>;
        GCShieldedWrappers: TArray<EnvQueryInstanceBlueprintWrapper>;
        MaxAllowedTestingTime: number;
        bTestQueriesUsingBreadth: boolean;
        QueryCountWarningThreshold: number;
        QueryCountWarningInterval: number;

        static RunEQSQuery(WorldContextObject: $Nullable<Object>, QueryTemplate: $Nullable<EnvQuery>, Querier: $Nullable<Object>, RunMode: EEnvQueryRunMode, WrapperClass: $Nullable<Class>): EnvQueryInstanceBlueprintWrapper;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryManager;

        static Load(InName: string): EnvQueryManager;
    }

    export class NavLocalGridManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddLocalNavigationGridForBox(WorldContextObject: $Nullable<Object>, Location: Vector, Extent?: Vector /* = 1.000000,1.000000,1.000000 */, Rotation?: Rotator /* =  */, Radius2D?: number /* = 5 */, Height?: number /* = 100.000000 */, bRebuildGrids?: boolean /* = true */): number;

        static AddLocalNavigationGridForCapsule(WorldContextObject: $Nullable<Object>, Location: Vector, CapsuleRadius: number, CapsuleHalfHeight: number, Radius2D?: number /* = 5 */, Height?: number /* = 100.000000 */, bRebuildGrids?: boolean /* = true */): number;

        static AddLocalNavigationGridForPoint(WorldContextObject: $Nullable<Object>, Location: Vector, Radius2D?: number /* = 5 */, Height?: number /* = 100.000000 */, bRebuildGrids?: boolean /* = true */): number;

        static AddLocalNavigationGridForPoints(WorldContextObject: $Nullable<Object>, Locations: TArray<Vector>, Radius2D?: number /* = 5 */, Height?: number /* = 100.000000 */, bRebuildGrids?: boolean /* = true */): number;

        static FindLocalNavigationGridPath(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, PathPoints: $Ref<TArray<Vector>>): boolean;

        static RemoveLocalNavigationGrid(WorldContextObject: $Nullable<Object>, GridId: number, bRebuildGrids?: boolean /* = true */): void;

        static SetLocalNavigationGridDensity(WorldContextObject: $Nullable<Object>, CellSize: number): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLocalGridManager;

        static Load(InName: string): NavLocalGridManager;
    }

    export class AISystem extends AISystemBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PerceptionSystemClassName: SoftClassPath;
        HotSpotManagerClassName: SoftClassPath;
        AcceptanceRadius: number;
        PathfollowingRegularPathPointAcceptanceRadius: number;
        PathfollowingNavLinkAcceptanceRadius: number;
        bFinishMoveOnGoalOverlap: boolean;
        bAcceptPartialPaths: boolean;
        bAllowStrafing: boolean;
        bEnableBTAITasks: boolean;
        bAllowControllersAsEQSQuerier: boolean;
        bEnableDebuggerPlugin: boolean;
        bForgetStaleActors: boolean;
        bAddBlackboardSelfKey: boolean;
        DefaultSightCollisionChannel: ECollisionChannel;
        BehaviorTreeManager: BehaviorTreeManager;
        EnvironmentQueryManager: EnvQueryManager;
        PerceptionSystem: AIPerceptionSystem;
        AllProxyObjects: TArray<AIAsyncTaskBlueprintProxy>;
        HotSpotManager: AIHotSpotManager;
        NavLocalGrids: NavLocalGridManager;

        AIIgnorePlayers(): void;

        AILoggingVerbose(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISystem;

        static Load(InName: string): AISystem;
    }

    export class AISubsystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AISystem: AISystem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISubsystem;

        static Load(InName: string): AISubsystem;
    }

    export enum EAISenseNotifyType { OnEveryPerception, OnPerceptionChange, EAISenseNotifyType_MAX }

    export class AISense extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultExpirationAge: number;
        NotifyType: EAISenseNotifyType;
        bWantsNewPawnNotification: boolean;
        bAutoRegisterAllPawnsAsSources: boolean;
        PerceptionSystemInstance: AIPerceptionSystem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISense;

        static Load(InName: string): AISense;
    }

    export class AISenseEvent extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseEvent;

        static Load(InName: string): AISenseEvent;
    }

    export class AIPerceptionSystem extends AISubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Senses: TArray<AISense>;
        PerceptionAgingRate: number;

        OnPerceptionStimuliSourceEndPlay(Actor: $Nullable<Actor>, EndPlayReason: EEndPlayReason): void;

        ReportEvent(PerceptionEvent: $Nullable<AISenseEvent>): void;

        static GetSenseClassForStimulus(WorldContextObject: $Nullable<Object>, Stimulus: AIStimulus): Class;

        static RegisterPerceptionStimuliSource(WorldContextObject: $Nullable<Object>, Sense: $Nullable<Class>, Target: $Nullable<Actor>): boolean;

        static ReportPerceptionEvent(WorldContextObject: $Nullable<Object>, PerceptionEvent: $Nullable<AISenseEvent>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIPerceptionSystem;

        static Load(InName: string): AIPerceptionSystem;
    }

    export class GameplayTaskResource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ManualResourceID: number;
        AutoResourceID: number;
        bManuallySetID: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTaskResource;

        static Load(InName: string): GameplayTaskResource;
    }

    export class AIResource_Logic extends GameplayTaskResource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIResource_Logic;

        static Load(InName: string): AIResource_Logic;
    }

    export class AIResource_Movement extends GameplayTaskResource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIResource_Movement;

        static Load(InName: string): AIResource_Movement;
    }

    export class AIResourceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AIResourceInterface;

        static Load(InName: string): AIResourceInterface;
    }

    export class AISense_Blueprint extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ListenerDataType: Class;
        ListenerContainer: TArray<AIPerceptionComponent>;
        UnprocessedEvents: TArray<AISenseEvent>;

        GetAllListenerActors(ListenerActors: $Ref<TArray<Actor>>): void;

        GetAllListenerComponents(ListenerComponents: $Ref<TArray<AIPerceptionComponent>>): void;

        K2_OnNewPawn(NewPawn: $Nullable<Pawn>): void;

        OnListenerRegistered(ActorListener: $Nullable<Actor>, PerceptionComponent: $Nullable<AIPerceptionComponent>): void;

        OnListenerUnregistered(ActorListener: $Nullable<Actor>, PerceptionComponent: $Nullable<AIPerceptionComponent>): void;

        OnListenerUpdated(ActorListener: $Nullable<Actor>, PerceptionComponent: $Nullable<AIPerceptionComponent>): void;

        OnUpdate(EventsToProcess: TArray<AISenseEvent>): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISense_Blueprint;

        static Load(InName: string): AISense_Blueprint;
    }

    export class AIDamageEvent {
        constructor();
        constructor(Amount: number, Location: Vector, HitLocation: Vector, DamagedActor: Actor, Instigator: Actor);

        Amount: number;
        Location: Vector;
        HitLocation: Vector;
        DamagedActor: Actor;
        Instigator: Actor;

        static StaticClass(): Class;
    }

    export class AISense_Damage extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RegisteredEvents: TArray<AIDamageEvent>;

        static ReportDamageEvent(WorldContextObject: $Nullable<Object>, DamagedActor: $Nullable<Actor>, Instigator: $Nullable<Actor>, DamageAmount: number, EventLocation: Vector, HitLocation: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISense_Damage;

        static Load(InName: string): AISense_Damage;
    }

    export class AINoiseEvent {
        constructor();
        constructor(NoiseLocation: Vector, Loudness: number, MaxRange: number, Instigator: Actor, Tag: string);

        NoiseLocation: Vector;
        Loudness: number;
        MaxRange: number;
        Instigator: Actor;
        Tag: string;

        static StaticClass(): Class;
    }

    export class AISense_Hearing extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NoiseEvents: TArray<AINoiseEvent>;
        SpeedOfSoundSq: number;

        static ReportNoiseEvent(WorldContextObject: $Nullable<Object>, NoiseLocation: Vector, Loudness?: number /* = 1.000000 */, Instigator?: Actor /* = None */, MaxRange?: number /* = 0.000000 */, Tag?: string /* = "None" */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISense_Hearing;

        static Load(InName: string): AISense_Hearing;
    }

    export class AIPredictionEvent {
        constructor();
        constructor(Requestor: Actor, PredictedActor: Actor);

        Requestor: Actor;
        PredictedActor: Actor;

        static StaticClass(): Class;
    }

    export class AISense_Prediction extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RegisteredEvents: TArray<AIPredictionEvent>;

        static RequestControllerPredictionEvent(Requestor: $Nullable<AIController>, PredictedActor: $Nullable<Actor>, PredictionTime: number): void;

        static RequestPawnPredictionEvent(Requestor: $Nullable<Pawn>, PredictedActor: $Nullable<Actor>, PredictionTime: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISense_Prediction;

        static Load(InName: string): AISense_Prediction;
    }

    export class AISense_Sight extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxTracesPerTick: number;
        MinQueriesPerTimeSliceCheck: number;
        MaxTimeSlicePerTick: number;
        HighImportanceQueryDistanceThreshold: number;
        MaxQueryImportance: number;
        SightLimitQueryImportance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISense_Sight;

        static Load(InName: string): AISense_Sight;
    }

    export class AITeamStimulusEvent {
        constructor();
        constructor(Broadcaster: Actor, Enemy: Actor);

        Broadcaster: Actor;
        Enemy: Actor;

        static StaticClass(): Class;
    }

    export class AISense_Team extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RegisteredEvents: TArray<AITeamStimulusEvent>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISense_Team;

        static Load(InName: string): AISense_Team;
    }

    export class AITouchEvent {
        constructor();
        constructor(TouchReceiver: Actor, OtherActor: Actor);

        TouchReceiver: Actor;
        OtherActor: Actor;

        static StaticClass(): Class;
    }

    export class AISense_Touch extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RegisteredEvents: TArray<AITouchEvent>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISense_Touch;

        static Load(InName: string): AISense_Touch;
    }

    export enum EUserDefinedStructureStatus { UDSS_UpToDate, UDSS_Dirty, UDSS_Error, UDSS_Duplicate, UDSS_MAX }

    export class UserDefinedStruct extends ScriptStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PrimaryStruct: TWeakObjectPtr<UserDefinedStruct>;
        ErrorMessage: string;
        EditorData: Object;
        Status: EUserDefinedStructureStatus;
        Guid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserDefinedStruct;

        static Load(InName: string): UserDefinedStruct;
    }

    export class AISenseBlueprintListener extends UserDefinedStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseBlueprintListener;

        static Load(InName: string): AISenseBlueprintListener;
    }

    export class AISenseConfig_Blueprint extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Implementation: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Blueprint;

        static Load(InName: string): AISenseConfig_Blueprint;
    }

    export class AISenseConfig_Damage extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Implementation: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Damage;

        static Load(InName: string): AISenseConfig_Damage;
    }

    export class AISenseAffiliationFilter {
        constructor();
        constructor(bDetectEnemies: boolean, bDetectNeutrals: boolean, bDetectFriendlies: boolean);

        bDetectEnemies: boolean;
        bDetectNeutrals: boolean;
        bDetectFriendlies: boolean;

        static StaticClass(): Class;
    }

    export class AISenseConfig_Hearing extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Implementation: Class;
        HearingRange: number;
        LoSHearingRange: number;
        bUseLoSHearing: boolean;
        DetectionByAffiliation: AISenseAffiliationFilter;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Hearing;

        static Load(InName: string): AISenseConfig_Hearing;
    }

    export class AISenseConfig_Prediction extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Prediction;

        static Load(InName: string): AISenseConfig_Prediction;
    }

    export class AISenseConfig_Sight extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Implementation: Class;
        SightRadius: number;
        LoseSightRadius: number;
        PeripheralVisionAngleDegrees: number;
        DetectionByAffiliation: AISenseAffiliationFilter;
        AutoSuccessRangeFromLastSeenLocation: number;
        PointOfViewBackwardOffset: number;
        NearClippingRadius: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Sight;

        static Load(InName: string): AISenseConfig_Sight;
    }

    export class AISenseConfig_Team extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Team;

        static Load(InName: string): AISenseConfig_Team;
    }

    export class AISenseConfig_Touch extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Touch;

        static Load(InName: string): AISenseConfig_Touch;
    }

    export class AISenseEvent_Damage extends AISenseEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Event: AIDamageEvent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseEvent_Damage;

        static Load(InName: string): AISenseEvent_Damage;
    }

    export class AISenseEvent_Hearing extends AISenseEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Event: AINoiseEvent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISenseEvent_Hearing;

        static Load(InName: string): AISenseEvent_Hearing;
    }

    export class AISightTargetInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AISightTargetInterface;

        static Load(InName: string): AISightTargetInterface;
    }

    export class AITask extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwnerController: AIController;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AITask;

        static Load(InName: string): AITask;
    }

    export class AITask_LockLogic extends AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AITask_LockLogic;

        static Load(InName: string): AITask_LockLogic;
    }

    export class AIMoveRequest {
        constructor();
        constructor(GoalActor: Actor);

        GoalActor: Actor;

        static StaticClass(): Class;
    }

    export enum EAIOptionFlag { Default, Enable, Disable, MAX }

    export class AITask_MoveTo extends AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnRequestFailed: $MulticastDelegate<() => void>;
        OnMoveFinished: $MulticastDelegate<(Result: EPathFollowingResult, AIController: $Nullable<AIController>) => void>;
        MoveRequest: AIMoveRequest;

        static AIMoveTo(Controller: $Nullable<AIController>, GoalLocation: Vector, GoalActor?: Actor /* = None */, AcceptanceRadius?: number /* = -1.000000 */, StopOnOverlap?: EAIOptionFlag /* = Default */, AcceptPartialPath?: EAIOptionFlag /* = Default */, bUsePathfinding?: boolean /* = true */, bLockAILogic?: boolean /* = true */, bUseContinuosGoalTracking?: boolean /* = false */, ProjectGoalOnNavigation?: EAIOptionFlag /* = Default */): AITask_MoveTo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AITask_MoveTo;

        static Load(InName: string): AITask_MoveTo;
    }

    export class AITask_RunEQS extends AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static RunEQS(Controller: $Nullable<AIController>, QueryTemplate: $Nullable<EnvQuery>): AITask_RunEQS;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AITask_RunEQS;

        static Load(InName: string): AITask_RunEQS;
    }

    export class AudioComponentParam {
        constructor();
        constructor(ParamName: string, FloatParam: number, BoolParam: boolean, IntParam: number, SoundWaveParam: SoundWave);

        ParamName: string;
        FloatParam: number;
        BoolParam: boolean;
        IntParam: number;
        SoundWaveParam: SoundWave;

        static StaticClass(): Class;
    }

    export enum EAudioComponentPlayState {
        Playing,
        Stopped,
        Paused,
        FadingIn,
        FadingOut,
        Count,
        EAudioComponentPlayState_MAX
    }

    export enum EQuartzCommandDelegateSubType {
        CommandOnFailedToQueue,
        CommandOnQueued,
        CommandOnCanceled,
        CommandOnAboutToStart,
        CommandOnStarted,
        Count,
        EQuartzCommandDelegateSubType_MAX
    }

    export enum EQuartzCommandQuantization {
        Bar,
        Beat,
        ThirtySecondNote,
        SixteenthNote,
        EighthNote,
        QuarterNote,
        HalfNote,
        WholeNote,
        DottedSixteenthNote,
        DottedEighthNote,
        DottedQuarterNote,
        DottedHalfNote,
        DottedWholeNote,
        SixteenthNoteTriplet,
        EighthNoteTriplet,
        QuarterNoteTriplet,
        HalfNoteTriplet,
        Tick,
        Count,
        EQuartzCommandQuantization_MAX
    }

    export enum EQuarztQuantizationReference {
        BarRelative,
        TransportRelative,
        CurrentTimeRelative,
        Count,
        EQuarztQuantizationReference_MAX
    }

    export class QuartzQuantizationBoundary {
        constructor();
        constructor(Quantization: EQuartzCommandQuantization, Multiplier: number, CountingReferencePoint: EQuarztQuantizationReference);

        Quantization: EQuartzCommandQuantization;
        Multiplier: number;
        CountingReferencePoint: EQuarztQuantizationReference;

        static StaticClass(): Class;
    }

    export class QuartzClockHandle extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetBeatsPerMinute(WorldContextObject: $Nullable<Object>): number;

        GetMillisecondsPerTick(WorldContextObject: $Nullable<Object>): number;

        GetSecondsPerTick(WorldContextObject: $Nullable<Object>): number;

        GetThirtySecondNotesPerMinute(WorldContextObject: $Nullable<Object>): number;

        GetTicksPerSecond(WorldContextObject: $Nullable<Object>): number;

        PauseClock(WorldContextObject: $Nullable<Object>): void;

        ResetTransport(WorldContextObject: $Nullable<Object>, InDelegate: $Delegate<(EventType: EQuartzCommandDelegateSubType, Name: string) => void>): void;

        ResumeClock(WorldContextObject: $Nullable<Object>): void;

        SetBeatsPerMinute(WorldContextObject: $Nullable<Object>, QuantizationBoundary: QuartzQuantizationBoundary, Delegate: $Delegate<(EventType: EQuartzCommandDelegateSubType, Name: string) => void>, BeatsPerMinute?: number /* = 60.000000 */): void;

        SetMillisecondsPerTick(WorldContextObject: $Nullable<Object>, QuantizationBoundary: QuartzQuantizationBoundary, Delegate: $Delegate<(EventType: EQuartzCommandDelegateSubType, Name: string) => void>, MillisecondsPerTick?: number /* = 100.000000 */): void;

        SetSecondsPerTick(WorldContextObject: $Nullable<Object>, QuantizationBoundary: QuartzQuantizationBoundary, Delegate: $Delegate<(EventType: EQuartzCommandDelegateSubType, Name: string) => void>, SecondsPerTick?: number /* = 0.250000 */): void;

        SetThirtySecondNotesPerMinute(WorldContextObject: $Nullable<Object>, QuantizationBoundary: QuartzQuantizationBoundary, Delegate: $Delegate<(EventType: EQuartzCommandDelegateSubType, Name: string) => void>, ThirtySecondsNotesPerMinute?: number /* = 960.000000 */): void;

        SetTicksPerSecond(WorldContextObject: $Nullable<Object>, QuantizationBoundary: QuartzQuantizationBoundary, Delegate: $Delegate<(EventType: EQuartzCommandDelegateSubType, Name: string) => void>, TicksPerSecond?: number /* = 10.000000 */): void;

        SubscribeToAllQuantizationEvents(WorldContextObject: $Nullable<Object>, OnQuantizationEvent: $Delegate<(ClockName: string, QuantizationType: EQuartzCommandQuantization, NumBars: number, Beat: number, BeatFraction: number) => void>): void;

        SubscribeToQuantizationEvent(WorldContextObject: $Nullable<Object>, InQuantizationBoundary: EQuartzCommandQuantization, OnQuantizationEvent: $Delegate<(ClockName: string, QuantizationType: EQuartzCommandQuantization, NumBars: number, Beat: number, BeatFraction: number) => void>): void;

        UnsubscribeFromAllTimeDivisions(WorldContextObject: $Nullable<Object>): void;

        UnsubscribeFromTimeDivision(WorldContextObject: $Nullable<Object>, InQuantizationBoundary: EQuartzCommandQuantization): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): QuartzClockHandle;

        static Load(InName: string): QuartzClockHandle;
    }

    export enum EAudioFaderCurve { Linear, Logarithmic, SCurve, Sin, Count, EAudioFaderCurve_MAX }

    export class SoundWaveSpectralData {
        constructor();
        constructor(FrequencyHz: number, Magnitude: number, NormalizedMagnitude: number);

        FrequencyHz: number;
        Magnitude: number;
        NormalizedMagnitude: number;

        static StaticClass(): Class;
    }

    export class SoundWaveSpectralDataPerSound {
        constructor();
        constructor(SpectralData: TArray<SoundWaveSpectralData>, PlaybackTime: number, SoundWave: SoundWave);

        SpectralData: TArray<SoundWaveSpectralData>;
        PlaybackTime: number;
        SoundWave: SoundWave;

        static StaticClass(): Class;
    }

    export class SoundWaveEnvelopeDataPerSound {
        constructor();
        constructor(Envelope: number, PlaybackTime: number, SoundWave: SoundWave);

        Envelope: number;
        PlaybackTime: number;
        SoundWave: SoundWave;

        static StaticClass(): Class;
    }

    export class AudioComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sound: SoundBase;
        InstanceParameters: TArray<AudioComponentParam>;
        SoundClassOverride: SoundClass;
        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bShouldRemainActiveIfDropped: boolean;
        bAllowSpatialization: boolean;
        bOverrideAttenuation: boolean;
        bOverrideSubtitlePriority: boolean;
        bIsUISound: boolean;
        bEnableLowPassFilter: boolean;
        bOverridePriority: boolean;
        bSuppressSubtitles: boolean;
        bAutoManageAttachment: boolean;
        AudioComponentUserID: string;
        PitchModulationMin: number;
        PitchModulationMax: number;
        VolumeModulationMin: number;
        VolumeModulationMax: number;
        VolumeMultiplier: number;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        Priority: number;
        SubtitlePriority: number;
        SourceEffectChain: SoundEffectSourcePresetChain;
        VolumeWeightedPriorityScale: number;
        HighFrequencyGainMultiplier: number;
        PitchMultiplier: number;
        LowPassFilterFrequency: number;
        AttenuationSettings: SoundAttenuation;
        AttenuationOverrides: SoundAttenuationSettings;
        ConcurrencySettings: SoundConcurrency;
        ConcurrencySet: TSet<SoundConcurrency>;
        AutoAttachLocationRule: EAttachmentRule;
        AutoAttachRotationRule: EAttachmentRule;
        AutoAttachScaleRule: EAttachmentRule;
        ModulationRouting: SoundModulationDefaultRoutingSettings;
        OnAudioPlayStateChanged: $MulticastDelegate<(PlayState: EAudioComponentPlayState) => void>;
        OnAudioVirtualizationChanged: $MulticastDelegate<(bIsVirtualized: boolean) => void>;
        OnAudioFinished: $MulticastDelegate<() => void>;
        OnAudioPlaybackPercent: $MulticastDelegate<(PlayingSoundWave: $Nullable<SoundWave>, PlaybackPercent: number) => void>;
        OnAudioSingleEnvelopeValue: $MulticastDelegate<(PlayingSoundWave: $Nullable<SoundWave>, EnvelopeValue: number) => void>;
        OnAudioMultiEnvelopeValue: $MulticastDelegate<(AverageEnvelopeValue: number, MaxEnvelope: number, NumWaveInstances: number) => void>;
        OnQueueSubtitles: $Delegate<(Subtitles: TArray<SubtitleCue>, CueDuration: number) => void>;
        AutoAttachParent: TWeakObjectPtr<SceneComponent>;
        AutoAttachSocketName: string;

        AdjustAttenuation(InAttenuationSettings: SoundAttenuationSettings): void;

        AdjustVolume(AdjustVolumeDuration: number, AdjustVolumeLevel: number, FadeCurve?: EAudioFaderCurve /* = Linear */): void;

        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<SoundAttenuationSettings>): boolean;

        FadeIn(FadeInDuration: number, FadeVolumeLevel?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, FadeCurve?: EAudioFaderCurve /* = Linear */): void;

        FadeOut(FadeOutDuration: number, FadeVolumeLevel: number, FadeCurve?: EAudioFaderCurve /* = Linear */): void;

        GetCookedEnvelopeData(OutEnvelopeData: $Ref<number>): boolean;

        GetCookedEnvelopeDataForAllPlayingSounds(OutEnvelopeData: $Ref<TArray<SoundWaveEnvelopeDataPerSound>>): boolean;

        GetCookedFFTData(FrequenciesToGet: TArray<number>, OutSoundWaveSpectralData: $Ref<TArray<SoundWaveSpectralData>>): boolean;

        GetCookedFFTDataForAllPlayingSounds(OutSoundWaveSpectralData: $Ref<TArray<SoundWaveSpectralDataPerSound>>): boolean;

        GetPlayState(): EAudioComponentPlayState;

        HasCookedAmplitudeEnvelopeData(): boolean;

        HasCookedFFTData(): boolean;

        IsPlaying(): boolean;

        IsVirtualized(): boolean;

        Play(StartTime?: number /* = 0.000000 */): void;

        PlayQuantized(WorldContextObject: $Nullable<Object>, InClockHandle: $Ref<QuartzClockHandle>, InQuantizationBoundary: $Ref<QuartzQuantizationBoundary>, InDelegate: $Delegate<(EventType: EQuartzCommandDelegateSubType, Name: string) => void>, InStartTime?: number /* = 0.000000 */, InFadeInDuration?: number /* = 0.000000 */, InFadeVolumeLevel?: number /* = 1.000000 */, InFadeCurve?: EAudioFaderCurve /* = Linear */): void;

        SetAudioBusSendPostEffect(AudioBus: $Nullable<AudioBus>, SourceBusSendLevel: number): void;

        SetAudioBusSendPreEffect(AudioBus: $Nullable<AudioBus>, AudioBusSendLevel: number): void;

        SetBoolParameter(InName: string, InBool: boolean): void;

        SetFloatParameter(InName: string, InFloat: number): void;

        SetIntParameter(InName: string, InInt: number): void;

        SetLowPassFilterEnabled(InLowPassFilterEnabled: boolean): void;

        SetLowPassFilterFrequency(InLowPassFilterFrequency: number): void;

        SetPaused(bPause: boolean): void;

        SetPitchMultiplier(NewPitchMultiplier: number): void;

        SetSound(NewSound: $Nullable<SoundBase>): void;

        SetSourceBusSendPostEffect(SoundSourceBus: $Nullable<SoundSourceBus>, SourceBusSendLevel: number): void;

        SetSourceBusSendPreEffect(SoundSourceBus: $Nullable<SoundSourceBus>, SourceBusSendLevel: number): void;

        SetSubmixSend(Submix: $Nullable<SoundSubmixBase>, SendLevel: number): void;

        SetUISound(bInUISound: boolean): void;

        SetVolumeMultiplier(NewVolumeMultiplier: number): void;

        SetWaveParameter(InName: string, InWave: $Nullable<SoundWave>): void;

        Stop(): void;

        StopDelayed(DelayTime: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioComponent;

        static Load(InName: string): AudioComponent;
    }

    export class AmbientSound extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AudioComponent: AudioComponent;

        AdjustVolume(AdjustVolumeDuration: number, AdjustVolumeLevel: number): void;

        FadeIn(FadeInDuration: number, FadeVolumeLevel?: number /* = 1.000000 */): void;

        FadeOut(FadeOutDuration: number, FadeVolumeLevel: number): void;

        Play(StartTime?: number /* = 0.000000 */): void;

        Stop(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AmbientSound;

        static Load(InName: string): AmbientSound;
    }

    export class AmbisonicsEncodingSettings extends SoundfieldEncodingSettingsBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AmbisonicsOrder: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AmbisonicsEncodingSettings;

        static Load(InName: string): AmbisonicsEncodingSettings;
    }

    export class AnalyticsPrivacySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSendUsageData: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnalyticsPrivacySettings;

        static Load(InName: string): AnalyticsPrivacySettings;
    }

    export class AndroidFileMediaSourceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AndroidFileMediaSourceFactory;

        static Load(InName: string): AndroidFileMediaSourceFactory;
    }

    export class AndroidMediaSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CacheableVideoSampleBuffers: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AndroidMediaSettings;

        static Load(InName: string): AndroidMediaSettings;
    }

    export class AndroidPermissionCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPermissionsGrantedDynamicDelegate: $MulticastDelegate<(Permissions: TArray<string>, GrantResults: TArray<boolean>) => void>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AndroidPermissionCallbackProxy;

        static Load(InName: string): AndroidPermissionCallbackProxy;
    }

    export class AndroidPermissionFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AcquirePermissions(permissions: TArray<string>): AndroidPermissionCallbackProxy;

        static CheckPermission(permission: string): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AndroidPermissionFunctionLibrary;

        static Load(InName: string): AndroidPermissionFunctionLibrary;
    }

    export class AnimationBlueprintEditorOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bHideUnrelatedNodes: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationBlueprintEditorOptions;

        static Load(InName: string): AnimationBlueprintEditorOptions;
    }

    export enum ERawCurveTrackTypes { RCT_Float, RCT_Vector, RCT_Transform, RCT_MAX }

    export class AnimationBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddAnimationNotifyEvent(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string, StartTime: number, NotifyClass: $Nullable<Class>): AnimNotify;

        static AddAnimationNotifyEventObject(AnimationSequence: $Nullable<AnimSequence>, StartTime: number, Notify: $Nullable<AnimNotify>, NotifyTrackName: string): void;

        static AddAnimationNotifyStateEvent(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string, StartTime: number, Duration: number, NotifyStateClass: $Nullable<Class>): AnimNotifyState;

        static AddAnimationNotifyStateEventObject(AnimationSequence: $Nullable<AnimSequence>, StartTime: number, Duration: number, NotifyState: $Nullable<AnimNotifyState>, NotifyTrackName: string): void;

        static AddAnimationNotifyTrack(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string, TrackColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        static AddAnimationSyncMarker(AnimationSequence: $Nullable<AnimSequence>, MarkerName: string, Time: number, NotifyTrackName: string): void;

        static AddCurve(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, CurveType?: ERawCurveTrackTypes /* = RCT_Float */, bMetaDataCurve?: boolean /* = false */): void;

        static AddFloatCurveKey(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Time: number, Value: number): void;

        static AddFloatCurveKeys(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Times: TArray<number>, Values: TArray<number>): void;

        static AddMetaData(AnimationSequence: $Nullable<AnimSequence>, MetaDataClass: $Nullable<Class>, MetaDataInstance: AnimMetaData): void;

        static AddMetaDataObject(AnimationSequence: $Nullable<AnimSequence>, MetaDataObject: $Nullable<AnimMetaData>): void;

        static AddTransformationCurveKey(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Time: number, Transform: Transform): void;

        static AddTransformationCurveKeys(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Times: TArray<number>, Transforms: TArray<Transform>): void;

        static AddVectorCurveKey(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Time: number, Vector: Vector): void;

        static AddVectorCurveKeys(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Times: TArray<number>, Vectors: TArray<Vector>): void;

        static AddVirtualBone(AnimationSequence: $Nullable<AnimSequence>, SourceBoneName: string, TargetBoneName: string, VirtualBoneName: $Ref<string>): void;

        static ContainsMetaDataOfClass(AnimationSequence: $Nullable<AnimSequence>, MetaDataClass: $Nullable<Class>): boolean;

        static CopyAnimNotifiesFromSequence(SrcAnimSequence: $Nullable<AnimSequence>, DestAnimSequence: $Nullable<AnimSequence>): void;

        static DoesBoneNameExist(AnimationSequence: $Nullable<AnimSequence>, BoneName: string, bExists: $Ref<boolean>): void;

        static DoesCurveExist(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, CurveType: ERawCurveTrackTypes): boolean;

        static FinalizeBoneAnimation(AnimationSequence: $Nullable<AnimSequence>): void;

        static FindBonePathToRoot(AnimationSequence: $Nullable<AnimSequence>, BoneName: string, BonePath: $Ref<TArray<string>>): void;

        static GetAdditiveAnimationType(AnimationSequence: $Nullable<AnimSequence>, AdditiveAnimationType: $Ref<EAdditiveAnimationType>): void;

        static GetAdditiveBasePoseType(AnimationSequence: $Nullable<AnimSequence>, AdditiveBasePoseType: $Ref<EAdditiveBasePoseType>): void;

        static GetAnimationCurveNames(AnimationSequence: $Nullable<AnimSequence>, CurveType: ERawCurveTrackTypes, CurveNames: $Ref<TArray<string>>): void;

        static GetAnimationInterpolationType(AnimationSequence: $Nullable<AnimSequence>, InterpolationType: $Ref<EAnimInterpolationType>): void;

        static GetAnimationNotifyEventNames(AnimationSequence: $Nullable<AnimSequence>, EventNames: $Ref<TArray<string>>): void;

        static GetAnimationNotifyEvents(AnimationSequence: $Nullable<AnimSequence>, NotifyEvents: $Ref<TArray<AnimNotifyEvent>>): void;

        static GetAnimationNotifyEventsForTrack(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string, Events: $Ref<TArray<AnimNotifyEvent>>): void;

        static GetAnimationNotifyTrackNames(AnimationSequence: $Nullable<AnimSequence>, TrackNames: $Ref<TArray<string>>): void;

        static GetAnimationSyncMarkers(AnimationSequence: $Nullable<AnimSequence>, Markers: $Ref<TArray<AnimSyncMarker>>): void;

        static GetAnimationSyncMarkersForTrack(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string, Markers: $Ref<TArray<AnimSyncMarker>>): void;

        static GetAnimationTrackNames(AnimationSequence: $Nullable<AnimSequence>, TrackNames: $Ref<TArray<string>>): void;

        static GetAnimNotifyEventTriggerTime(NotifyEvent: AnimNotifyEvent): number;

        static GetBoneCompressionSettings(AnimationSequence: $Nullable<AnimSequence>, CompressionSettings: $Ref<AnimBoneCompressionSettings>): void;

        static GetBonePoseForFrame(AnimationSequence: $Nullable<AnimSequence>, BoneName: string, Frame: number, bExtractRootMotion: boolean, Pose: $Ref<Transform>): void;

        static GetBonePoseForTime(AnimationSequence: $Nullable<AnimSequence>, BoneName: string, Time: number, bExtractRootMotion: boolean, Pose: $Ref<Transform>): void;

        static GetBonePosesForFrame(AnimationSequence: $Nullable<AnimSequence>, BoneNames: TArray<string>, Frame: number, bExtractRootMotion: boolean, Poses: $Ref<TArray<Transform>>, PreviewMesh?: SkeletalMesh /* = None */): void;

        static GetBonePosesForTime(AnimationSequence: $Nullable<AnimSequence>, BoneNames: TArray<string>, Time: number, bExtractRootMotion: boolean, Poses: $Ref<TArray<Transform>>, PreviewMesh?: SkeletalMesh /* = None */): void;

        static GetCurveCompressionSettings(AnimationSequence: $Nullable<AnimSequence>, CompressionSettings: $Ref<AnimCurveCompressionSettings>): void;

        static GetFloatKeys(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<number>>): void;

        static GetFrameAtTime(AnimationSequence: $Nullable<AnimSequence>, Time: number, Frame: $Ref<number>): void;

        static GetMetaData(AnimationSequence: $Nullable<AnimSequence>, MetaData: TArray<AnimMetaData>): void;

        static GetMetaDataOfClass(AnimationSequence: $Nullable<AnimSequence>, MetaDataClass: $Nullable<Class>, MetaDataOfClass: TArray<AnimMetaData>): void;

        static GetNumFrames(AnimationSequence: $Nullable<AnimSequence>, NumFrames: $Ref<number>): void;

        static GetRateScale(AnimationSequence: $Nullable<AnimSequence>, RateScale: $Ref<number>): void;

        static GetRawTrackData(AnimationSequence: $Nullable<AnimSequence>, TrackName: string, PositionKeys: $Ref<TArray<Vector>>, RotationKeys: $Ref<TArray<Quat>>, ScalingKeys: $Ref<TArray<Vector>>): void;

        static GetRawTrackPositionData(AnimationSequence: $Nullable<AnimSequence>, TrackName: string, PositionData: $Ref<TArray<Vector>>): void;

        static GetRawTrackRotationData(AnimationSequence: $Nullable<AnimSequence>, TrackName: string, RotationData: $Ref<TArray<Quat>>): void;

        static GetRawTrackScaleData(AnimationSequence: $Nullable<AnimSequence>, TrackName: string, ScaleData: $Ref<TArray<Vector>>): void;

        static GetRootMotionLockType(AnimationSequence: $Nullable<AnimSequence>, LockType: $Ref<ERootMotionRootLock>): void;

        static GetSequenceLength(AnimationSequence: $Nullable<AnimSequence>, Length: $Ref<number>): void;

        static GetTimeAtFrame(AnimationSequence: $Nullable<AnimSequence>, Frame: number, Time: $Ref<number>): void;

        static GetTransformationKeys(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<Transform>>): void;

        static GetUniqueMarkerNames(AnimationSequence: $Nullable<AnimSequence>, MarkerNames: $Ref<TArray<string>>): void;

        static GetVectorKeys(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<Vector>>): void;

        static IsRootMotionEnabled(AnimationSequence: $Nullable<AnimSequence>): boolean;

        static IsRootMotionLockForced(AnimationSequence: $Nullable<AnimSequence>): boolean;

        static IsValidAnimationSyncMarkerName(AnimationSequence: $Nullable<AnimSequence>, MarkerName: string): boolean;

        static IsValidAnimNotifyTrackName(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string): boolean;

        static IsValidRawAnimationTrackName(AnimationSequence: $Nullable<AnimSequence>, TrackName: string): boolean;

        static IsValidTime(AnimationSequence: $Nullable<AnimSequence>, Time: number, IsValid: $Ref<boolean>): void;

        static RemoveAllAnimationNotifyTracks(AnimationSequence: $Nullable<AnimSequence>): void;

        static RemoveAllAnimationSyncMarkers(AnimationSequence: $Nullable<AnimSequence>): void;

        static RemoveAllBoneAnimation(AnimationSequence: $Nullable<AnimSequence>): void;

        static RemoveAllCurveData(AnimationSequence: $Nullable<AnimSequence>): void;

        static RemoveAllMetaData(AnimationSequence: $Nullable<AnimSequence>): void;

        static RemoveAllVirtualBones(AnimationSequence: $Nullable<AnimSequence>): void;

        static RemoveAnimationNotifyEventsByName(AnimationSequence: $Nullable<AnimSequence>, NotifyName: string): number;

        static RemoveAnimationNotifyEventsByTrack(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string): number;

        static RemoveAnimationNotifyTrack(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string): void;

        static RemoveAnimationSyncMarkersByName(AnimationSequence: $Nullable<AnimSequence>, MarkerName: string): number;

        static RemoveAnimationSyncMarkersByTrack(AnimationSequence: $Nullable<AnimSequence>, NotifyTrackName: string): number;

        static RemoveBoneAnimation(AnimationSequence: $Nullable<AnimSequence>, BoneName: string, bIncludeChildren?: boolean /* = true */, bFinalize?: boolean /* = true */): void;

        static RemoveCurve(AnimationSequence: $Nullable<AnimSequence>, CurveName: string, bRemoveNameFromSkeleton?: boolean /* = false */): void;

        static RemoveMetaData(AnimationSequence: $Nullable<AnimSequence>, MetaDataObject: $Nullable<AnimMetaData>): void;

        static RemoveMetaDataOfClass(AnimationSequence: $Nullable<AnimSequence>, MetaDataClass: $Nullable<Class>): void;

        static RemoveVirtualBone(AnimationSequence: $Nullable<AnimSequence>, VirtualBoneName: string): void;

        static RemoveVirtualBones(AnimationSequence: $Nullable<AnimSequence>, VirtualBoneNames: TArray<string>): void;

        static ReplaceAnimNotifies(AnimationSequence: $Nullable<AnimSequenceBase>, OldNotifyClass: $Nullable<Class>, NewNotifyClass: $Nullable<Class>, OnNotifyReplaced: $Delegate<(OldNotify: $Nullable<AnimNotify>, NewNotify: $Nullable<AnimNotify>) => void>): void;

        static ReplaceAnimNotifyStates(AnimationSequence: $Nullable<AnimSequenceBase>, OldNotifyClass: $Nullable<Class>, NewNotifyClass: $Nullable<Class>, OnNotifyStateReplaced: $Delegate<(OldNotifyState: $Nullable<AnimNotifyState>, NewNotifyState: $Nullable<AnimNotifyState>) => void>): void;

        static SetAdditiveAnimationType(AnimationSequence: $Nullable<AnimSequence>, AdditiveAnimationType: EAdditiveAnimationType): void;

        static SetAdditiveBasePoseType(AnimationSequence: $Nullable<AnimSequence>, AdditiveBasePoseType: EAdditiveBasePoseType): void;

        static SetAnimationInterpolationType(AnimationSequence: $Nullable<AnimSequence>, InterpolationType: EAnimInterpolationType): void;

        static SetBoneCompressionSettings(AnimationSequence: $Nullable<AnimSequence>, CompressionSettings: $Nullable<AnimBoneCompressionSettings>): void;

        static SetCurveCompressionSettings(AnimationSequence: $Nullable<AnimSequence>, CompressionSettings: $Nullable<AnimCurveCompressionSettings>): void;

        static SetIsRootMotionLockForced(AnimationSequence: $Nullable<AnimSequence>, bForced: boolean): void;

        static SetRateScale(AnimationSequence: $Nullable<AnimSequence>, RateScale: number): void;

        static SetRootMotionEnabled(AnimationSequence: $Nullable<AnimSequence>, bEnabled: boolean): void;

        static SetRootMotionLockType(AnimationSequence: $Nullable<AnimSequence>, RootMotionLockType: ERootMotionRootLock): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationBlueprintLibrary;

        static Load(InName: string): AnimationBlueprintLibrary;
    }

    export class BlueprintCallableFunctionRedirect {
        constructor();
        constructor(ClassName: string, OldFunctionName: string, NewFunctionName: string, BlueprintParamName: string, ClassParamName: string);

        ClassName: string;
        OldFunctionName: string;
        NewFunctionName: string;
        BlueprintParamName: string;
        ClassParamName: string;

        static StaticClass(): Class;
    }

    export class EdGraphSchema_K2 extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EditoronlyBPFunctionRedirects: TArray<BlueprintCallableFunctionRedirect>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_K2;

        static Load(InName: string): EdGraphSchema_K2;
    }

    export class AnimationConduitGraphSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationConduitGraphSchema;

        static Load(InName: string): AnimationConduitGraphSchema;
    }

    export class AnimationGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlendOptions: AnimGraphBlendOptions;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationGraph;

        static Load(InName: string): AnimationGraph;
    }

    export class K2Node extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node;

        static Load(InName: string): K2Node;
    }

    export class OptionalPinFromProperty {
        constructor();
        constructor(PropertyName: string, PropertyFriendlyName: string, PropertyTooltip: string, CategoryName: string, bShowPin: boolean, bCanToggleVisibility: boolean, bPropertyIsCustomized: boolean, bHasOverridePin: boolean, bIsMarkedForAdvancedDisplay: boolean, bIsOverrideEnabled: boolean, bIsSetValuePinVisible: boolean, bIsOverridePinVisible: boolean);

        PropertyName: string;
        PropertyFriendlyName: string;
        PropertyTooltip: string;
        CategoryName: string;
        bShowPin: boolean;
        bCanToggleVisibility: boolean;
        bPropertyIsCustomized: boolean;
        bHasOverridePin: boolean;
        bIsMarkedForAdvancedDisplay: boolean;
        bIsOverrideEnabled: boolean;
        bIsSetValuePinVisible: boolean;
        bIsOverridePinVisible: boolean;

        static StaticClass(): Class;
    }

    export enum EAnimGraphNodePropertyBindingType { None, Property, Function, EAnimGraphNodePropertyBindingType_MAX }

    export class AnimGraphNodePropertyBinding {
        constructor();
        constructor(PinType: EdGraphPinType, PromotedPinType: EdGraphPinType, PropertyName: string, PathAsText: string, PropertyPath: TArray<string>, Type: EAnimGraphNodePropertyBindingType, bIsBound: boolean, bIsPromotion: boolean);

        PinType: EdGraphPinType;
        PromotedPinType: EdGraphPinType;
        PropertyName: string;
        PathAsText: string;
        PropertyPath: TArray<string>;
        Type: EAnimGraphNodePropertyBindingType;
        bIsBound: boolean;
        bIsPromotion: boolean;

        static StaticClass(): Class;
    }

    export enum EBlueprintUsage { NoProperties, DoesNotUseBlueprint, UsesBlueprint, EBlueprintUsage_MAX }

    export class AnimGraphNode_Base extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShowPinForProperties: TArray<OptionalPinFromProperty>;
        PropertyBindings: TMap<string, AnimGraphNodePropertyBinding>;
        BlueprintUsage: EBlueprintUsage;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Base;

        static Load(InName: string): AnimGraphNode_Base;
    }

    export class AnimNode_Base {
        constructor();

        static StaticClass(): Class;
    }

    export class PoseLinkBase {
        constructor();
        constructor(LinkID: number, SourceLinkID: number);

        LinkID: number;
        SourceLinkID: number;

        static StaticClass(): Class;
    }

    export class PoseLink extends PoseLinkBase {
        constructor();

        static StaticClass(): Class;
    }

    export class AnimNode_Root extends AnimNode_Base {
        constructor();
        constructor(Result: PoseLink, Name: string, Group: string);

        Result: PoseLink;
        Name: string;
        Group: string;

        static StaticClass(): Class;
    }

    export class AnimNode_StateResult extends AnimNode_Root {
        constructor();

        static StaticClass(): Class;
    }

    export class AnimGraphNode_StateResult extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_StateResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateResult;

        static Load(InName: string): AnimGraphNode_StateResult;
    }

    export class AnimGraphNode_CustomTransitionResult extends AnimGraphNode_StateResult {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CustomTransitionResult;

        static Load(InName: string): AnimGraphNode_CustomTransitionResult;
    }

    export class AnimationCustomTransitionGraph extends AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MyResultNode: AnimGraphNode_CustomTransitionResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationCustomTransitionGraph;

        static Load(InName: string): AnimationCustomTransitionGraph;
    }

    export class AnimationGraphSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PN_SequenceName: string;
        NAME_NeverAsPin: string;
        NAME_PinHiddenByDefault: string;
        NAME_PinShownByDefault: string;
        NAME_AlwaysAsPin: string;
        NAME_CustomizeProperty: string;
        NAME_OnEvaluate: string;
        DefaultEvaluationHandlerName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationGraphSchema;

        static Load(InName: string): AnimationGraphSchema;
    }

    export class AnimationCustomTransitionSchema extends AnimationGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationCustomTransitionSchema;

        static Load(InName: string): AnimationCustomTransitionSchema;
    }

    export class AnimationDataSourceRegistry extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DataSources: TMap<string, TWeakObjectPtr<Object>>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationDataSourceRegistry;

        static Load(InName: string): AnimationDataSourceRegistry;
    }

    export class AnimationEditorPreviewActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationEditorPreviewActor;

        static Load(InName: string): AnimationEditorPreviewActor;
    }

    export class AnimationModifier extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RevisionGuid: Guid;
        AppliedGuid: Guid;
        StoredNativeRevision: number;
        PreviouslyAppliedModifier: AnimationModifier;

        OnApply(AnimationSequence: $Nullable<AnimSequence>): void;

        OnRevert(AnimationSequence: $Nullable<AnimSequence>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationModifier;

        static Load(InName: string): AnimationModifier;
    }

    export class AnimationModifiersAssetUserData extends AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimationModifierInstances: TArray<AnimationModifier>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationModifiersAssetUserData;

        static Load(InName: string): AnimationModifiersAssetUserData;
    }

    export class DeveloperSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DeveloperSettings;

        static Load(InName: string): DeveloperSettings;
    }

    export class CustomAttributeSetting {
        constructor();
        constructor(Name: string, Meaning: string);

        Name: string;
        Meaning: string;

        static StaticClass(): Class;
    }

    export enum ECustomAttributeBlendType { Override, Blend, ECustomAttributeBlendType_MAX }

    export class AnimationSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CompressCommandletVersion: number;
        KeyEndEffectorsMatchNameArray: TArray<string>;
        ForceRecompression: boolean;
        bForceBelowThreshold: boolean;
        bFirstRecompressUsingCurrentOrDefault: boolean;
        bRaiseMaxErrorToExisting: boolean;
        bEnablePerformanceLog: boolean;
        bStripAnimationDataOnDedicatedServer: boolean;
        bTickAnimationOnSkeletalMeshInit: boolean;
        BoneCustomAttributesNames: TArray<CustomAttributeSetting>;
        BoneNamesWithCustomAttributes: TArray<string>;
        AttributeBlendModes: TMap<string, ECustomAttributeBlendType>;
        DefaultAttributeBlendMode: ECustomAttributeBlendType;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationSettings;

        static Load(InName: string): AnimationSettings;
    }

    export class AnimLayerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimLayerInterface;

        static Load(InName: string): AnimLayerInterface;
    }

    export class AnimationStanceInterface_C extends AnimLayerInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimationInterfaceStance(Input1: PoseLink, InSpeed: number, InDirection: number, InPitch: number, AnimationInterfaceStance: $Ref<PoseLink>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationStanceInterface_C;

        static Load(InName: string): AnimationStanceInterface_C;
    }

    export class AnimationStateGraph extends AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MyResultNode: AnimGraphNode_StateResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationStateGraph;

        static Load(InName: string): AnimationStateGraph;
    }

    export class AnimationStateGraphSchema extends AnimationGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationStateGraphSchema;

        static Load(InName: string): AnimationStateGraphSchema;
    }

    export class AnimStateEntryNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimStateEntryNode;

        static Load(InName: string): AnimStateEntryNode;
    }

    export class AnimGraphNode_StateMachineBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EditorStateMachineGraph: AnimationStateMachineGraph;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateMachineBase;

        static Load(InName: string): AnimGraphNode_StateMachineBase;
    }

    export class AnimationStateMachineGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EntryNode: AnimStateEntryNode;
        OwnerAnimGraphNode: AnimGraphNode_StateMachineBase;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationStateMachineGraph;

        static Load(InName: string): AnimationStateMachineGraph;
    }

    export class AnimationStateMachineSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationStateMachineSchema;

        static Load(InName: string): AnimationStateMachineSchema;
    }

    export class SkeletalMeshActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bShouldDoAnimNotifies: boolean;
        bWakeOnLevelStart: boolean;
        SkeletalMeshComponent: SkeletalMeshComponent;
        ReplicatedMesh: SkeletalMesh;
        ReplicatedPhysAsset: PhysicsAsset;
        ReplicatedMaterial0: MaterialInterface;
        ReplicatedMaterial1: MaterialInterface;

        OnRep_ReplicatedMaterial0(): void;

        OnRep_ReplicatedMaterial1(): void;

        OnRep_ReplicatedMesh(): void;

        OnRep_ReplicatedPhysAsset(): void;

        OutlineEffectAdd(): void;

        OutlineEffectRemove(): void;

        UnifySpecifyPassWithOutlineMaterialType(): void;

        UnifySpecifyPassWithPassMaterialParams(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshActor;

        static Load(InName: string): SkeletalMeshActor;
    }

    export class AnimationThumbnailSkeletalMeshActor extends SkeletalMeshActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationThumbnailSkeletalMeshActor;

        static Load(InName: string): AnimationThumbnailSkeletalMeshActor;
    }

    export class AnimNode_TransitionResult extends AnimNode_Base {
        constructor();
        constructor(bCanEnterTransition: boolean);

        bCanEnterTransition: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_TransitionResult extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_TransitionResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TransitionResult;

        static Load(InName: string): AnimGraphNode_TransitionResult;
    }

    export class AnimationTransitionGraph extends AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MyResultNode: AnimGraphNode_TransitionResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationTransitionGraph;

        static Load(InName: string): AnimationTransitionGraph;
    }

    export class AnimationTransitionSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimationTransitionSchema;

        static Load(InName: string): AnimationTransitionSchema;
    }

    export class AnimBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlueprintType: EBlueprintType;
        ParentClass: Class;
        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimBlueprintFactory;

        static Load(InName: string): AnimBlueprintFactory;
    }

    export class AnimBlueprintPostCompileValidation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimBlueprintPostCompileValidation;

        static Load(InName: string): AnimBlueprintPostCompileValidation;
    }

    export class ThumbnailRenderer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ThumbnailRenderer;

        static Load(InName: string): ThumbnailRenderer;
    }

    export class DefaultSizedThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultSizeX: number;
        DefaultSizeY: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DefaultSizedThumbnailRenderer;

        static Load(InName: string): DefaultSizedThumbnailRenderer;
    }

    export class AnimBlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimBlueprintThumbnailRenderer;

        static Load(InName: string): AnimBlueprintThumbnailRenderer;
    }

    export class AnimBoneCompressionSettingsFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimBoneCompressionSettingsFactory;

        static Load(InName: string): AnimBoneCompressionSettingsFactory;
    }

    export class AnimBlueprintFunction {
        constructor();
        constructor(Name: string, Group: string, OutputPoseNodeIndex: number, InputPoseNames: TArray<string>, InputPoseNodeIndices: TArray<number>, bImplemented: boolean);

        Name: string;
        Group: string;
        OutputPoseNodeIndex: number;
        InputPoseNames: TArray<string>;
        InputPoseNodeIndices: TArray<number>;
        bImplemented: boolean;

        static StaticClass(): Class;
    }

    export class AnimBlueprintFunctionData {
        static StaticClass(): Class;
    }

    export class AnimClassData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BakedStateMachines: TArray<BakedAnimationStateMachine>;
        TargetSkeleton: Skeleton;
        AnimNotifies: TArray<AnimNotifyEvent>;
        OrderedSavedPoseIndicesMap: TMap<string, CachedPoseIndices>;
        AnimBlueprintFunctions: TArray<AnimBlueprintFunction>;
        AnimBlueprintFunctionData: TArray<AnimBlueprintFunctionData>;
        GraphNameAssetPlayers: TMap<string, GraphAssetPlayerInformation>;
        SyncGroupNames: TArray<string>;
        EvaluateGraphExposedInputs: TArray<ExposedValueHandler>;
        GraphBlendOptions: TMap<string, AnimGraphBlendOptions>;
        PropertyAccessLibrary: PropertyAccessLibrary;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimClassData;

        static Load(InName: string): AnimClassData;
    }

    export class AnimClassInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimClassInterface;

        static Load(InName: string): AnimClassInterface;
    }

    export class AnimComposite extends AnimCompositeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimationTrack: AnimTrack;
        PreviewBasePose: AnimSequence;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimComposite;

        static Load(InName: string): AnimComposite;
    }

    export class AnimCompositeFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeleton: Skeleton;
        SourceAnimation: AnimSequence;
        PreviewSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompositeFactory;

        static Load(InName: string): AnimCompositeFactory;
    }

    export enum AnimationCompressionFormat {
        ACF_None,
        ACF_Float96NoW,
        ACF_Fixed48NoW,
        ACF_IntervalFixed32NoW,
        ACF_Fixed32NoW,
        ACF_Float32NoW,
        ACF_Identity,
        ACF_MAX
    }

    export class AnimCompress extends AnimBoneCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bNeedsSkeleton: boolean;
        TranslationCompressionFormat: AnimationCompressionFormat;
        RotationCompressionFormat: AnimationCompressionFormat;
        ScaleCompressionFormat: AnimationCompressionFormat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompress;

        static Load(InName: string): AnimCompress;
    }

    export class AnimCompress_BitwiseCompressOnly extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompress_BitwiseCompressOnly;

        static Load(InName: string): AnimCompress_BitwiseCompressOnly;
    }

    export class AnimCompress_LeastDestructive extends AnimCompress_BitwiseCompressOnly {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompress_LeastDestructive;

        static Load(InName: string): AnimCompress_LeastDestructive;
    }

    export class AnimCompress_RemoveLinearKeys extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxPosDiff: number;
        MaxAngleDiff: number;
        MaxScaleDiff: number;
        MaxEffectorDiff: number;
        MinEffectorDiff: number;
        EffectorDiffSocket: number;
        ParentKeyScale: number;
        bRetarget: boolean;
        bActuallyFilterLinearKeys: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveLinearKeys;

        static Load(InName: string): AnimCompress_RemoveLinearKeys;
    }

    export class AnimCompress_PerTrackCompression extends AnimCompress_RemoveLinearKeys {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxZeroingThreshold: number;
        MaxPosDiffBitwise: number;
        MaxAngleDiffBitwise: number;
        MaxScaleDiffBitwise: number;
        AllowedRotationFormats: TArray<AnimationCompressionFormat>;
        AllowedTranslationFormats: TArray<AnimationCompressionFormat>;
        AllowedScaleFormats: TArray<AnimationCompressionFormat>;
        bResampleAnimation: boolean;
        ResampledFramerate: number;
        MinKeysForResampling: number;
        bUseAdaptiveError: boolean;
        bUseOverrideForEndEffectors: boolean;
        TrackHeightBias: number;
        ParentingDivisor: number;
        ParentingDivisorExponent: number;
        bUseAdaptiveError2: boolean;
        RotationErrorSourceRatio: number;
        TranslationErrorSourceRatio: number;
        ScaleErrorSourceRatio: number;
        MaxErrorPerTrackRatio: number;
        PerturbationProbeSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompress_PerTrackCompression;

        static Load(InName: string): AnimCompress_PerTrackCompression;
    }

    export class AnimCompress_RemoveEverySecondKey extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MinKeys: number;
        bStartAtSecondKey: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveEverySecondKey;

        static Load(InName: string): AnimCompress_RemoveEverySecondKey;
    }

    export class AnimCompress_RemoveTrivialKeys extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxPosDiff: number;
        MaxAngleDiff: number;
        MaxScaleDiff: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveTrivialKeys;

        static Load(InName: string): AnimCompress_RemoveTrivialKeys;
    }

    export class AnimCurveCompressionCodec_CompressedRichCurve extends AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxCurveError: number;
        UseAnimSequenceSampleRate: boolean;
        ErrorSampleRate: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_CompressedRichCurve;

        static Load(InName: string): AnimCurveCompressionCodec_CompressedRichCurve;
    }

    export class AnimCurveCompressionCodec_UniformIndexable extends AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_UniformIndexable;

        static Load(InName: string): AnimCurveCompressionCodec_UniformIndexable;
    }

    export class AnimCurveCompressionCodec_UniformlySampled extends AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UseAnimSequenceSampleRate: boolean;
        SampleRate: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_UniformlySampled;

        static Load(InName: string): AnimCurveCompressionCodec_UniformlySampled;
    }

    export class AnimCurveCompressionSettingsFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionSettingsFactory;

        static Load(InName: string): AnimCurveCompressionSettingsFactory;
    }

    export enum EAnimGroupRole {
        CanBeLeader,
        AlwaysFollower,
        AlwaysLeader,
        TransitionLeader,
        TransitionFollower,
        EAnimGroupRole_MAX
    }

    export enum EAnimSyncGroupScope { Local, Component, EAnimSyncGroupScope_MAX }

    export class AnimationGroupReference {
        constructor();
        constructor(GroupName: string, GroupRole: EAnimGroupRole, GroupScope: EAnimSyncGroupScope);

        GroupName: string;
        GroupRole: EAnimGroupRole;
        GroupScope: EAnimSyncGroupScope;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_AssetPlayerBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SyncGroup: AnimationGroupReference;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AssetPlayerBase;

        static Load(InName: string): AnimGraphNode_AssetPlayerBase;
    }

    export class AnimGraphNode_BlendSpaceBase extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpaceBase;

        static Load(InName: string): AnimGraphNode_BlendSpaceBase;
    }

    export class AnimNode_AssetPlayerBase extends AnimNode_Base {
        constructor();
        constructor(GroupName: string, GroupIndex: number, GroupRole: EAnimGroupRole, GroupScope: EAnimSyncGroupScope, bIgnoreForRelevancyTest: boolean, BlendWeight: number, InternalTimeAccumulator: number);

        GroupName: string;
        GroupIndex: number;
        GroupRole: EAnimGroupRole;
        GroupScope: EAnimSyncGroupScope;
        bIgnoreForRelevancyTest: boolean;
        BlendWeight: number;
        InternalTimeAccumulator: number;

        static StaticClass(): Class;
    }

    export class AnimNode_BlendSpacePlayer extends AnimNode_AssetPlayerBase {
        constructor();
        constructor(X: number, Y: number, Z: number, PlayRate: number, bLoop: boolean, bResetPlayTimeWhenBlendSpaceChanges: boolean, StartPosition: number, BlendSpace: BlendSpaceBase, PreviousBlendSpace: BlendSpaceBase);

        X: number;
        Y: number;
        Z: number;
        PlayRate: number;
        bLoop: boolean;
        bResetPlayTimeWhenBlendSpaceChanges: boolean;
        StartPosition: number;
        BlendSpace: BlendSpaceBase;
        PreviousBlendSpace: BlendSpaceBase;

        static StaticClass(): Class;
    }

    export class AnimNode_AimOffsetLookAt extends AnimNode_BlendSpacePlayer {
        constructor();
        constructor(BasePose: PoseLink, LODThreshold: number, SourceSocketName: string, PivotSocketName: string, LookAtLocation: Vector, SocketAxis: Vector, Alpha: number);

        BasePose: PoseLink;
        LODThreshold: number;
        SourceSocketName: string;
        PivotSocketName: string;
        LookAtLocation: Vector;
        SocketAxis: Vector;
        Alpha: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_AimOffsetLookAt extends AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_AimOffsetLookAt;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AimOffsetLookAt;

        static Load(InName: string): AnimGraphNode_AimOffsetLookAt;
    }

    export class AnimGraphNode_SkeletalControlBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SkeletalControlBase;

        static Load(InName: string): AnimGraphNode_SkeletalControlBase;
    }

    export class ComponentSpacePoseLink extends PoseLinkBase {
        constructor();

        static StaticClass(): Class;
    }

    export enum EAnimAlphaInputType { Float, Bool, Curve, EAnimAlphaInputType_MAX }

    export class InputScaleBias {
        constructor();
        constructor(Scale: number, Bias: number);

        Scale: number;
        Bias: number;

        static StaticClass(): Class;
    }

    export class InputAlphaBoolBlend {
        constructor();
        constructor(BlendInTime: number, BlendOutTime: number, BlendOption: EAlphaBlendOption, bInitialized: boolean, CustomCurve: CurveFloat, AlphaBlend: AlphaBlend);

        BlendInTime: number;
        BlendOutTime: number;
        BlendOption: EAlphaBlendOption;
        bInitialized: boolean;
        CustomCurve: CurveFloat;
        AlphaBlend: AlphaBlend;

        static StaticClass(): Class;
    }

    export class InputRange {
        constructor();
        constructor(Min: number, Max: number);

        Min: number;
        Max: number;

        static StaticClass(): Class;
    }

    export class InputScaleBiasClamp {
        constructor();
        constructor(bMapRange: boolean, bClampResult: boolean, bInterpResult: boolean, InRange: InputRange, OutRange: InputRange, Scale: number, Bias: number, ClampMin: number, ClampMax: number, InterpSpeedIncreasing: number, InterpSpeedDecreasing: number);

        bMapRange: boolean;
        bClampResult: boolean;
        bInterpResult: boolean;
        InRange: InputRange;
        OutRange: InputRange;
        Scale: number;
        Bias: number;
        ClampMin: number;
        ClampMax: number;
        InterpSpeedIncreasing: number;
        InterpSpeedDecreasing: number;

        static StaticClass(): Class;
    }

    export class AnimNode_SkeletalControlBase extends AnimNode_Base {
        constructor();
        constructor(ComponentPose: ComponentSpacePoseLink, LODThreshold: number, ActualAlpha: number, AlphaInputType: EAnimAlphaInputType, bAlphaBoolEnabled: boolean, Alpha: number, AlphaScaleBias: InputScaleBias, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: InputScaleBiasClamp);

        ComponentPose: ComponentSpacePoseLink;
        LODThreshold: number;
        ActualAlpha: number;
        AlphaInputType: EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: InputScaleBiasClamp;

        static StaticClass(): Class;
    }

    export enum AnimPhysLinearConstraintType { Free, Limited, AnimPhysLinearConstraintType_MAX }

    export enum AnimPhysAngularConstraintType { Angular, Cone, AnimPhysAngularConstraintType_MAX }

    export enum AnimPhysTwistAxis { AxisX, AxisY, AxisZ, AnimPhysTwistAxis_MAX }

    export class AnimPhysConstraintSetup {
        constructor();
        constructor(LinearXLimitType: AnimPhysLinearConstraintType, LinearYLimitType: AnimPhysLinearConstraintType, LinearZLimitType: AnimPhysLinearConstraintType, LinearAxesMin: Vector, LinearAxesMax: Vector, AngularConstraintType: AnimPhysAngularConstraintType, TwistAxis: AnimPhysTwistAxis, AngularTargetAxis: AnimPhysTwistAxis, ConeAngle: number, AngularXAngle: number, AngularYAngle: number, AngularZAngle: number, AngularLimitsMin: Vector, AngularLimitsMax: Vector, AngularTarget: Vector);

        LinearXLimitType: AnimPhysLinearConstraintType;
        LinearYLimitType: AnimPhysLinearConstraintType;
        LinearZLimitType: AnimPhysLinearConstraintType;
        LinearAxesMin: Vector;
        LinearAxesMax: Vector;
        AngularConstraintType: AnimPhysAngularConstraintType;
        TwistAxis: AnimPhysTwistAxis;
        AngularTargetAxis: AnimPhysTwistAxis;
        ConeAngle: number;
        AngularXAngle: number;
        AngularYAngle: number;
        AngularZAngle: number;
        AngularLimitsMin: Vector;
        AngularLimitsMax: Vector;
        AngularTarget: Vector;

        static StaticClass(): Class;
    }

    export enum ESphericalLimitType { Inner, Outer, ESphericalLimitType_MAX }

    export class AnimPhysSphericalLimit {
        constructor();
        constructor(DrivingBone: BoneReference, SphereLocalOffset: Vector, LimitRadius: number, LimitType: ESphericalLimitType);

        DrivingBone: BoneReference;
        SphereLocalOffset: Vector;
        LimitRadius: number;
        LimitType: ESphericalLimitType;

        static StaticClass(): Class;
    }

    export class AnimPhysPlanarLimit {
        constructor();
        constructor(DrivingBone: BoneReference, PlaneTransform: Transform);

        DrivingBone: BoneReference;
        PlaneTransform: Transform;

        static StaticClass(): Class;
    }

    export enum AnimPhysCollisionType { CoM, CustomSphere, InnerSphere, OuterSphere, AnimPhysCollisionType_MAX }

    export enum AnimPhysSimSpaceType { Component, Actor, World, RootRelative, BoneRelative, AnimPhysSimSpaceType_MAX }

    export enum ERotationComponent {
        EulerX,
        EulerY,
        EulerZ,
        QuaternionAngle,
        SwingAngle,
        TwistAngle,
        ERotationComponent_MAX
    }

    export enum EEasingFuncType {
        Linear,
        Sinusoidal,
        Cubic,
        QuadraticInOut,
        CubicInOut,
        HermiteCubic,
        QuarticInOut,
        QuinticInOut,
        CircularIn,
        CircularOut,
        CircularInOut,
        ExpIn,
        ExpOut,
        ExpInOut,
        CustomCurve,
        EEasingFuncType_MAX
    }

    export class RotationRetargetingInfo {
        constructor();
        constructor(bEnabled: boolean, Source: Transform, Target: Transform, RotationComponent: ERotationComponent, TwistAxis: Vector, bUseAbsoluteAngle: boolean, SourceMinimum: number, SourceMaximum: number, TargetMinimum: number, TargetMaximum: number, EasingType: EEasingFuncType, CustomCurve: RuntimeFloatCurve, bFlipEasing: boolean, EasingWeight: number, bClamp: boolean);

        bEnabled: boolean;
        Source: Transform;
        Target: Transform;
        RotationComponent: ERotationComponent;
        TwistAxis: Vector;
        bUseAbsoluteAngle: boolean;
        SourceMinimum: number;
        SourceMaximum: number;
        TargetMinimum: number;
        TargetMaximum: number;
        EasingType: EEasingFuncType;
        CustomCurve: RuntimeFloatCurve;
        bFlipEasing: boolean;
        EasingWeight: number;
        bClamp: boolean;

        static StaticClass(): Class;
    }

    export class AnimNode_AnimDynamics extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(LinearDampingOverride: number, AngularDampingOverride: number, RelativeSpaceBone: BoneReference, BoundBone: BoneReference, ChainEnd: BoneReference, BoxExtents: Vector, LocalJointOffset: Vector, GravityScale: number, GravityOverride: Vector, LinearSpringConstant: number, AngularSpringConstant: number, WindScale: number, ComponentLinearAccScale: Vector, ComponentLinearVelScale: Vector, ComponentAppliedLinearAccClamp: Vector, AngularBiasOverride: number, NumSolverIterationsPreUpdate: number, NumSolverIterationsPostUpdate: number, ConstraintSetup: AnimPhysConstraintSetup, SphericalLimits: TArray<AnimPhysSphericalLimit>, SphereCollisionRadius: number, ExternalForce: Vector, PlanarLimits: TArray<AnimPhysPlanarLimit>, CollisionType: AnimPhysCollisionType, SimulationSpace: AnimPhysSimSpaceType, bUseSphericalLimits: boolean, bUsePlanarLimit: boolean, bDoUpdate: boolean, bDoEval: boolean, bOverrideLinearDamping: boolean, bOverrideAngularBias: boolean, bOverrideAngularDamping: boolean, bEnableWind: boolean, bUseGravityOverride: boolean, bLinearSpring: boolean, bAngularSpring: boolean, bChain: boolean, RetargetingSettings: RotationRetargetingInfo);

        LinearDampingOverride: number;
        AngularDampingOverride: number;
        RelativeSpaceBone: BoneReference;
        BoundBone: BoneReference;
        ChainEnd: BoneReference;
        BoxExtents: Vector;
        LocalJointOffset: Vector;
        GravityScale: number;
        GravityOverride: Vector;
        LinearSpringConstant: number;
        AngularSpringConstant: number;
        WindScale: number;
        ComponentLinearAccScale: Vector;
        ComponentLinearVelScale: Vector;
        ComponentAppliedLinearAccClamp: Vector;
        AngularBiasOverride: number;
        NumSolverIterationsPreUpdate: number;
        NumSolverIterationsPostUpdate: number;
        ConstraintSetup: AnimPhysConstraintSetup;
        SphericalLimits: TArray<AnimPhysSphericalLimit>;
        SphereCollisionRadius: number;
        ExternalForce: Vector;
        PlanarLimits: TArray<AnimPhysPlanarLimit>;
        CollisionType: AnimPhysCollisionType;
        SimulationSpace: AnimPhysSimSpaceType;
        bUseSphericalLimits: boolean;
        bUsePlanarLimit: boolean;
        bDoUpdate: boolean;
        bDoEval: boolean;
        bOverrideLinearDamping: boolean;
        bOverrideAngularBias: boolean;
        bOverrideAngularDamping: boolean;
        bEnableWind: boolean;
        bUseGravityOverride: boolean;
        bLinearSpring: boolean;
        bAngularSpring: boolean;
        bChain: boolean;
        RetargetingSettings: RotationRetargetingInfo;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_AnimDynamics extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_AnimDynamics;
        bPreviewLive: boolean;
        bShowLinearLimits: boolean;
        bShowAngularLimits: boolean;
        bShowPlanarLimit: boolean;
        bShowSphericalLimit: boolean;
        bShowCollisionSpheres: boolean;
        LastPreviewComponent: SkeletalMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AnimDynamics;

        static Load(InName: string): AnimGraphNode_AnimDynamics;
    }

    export class AnimNode_ApplyAdditive extends AnimNode_Base {
        constructor();
        constructor(Base: PoseLink, Additive: PoseLink, Alpha: number, AlphaScaleBias: InputScaleBias, LODThreshold: number, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: InputScaleBiasClamp, AlphaInputType: EAnimAlphaInputType, bAlphaBoolEnabled: boolean);

        Base: PoseLink;
        Additive: PoseLink;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        LODThreshold: number;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: InputScaleBiasClamp;
        AlphaInputType: EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ApplyAdditive extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ApplyAdditive;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyAdditive;

        static Load(InName: string): AnimGraphNode_ApplyAdditive;
    }

    export class AngularRangeLimit {
        constructor();
        constructor(LimitMin: Vector, LimitMax: Vector, Bone: BoneReference);

        LimitMin: Vector;
        LimitMax: Vector;
        Bone: BoneReference;

        static StaticClass(): Class;
    }

    export class AnimNode_ApplyLimits extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(AngularRangeLimits: TArray<AngularRangeLimit>, AngularOffsets: TArray<Vector>);

        AngularRangeLimits: TArray<AngularRangeLimit>;
        AngularOffsets: TArray<Vector>;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ApplyLimits extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ApplyLimits;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyLimits;

        static Load(InName: string): AnimGraphNode_ApplyLimits;
    }

    export class AnimNode_ApplyMeshSpaceAdditive extends AnimNode_Base {
        constructor();
        constructor(Base: PoseLink, Additive: PoseLink, AlphaInputType: EAnimAlphaInputType, Alpha: number, bAlphaBoolEnabled: boolean, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBias: InputScaleBias, AlphaScaleBiasClamp: InputScaleBiasClamp, LODThreshold: number);

        Base: PoseLink;
        Additive: PoseLink;
        AlphaInputType: EAnimAlphaInputType;
        Alpha: number;
        bAlphaBoolEnabled: boolean;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBias: InputScaleBias;
        AlphaScaleBiasClamp: InputScaleBiasClamp;
        LODThreshold: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ApplyMeshSpaceAdditive extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ApplyMeshSpaceAdditive;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyMeshSpaceAdditive;

        static Load(InName: string): AnimGraphNode_ApplyMeshSpaceAdditive;
    }

    export class BlendBoneByChannelEntry {
        constructor();
        constructor(SourceBone: BoneReference, TargetBone: BoneReference, bBlendTranslation: boolean, bBlendRotation: boolean, bBlendScale: boolean);

        SourceBone: BoneReference;
        TargetBone: BoneReference;
        bBlendTranslation: boolean;
        bBlendRotation: boolean;
        bBlendScale: boolean;

        static StaticClass(): Class;
    }

    export enum EBoneControlSpace { BCS_WorldSpace, BCS_ComponentSpace, BCS_ParentBoneSpace, BCS_BoneSpace, BCS_MAX }

    export class AnimNode_BlendBoneByChannel extends AnimNode_Base {
        constructor();
        constructor(A: PoseLink, B: PoseLink, BoneDefinitions: TArray<BlendBoneByChannelEntry>, Alpha: number, AlphaScaleBias: InputScaleBias, TransformsSpace: EBoneControlSpace);

        A: PoseLink;
        B: PoseLink;
        BoneDefinitions: TArray<BlendBoneByChannelEntry>;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        TransformsSpace: EBoneControlSpace;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_BlendBoneByChannel extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlendNode: AnimNode_BlendBoneByChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendBoneByChannel;

        static Load(InName: string): AnimGraphNode_BlendBoneByChannel;
    }

    export class AnimGraphNode_BlendListBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListBase;

        static Load(InName: string): AnimGraphNode_BlendListBase;
    }

    export enum EBlendListTransitionType { StandardBlend, Inertialization, EBlendListTransitionType_MAX }

    export class AnimNode_BlendListBase extends AnimNode_Base {
        constructor();
        constructor(BlendPose: TArray<PoseLink>, BlendTime: TArray<number>, TransitionType: EBlendListTransitionType, BlendType: EAlphaBlendOption, bResetChildOnActivation: boolean, CustomBlendCurve: CurveFloat, BlendProfile: BlendProfile);

        BlendPose: TArray<PoseLink>;
        BlendTime: TArray<number>;
        TransitionType: EBlendListTransitionType;
        BlendType: EAlphaBlendOption;
        bResetChildOnActivation: boolean;
        CustomBlendCurve: CurveFloat;
        BlendProfile: BlendProfile;

        static StaticClass(): Class;
    }

    export class AnimNode_BlendListByBool extends AnimNode_BlendListBase {
        constructor();
        constructor(bActiveValue: boolean);

        bActiveValue: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_BlendListByBool extends AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_BlendListByBool;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByBool;

        static Load(InName: string): AnimGraphNode_BlendListByBool;
    }

    export class AnimNode_BlendListByEnum extends AnimNode_BlendListBase {
        constructor();
        constructor(EnumToPoseIndex: TArray<number>, ActiveEnumValue: number);

        enumToPoseIndex: TArray<number>;
        ActiveEnumValue: number;

        static StaticClass(): Class;
    }

    export class Enum extends Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Enum;

        static Load(InName: string): Enum;
    }

    export class AnimGraphNode_BlendListByEnum extends AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_BlendListByEnum;
        BoundEnum: Enum;
        VisibleEnumEntries: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByEnum;

        static Load(InName: string): AnimGraphNode_BlendListByEnum;
    }

    export class AnimNode_BlendListByInt extends AnimNode_BlendListBase {
        constructor();
        constructor(ActiveChildIndex: number);

        ActiveChildIndex: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_BlendListByInt extends AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_BlendListByInt;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByInt;

        static Load(InName: string): AnimGraphNode_BlendListByInt;
    }

    export class AnimNode_BlendSpaceEvaluator extends AnimNode_BlendSpacePlayer {
        constructor();
        constructor(NormalizedTime: number);

        NormalizedTime: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_BlendSpaceEvaluator extends AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_BlendSpaceEvaluator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpaceEvaluator;

        static Load(InName: string): AnimGraphNode_BlendSpaceEvaluator;
    }

    export class AnimGraphNode_BlendSpacePlayer extends AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_BlendSpacePlayer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpacePlayer;

        static Load(InName: string): AnimGraphNode_BlendSpacePlayer;
    }

    export enum EComponentType {
        None,
        TranslationX,
        TranslationY,
        TranslationZ,
        RotationX,
        RotationY,
        RotationZ,
        Scale,
        ScaleX,
        ScaleY,
        ScaleZ,
        EComponentType_MAX
    }

    export enum EDrivenDestinationMode { Bone, MorphTarget, MaterialParameter, EDrivenDestinationMode_MAX }

    export enum EDrivenBoneModificationMode {
        AddToInput,
        ReplaceComponent,
        AddToRefPose,
        EDrivenBoneModificationMode_MAX
    }

    export class AnimNode_BoneDrivenController extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(SourceBone: BoneReference, DrivingCurve: CurveFloat, Multiplier: number, RangeMin: number, RangeMax: number, RemappedMin: number, RemappedMax: number, ParameterName: string, TargetBone: BoneReference, TargetComponent: EComponentType, DestinationMode: EDrivenDestinationMode, ModificationMode: EDrivenBoneModificationMode, SourceComponent: EComponentType, bUseRange: boolean, bAffectTargetTranslationX: boolean, bAffectTargetTranslationY: boolean, bAffectTargetTranslationZ: boolean, bAffectTargetRotationX: boolean, bAffectTargetRotationY: boolean, bAffectTargetRotationZ: boolean, bAffectTargetScaleX: boolean, bAffectTargetScaleY: boolean, bAffectTargetScaleZ: boolean);

        SourceBone: BoneReference;
        DrivingCurve: CurveFloat;
        Multiplier: number;
        RangeMin: number;
        RangeMax: number;
        RemappedMin: number;
        RemappedMax: number;
        ParameterName: string;
        TargetBone: BoneReference;
        TargetComponent: EComponentType;
        DestinationMode: EDrivenDestinationMode;
        ModificationMode: EDrivenBoneModificationMode;
        SourceComponent: EComponentType;
        bUseRange: boolean;
        bAffectTargetTranslationX: boolean;
        bAffectTargetTranslationY: boolean;
        bAffectTargetTranslationZ: boolean;
        bAffectTargetRotationX: boolean;
        bAffectTargetRotationY: boolean;
        bAffectTargetRotationZ: boolean;
        bAffectTargetScaleX: boolean;
        bAffectTargetScaleY: boolean;
        bAffectTargetScaleZ: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_BoneDrivenController extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_BoneDrivenController;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BoneDrivenController;

        static Load(InName: string): AnimGraphNode_BoneDrivenController;
    }

    export class SocketReference {
        constructor();
        constructor(SocketName: string);

        SocketName: string;

        static StaticClass(): Class;
    }

    export class BoneSocketTarget {
        constructor();
        constructor(bUseSocket: boolean, BoneReference: BoneReference, SocketReference: SocketReference);

        bUseSocket: boolean;
        BoneReference: BoneReference;
        SocketReference: SocketReference;

        static StaticClass(): Class;
    }

    export class AnimNode_CCDIK extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(EffectorLocation: Vector, EffectorLocationSpace: EBoneControlSpace, EffectorTarget: BoneSocketTarget, TipBone: BoneReference, RootBone: BoneReference, Precision: number, MaxIterations: number, bStartFromTail: boolean, bEnableRotationLimit: boolean, RotationLimitPerJoints: TArray<number>);

        EffectorLocation: Vector;
        EffectorLocationSpace: EBoneControlSpace;
        EffectorTarget: BoneSocketTarget;
        TipBone: BoneReference;
        RootBone: BoneReference;
        Precision: number;
        MaxIterations: number;
        bStartFromTail: boolean;
        bEnableRotationLimit: boolean;
        RotationLimitPerJoints: TArray<number>;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_CCDIK extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_CCDIK;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CCDIK;

        static Load(InName: string): AnimGraphNode_CCDIK;
    }

    export class AnimNode_ConvertComponentToLocalSpace extends AnimNode_Base {
        constructor();
        constructor(ComponentPose: ComponentSpacePoseLink);

        ComponentPose: ComponentSpacePoseLink;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ComponentToLocalSpace extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ConvertComponentToLocalSpace;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ComponentToLocalSpace;

        static Load(InName: string): AnimGraphNode_ComponentToLocalSpace;
    }

    export enum EConstraintOffsetOption { None, Offset_RefPose, EConstraintOffsetOption_MAX }

    export enum ETransformConstraintType { Translation, Rotation, Scale, Parent, ETransformConstraintType_MAX }

    export class FilterOptionPerAxis {
        constructor();
        constructor(bX: boolean, bY: boolean, bZ: boolean);

        bX: boolean;
        bY: boolean;
        bZ: boolean;

        static StaticClass(): Class;
    }

    export class Constraint {
        constructor();
        constructor(TargetBone: BoneReference, OffsetOption: EConstraintOffsetOption, TransformType: ETransformConstraintType, PerAxis: FilterOptionPerAxis);

        TargetBone: BoneReference;
        OffsetOption: EConstraintOffsetOption;
        TransformType: ETransformConstraintType;
        PerAxis: FilterOptionPerAxis;

        static StaticClass(): Class;
    }

    export class AnimNode_Constraint extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(BoneToModify: BoneReference, ConstraintSetup: TArray<Constraint>, ConstraintWeights: TArray<number>);

        BoneToModify: BoneReference;
        ConstraintSetup: TArray<Constraint>;
        ConstraintWeights: TArray<number>;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_Constraint extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_Constraint;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Constraint;

        static Load(InName: string): AnimGraphNode_Constraint;
    }

    export class AnimNode_CopyBone extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(SourceBone: BoneReference, TargetBone: BoneReference, bCopyTranslation: boolean, bCopyRotation: boolean, bCopyScale: boolean, ControlSpace: EBoneControlSpace);

        SourceBone: BoneReference;
        TargetBone: BoneReference;
        bCopyTranslation: boolean;
        bCopyRotation: boolean;
        bCopyScale: boolean;
        ControlSpace: EBoneControlSpace;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_CopyBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_CopyBone;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyBone;

        static Load(InName: string): AnimGraphNode_CopyBone;
    }

    export enum CopyBoneDeltaMode { Accumulate, Copy, CopyBoneDeltaMode_MAX }

    export class AnimNode_CopyBoneDelta extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(SourceBone: BoneReference, TargetBone: BoneReference, bCopyTranslation: boolean, bCopyRotation: boolean, bCopyScale: boolean, CopyMode: CopyBoneDeltaMode, TranslationMultiplier: number, RotationMultiplier: number, ScaleMultiplier: number);

        SourceBone: BoneReference;
        TargetBone: BoneReference;
        bCopyTranslation: boolean;
        bCopyRotation: boolean;
        bCopyScale: boolean;
        CopyMode: CopyBoneDeltaMode;
        TranslationMultiplier: number;
        RotationMultiplier: number;
        ScaleMultiplier: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_CopyBoneDelta extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_CopyBoneDelta;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyBoneDelta;

        static Load(InName: string): AnimGraphNode_CopyBoneDelta;
    }

    export class AnimNode_CopyPoseFromMesh extends AnimNode_Base {
        constructor();
        constructor(SourceMeshComponent: TWeakObjectPtr<SkeletalMeshComponent>, bUseAttachedParent: boolean, bCopyCurves: boolean, bCopyCustomAttributes: boolean, bUseMeshPose: boolean, RootBoneToCopy: string);

        SourceMeshComponent: TWeakObjectPtr<SkeletalMeshComponent>;
        bUseAttachedParent: boolean;
        bCopyCurves: boolean;
        bCopyCustomAttributes: boolean;
        bUseMeshPose: boolean;
        RootBoneToCopy: string;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_CopyPoseFromMesh extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_CopyPoseFromMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyPoseFromMesh;

        static Load(InName: string): AnimGraphNode_CopyPoseFromMesh;
    }

    export class NamedCurveValue {
        constructor();
        constructor(Name: string, Value: number);

        Name: string;
        Value: number;

        static StaticClass(): Class;
    }

    export class CurveSourceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetBindingName(): string;

        GetCurves(OutValues: $Ref<TArray<NamedCurveValue>>): void;

        GetCurveValue(CurveName: string): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveSourceInterface;

        static Load(InName: string): CurveSourceInterface;
    }

    export class AnimNode_CurveSource extends AnimNode_Base {
        constructor();
        constructor(SourcePose: PoseLink, SourceBinding: string, Alpha: number, CurveSource: CurveSourceInterface);

        SourcePose: PoseLink;
        SourceBinding: string;
        Alpha: number;
        CurveSource: CurveSourceInterface;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_CurveSource extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_CurveSource;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CurveSource;

        static Load(InName: string): AnimGraphNode_CurveSource;
    }

    export class AnimGraphNode_CustomProperty extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        KnownExposableProperties: TArray<string>;
        ExposedPropertyNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CustomProperty;

        static Load(InName: string): AnimGraphNode_CustomProperty;
    }

    export enum EBoneRotationSource {
        BRS_KeepComponentSpaceRotation,
        BRS_KeepLocalSpaceRotation,
        BRS_CopyFromTarget,
        BRS_MAX
    }

    export class AnimNode_Fabrik extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(EffectorTransform: Transform, EffectorTarget: BoneSocketTarget, TipBone: BoneReference, RootBone: BoneReference, Precision: number, MaxIterations: number, EffectorTransformSpace: EBoneControlSpace, EffectorRotationSource: EBoneRotationSource, bEnableDebugDraw: boolean, EffectorTransformBone: BoneReference);

        EffectorTransform: Transform;
        EffectorTarget: BoneSocketTarget;
        TipBone: BoneReference;
        RootBone: BoneReference;
        Precision: number;
        MaxIterations: number;
        EffectorTransformSpace: EBoneControlSpace;
        EffectorRotationSource: EBoneRotationSource;
        bEnableDebugDraw: boolean;
        EffectorTransformBone: BoneReference;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_Fabrik extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_Fabrik;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Fabrik;

        static Load(InName: string): AnimGraphNode_Fabrik;
    }

    export class AnimNode_HandIKRetargeting extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(RightHandFK: BoneReference, LeftHandFK: BoneReference, RightHandIK: BoneReference, LeftHandIK: BoneReference, IKBonesToMove: TArray<BoneReference>, HandFKWeight: number);

        RightHandFK: BoneReference;
        LeftHandFK: BoneReference;
        RightHandIK: BoneReference;
        LeftHandIK: BoneReference;
        IKBonesToMove: TArray<BoneReference>;
        HandFKWeight: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_HandIKRetargeting extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_HandIKRetargeting;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_HandIKRetargeting;

        static Load(InName: string): AnimGraphNode_HandIKRetargeting;
    }

    export enum ERefPoseType { EIT_LocalSpace, EIT_Additive, EIT_MAX }

    export class AnimNode_RefPose extends AnimNode_Base {
        constructor();
        constructor(RefPoseType: ERefPoseType);

        RefPoseType: ERefPoseType;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_RefPoseBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_RefPose;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RefPoseBase;

        static Load(InName: string): AnimGraphNode_RefPoseBase;
    }

    export class AnimGraphNode_IdentityPose extends AnimGraphNode_RefPoseBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_IdentityPose;

        static Load(InName: string): AnimGraphNode_IdentityPose;
    }

    export class AnimNode_Inertialization extends AnimNode_Base {
        constructor();
        constructor(Source: PoseLink);

        Source: PoseLink;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_Inertialization extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_Inertialization;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Inertialization;

        static Load(InName: string): AnimGraphNode_Inertialization;
    }

    export class KawaiiPhysicsSettings {
        constructor();
        constructor(Damping: number, WorldDampingLocation: number, WorldDampingRotation: number, Stiffness: number, Radius: number, LimitAngle: number);

        Damping: number;
        WorldDampingLocation: number;
        WorldDampingRotation: number;
        Stiffness: number;
        Radius: number;
        LimitAngle: number;

        static StaticClass(): Class;
    }

    export enum EBoneForwardAxis {
        X_Positive,
        X_Negative,
        Y_Positive,
        Y_Negative,
        Z_Positive,
        Z_Negative,
        EBoneForwardAxis_MAX
    }

    export enum EPlanarConstraint { None, X, Y, Z, EPlanarConstraint_MAX }

    export enum ECollisionLimitType { None, Spherical, Capsule, Planar, ECollisionLimitType_MAX }

    export class CollisionLimitBase {
        constructor();
        constructor(DrivingBone: BoneReference, DrivingBoneNameFromOuter: string, DrivingBoneNameFromOuter_End: string, OffsetLocation: Vector, OffsetRotation: Rotator, MinScale: Vector, MaxScale: Vector, Location: Vector, Rotation: Quat, Scale: Vector, bFromDataAsset: boolean, Guid: Guid, Type: ECollisionLimitType);

        DrivingBone: BoneReference;
        DrivingBoneNameFromOuter: string;
        DrivingBoneNameFromOuter_End: string;
        OffsetLocation: Vector;
        OffsetRotation: Rotator;
        MinScale: Vector;
        MaxScale: Vector;
        Location: Vector;
        Rotation: Quat;
        Scale: Vector;
        bFromDataAsset: boolean;
        Guid: Guid;
        Type: ECollisionLimitType;

        static StaticClass(): Class;
    }

    export class SphericalLimit extends CollisionLimitBase {
        constructor();
        constructor(Radius: number, LimitType: ESphericalLimitType);

        Radius: number;
        LimitType: ESphericalLimitType;

        static StaticClass(): Class;
    }

    export class CapsuleLimit extends CollisionLimitBase {
        constructor();
        constructor(Radius: number, Length: number);

        Radius: number;
        Length: number;

        static StaticClass(): Class;
    }

    export class PlanarLimit extends CollisionLimitBase {
        constructor();
        constructor(Plane: Plane);

        Plane: Plane;

        static StaticClass(): Class;
    }

    export class CollisionLimitDataBase {
        constructor();
        constructor(DrivingBoneName: string, DrivingBoneNameFromOuter: string, DrivingBoneNameFromOuter_End: string, OffsetLocation: Vector, OffsetRotation: Rotator, Location: Vector, Rotation: Quat, MinScale: Vector, MaxScale: Vector, Guid: Guid);

        DrivingBoneName: string;
        DrivingBoneNameFromOuter: string;
        DrivingBoneNameFromOuter_End: string;
        OffsetLocation: Vector;
        OffsetRotation: Rotator;
        Location: Vector;
        Rotation: Quat;
        MinScale: Vector;
        MaxScale: Vector;
        Guid: Guid;

        static StaticClass(): Class;
    }

    export class SphericalLimitData extends CollisionLimitDataBase {
        constructor();
        constructor(Radius: number, LimitType: ESphericalLimitType);

        Radius: number;
        LimitType: ESphericalLimitType;

        static StaticClass(): Class;
    }

    export class CapsuleLimitData extends CollisionLimitDataBase {
        constructor();
        constructor(Radius: number, Length: number);

        Radius: number;
        Length: number;

        static StaticClass(): Class;
    }

    export class PlanarLimitData extends CollisionLimitDataBase {
        constructor();
        constructor(Plane: Plane);

        Plane: Plane;

        static StaticClass(): Class;
    }

    export class KawaiiPhysicsLimitsDataAsset extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SphericalLimitsData: TArray<SphericalLimitData>;
        CapsuleLimitsData: TArray<CapsuleLimitData>;
        PlanarLimitsData: TArray<PlanarLimitData>;
        SphericalLimits: TArray<SphericalLimit>;
        CapsuleLimits: TArray<CapsuleLimit>;
        PlanarLimits: TArray<PlanarLimit>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KawaiiPhysicsLimitsDataAsset;

        static Load(InName: string): KawaiiPhysicsLimitsDataAsset;
    }

    export class KawaiiPhysicsModifyBone {
        constructor();
        constructor(BoneRef: BoneReference, ParentIndex: number, ChildIndexs: TArray<number>, PhysicsSettings: KawaiiPhysicsSettings, Location: Vector, PrevLocation: Vector, PrevRotation: Quat, PoseLocation: Vector, PoseRotation: Quat, PoseScale: Vector, LengthFromRoot: number, bDummy: boolean);

        BoneRef: BoneReference;
        ParentIndex: number;
        ChildIndexs: TArray<number>;
        PhysicsSettings: KawaiiPhysicsSettings;
        Location: Vector;
        PrevLocation: Vector;
        PrevRotation: Quat;
        PoseLocation: Vector;
        PoseRotation: Quat;
        PoseScale: Vector;
        LengthFromRoot: number;
        bDummy: boolean;

        static StaticClass(): Class;
    }

    export class AnimNode_KawaiiPhysics extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(RootBone: BoneReference, ExcludeBones: TArray<BoneReference>, TargetFramerate: number, OverrideTargetFramerate: boolean, PhysicsSettings: KawaiiPhysicsSettings, DampingCurve: CurveFloat, WorldDampingLocationCurve: CurveFloat, WorldDampingRotationCurve: CurveFloat, StiffnessCurve: CurveFloat, RadiusCurve: CurveFloat, LimitAngleCurve: CurveFloat, bUpdatePhysicsSettingsInGame: boolean, DummyBoneLength: number, BoneForwardAxis: EBoneForwardAxis, PlanarConstraint: EPlanarConstraint, SphericalLimits: TArray<SphericalLimit>, CapsuleLimits: TArray<CapsuleLimit>, PlanarLimits: TArray<PlanarLimit>, LimitsDataAsset: KawaiiPhysicsLimitsDataAsset, SphericalLimitsData: TArray<SphericalLimit>, CapsuleLimitsData: TArray<CapsuleLimit>, PlanarLimitsData: TArray<PlanarLimit>, TeleportDistanceThreshold: number, TeleportRotationThreshold: number, Gravity: Vector, bEnableWind: boolean, WindScale: number, ModifyBones: TArray<KawaiiPhysicsModifyBone>, TotalBoneLength: number, PreSkelCompTransform: Transform, bInitPhysicsSettings: boolean, bEditing: boolean, MainAnimInstance: AnimInstance, CapsuleComp: CapsuleComponent, SphereComp: SphereComponent, PlaneComp: StaticMeshComponent, FromDrivingBone: string, ShowCapsule: boolean, ShowShpere: boolean, ShowPlane: boolean);

        RootBone: BoneReference;
        ExcludeBones: TArray<BoneReference>;
        TargetFramerate: number;
        OverrideTargetFramerate: boolean;
        PhysicsSettings: KawaiiPhysicsSettings;
        DampingCurve: CurveFloat;
        WorldDampingLocationCurve: CurveFloat;
        WorldDampingRotationCurve: CurveFloat;
        StiffnessCurve: CurveFloat;
        RadiusCurve: CurveFloat;
        LimitAngleCurve: CurveFloat;
        bUpdatePhysicsSettingsInGame: boolean;
        DummyBoneLength: number;
        BoneForwardAxis: EBoneForwardAxis;
        PlanarConstraint: EPlanarConstraint;
        SphericalLimits: TArray<SphericalLimit>;
        CapsuleLimits: TArray<CapsuleLimit>;
        PlanarLimits: TArray<PlanarLimit>;
        LimitsDataAsset: KawaiiPhysicsLimitsDataAsset;
        SphericalLimitsData: TArray<SphericalLimit>;
        CapsuleLimitsData: TArray<CapsuleLimit>;
        PlanarLimitsData: TArray<PlanarLimit>;
        TeleportDistanceThreshold: number;
        TeleportRotationThreshold: number;
        Gravity: Vector;
        bEnableWind: boolean;
        WindScale: number;
        ModifyBones: TArray<KawaiiPhysicsModifyBone>;
        TotalBoneLength: number;
        PreSkelCompTransform: Transform;
        bInitPhysicsSettings: boolean;
        bEditing: boolean;
        MainAnimInstance: AnimInstance;
        CapsuleComp: CapsuleComponent;
        SphereComp: SphereComponent;
        PlaneComp: StaticMeshComponent;
        FromDrivingBone: string;
        ShowCapsule: boolean;
        ShowShpere: boolean;
        ShowPlane: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_KawaiiPhysics extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_KawaiiPhysics;
        bEnableDebugDrawBone: boolean;
        bEnableDebugBoneLengthRate: boolean;
        bEnableDebugDrawAngleLimit: boolean;
        bEnableDebugDrawSphereLimit: boolean;
        bEnableDebugDrawCapsuleLimit: boolean;
        bEnableDebugDrawPlanerLimit: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_KawaiiPhysics;

        static Load(InName: string): AnimGraphNode_KawaiiPhysics;
    }

    export class BranchFilter {
        constructor();
        constructor(BoneName: string, BlendDepth: number);

        BoneName: string;
        BlendDepth: number;

        static StaticClass(): Class;
    }

    export class InputBlendPose {
        constructor();
        constructor(BranchFilters: TArray<BranchFilter>);

        BranchFilters: TArray<BranchFilter>;

        static StaticClass(): Class;
    }

    export enum ECurveBlendOption {
        Override,
        DoNotOverride,
        NormalizeByWeight,
        BlendByWeight,
        UseBasePose,
        UseMaxValue,
        UseMinValue,
        ECurveBlendOption_MAX
    }

    export class PerBoneBlendWeight {
        constructor();
        constructor(SourceIndex: number, BlendWeight: number);

        SourceIndex: number;
        BlendWeight: number;

        static StaticClass(): Class;
    }

    export class AnimNode_LayeredBoneBlend extends AnimNode_Base {
        constructor();
        constructor(BasePose: PoseLink, BlendPoses: TArray<PoseLink>, LayerSetup: TArray<InputBlendPose>, BlendWeights: TArray<number>, bMeshSpaceRotationBlend: boolean, bMeshSpaceScaleBlend: boolean, CurveBlendOption: ECurveBlendOption, bBlendRootMotionBasedOnRootBone: boolean, LODThreshold: number, PerBoneBlendWeights: TArray<PerBoneBlendWeight>, SkeletonGuid: Guid, VirtualBoneGuid: Guid);

        BasePose: PoseLink;
        BlendPoses: TArray<PoseLink>;
        LayerSetup: TArray<InputBlendPose>;
        BlendWeights: TArray<number>;
        bMeshSpaceRotationBlend: boolean;
        bMeshSpaceScaleBlend: boolean;
        CurveBlendOption: ECurveBlendOption;
        bBlendRootMotionBasedOnRootBone: boolean;
        LODThreshold: number;
        PerBoneBlendWeights: TArray<PerBoneBlendWeight>;
        SkeletonGuid: Guid;
        VirtualBoneGuid: Guid;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_LayeredBoneBlend extends AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_LayeredBoneBlend;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LayeredBoneBlend;

        static Load(InName: string): AnimGraphNode_LayeredBoneBlend;
    }

    export class AnimLegIKDefinition {
        constructor();
        constructor(IKFootBone: BoneReference, FKFootBone: BoneReference, NumBonesInLimb: number, MinRotationAngle: number, FootBoneForwardAxis: EAxis, HingeRotationAxis: EAxis, bEnableRotationLimit: boolean, bEnableKneeTwistCorrection: boolean);

        IKFootBone: BoneReference;
        FKFootBone: BoneReference;
        NumBonesInLimb: number;
        MinRotationAngle: number;
        FootBoneForwardAxis: EAxis;
        HingeRotationAxis: EAxis;
        bEnableRotationLimit: boolean;
        bEnableKneeTwistCorrection: boolean;

        static StaticClass(): Class;
    }

    export class AnimNode_LegIK extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(ReachPrecision: number, MaxIterations: number, LegsDefinition: TArray<AnimLegIKDefinition>);

        ReachPrecision: number;
        MaxIterations: number;
        LegsDefinition: TArray<AnimLegIKDefinition>;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_LegIK extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_LegIK;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LegIK;

        static Load(InName: string): AnimGraphNode_LegIK;
    }

    export class AnimGraphNode_LinkedAnimGraphBase extends AnimGraphNode_CustomProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimGraphBase;

        static Load(InName: string): AnimGraphNode_LinkedAnimGraphBase;
    }

    export class AnimNode_CustomProperty extends AnimNode_Base {
        constructor();
        constructor(SourcePropertyNames: TArray<string>, DestPropertyNames: TArray<string>, TargetInstance: Object);

        SourcePropertyNames: TArray<string>;
        DestPropertyNames: TArray<string>;
        TargetInstance: Object;

        static StaticClass(): Class;
    }

    export class AnimNode_LinkedAnimGraph extends AnimNode_CustomProperty {
        constructor();
        constructor(InputPoses: TArray<PoseLink>, InputPoseNames: TArray<string>, InstanceClass: Class, Tag: string, bReceiveNotifiesFromLinkedInstances: boolean, bPropagateNotifiesToLinkedInstances: boolean);

        InputPoses: TArray<PoseLink>;
        InputPoseNames: TArray<string>;
        InstanceClass: Class;
        Tag: string;
        bReceiveNotifiesFromLinkedInstances: boolean;
        bPropagateNotifiesToLinkedInstances: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_LinkedAnimGraph extends AnimGraphNode_LinkedAnimGraphBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_LinkedAnimGraph;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimGraph;

        static Load(InName: string): AnimGraphNode_LinkedAnimGraph;
    }

    export class AnimNode_LinkedAnimLayer extends AnimNode_LinkedAnimGraph {
        constructor();
        constructor(Interface: Class, Layer: string);

        Interface: Class;
        Layer: string;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_LinkedAnimLayer extends AnimGraphNode_LinkedAnimGraphBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_LinkedAnimLayer;
        InterfaceGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimLayer;

        static Load(InName: string): AnimGraphNode_LinkedAnimLayer;
    }

    export class AnimNode_LinkedInputPose extends AnimNode_Base {
        constructor();
        constructor(Name: string, Graph: string, InputPose: PoseLink);

        Name: string;
        Graph: string;
        InputPose: PoseLink;

        static StaticClass(): Class;
    }

    export class AnimBlueprintFunctionPinInfo {
        constructor();
        constructor(Name: string, Type: EdGraphPinType);

        Name: string;
        Type: EdGraphPinType;

        static StaticClass(): Class;
    }

    export class MemberReference {
        constructor();
        constructor(MemberParent: Object, MemberScope: string, MemberName: string, MemberGuid: Guid, bSelfContext: boolean, bWasDeprecated: boolean);

        MemberParent: Object;
        MemberScope: string;
        MemberName: string;
        MemberGuid: Guid;
        bSelfContext: boolean;
        bWasDeprecated: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_LinkedInputPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_LinkedInputPose;
        Inputs: TArray<AnimBlueprintFunctionPinInfo>;
        FunctionReference: MemberReference;
        InputPoseIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedInputPose;

        static Load(InName: string): AnimGraphNode_LinkedInputPose;
    }

    export class AnimGraphNode_LocalRefPose extends AnimGraphNode_RefPoseBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LocalRefPose;

        static Load(InName: string): AnimGraphNode_LocalRefPose;
    }

    export class AnimNode_ConvertLocalToComponentSpace extends AnimNode_Base {
        constructor();
        constructor(LocalPose: PoseLink);

        LocalPose: PoseLink;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_LocalToComponentSpace extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ConvertLocalToComponentSpace;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LocalToComponentSpace;

        static Load(InName: string): AnimGraphNode_LocalToComponentSpace;
    }

    export class Axis {
        constructor();
        constructor(Axis: Vector, bInLocalSpace: boolean);

        Axis: Vector;
        bInLocalSpace: boolean;

        static StaticClass(): Class;
    }

    export enum EInterpolationBlend {
        Linear,
        Cubic,
        Sinusoidal,
        EaseInOutExponent2,
        EaseInOutExponent3,
        EaseInOutExponent4,
        EaseInOutExponent5,
        MAX
    }

    export enum EAxisOption { X, Y, Z, X_Neg, Y_Neg, Z_Neg, Custom, EAxisOption_MAX }

    export class AnimNode_LookAt extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(BoneToModify: BoneReference, LookAtTarget: BoneSocketTarget, LookAtLocation: Vector, LookAt_Axis: Axis, bUseLookUpAxis: boolean, InterpolationType: EInterpolationBlend, LookUp_Axis: Axis, LookAtClamp: number, InterpolationTime: number, InterpolationTriggerThreashold: number, LookAtBone: BoneReference, LookAtSocket: string, LookAtAxis: EAxisOption, CustomLookAtAxis: Vector, LookUpAxis: EAxisOption, CustomLookUpAxis: Vector);

        BoneToModify: BoneReference;
        LookAtTarget: BoneSocketTarget;
        LookAtLocation: Vector;
        LookAt_Axis: Axis;
        bUseLookUpAxis: boolean;
        InterpolationType: EInterpolationBlend;
        LookUp_Axis: Axis;
        LookAtClamp: number;
        InterpolationTime: number;
        InterpolationTriggerThreashold: number;
        LookAtBone: BoneReference;
        LookAtSocket: string;
        LookAtAxis: EAxisOption;
        CustomLookAtAxis: Vector;
        LookUpAxis: EAxisOption;
        CustomLookUpAxis: Vector;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_LookAt extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_LookAt;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LookAt;

        static Load(InName: string): AnimGraphNode_LookAt;
    }

    export class AnimNode_MakeDynamicAdditive extends AnimNode_Base {
        constructor();
        constructor(Base: PoseLink, Additive: PoseLink, bMeshSpaceAdditive: boolean);

        Base: PoseLink;
        Additive: PoseLink;
        bMeshSpaceAdditive: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_MakeDynamicAdditive extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_MakeDynamicAdditive;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MakeDynamicAdditive;

        static Load(InName: string): AnimGraphNode_MakeDynamicAdditive;
    }

    export class AnimNode_MeshSpaceRefPose extends AnimNode_Base {
        constructor();

        static StaticClass(): Class;
    }

    export class AnimGraphNode_MeshRefPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_MeshSpaceRefPose;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MeshRefPose;

        static Load(InName: string): AnimGraphNode_MeshRefPose;
    }

    export enum EBoneModificationMode { BMM_Ignore, BMM_Replace, BMM_Additive, BMM_MAX }

    export class AnimNode_ModifyBone extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(BoneToModify: BoneReference, Translation: Vector, Rotation: Rotator, Scale: Vector, TranslationMode: EBoneModificationMode, RotationMode: EBoneModificationMode, ScaleMode: EBoneModificationMode, TranslationSpace: EBoneControlSpace, RotationSpace: EBoneControlSpace, ScaleSpace: EBoneControlSpace);

        BoneToModify: BoneReference;
        Translation: Vector;
        Rotation: Rotator;
        Scale: Vector;
        TranslationMode: EBoneModificationMode;
        RotationMode: EBoneModificationMode;
        ScaleMode: EBoneModificationMode;
        TranslationSpace: EBoneControlSpace;
        RotationSpace: EBoneControlSpace;
        ScaleSpace: EBoneControlSpace;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ModifyBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ModifyBone;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ModifyBone;

        static Load(InName: string): AnimGraphNode_ModifyBone;
    }

    export enum EModifyCurveApplyMode {
        Add,
        Scale,
        Blend,
        WeightedMovingAverage,
        RemapCurve,
        EModifyCurveApplyMode_MAX
    }

    export class AnimNode_ModifyCurve extends AnimNode_Base {
        constructor();
        constructor(SourcePose: PoseLink, CurveValues: TArray<number>, CurveNames: TArray<string>, Alpha: number, ApplyMode: EModifyCurveApplyMode);

        SourcePose: PoseLink;
        CurveValues: TArray<number>;
        CurveNames: TArray<string>;
        Alpha: number;
        ApplyMode: EModifyCurveApplyMode;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ModifyCurve extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ModifyCurve;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ModifyCurve;

        static Load(InName: string): AnimGraphNode_ModifyCurve;
    }

    export class AnimNode_MultiWayBlend extends AnimNode_Base {
        constructor();
        constructor(Poses: TArray<PoseLink>, DesiredAlphas: TArray<number>, AlphaScaleBias: InputScaleBias, bAdditiveNode: boolean, bNormalizeAlpha: boolean);

        Poses: TArray<PoseLink>;
        DesiredAlphas: TArray<number>;
        AlphaScaleBias: InputScaleBias;
        bAdditiveNode: boolean;
        bNormalizeAlpha: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_MultiWayBlend extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_MultiWayBlend;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MultiWayBlend;

        static Load(InName: string): AnimGraphNode_MultiWayBlend;
    }

    export class AnimNode_ObserveBone extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(BoneToObserve: BoneReference, DisplaySpace: EBoneControlSpace, bRelativeToRefPose: boolean, Translation: Vector, Rotation: Rotator, Scale: Vector);

        BoneToObserve: BoneReference;
        DisplaySpace: EBoneControlSpace;
        bRelativeToRefPose: boolean;
        Translation: Vector;
        Rotation: Rotator;
        Scale: Vector;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ObserveBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ObserveBone;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ObserveBone;

        static Load(InName: string): AnimGraphNode_ObserveBone;
    }

    export class AnimGraphNode_PoseHandler extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseHandler;

        static Load(InName: string): AnimGraphNode_PoseHandler;
    }

    export class AnimNode_PoseHandler extends AnimNode_AssetPlayerBase {
        constructor();
        constructor(PoseAsset: PoseAsset);

        PoseAsset: PoseAsset;

        static StaticClass(): Class;
    }

    export class AnimNode_PoseBlendNode extends AnimNode_PoseHandler {
        constructor();
        constructor(SourcePose: PoseLink, BlendOption: EAlphaBlendOption, CustomCurve: CurveFloat);

        SourcePose: PoseLink;
        BlendOption: EAlphaBlendOption;
        CustomCurve: CurveFloat;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_PoseBlendNode extends AnimGraphNode_PoseHandler {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_PoseBlendNode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseBlendNode;

        static Load(InName: string): AnimGraphNode_PoseBlendNode;
    }

    export class AnimNode_PoseByName extends AnimNode_PoseHandler {
        constructor();
        constructor(PoseName: string, PoseWeight: number);

        PoseName: string;
        PoseWeight: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_PoseByName extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_PoseByName;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseByName;

        static Load(InName: string): AnimGraphNode_PoseByName;
    }

    export class PoseDriverTransform {
        constructor();
        constructor(TargetTranslation: Vector, TargetRotation: Rotator);

        TargetTranslation: Vector;
        TargetRotation: Rotator;

        static StaticClass(): Class;
    }

    export enum ERBFDistanceMethod {
        Euclidean,
        Quaternion,
        SwingAngle,
        TwistAngle,
        DefaultMethod,
        ERBFDistanceMethod_MAX
    }

    export enum ERBFFunctionType {
        Gaussian,
        Exponential,
        Linear,
        Cubic,
        Quintic,
        DefaultFunction,
        ERBFFunctionType_MAX
    }

    export class PoseDriverTarget {
        constructor();
        constructor(BoneTransforms: TArray<PoseDriverTransform>, TargetRotation: Rotator, TargetScale: number, DistanceMethod: ERBFDistanceMethod, FunctionType: ERBFFunctionType, bApplyCustomCurve: boolean, CustomCurve: RichCurve, DrivenName: string, bIsHidden: boolean);

        BoneTransforms: TArray<PoseDriverTransform>;
        TargetRotation: Rotator;
        TargetScale: number;
        DistanceMethod: ERBFDistanceMethod;
        FunctionType: ERBFFunctionType;
        bApplyCustomCurve: boolean;
        CustomCurve: RichCurve;
        DrivenName: string;
        bIsHidden: boolean;

        static StaticClass(): Class;
    }

    export enum ERBFSolverType { Additive, Interpolative, ERBFSolverType_MAX }

    export enum EBoneAxis { BA_X, BA_Y, BA_Z, BA_MAX }

    export enum ERBFNormalizeMethod {
        OnlyNormalizeAboveOne,
        AlwaysNormalize,
        NormalizeWithinMedian,
        NoNormalization,
        ERBFNormalizeMethod_MAX
    }

    export class RBFParams {
        constructor();
        constructor(TargetDimensions: number, SolverType: ERBFSolverType, Radius: number, bAutomaticRadius: boolean, Function: ERBFFunctionType, DistanceMethod: ERBFDistanceMethod, TwistAxis: EBoneAxis, WeightThreshold: number, NormalizeMethod: ERBFNormalizeMethod, MedianReference: Vector, MedianMin: number, MedianMax: number);

        TargetDimensions: number;
        SolverType: ERBFSolverType;
        Radius: number;
        bAutomaticRadius: boolean;
        Function: ERBFFunctionType;
        DistanceMethod: ERBFDistanceMethod;
        TwistAxis: EBoneAxis;
        WeightThreshold: number;
        NormalizeMethod: ERBFNormalizeMethod;
        MedianReference: Vector;
        MedianMin: number;
        MedianMax: number;

        static StaticClass(): Class;
    }

    export enum EPoseDriverType { SwingAndTwist, SwingOnly, Translation, EPoseDriverType_MAX }

    export enum EPoseDriverSource { Rotation, Translation, EPoseDriverSource_MAX }

    export enum EPoseDriverOutput { DrivePoses, DriveCurves, EPoseDriverOutput_MAX }

    export class AnimNode_PoseDriver extends AnimNode_PoseHandler {
        constructor();
        constructor(SourcePose: PoseLink, SourceBones: TArray<BoneReference>, OnlyDriveBones: TArray<BoneReference>, PoseTargets: TArray<PoseDriverTarget>, EvalSpaceBone: BoneReference, RBFParams: RBFParams, SourceBone: BoneReference, TwistAxis: EBoneAxis, Type: EPoseDriverType, RadialScaling: number, DriveSource: EPoseDriverSource, DriveOutput: EPoseDriverOutput, bOnlyDriveSelectedBones: boolean, bSoloDrivenOnly: boolean, LODThreshold: number);

        SourcePose: PoseLink;
        SourceBones: TArray<BoneReference>;
        OnlyDriveBones: TArray<BoneReference>;
        PoseTargets: TArray<PoseDriverTarget>;
        EvalSpaceBone: BoneReference;
        RBFParams: RBFParams;
        SourceBone: BoneReference;
        TwistAxis: EBoneAxis;
        Type: EPoseDriverType;
        RadialScaling: number;
        DriveSource: EPoseDriverSource;
        DriveOutput: EPoseDriverOutput;
        bOnlyDriveSelectedBones: boolean;
        bSoloDrivenOnly: boolean;
        LODThreshold: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_PoseDriver extends AnimGraphNode_PoseHandler {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_PoseDriver;
        AxisLength: number;
        ConeSubdivision: number;
        bDrawDebugCones: boolean;
        LastPreviewComponent: SkeletalMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseDriver;

        static Load(InName: string): AnimGraphNode_PoseDriver;
    }

    export enum ESnapshotSourceMode { NamedSnapshot, SnapshotPin, ESnapshotSourceMode_MAX }

    export class AnimNode_PoseSnapshot extends AnimNode_Base {
        constructor();
        constructor(SnapshotName: string, Snapshot: PoseSnapshot, Mode: ESnapshotSourceMode);

        SnapshotName: string;
        Snapshot: PoseSnapshot;
        Mode: ESnapshotSourceMode;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_PoseSnapshot extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_PoseSnapshot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseSnapshot;

        static Load(InName: string): AnimGraphNode_PoseSnapshot;
    }

    export class RandomPlayerSequenceEntry {
        constructor();
        constructor(Sequence: AnimSequence, ChanceToPlay: number, MinLoopCount: number, MaxLoopCount: number, MinPlayRate: number, MaxPlayRate: number, BlendIn: AlphaBlend);

        Sequence: AnimSequence;
        ChanceToPlay: number;
        MinLoopCount: number;
        MaxLoopCount: number;
        MinPlayRate: number;
        MaxPlayRate: number;
        BlendIn: AlphaBlend;

        static StaticClass(): Class;
    }

    export class AnimNode_RandomPlayer extends AnimNode_Base {
        constructor();
        constructor(Entries: TArray<RandomPlayerSequenceEntry>, bShuffleMode: boolean);

        Entries: TArray<RandomPlayerSequenceEntry>;
        bShuffleMode: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_RandomPlayer extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_RandomPlayer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RandomPlayer;

        static Load(InName: string): AnimGraphNode_RandomPlayer;
    }

    export class AnimNode_ResetRoot extends AnimNode_SkeletalControlBase {
        constructor();

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ResetRoot extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ResetRoot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ResetRoot;

        static Load(InName: string): AnimGraphNode_ResetRoot;
    }

    export class SimSpaceSettings {
        constructor();
        constructor(MasterAlpha: number, VelocityScaleZ: number, MaxLinearVelocity: number, MaxAngularVelocity: number, MaxLinearAcceleration: number, MaxAngularAcceleration: number, ExternalLinearDrag: number, ExternalLinearDragV: Vector, ExternalLinearVelocity: Vector, ExternalAngularVelocity: Vector);

        MasterAlpha: number;
        VelocityScaleZ: number;
        MaxLinearVelocity: number;
        MaxAngularVelocity: number;
        MaxLinearAcceleration: number;
        MaxAngularAcceleration: number;
        ExternalLinearDrag: number;
        ExternalLinearDragV: Vector;
        ExternalLinearVelocity: Vector;
        ExternalAngularVelocity: Vector;

        static StaticClass(): Class;
    }

    export enum ESimulationSpace { ComponentSpace, WorldSpace, BaseBoneSpace, ESimulationSpace_MAX }

    export class AnimNode_RigidBody extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(OverridePhysicsAsset: PhysicsAsset, OverrideWorldGravity: Vector, ExternalForce: Vector, ComponentLinearAccScale: Vector, ComponentLinearVelScale: Vector, ComponentAppliedLinearAccClamp: Vector, SimSpaceSettings: SimSpaceSettings, CachedBoundsScale: number, BaseBoneRef: BoneReference, OverlapChannel: ECollisionChannel, SimulationSpace: ESimulationSpace, bForceDisableCollisionBetweenConstraintBodies: boolean, bEnableWorldGeometry: boolean, bOverrideWorldGravity: boolean, bTransferBoneVelocities: boolean, bFreezeIncomingPoseOnStart: boolean, bClampLinearTranslationLimitToRefPose: boolean, WorldSpaceMinimumScale: number, EvaluationResetTime: number, bComponentSpaceSimulation: boolean);

        OverridePhysicsAsset: PhysicsAsset;
        OverrideWorldGravity: Vector;
        ExternalForce: Vector;
        ComponentLinearAccScale: Vector;
        ComponentLinearVelScale: Vector;
        ComponentAppliedLinearAccClamp: Vector;
        SimSpaceSettings: SimSpaceSettings;
        CachedBoundsScale: number;
        BaseBoneRef: BoneReference;
        OverlapChannel: ECollisionChannel;
        SimulationSpace: ESimulationSpace;
        bForceDisableCollisionBetweenConstraintBodies: boolean;
        bEnableWorldGeometry: boolean;
        bOverrideWorldGravity: boolean;
        bTransferBoneVelocities: boolean;
        bFreezeIncomingPoseOnStart: boolean;
        bClampLinearTranslationLimitToRefPose: boolean;
        WorldSpaceMinimumScale: number;
        EvaluationResetTime: number;
        bComponentSpaceSimulation: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_RigidBody extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_RigidBody;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RigidBody;

        static Load(InName: string): AnimGraphNode_RigidBody;
    }

    export class AnimGraphNode_Root extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_Root;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Root;

        static Load(InName: string): AnimGraphNode_Root;
    }

    export class AnimNode_RotateRootBone extends AnimNode_Base {
        constructor();
        constructor(BasePose: PoseLink, Pitch: number, Yaw: number, PitchScaleBiasClamp: InputScaleBiasClamp, YawScaleBiasClamp: InputScaleBiasClamp, MeshToComponent: Rotator);

        BasePose: PoseLink;
        Pitch: number;
        Yaw: number;
        PitchScaleBiasClamp: InputScaleBiasClamp;
        YawScaleBiasClamp: InputScaleBiasClamp;
        MeshToComponent: Rotator;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_RotateRootBone extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_RotateRootBone;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotateRootBone;

        static Load(InName: string): AnimGraphNode_RotateRootBone;
    }

    export class AnimNode_RotationMultiplier extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(TargetBone: BoneReference, SourceBone: BoneReference, Multiplier: number, RotationAxisToRefer: EBoneAxis, bIsAdditive: boolean);

        TargetBone: BoneReference;
        SourceBone: BoneReference;
        Multiplier: number;
        RotationAxisToRefer: EBoneAxis;
        bIsAdditive: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_RotationMultiplier extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_RotationMultiplier;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotationMultiplier;

        static Load(InName: string): AnimGraphNode_RotationMultiplier;
    }

    export class AnimNode_RotationOffsetBlendSpace extends AnimNode_BlendSpacePlayer {
        constructor();
        constructor(BasePose: PoseLink, LODThreshold: number, Alpha: number, AlphaScaleBias: InputScaleBias, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: InputScaleBiasClamp, AlphaInputType: EAnimAlphaInputType, bAlphaBoolEnabled: boolean);

        BasePose: PoseLink;
        LODThreshold: number;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: InputScaleBiasClamp;
        AlphaInputType: EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_RotationOffsetBlendSpace extends AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_RotationOffsetBlendSpace;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotationOffsetBlendSpace;

        static Load(InName: string): AnimGraphNode_RotationOffsetBlendSpace;
    }

    export class AnimNode_SaveCachedPose extends AnimNode_Base {
        constructor();
        constructor(Pose: PoseLink, CachePoseName: string);

        Pose: PoseLink;
        CachePoseName: string;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_SaveCachedPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_SaveCachedPose;
        CacheName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SaveCachedPose;

        static Load(InName: string): AnimGraphNode_SaveCachedPose;
    }

    export enum EScaleChainInitialLength {
        FixedDefaultLengthValue,
        Distance,
        ChainLength,
        EScaleChainInitialLength_MAX
    }

    export class AnimNode_ScaleChainLength extends AnimNode_Base {
        constructor();
        constructor(InputPose: PoseLink, DefaultChainLength: number, ChainStartBone: BoneReference, ChainEndBone: BoneReference, TargetLocation: Vector, Alpha: number, AlphaScaleBias: InputScaleBias, ChainInitialLength: EScaleChainInitialLength);

        InputPose: PoseLink;
        DefaultChainLength: number;
        ChainStartBone: BoneReference;
        ChainEndBone: BoneReference;
        TargetLocation: Vector;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        ChainInitialLength: EScaleChainInitialLength;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_ScaleChainLength extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_ScaleChainLength;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ScaleChainLength;

        static Load(InName: string): AnimGraphNode_ScaleChainLength;
    }

    export enum ESequenceEvalReinit { NoReset, StartPosition, ExplicitTime, ESequenceEvalReinit_MAX }

    export class AnimNode_SequenceEvaluator extends AnimNode_AssetPlayerBase {
        constructor();
        constructor(Sequence: AnimSequenceBase, ExplicitTime: number, bShouldLoop: boolean, bTeleportToExplicitTime: boolean, ReinitializationBehavior: ESequenceEvalReinit, StartPosition: number);

        Sequence: AnimSequenceBase;
        ExplicitTime: number;
        bShouldLoop: boolean;
        bTeleportToExplicitTime: boolean;
        ReinitializationBehavior: ESequenceEvalReinit;
        StartPosition: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_SequenceEvaluator extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_SequenceEvaluator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SequenceEvaluator;

        static Load(InName: string): AnimGraphNode_SequenceEvaluator;
    }

    export class AnimNode_SequencePlayer extends AnimNode_AssetPlayerBase {
        constructor();
        constructor(Sequence: AnimSequenceBase, PlayRateBasis: number, PlayRate: number, PlayRateScaleBiasClamp: InputScaleBiasClamp, StartPosition: number, bLoopAnimation: boolean);

        Sequence: AnimSequenceBase;
        PlayRateBasis: number;
        PlayRate: number;
        PlayRateScaleBiasClamp: InputScaleBiasClamp;
        StartPosition: number;
        bLoopAnimation: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_SequencePlayer extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_SequencePlayer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SequencePlayer;

        static Load(InName: string): AnimGraphNode_SequencePlayer;
    }

    export class AnimNode_Slot extends AnimNode_Base {
        constructor();
        constructor(Source: PoseLink, SlotName: string, bAlwaysUpdateSourcePose: boolean);

        Source: PoseLink;
        SlotName: string;
        bAlwaysUpdateSourcePose: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_Slot extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_Slot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Slot;

        static Load(InName: string): AnimGraphNode_Slot;
    }

    export enum ESplineBoneAxis { None, X, Y, Z, ESplineBoneAxis_MAX }

    export class AnimNode_SplineIK extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(StartBone: BoneReference, EndBone: BoneReference, BoneAxis: ESplineBoneAxis, bAutoCalculateSpline: boolean, PointCount: number, ControlPoints: TArray<Transform>, Roll: number, TwistStart: number, TwistEnd: number, TwistBlend: AlphaBlend, Stretch: number, Offset: number);

        StartBone: BoneReference;
        EndBone: BoneReference;
        BoneAxis: ESplineBoneAxis;
        bAutoCalculateSpline: boolean;
        PointCount: number;
        ControlPoints: TArray<Transform>;
        Roll: number;
        TwistStart: number;
        TwistEnd: number;
        TwistBlend: AlphaBlend;
        Stretch: number;
        Offset: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_SplineIK extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_SplineIK;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SplineIK;

        static Load(InName: string): AnimGraphNode_SplineIK;
    }

    export class AnimNode_SpringBone extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(SpringBone: BoneReference, MaxDisplacement: number, SpringStiffness: number, SpringDamping: number, ErrorResetThresh: number, bNoZSpring: boolean, bLimitDisplacement: boolean, bTranslateX: boolean, bTranslateY: boolean, bTranslateZ: boolean, bRotateX: boolean, bRotateY: boolean, bRotateZ: boolean);

        SpringBone: BoneReference;
        MaxDisplacement: number;
        SpringStiffness: number;
        SpringDamping: number;
        ErrorResetThresh: number;
        bNoZSpring: boolean;
        bLimitDisplacement: boolean;
        bTranslateX: boolean;
        bTranslateY: boolean;
        bTranslateZ: boolean;
        bRotateX: boolean;
        bRotateY: boolean;
        bRotateZ: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_SpringBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_SpringBone;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SpringBone;

        static Load(InName: string): AnimGraphNode_SpringBone;
    }

    export class AnimNode_StateMachine extends AnimNode_Base {
        constructor();
        constructor(StateMachineIndexInClass: number, MaxTransitionsPerFrame: number, bSkipFirstUpdateTransition: boolean, bReinitializeOnBecomingRelevant: boolean);

        StateMachineIndexInClass: number;
        MaxTransitionsPerFrame: number;
        bSkipFirstUpdateTransition: boolean;
        bReinitializeOnBecomingRelevant: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_StateMachine extends AnimGraphNode_StateMachineBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_StateMachine;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateMachine;

        static Load(InName: string): AnimGraphNode_StateMachine;
    }

    export class RotationLimit {
        constructor();
        constructor(LimitMin: Vector, LimitMax: Vector);

        LimitMin: Vector;
        LimitMax: Vector;

        static StaticClass(): Class;
    }

    export class AnimNode_Trail extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(TrailBone: BoneReference, ChainLength: number, ChainBoneAxis: EAxis, bInvertChainBoneAxis: boolean, bLimitStretch: boolean, bLimitRotation: boolean, bUsePlanarLimit: boolean, bActorSpaceFakeVel: boolean, bReorientParentToChild: boolean, bEnableDebug: boolean, bShowBaseMotion: boolean, bShowTrailLocation: boolean, bShowLimit: boolean, DebugLifeTime: number, TrailRelaxation: number, MaxDeltaTime: number, RelaxationSpeedScale: number, TrailRelaxationSpeed: RuntimeFloatCurve, RelaxationSpeedScaleInputProcessor: InputScaleBiasClamp, RotationLimits: TArray<RotationLimit>, RotationOffsets: TArray<Vector>, PlanarLimits: TArray<AnimPhysPlanarLimit>, StretchLimit: number, FakeVelocity: Vector, BaseJoint: BoneReference, TrailBoneRotationBlendAlpha: number, LastBoneRotationAnimAlphaBlend: number);

        TrailBone: BoneReference;
        ChainLength: number;
        ChainBoneAxis: EAxis;
        bInvertChainBoneAxis: boolean;
        bLimitStretch: boolean;
        bLimitRotation: boolean;
        bUsePlanarLimit: boolean;
        bActorSpaceFakeVel: boolean;
        bReorientParentToChild: boolean;
        bEnableDebug: boolean;
        bShowBaseMotion: boolean;
        bShowTrailLocation: boolean;
        bShowLimit: boolean;
        DebugLifeTime: number;
        TrailRelaxation: number;
        MaxDeltaTime: number;
        RelaxationSpeedScale: number;
        TrailRelaxationSpeed: RuntimeFloatCurve;
        RelaxationSpeedScaleInputProcessor: InputScaleBiasClamp;
        RotationLimits: TArray<RotationLimit>;
        RotationOffsets: TArray<Vector>;
        PlanarLimits: TArray<AnimPhysPlanarLimit>;
        StretchLimit: number;
        FakeVelocity: Vector;
        BaseJoint: BoneReference;
        TrailBoneRotationBlendAlpha: number;
        LastBoneRotationAnimAlphaBlend: number;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_Trail extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_Trail;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Trail;

        static Load(InName: string): AnimGraphNode_Trail;
    }

    export enum EEvaluatorDataSource { EDS_SourcePose, EDS_DestinationPose, EDS_MAX }

    export enum EEvaluatorMode { EM_Standard, EM_Freeze, EM_DelayedFreeze, EM_MAX }

    export class AnimNode_TransitionPoseEvaluator extends AnimNode_Base {
        constructor();
        constructor(FramesToCachePose: number, DataSource: EEvaluatorDataSource, EvaluatorMode: EEvaluatorMode);

        FramesToCachePose: number;
        DataSource: EEvaluatorDataSource;
        EvaluatorMode: EEvaluatorMode;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_TransitionPoseEvaluator extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_TransitionPoseEvaluator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TransitionPoseEvaluator;

        static Load(InName: string): AnimGraphNode_TransitionPoseEvaluator;
    }

    export class ReferenceBoneFrame {
        constructor();
        constructor(Bone: BoneReference, Axis: Axis);

        Bone: BoneReference;
        Axis: Axis;

        static StaticClass(): Class;
    }

    export class AnimCurveParam {
        constructor();
        constructor(Name: string);

        Name: string;

        static StaticClass(): Class;
    }

    export class AnimNode_TwistCorrectiveNode extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(BaseFrame: ReferenceBoneFrame, TwistFrame: ReferenceBoneFrame, TwistPlaneNormalAxis: Axis, RangeMax: number, RemappedMin: number, RemappedMax: number, Curve: AnimCurveParam);

        BaseFrame: ReferenceBoneFrame;
        TwistFrame: ReferenceBoneFrame;
        TwistPlaneNormalAxis: Axis;
        RangeMax: number;
        RemappedMin: number;
        RemappedMax: number;
        Curve: AnimCurveParam;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_TwistCorrectiveNode extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_TwistCorrectiveNode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwistCorrectiveNode;

        static Load(InName: string): AnimGraphNode_TwistCorrectiveNode;
    }

    export class AnimNode_TwoBoneIK extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(IKBone: BoneReference, StartStretchRatio: number, MaxStretchScale: number, StretchLimits: Vector2D, bNoTwist: boolean, JointTargetSpaceBoneName: string, EffectorSpaceBoneName: string, EffectorLocation: Vector, EffectorTarget: BoneSocketTarget, JointTargetLocation: Vector, JointTarget: BoneSocketTarget, TwistAxis: Axis, EffectorLocationSpace: EBoneControlSpace, JointTargetLocationSpace: EBoneControlSpace, bAllowStretching: boolean, bTakeRotationFromEffectorSpace: boolean, bMaintainEffectorRelRot: boolean, bAllowTwist: boolean);

        IKBone: BoneReference;
        StartStretchRatio: number;
        MaxStretchScale: number;
        StretchLimits: Vector2D;
        bNoTwist: boolean;
        JointTargetSpaceBoneName: string;
        EffectorSpaceBoneName: string;
        EffectorLocation: Vector;
        EffectorTarget: BoneSocketTarget;
        JointTargetLocation: Vector;
        JointTarget: BoneSocketTarget;
        TwistAxis: Axis;
        EffectorLocationSpace: EBoneControlSpace;
        JointTargetLocationSpace: EBoneControlSpace;
        bAllowStretching: boolean;
        bTakeRotationFromEffectorSpace: boolean;
        bMaintainEffectorRelRot: boolean;
        bAllowTwist: boolean;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_TwoBoneIK extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_TwoBoneIK;
        bEnableDebugDraw: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwoBoneIK;

        static Load(InName: string): AnimGraphNode_TwoBoneIK;
    }

    export class AnimNode_TwoWayBlend extends AnimNode_Base {
        constructor();
        constructor(A: PoseLink, B: PoseLink, AlphaInputType: EAnimAlphaInputType, bAlphaBoolEnabled: boolean, bResetChildOnActivation: boolean, Alpha: number, AlphaScaleBias: InputScaleBias, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: InputScaleBiasClamp);

        A: PoseLink;
        B: PoseLink;
        AlphaInputType: EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
        bResetChildOnActivation: boolean;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: InputScaleBiasClamp;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_TwoWayBlend extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlendNode: AnimNode_TwoWayBlend;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwoWayBlend;

        static Load(InName: string): AnimGraphNode_TwoWayBlend;
    }

    export class AnimNode_UseCachedPose extends AnimNode_Base {
        constructor();
        constructor(LinkToCachingNode: PoseLink, CachePoseName: string);

        LinkToCachingNode: PoseLink;
        CachePoseName: string;

        static StaticClass(): Class;
    }

    export class AnimGraphNode_UseCachedPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_UseCachedPose;
        SaveCachedPoseNode: TWeakObjectPtr<AnimGraphNode_SaveCachedPose>;
        NameOfCache: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_UseCachedPose;

        static Load(InName: string): AnimGraphNode_UseCachedPose;
    }

    export class AnimNode_WheelHandler extends AnimNode_SkeletalControlBase {
        constructor();

        static StaticClass(): Class;
    }

    export class AnimGraphNode_WheelHandler extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_WheelHandler;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_WheelHandler;

        static Load(InName: string): AnimGraphNode_WheelHandler;
    }

    export class AnimLayerInterfaceFactory extends AnimBlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimLayerInterfaceFactory;

        static Load(InName: string): AnimLayerInterfaceFactory;
    }

    export class AnimMontageFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeleton: Skeleton;
        SourceAnimation: AnimSequence;
        PreviewSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimMontageFactory;

        static Load(InName: string): AnimMontageFactory;
    }

    export class AnimNotify_PauseClothingSimulation extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_PauseClothingSimulation;

        static Load(InName: string): AnimNotify_PauseClothingSimulation;
    }

    export class AnimNotify_PlayMontageNotify extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NotifyName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayMontageNotify;

        static Load(InName: string): AnimNotify_PlayMontageNotify;
    }

    export class AnimNotify_PlayMontageNotifyWindow extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NotifyName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayMontageNotifyWindow;

        static Load(InName: string): AnimNotify_PlayMontageNotifyWindow;
    }

    export class NiagaraScriptBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraScriptBase;

        static Load(InName: string): NiagaraScriptBase;
    }

    export enum ENiagaraScriptUsage {
        Function,
        Module,
        DynamicInput,
        ParticleSpawnScript,
        ParticleSpawnScriptInterpolated,
        ParticleUpdateScript,
        ParticleEventScript,
        ParticleSimulationStageScript,
        ParticleGPUComputeScript,
        EmitterSpawnScript,
        EmitterUpdateScript,
        SystemSpawnScript,
        SystemUpdateScript,
        ENiagaraScriptUsage_MAX
    }

    export enum ENiagaraModuleDependencyType { PreDependency, PostDependency, ENiagaraModuleDependencyType_MAX }

    export enum ENiagaraModuleDependencyScriptConstraint {
        SameScript,
        AllScripts,
        ENiagaraModuleDependencyScriptConstraint_MAX
    }

    export class NiagaraModuleDependency {
        constructor();
        constructor(Id: string, Type: ENiagaraModuleDependencyType, ScriptConstraint: ENiagaraModuleDependencyScriptConstraint, Description: string);

        Id: string;
        Type: ENiagaraModuleDependencyType;
        ScriptConstraint: ENiagaraModuleDependencyScriptConstraint;
        Description: string;

        static StaticClass(): Class;
    }

    export enum ENiagaraScriptLibraryVisibility {
        Invalid,
        Unexposed,
        Library,
        Hidden,
        ENiagaraScriptLibraryVisibility_MAX
    }

    export class NiagaraTypeDefinitionHandle {
        constructor();
        constructor(RegisteredTypeIndex: number);

        RegisteredTypeIndex: number;

        static StaticClass(): Class;
    }

    export class NiagaraTypeDefinition {
        constructor();
        constructor(ClassStructOrEnum: Object, UnderlyingType: number, Struct: Struct, Enum: Enum);

        ClassStructOrEnum: Object;
        UnderlyingType: number;
        Struct: Struct;

        static StaticClass(): Class;
    }

    export class NiagaraVariableBase {
        constructor();
        constructor(Name: string, TypeDefHandle: NiagaraTypeDefinitionHandle, TypeDef: NiagaraTypeDefinition);

        Name: string;
        TypeDefHandle: NiagaraTypeDefinitionHandle;
        TypeDef: NiagaraTypeDefinition;

        static StaticClass(): Class;
    }

    export class NiagaraVariable extends NiagaraVariableBase {
        constructor();
        constructor(VarData: TArray<number>);

        VarData: TArray<number>;

        static StaticClass(): Class;
    }

    export class NiagaraVariableWithOffset extends NiagaraVariableBase {
        constructor();
        constructor(Offset: number);

        Offset: number;

        static StaticClass(): Class;
    }

    export class NiagaraMergeable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MergeId: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraMergeable;

        static Load(InName: string): NiagaraMergeable;
    }

    export class NiagaraDataInterfaceBase extends NiagaraMergeable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceBase;

        static Load(InName: string): NiagaraDataInterfaceBase;
    }

    export class NiagaraDataInterface extends NiagaraDataInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterface;

        static Load(InName: string): NiagaraDataInterface;
    }

    export class NiagaraParameterStore {
        constructor();
        constructor(Owner: Object, ParameterOffsets: TMap<NiagaraVariable, number>, SortedParameterOffsets: TArray<NiagaraVariableWithOffset>, ParameterData: TArray<number>, DataInterfaces: TArray<NiagaraDataInterface>, UObjects: TArray<Object>, DebugName: string);

        Owner: Object;
        ParameterOffsets: TMap<NiagaraVariable, number>;
        SortedParameterOffsets: TArray<NiagaraVariableWithOffset>;
        ParameterData: TArray<number>;
        DataInterfaces: TArray<NiagaraDataInterface>;
        UObjects: TArray<Object>;
        DebugName: string;

        static StaticClass(): Class;
    }

    export enum ENiagaraNumericOutputTypeSelectionMode {
        None,
        Largest,
        Smallest,
        Scalar,
        ENiagaraNumericOutputTypeSelectionMode_MAX
    }

    export class NiagaraScriptHighlight {
        constructor();
        constructor(Color: LinearColor, DisplayName: string);

        Color: LinearColor;
        DisplayName: string;

        static StaticClass(): Class;
    }

    export class NiagaraScriptExecutionPaddingInfo {
        constructor();
        constructor(SrcOffset: number, DestOffset: number, SrcSize: number, DestSize: number);

        SrcOffset: number;
        DestOffset: number;
        SrcSize: number;
        DestSize: number;

        static StaticClass(): Class;
    }

    export class NiagaraScriptExecutionParameterStore extends NiagaraParameterStore {
        constructor();
        constructor(ParameterSize: number, PaddedParameterSize: number, PaddingInfo: TArray<NiagaraScriptExecutionPaddingInfo>, bInitialized: boolean);

        ParameterSize: number;
        PaddedParameterSize: number;
        PaddingInfo: TArray<NiagaraScriptExecutionPaddingInfo>;
        bInitialized: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraBoundParameter {
        constructor();
        constructor(Parameter: NiagaraVariable, SrcOffset: number, DestOffset: number);

        Parameter: NiagaraVariable;
        SrcOffset: number;
        DestOffset: number;

        static StaticClass(): Class;
    }

    export class NiagaraScriptSourceBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraScriptSourceBase;

        static Load(InName: string): NiagaraScriptSourceBase;
    }

    export class NiagaraCompileHash {
        constructor();
        constructor(DataHash: TArray<number>);

        DataHash: TArray<number>;

        static StaticClass(): Class;
    }

    export class NiagaraVMExecutableDataId {
        constructor();
        constructor(CompilerVersionID: Guid, ScriptUsageType: ENiagaraScriptUsage, ScriptUsageTypeID: Guid, AdditionalDefines: TArray<string>, bUsesRapidIterationParams: boolean, bInterpolatedSpawn: boolean, bRequiresPersistentIDs: boolean, BaseScriptID: Guid, BaseScriptCompileHash: NiagaraCompileHash, ReferencedCompileHashes: TArray<NiagaraCompileHash>);

        CompilerVersionID: Guid;
        ScriptUsageType: ENiagaraScriptUsage;
        ScriptUsageTypeID: Guid;
        AdditionalDefines: TArray<string>;
        bUsesRapidIterationParams: boolean;
        bInterpolatedSpawn: boolean;
        bRequiresPersistentIDs: boolean;
        BaseScriptID: Guid;
        BaseScriptCompileHash: NiagaraCompileHash;
        ReferencedCompileHashes: TArray<NiagaraCompileHash>;

        static StaticClass(): Class;
    }

    export class NiagaraParameters {
        constructor();
        constructor(Parameters: TArray<NiagaraVariable>);

        Parameters: TArray<NiagaraVariable>;

        static StaticClass(): Class;
    }

    export class NiagaraScriptDataUsageInfo {
        constructor();
        constructor(bReadsAttributeData: boolean);

        bReadsAttributeData: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraFunctionSignature {
        constructor();
        constructor(Name: string, Inputs: TArray<NiagaraVariable>, Outputs: TArray<NiagaraVariable>, OwnerName: string, bRequiresContext: boolean, bRequiresExecPin: boolean, bMemberFunction: boolean, bExperimental: boolean, ExperimentalMessage: string, FunctionVersion: number, bSupportsCPU: boolean, bSupportsGPU: boolean, bWriteFunction: boolean, bSoftDeprecatedFunction: boolean, ModuleUsageBitmask: number, ContextStageMinIndex: number, ContextStageMaxIndex: number, FunctionSpecifiers: TMap<string, string>, Description: string);

        Name: string;
        Inputs: TArray<NiagaraVariable>;
        Outputs: TArray<NiagaraVariable>;
        OwnerName: string;
        bRequiresContext: boolean;
        bRequiresExecPin: boolean;
        bMemberFunction: boolean;
        bExperimental: boolean;
        ExperimentalMessage: string;
        FunctionVersion: number;
        bSupportsCPU: boolean;
        bSupportsGPU: boolean;
        bWriteFunction: boolean;
        bSoftDeprecatedFunction: boolean;
        ModuleUsageBitmask: number;
        ContextStageMinIndex: number;
        ContextStageMaxIndex: number;
        FunctionSpecifiers: TMap<string, string>;
        Description: string;

        static StaticClass(): Class;
    }

    export class NiagaraScriptDataInterfaceCompileInfo {
        constructor();
        constructor(Name: string, UserPtrIdx: number, Type: NiagaraTypeDefinition, RegisteredFunctions: TArray<NiagaraFunctionSignature>, RegisteredParameterMapRead: string, RegisteredParameterMapWrite: string, bIsPlaceholder: boolean);

        Name: string;
        UserPtrIdx: number;
        Type: NiagaraTypeDefinition;
        RegisteredFunctions: TArray<NiagaraFunctionSignature>;
        RegisteredParameterMapRead: string;
        RegisteredParameterMapWrite: string;
        bIsPlaceholder: boolean;

        static StaticClass(): Class;
    }

    export class VMFunctionSpecifier {
        constructor();
        constructor(Key: string, Value: string);

        Key: string;
        Value: string;

        static StaticClass(): Class;
    }

    export class VMExternalFunctionBindingInfo {
        constructor();
        constructor(Name: string, OwnerName: string, InputParamLocations: TArray<boolean>, NumOutputs: number, FunctionSpecifiers: TArray<VMFunctionSpecifier>, Specifiers: TMap<string, string>);

        Name: string;
        OwnerName: string;
        InputParamLocations: TArray<boolean>;
        NumOutputs: number;
        FunctionSpecifiers: TArray<VMFunctionSpecifier>;
        Specifiers: TMap<string, string>;

        static StaticClass(): Class;
    }

    export enum ENiagaraDataSetType { ParticleData, Shared, Event, ENiagaraDataSetType_MAX }

    export class NiagaraDataSetID {
        constructor();
        constructor(Name: string, Type: ENiagaraDataSetType);

        Name: string;
        Type: ENiagaraDataSetType;

        static StaticClass(): Class;
    }

    export class NiagaraDataSetProperties {
        constructor();
        constructor(ID: NiagaraDataSetID, Variables: TArray<NiagaraVariable>);

        ID: NiagaraDataSetID;
        Variables: TArray<NiagaraVariable>;

        static StaticClass(): Class;
    }

    export class NiagaraStatScope {
        constructor();
        constructor(FullName: string, FriendlyName: string);

        FullName: string;
        FriendlyName: string;

        static StaticClass(): Class;
    }

    export class NiagaraDataInterfaceGeneratedFunction {
        constructor();

        static StaticClass(): Class;
    }

    export class NiagaraDataInterfaceGPUParamInfo {
        constructor();
        constructor(DataInterfaceHLSLSymbol: string, DIClassName: string, GeneratedFunctions: TArray<NiagaraDataInterfaceGeneratedFunction>);

        DataInterfaceHLSLSymbol: string;
        DIClassName: string;
        GeneratedFunctions: TArray<NiagaraDataInterfaceGeneratedFunction>;

        static StaticClass(): Class;
    }

    export enum ENiagaraScriptCompileStatus {
        NCS_Unknown,
        NCS_Dirty,
        NCS_Error,
        NCS_UpToDate,
        NCS_BeingCreated,
        NCS_UpToDateWithWarnings,
        NCS_ComputeUpToDateWithWarnings,
        NCS_MAX
    }

    export class SimulationStageMetaData {
        constructor();
        constructor(SimulationStageName: string, IterationSource: string, bSpawnOnly: boolean, bWritesParticles: boolean, bPartialParticleUpdate: boolean, OutputDestinations: TArray<string>, MinStage: number, MaxStage: number);

        SimulationStageName: string;
        IterationSource: string;
        bSpawnOnly: boolean;
        bWritesParticles: boolean;
        bPartialParticleUpdate: boolean;
        OutputDestinations: TArray<string>;
        MinStage: number;
        MaxStage: number;

        static StaticClass(): Class;
    }

    export enum FNiagaraCompileEventSeverity { Log, Warning, Error, FNiagaraCompileEventSeverity_MAX }

    export class NiagaraCompileEvent {
        constructor();
        constructor(Severity: FNiagaraCompileEventSeverity, Message: string, NodeGuid: Guid, PinGuid: Guid, StackGuids: TArray<Guid>);

        Severity: FNiagaraCompileEventSeverity;
        Message: string;
        NodeGuid: Guid;
        PinGuid: Guid;
        StackGuids: TArray<Guid>;

        static StaticClass(): Class;
    }

    export class NiagaraVMExecutableData {
        constructor();
        constructor(ByteCode: TArray<number>, OptimizedByteCode: TArray<number>, NumTempRegisters: number, NumUserPtrs: number, Parameters: NiagaraParameters, InternalParameters: NiagaraParameters, ScriptLiterals: TArray<number>, Attributes: TArray<NiagaraVariable>, DataUsage: NiagaraScriptDataUsageInfo, DataSetToParameters: TMap<string, NiagaraParameters>, AdditionalExternalFunctions: TArray<NiagaraFunctionSignature>, DataInterfaceInfo: TArray<NiagaraScriptDataInterfaceCompileInfo>, CalledVMExternalFunctions: TArray<VMExternalFunctionBindingInfo>, ReadDataSets: TArray<NiagaraDataSetID>, WriteDataSets: TArray<NiagaraDataSetProperties>, StatScopes: TArray<NiagaraStatScope>, LastHlslTranslation: string, LastHlslTranslationGPU: string, LastAssemblyTranslation: string, LastOpCount: number, DIParamInfo: TArray<NiagaraDataInterfaceGPUParamInfo>, ParameterCollectionPaths: TArray<string>, LastCompileStatus: ENiagaraScriptCompileStatus, SimulationStageMetaData: TArray<SimulationStageMetaData>, bReadsAttributeData: boolean, ErrorMsg: string, CompileTime: number, LastCompileEvents: TArray<NiagaraCompileEvent>, bReadsSignificanceIndex: boolean);

        ByteCode: TArray<number>;
        OptimizedByteCode: TArray<number>;
        NumTempRegisters: number;
        NumUserPtrs: number;
        Parameters: NiagaraParameters;
        InternalParameters: NiagaraParameters;
        ScriptLiterals: TArray<number>;
        Attributes: TArray<NiagaraVariable>;
        DataUsage: NiagaraScriptDataUsageInfo;
        DataSetToParameters: TMap<string, NiagaraParameters>;
        AdditionalExternalFunctions: TArray<NiagaraFunctionSignature>;
        DataInterfaceInfo: TArray<NiagaraScriptDataInterfaceCompileInfo>;
        CalledVMExternalFunctions: TArray<VMExternalFunctionBindingInfo>;
        ReadDataSets: TArray<NiagaraDataSetID>;
        WriteDataSets: TArray<NiagaraDataSetProperties>;
        StatScopes: TArray<NiagaraStatScope>;
        LastHlslTranslation: string;
        LastHlslTranslationGPU: string;
        LastAssemblyTranslation: string;
        LastOpCount: number;
        DIParamInfo: TArray<NiagaraDataInterfaceGPUParamInfo>;
        ParameterCollectionPaths: TArray<string>;
        LastCompileStatus: ENiagaraScriptCompileStatus;
        SimulationStageMetaData: TArray<SimulationStageMetaData>;
        bReadsAttributeData: boolean;
        ErrorMsg: string;
        CompileTime: number;
        LastCompileEvents: TArray<NiagaraCompileEvent>;
        bReadsSignificanceIndex: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraParameterCollectionInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Collection: NiagaraParameterCollection;
        OverridenParameters: TArray<NiagaraVariable>;
        ParameterStorage: NiagaraParameterStore;

        GetBoolParameter(InVariableName: string): boolean;

        GetColorParameter(InVariableName: string): LinearColor;

        GetFloatParameter(InVariableName: string): number;

        GetIntParameter(InVariableName: string): number;

        GetQuatParameter(InVariableName: string): Quat;

        GetVector2DParameter(InVariableName: string): Vector2D;

        GetVector4Parameter(InVariableName: string): Vector4;

        GetVectorParameter(InVariableName: string): Vector;

        SetBoolParameter(InVariableName: string, InValue: boolean): void;

        SetColorParameter(InVariableName: string, InValue: LinearColor): void;

        SetFloatParameter(InVariableName: string, InValue: number): void;

        SetIntParameter(InVariableName: string, InValue: number): void;

        SetQuatParameter(InVariableName: string, InValue: Quat): void;

        SetVector2DParameter(InVariableName: string, InValue: Vector2D): void;

        SetVector4Parameter(InVariableName: string, InValue: Vector4): void;

        SetVectorParameter(InVariableName: string, InValue: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraParameterCollectionInstance;

        static Load(InName: string): NiagaraParameterCollectionInstance;
    }

    export class NiagaraParameterCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Namespace: string;
        Parameters: TArray<NiagaraVariable>;
        SourceMaterialCollection: MaterialParameterCollection;
        DefaultInstance: NiagaraParameterCollectionInstance;
        CompileId: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraParameterCollection;

        static Load(InName: string): NiagaraParameterCollection;
    }

    export class NiagaraScriptDataInterfaceInfo {
        constructor();
        constructor(DataInterface: NiagaraDataInterface, Name: string, UserPtrIdx: number, Type: NiagaraTypeDefinition, RegisteredParameterMapRead: string, RegisteredParameterMapWrite: string);

        DataInterface: NiagaraDataInterface;
        Name: string;
        UserPtrIdx: number;
        Type: NiagaraTypeDefinition;
        RegisteredParameterMapRead: string;
        RegisteredParameterMapWrite: string;

        static StaticClass(): Class;
    }

    export class NiagaraScript extends NiagaraScriptBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Usage: ENiagaraScriptUsage;
        UsageIndex: number;
        UsageId: Guid;
        ModuleUsageBitmask: number;
        Category: string;
        ProvidedDependencies: TArray<string>;
        RequiredDependencies: TArray<NiagaraModuleDependency>;
        bDeprecated: boolean;
        DeprecationMessage: string;
        DeprecationRecommendation: NiagaraScript;
        ConversionUtility: Class;
        bExperimental: boolean;
        ExperimentalMessage: string;
        bExposeToLibrary: boolean;
        LibraryVisibility: ENiagaraScriptLibraryVisibility;
        RapidIterationParameters: NiagaraParameterStore;
        NumericOutputTypeSelectionMode: ENiagaraNumericOutputTypeSelectionMode;
        Description: string;
        Keywords: string;
        CollapsedViewFormat: string;
        Highlights: TArray<NiagaraScriptHighlight>;
        ScriptMetaData: TMap<string, string>;
        ScriptExecutionParamStoreCPU: NiagaraScriptExecutionParameterStore;
        ScriptExecutionParamStoreGPU: NiagaraScriptExecutionParameterStore;
        ScriptExecutionParamStore: NiagaraScriptExecutionParameterStore;
        ScriptExecutionBoundParameters: TArray<NiagaraBoundParameter>;
        Source: NiagaraScriptSourceBase;
        CachedScriptVMId: NiagaraVMExecutableDataId;
        LastGeneratedVMId: NiagaraVMExecutableDataId;
        ActiveCompileRoots: TArray<Object>;
        CachedScriptVM: NiagaraVMExecutableData;
        CachedParameterCollectionReferences: TArray<NiagaraParameterCollection>;
        CachedDefaultDataInterfaces: TArray<NiagaraScriptDataInterfaceInfo>;

        RaiseOnGPUCompilationComplete(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraScript;

        static Load(InName: string): NiagaraScript;
    }

    export enum ENiagaraTickBehavior {
        UsePrereqs,
        UseComponentTickGroup,
        ForceTickFirst,
        ForceTickLast,
        ENiagaraTickBehavior_MAX
    }

    export class NiagaraUserRedirectionParameterStore extends NiagaraParameterStore {
        constructor();
        constructor(UserParameterRedirects: TMap<NiagaraVariable, NiagaraVariable>);

        UserParameterRedirects: TMap<NiagaraVariable, NiagaraVariable>;

        static StaticClass(): Class;
    }

    export enum ENiagaraVariantMode { None, Object, DataInterface, Bytes, ENiagaraVariantMode_MAX }

    export class NiagaraVariant {
        constructor();
        constructor(Object: Object, DataInterface: NiagaraDataInterface, Bytes: TArray<number>, CurrentMode: ENiagaraVariantMode);

        Object: Object;
        DataInterface: NiagaraDataInterface;
        Bytes: TArray<number>;
        CurrentMode: ENiagaraVariantMode;

        static StaticClass(): Class;
    }

    export class NiagaraDeviceProfileStateEntry {
        constructor();
        constructor(ProfileName: string, QualityLevelMask: number, SetQualityLevelMask: number);

        ProfileName: string;
        QualityLevelMask: number;
        SetQualityLevelMask: number;

        static StaticClass(): Class;
    }

    export class NiagaraPlatformSetCVarCondition {
        constructor();
        constructor(CVarName: string, Value: boolean, MinInt: number, MaxInt: number, MinFloat: number, MaxFloat: number, bUseMinInt: boolean, bUseMaxInt: boolean, bUseMinFloat: boolean, bUseMaxFloat: boolean);

        CVarName: string;
        Value: boolean;
        MinInt: number;
        MaxInt: number;
        MinFloat: number;
        MaxFloat: number;
        bUseMinInt: boolean;
        bUseMaxInt: boolean;
        bUseMinFloat: boolean;
        bUseMaxFloat: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraPlatformSet {
        constructor();
        constructor(QualityLevelMask: number, DeviceProfileStates: TArray<NiagaraDeviceProfileStateEntry>, CVarConditions: TArray<NiagaraPlatformSetCVarCondition>);

        QualityLevelMask: number;
        DeviceProfileStates: TArray<NiagaraDeviceProfileStateEntry>;
        CVarConditions: TArray<NiagaraPlatformSetCVarCondition>;

        static StaticClass(): Class;
    }

    export class NiagaraRendererProperties extends NiagaraMergeable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Platforms: NiagaraPlatformSet;
        SortOrderHint: number;
        bIsEnabled: boolean;
        bMotionBlurEnabled: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraRendererProperties;

        static Load(InName: string): NiagaraRendererProperties;
    }

    export class NiagaraMaterialOverride {
        constructor();
        constructor(Material: MaterialInterface, MaterialSubIndex: number, EmitterRendererProperty: NiagaraRendererProperties);

        Material: MaterialInterface;
        MaterialSubIndex: number;
        EmitterRendererProperty: NiagaraRendererProperties;

        static StaticClass(): Class;
    }

    export class TextureRenderTarget extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetGamma: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTarget;

        static Load(InName: string): TextureRenderTarget;
    }

    export enum ENiagaraAgeUpdateMode { TickDeltaTime, DesiredAge, DesiredAgeNoSeek, ENiagaraAgeUpdateMode_MAX }

    export class NiagaraComponent extends FXSystemComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Asset: NiagaraSystem;
        TickBehavior: ENiagaraTickBehavior;
        OverrideParameters: NiagaraUserRedirectionParameterStore;
        EditorOverridesValue: TMap<string, boolean>;
        TemplateParameterOverrides: TMap<NiagaraVariableBase, NiagaraVariant>;
        InstanceParameterOverrides: TMap<NiagaraVariableBase, NiagaraVariant>;
        bForceSolo: boolean;
        bEnableGpuComputeDebug: boolean;
        bAutoDestroy: boolean;
        bRenderingEnabled: boolean;
        bAutoManageAttachment: boolean;
        bAutoAttachWeldSimulatedBodies: boolean;
        MaxTimeBeforeForceUpdateTransform: number;
        EmitterMaterials: TArray<NiagaraMaterialOverride>;
        OnSystemFinished: $MulticastDelegate<(PSystem: $Nullable<NiagaraComponent>) => void>;
        AutoAttachParent: TWeakObjectPtr<SceneComponent>;
        AutoAttachSocketName: string;
        AutoAttachLocationRule: EAttachmentRule;
        AutoAttachRotationRule: EAttachmentRule;
        AutoAttachScaleRule: EAttachmentRule;
        bWaitForCompilationOnActivate: boolean;

        AdvanceSimulation(TickCount: number, TickDeltaSeconds: number): void;

        AdvanceSimulationByTime(SimulateTime: number, TickDeltaSeconds: number): void;

        GetAgeUpdateMode(): ENiagaraAgeUpdateMode;

        GetAsset(): NiagaraSystem;

        GetDataInterface(Name: string): NiagaraDataInterface;

        GetDesiredAge(): number;

        GetForceSolo(): boolean;

        GetMaxSimTime(): number;

        GetNiagaraParticlePositions_DebugOnly(InEmitterName: string): TArray<Vector>;

        GetNiagaraParticleValues_DebugOnly(InEmitterName: string, InValueName: string): TArray<number>;

        GetNiagaraParticleValueVec3_DebugOnly(InEmitterName: string, InValueName: string): TArray<Vector>;

        GetPreviewLODDistance(): number;

        GetPreviewLODDistanceEnabled(): boolean;

        GetSeekDelta(): number;

        GetTickBehavior(): ENiagaraTickBehavior;

        IsPaused(): boolean;

        ReinitializeSystem(): void;

        ResetSystem(): void;

        SeekToDesiredAge(InDesiredAge: number): void;

        SetAgeUpdateMode(InAgeUpdateMode: ENiagaraAgeUpdateMode): void;

        SetAllowScalability(bAllow: boolean): void;

        SetAsset(InAsset: $Nullable<NiagaraSystem>): void;

        SetAutoDestroy(bInAutoDestroy: boolean): void;

        SetCanRenderWhileSeeking(bInCanRenderWhileSeeking: boolean): void;

        SetDesiredAge(InDesiredAge: number): void;

        SetForceSolo(bInForceSolo: boolean): void;

        SetGpuComputeDebug(bEnableDebug: boolean): void;

        SetMaxSimTime(InMaxTime: number): void;

        SetNiagaraVariableActor(InVariableName: string, Actor: $Nullable<Actor>): void;

        SetNiagaraVariableBool(InVariableName: string, InValue: boolean): void;

        SetNiagaraVariableFloat(InVariableName: string, InValue: number): void;

        SetNiagaraVariableInt(InVariableName: string, InValue: number): void;

        SetNiagaraVariableLinearColor(InVariableName: string, InValue: LinearColor): void;

        SetNiagaraVariableObject(InVariableName: string, Object: $Nullable<Object>): void;

        SetNiagaraVariableQuat(InVariableName: string, InValue: Quat): void;

        SetNiagaraVariableVec2(InVariableName: string, InValue: Vector2D): void;

        SetNiagaraVariableVec3(InVariableName: string, InValue: Vector): void;

        SetNiagaraVariableVec4(InVariableName: string, InValue: Vector4): void;

        SetPaused(bInPaused: boolean): void;

        SetPreviewLODDistance(bEnablePreviewLODDistance: boolean, PreviewLODDistance: number): void;

        SetRenderingEnabled(bInRenderingEnabled: boolean): void;

        SetSeekDelta(InSeekDelta: number): void;

        SetTickBehavior(NewTickBehavior: ENiagaraTickBehavior): void;

        SetVariableActor(InVariableName: string, Actor: $Nullable<Actor>): void;

        SetVariableBool(InVariableName: string, InValue: boolean): void;

        SetVariableFloat(InVariableName: string, InValue: number): void;

        SetVariableInt(InVariableName: string, InValue: number): void;

        SetVariableLinearColor(InVariableName: string, InValue: LinearColor): void;

        SetVariableMaterial(InVariableName: string, Object: $Nullable<MaterialInterface>): void;

        SetVariableObject(InVariableName: string, Object: $Nullable<Object>): void;

        SetVariableQuat(InVariableName: string, InValue: Quat): void;

        SetVariableTextureRenderTarget(InVariableName: string, TextureRenderTarget: $Nullable<TextureRenderTarget>): void;

        SetVariableVec2(InVariableName: string, InValue: Vector2D): void;

        SetVariableVec3(InVariableName: string, InValue: Vector): void;

        SetVariableVec4(InVariableName: string, InValue: Vector4): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraComponent;

        static Load(InName: string): NiagaraComponent;
    }

    export class NiagaraSystemUpdateContext {
        constructor();
        constructor(ComponentsToReset: TArray<NiagaraComponent>, ComponentsToReInit: TArray<NiagaraComponent>, ComponentsToNotifySimDestroy: TArray<NiagaraComponent>, SystemSimsToDestroy: TArray<NiagaraSystem>);

        ComponentsToReset: TArray<NiagaraComponent>;
        ComponentsToReInit: TArray<NiagaraComponent>;
        ComponentsToNotifySimDestroy: TArray<NiagaraComponent>;
        SystemSimsToDestroy: TArray<NiagaraSystem>;

        static StaticClass(): Class;
    }

    export enum ENiagaraScalabilityUpdateFrequency {
        SpawnOnly,
        Low,
        Medium,
        High,
        Continuous,
        ENiagaraScalabilityUpdateFrequency_MAX
    }

    export enum ENiagaraCullReaction {
        Deactivate,
        DeactivateImmediate,
        DeactivateResume,
        DeactivateImmediateResume,
        ENiagaraCullReaction_MAX
    }

    export class NiagaraSignificanceHandler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSignificanceHandler;

        static Load(InName: string): NiagaraSignificanceHandler;
    }

    export class NiagaraSystemScalabilitySettings {
        constructor();
        constructor(Platforms: NiagaraPlatformSet, bCullByDistance: boolean, bCullMaxInstanceCount: boolean, bCullPerSystemMaxInstanceCount: boolean, bCullByMaxTimeWithoutRender: boolean, MaxDistance: number, MaxInstances: number, MaxSystemInstances: number, MaxTimeWithoutRender: number);

        Platforms: NiagaraPlatformSet;
        bCullByDistance: boolean;
        bCullMaxInstanceCount: boolean;
        bCullPerSystemMaxInstanceCount: boolean;
        bCullByMaxTimeWithoutRender: boolean;
        MaxDistance: number;
        MaxInstances: number;
        MaxSystemInstances: number;
        MaxTimeWithoutRender: number;

        static StaticClass(): Class;
    }

    export class NiagaraSystemScalabilitySettingsArray {
        constructor();
        constructor(Settings: TArray<NiagaraSystemScalabilitySettings>);

        Settings: TArray<NiagaraSystemScalabilitySettings>;

        static StaticClass(): Class;
    }

    export class NiagaraEmitterScalabilitySettings {
        constructor();
        constructor(Platforms: NiagaraPlatformSet, bScaleSpawnCount: boolean, SpawnCountScale: number);

        Platforms: NiagaraPlatformSet;
        bScaleSpawnCount: boolean;
        SpawnCountScale: number;

        static StaticClass(): Class;
    }

    export class NiagaraEmitterScalabilitySettingsArray {
        constructor();
        constructor(Settings: TArray<NiagaraEmitterScalabilitySettings>);

        Settings: TArray<NiagaraEmitterScalabilitySettings>;

        static StaticClass(): Class;
    }

    export class NiagaraEffectType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UpdateFrequency: ENiagaraScalabilityUpdateFrequency;
        CullReaction: ENiagaraCullReaction;
        SignificanceHandler: NiagaraSignificanceHandler;
        DetailLevelScalabilitySettings: TArray<NiagaraSystemScalabilitySettings>;
        SystemScalabilitySettings: NiagaraSystemScalabilitySettingsArray;
        EmitterScalabilitySettings: NiagaraEmitterScalabilitySettingsArray;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEffectType;

        static Load(InName: string): NiagaraEffectType;
    }

    export class NiagaraSystemScalabilityOverride extends NiagaraSystemScalabilitySettings {
        constructor();
        constructor(bOverrideDistanceSettings: boolean, bOverrideInstanceCountSettings: boolean, bOverridePerSystemInstanceCountSettings: boolean, bOverrideTimeSinceRendererSettings: boolean);

        bOverrideDistanceSettings: boolean;
        bOverrideInstanceCountSettings: boolean;
        bOverridePerSystemInstanceCountSettings: boolean;
        bOverrideTimeSinceRendererSettings: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraSystemScalabilityOverrides {
        constructor();
        constructor(Overrides: TArray<NiagaraSystemScalabilityOverride>);

        Overrides: TArray<NiagaraSystemScalabilityOverride>;

        static StaticClass(): Class;
    }

    export enum EParticleAllocationMode { AutomaticEstimate, ManualEstimate, EParticleAllocationMode_MAX }

    export class NiagaraEventReceiverProperties {
        constructor();
        constructor(Name: string, SourceEventGenerator: string, SourceEmitter: string);

        Name: string;
        SourceEventGenerator: string;
        SourceEmitter: string;

        static StaticClass(): Class;
    }

    export class NiagaraTypeLayoutInfo {
        constructor();
        constructor(FloatComponentByteOffsets: TArray<number>, FloatComponentRegisterOffsets: TArray<number>, Int32ComponentByteOffsets: TArray<number>, Int32ComponentRegisterOffsets: TArray<number>, HalfComponentByteOffsets: TArray<number>, HalfComponentRegisterOffsets: TArray<number>);

        FloatComponentByteOffsets: TArray<number>;
        FloatComponentRegisterOffsets: TArray<number>;
        Int32ComponentByteOffsets: TArray<number>;
        Int32ComponentRegisterOffsets: TArray<number>;
        HalfComponentByteOffsets: TArray<number>;
        HalfComponentRegisterOffsets: TArray<number>;

        static StaticClass(): Class;
    }

    export class NiagaraVariableLayoutInfo {
        constructor();
        constructor(FloatComponentStart: number, Int32ComponentStart: number, HalfComponentStart: number, LayoutInfo: NiagaraTypeLayoutInfo);

        FloatComponentStart: number;
        Int32ComponentStart: number;
        HalfComponentStart: number;
        LayoutInfo: NiagaraTypeLayoutInfo;

        static StaticClass(): Class;
    }

    export enum ENiagaraSimTarget { CPUSim, GPUComputeSim, ENiagaraSimTarget_MAX }

    export class NiagaraDataSetCompiledData {
        constructor();
        constructor(Variables: TArray<NiagaraVariable>, VariableLayouts: TArray<NiagaraVariableLayoutInfo>, ID: NiagaraDataSetID, TotalFloatComponents: number, TotalInt32Components: number, TotalHalfComponents: number, bRequiresPersistentIDs: boolean, SimTarget: ENiagaraSimTarget);

        Variables: TArray<NiagaraVariable>;
        VariableLayouts: TArray<NiagaraVariableLayoutInfo>;
        ID: NiagaraDataSetID;
        TotalFloatComponents: number;
        TotalInt32Components: number;
        TotalHalfComponents: number;
        bRequiresPersistentIDs: boolean;
        SimTarget: ENiagaraSimTarget;

        static StaticClass(): Class;
    }

    export class NiagaraEventGeneratorProperties {
        constructor();
        constructor(MaxEventsPerFrame: number, ID: string, DataSetCompiledData: NiagaraDataSetCompiledData);

        MaxEventsPerFrame: number;
        ID: string;
        DataSetCompiledData: NiagaraDataSetCompiledData;

        static StaticClass(): Class;
    }

    export class NiagaraEmitterScriptProperties {
        constructor();
        constructor(Script: NiagaraScript, EventReceivers: TArray<NiagaraEventReceiverProperties>, EventGenerators: TArray<NiagaraEventGeneratorProperties>);

        Script: NiagaraScript;
        EventReceivers: TArray<NiagaraEventReceiverProperties>;
        EventGenerators: TArray<NiagaraEventGeneratorProperties>;

        static StaticClass(): Class;
    }

    export class NiagaraDetailsLevelScaleOverrides {
        constructor();
        constructor(Low: number, Medium: number, High: number, Epic: number, Cine: number);

        Low: number;
        Medium: number;
        High: number;
        Epic: number;
        Cine: number;

        static StaticClass(): Class;
    }

    export class NiagaraEmitterScalabilityOverride extends NiagaraEmitterScalabilitySettings {
        constructor();
        constructor(bOverrideSpawnCountScale: boolean);

        bOverrideSpawnCountScale: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraEmitterScalabilityOverrides {
        constructor();
        constructor(Overrides: TArray<NiagaraEmitterScalabilityOverride>);

        Overrides: TArray<NiagaraEmitterScalabilityOverride>;

        static StaticClass(): Class;
    }

    export class NiagaraEditorDataBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEditorDataBase;

        static Load(InName: string): NiagaraEditorDataBase;
    }

    export enum EScriptExecutionMode { EveryParticle, SpawnedParticles, SingleParticle, EScriptExecutionMode_MAX }

    export class NiagaraEventScriptProperties extends NiagaraEmitterScriptProperties {
        constructor();
        constructor(ExecutionMode: EScriptExecutionMode, SpawnNumber: number, MaxEventsPerFrame: number, SourceEmitterID: Guid, SourceEventName: string, bRandomSpawnNumber: boolean, MinSpawnNumber: number);

        ExecutionMode: EScriptExecutionMode;
        SpawnNumber: number;
        MaxEventsPerFrame: number;
        SourceEmitterID: Guid;
        SourceEventName: string;
        bRandomSpawnNumber: boolean;
        MinSpawnNumber: number;

        static StaticClass(): Class;
    }

    export class NiagaraSimulationStageBase extends NiagaraMergeable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Script: NiagaraScript;
        SimulationStageName: string;
        bEnabled: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSimulationStageBase;

        static Load(InName: string): NiagaraSimulationStageBase;
    }

    export class NiagaraMessageDataBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraMessageDataBase;

        static Load(InName: string): NiagaraMessageDataBase;
    }

    export class NiagaraEmitter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bLocalSpace: boolean;
        bDeterminism: boolean;
        RandomSeed: number;
        AllocationMode: EParticleAllocationMode;
        PreAllocationCount: number;
        UpdateScriptProps: NiagaraEmitterScriptProperties;
        SpawnScriptProps: NiagaraEmitterScriptProperties;
        EmitterSpawnScriptProps: NiagaraEmitterScriptProperties;
        EmitterUpdateScriptProps: NiagaraEmitterScriptProperties;
        AttributesToPreserve: TArray<string>;
        SimTarget: ENiagaraSimTarget;
        FixedBounds: Box;
        MinDetailLevel: number;
        MaxDetailLevel: number;
        GlobalSpawnCountScaleOverrides: NiagaraDetailsLevelScaleOverrides;
        Platforms: NiagaraPlatformSet;
        ScalabilityOverrides: NiagaraEmitterScalabilityOverrides;
        bInterpolatedSpawning: boolean;
        bFixedBounds: boolean;
        bUseMinDetailLevel: boolean;
        bUseMaxDetailLevel: boolean;
        bOverrideGlobalSpawnCountScale: boolean;
        bRequiresPersistentIDs: boolean;
        bCombineEventSpawn: boolean;
        MaxDeltaTimePerTick: number;
        DefaultShaderStageIndex: number;
        MaxUpdateIterations: number;
        SpawnStages: TSet<number>;
        bSimulationStagesEnabled: boolean;
        bDeprecatedShaderStagesEnabled: boolean;
        bLimitDeltaTime: boolean;
        GraphSource: NiagaraScriptSourceBase;
        bBakeOutRapidIteration: boolean;
        ThumbnailImage: Texture2D;
        ThumbnailImageOutOfDate: boolean;
        bExposeToLibrary: boolean;
        bIsTemplateAsset: boolean;
        TemplateAssetDescription: string;
        ScratchPadScripts: TArray<NiagaraScript>;
        ParentScratchPadScripts: TArray<NiagaraScript>;
        ChangeId: Guid;
        EditorData: NiagaraEditorDataBase;
        UniqueEmitterName: string;
        RendererProperties: TArray<NiagaraRendererProperties>;
        EventHandlerScriptProps: TArray<NiagaraEventScriptProperties>;
        SimulationStages: TArray<NiagaraSimulationStageBase>;
        GPUComputeScript: NiagaraScript;
        SharedEventGeneratorIds: TArray<string>;
        Parent: NiagaraEmitter;
        ParentAtLastMerge: NiagaraEmitter;
        MessageKeyToMessageMap: TMap<Guid, NiagaraMessageDataBase>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEmitter;

        static Load(InName: string): NiagaraEmitter;
    }

    export class NiagaraEmitterHandle {
        constructor();
        constructor(Id: Guid, IdName: string, bIsEnabled: boolean, Name: string, Source: NiagaraEmitter, LastMergedSource: NiagaraEmitter, Instance: NiagaraEmitter);

        Id: Guid;
        IdName: string;
        bIsEnabled: boolean;
        Name: string;
        Source: NiagaraEmitter;
        LastMergedSource: NiagaraEmitter;
        Instance: NiagaraEmitter;

        static StaticClass(): Class;
    }

    export class NiagaraSystemCompileRequest {
        constructor();
        constructor(RootObjects: TArray<Object>);

        RootObjects: TArray<Object>;

        static StaticClass(): Class;
    }

    export class NiagaraParameterDataSetBinding {
        constructor();
        constructor(ParameterOffset: number, DataSetComponentOffset: number);

        ParameterOffset: number;
        DataSetComponentOffset: number;

        static StaticClass(): Class;
    }

    export class NiagaraParameterDataSetBindingCollection {
        constructor();
        constructor(FloatOffsets: TArray<NiagaraParameterDataSetBinding>, Int32Offsets: TArray<NiagaraParameterDataSetBinding>);

        FloatOffsets: TArray<NiagaraParameterDataSetBinding>;
        Int32Offsets: TArray<NiagaraParameterDataSetBinding>;

        static StaticClass(): Class;
    }

    export class NiagaraSystemCompiledData {
        constructor();
        constructor(InstanceParamStore: NiagaraParameterStore, DataSetCompiledData: NiagaraDataSetCompiledData, SpawnInstanceParamsDataSetCompiledData: NiagaraDataSetCompiledData, UpdateInstanceParamsDataSetCompiledData: NiagaraDataSetCompiledData, SpawnInstanceGlobalBinding: NiagaraParameterDataSetBindingCollection, SpawnInstanceSystemBinding: NiagaraParameterDataSetBindingCollection, SpawnInstanceOwnerBinding: NiagaraParameterDataSetBindingCollection, SpawnInstanceEmitterBindings: TArray<NiagaraParameterDataSetBindingCollection>, UpdateInstanceGlobalBinding: NiagaraParameterDataSetBindingCollection, UpdateInstanceSystemBinding: NiagaraParameterDataSetBindingCollection, UpdateInstanceOwnerBinding: NiagaraParameterDataSetBindingCollection, UpdateInstanceEmitterBindings: TArray<NiagaraParameterDataSetBindingCollection>);

        InstanceParamStore: NiagaraParameterStore;
        DataSetCompiledData: NiagaraDataSetCompiledData;
        SpawnInstanceParamsDataSetCompiledData: NiagaraDataSetCompiledData;
        UpdateInstanceParamsDataSetCompiledData: NiagaraDataSetCompiledData;
        SpawnInstanceGlobalBinding: NiagaraParameterDataSetBindingCollection;
        SpawnInstanceSystemBinding: NiagaraParameterDataSetBindingCollection;
        SpawnInstanceOwnerBinding: NiagaraParameterDataSetBindingCollection;
        SpawnInstanceEmitterBindings: TArray<NiagaraParameterDataSetBindingCollection>;
        UpdateInstanceGlobalBinding: NiagaraParameterDataSetBindingCollection;
        UpdateInstanceSystemBinding: NiagaraParameterDataSetBindingCollection;
        UpdateInstanceOwnerBinding: NiagaraParameterDataSetBindingCollection;
        UpdateInstanceEmitterBindings: TArray<NiagaraParameterDataSetBindingCollection>;

        static StaticClass(): Class;
    }

    export class NiagaraSystem extends FXSystemAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ThumbnailImage: Texture2D;
        ThumbnailImageOutOfDate: boolean;
        bExposeToLibrary: boolean;
        bIsTemplateAsset: boolean;
        TemplateAssetDescription: string;
        ScratchPadScripts: TArray<NiagaraScript>;
        EditorOnlyAddedParameters: NiagaraParameterStore;
        UpdateContext: NiagaraSystemUpdateContext;
        bBakeOutRapidIteration: boolean;
        bBakeOutRapidIterationOnCook: boolean;
        bCompressAttributes: boolean;
        bTrimAttributes: boolean;
        bTrimAttributesOnCook: boolean;
        bDumpDebugSystemInfo: boolean;
        bDumpDebugEmitterInfo: boolean;
        bRequireCurrentFrameData: boolean;
        bFixedBounds: boolean;
        EffectType: NiagaraEffectType;
        bOverrideScalabilitySettings: boolean;
        ScalabilityOverrides: TArray<NiagaraSystemScalabilityOverride>;
        SystemScalabilityOverrides: NiagaraSystemScalabilityOverrides;
        EmitterHandles: TArray<NiagaraEmitterHandle>;
        ParameterCollectionOverrides: TArray<NiagaraParameterCollectionInstance>;
        ActiveCompilations: TArray<NiagaraSystemCompileRequest>;
        SystemSpawnScript: NiagaraScript;
        SystemUpdateScript: NiagaraScript;
        SystemCompiledData: NiagaraSystemCompiledData;
        ExposedParameters: NiagaraUserRedirectionParameterStore;
        EditorData: NiagaraEditorDataBase;
        FixedBounds: Box;
        bAutoDeactivate: boolean;
        WarmupTime: number;
        WarmupTickCount: number;
        WarmupTickDelta: number;
        bHasSystemScriptDIsWithPerInstanceData: boolean;
        UserDINamesReadInSystemScripts: TArray<string>;
        MessageKeyToMessageMap: TMap<Guid, NiagaraMessageDataBase>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSystem;

        static Load(InName: string): NiagaraSystem;
    }

    export class AnimNotify_PlayNiagaraEffect extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Template: NiagaraSystem;
        LocationOffset: Vector;
        RotationOffset: Rotator;
        Scale: Vector;
        bAbsoluteScale: boolean;
        Attached: boolean;
        SocketName: string;

        GetSpawnedEffect(): FXSystemComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayNiagaraEffect;

        static Load(InName: string): AnimNotify_PlayNiagaraEffect;
    }

    export class AnimNotify_PlayParticleEffect extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PSTemplate: ParticleSystem;
        LocationOffset: Vector;
        RotationOffset: Rotator;
        Scale: Vector;
        Attached: boolean;
        SocketName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayParticleEffect;

        static Load(InName: string): AnimNotify_PlayParticleEffect;
    }

    export class AnimNotify_PlaySound extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sound: SoundBase;
        VolumeMultiplier: number;
        PitchMultiplier: number;
        bFollow: boolean;
        bPreviewIgnoreAttenuation: boolean;
        AttachName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlaySound;

        static Load(InName: string): AnimNotify_PlaySound;
    }

    export class AnimNotify_ResetClothingSimulation extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResetClothingSimulation;

        static Load(InName: string): AnimNotify_ResetClothingSimulation;
    }

    export class AnimNotify_ResetDynamics extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResetDynamics;

        static Load(InName: string): AnimNotify_ResetDynamics;
    }

    export class AnimNotify_ResumeClothingSimulation extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResumeClothingSimulation;

        static Load(InName: string): AnimNotify_ResumeClothingSimulation;
    }

    export class AnimNotifyState_DisableRootMotion extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_DisableRootMotion;

        static Load(InName: string): AnimNotifyState_DisableRootMotion;
    }

    export class AnimNotifyState_TimedNiagaraEffect extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Template: NiagaraSystem;
        SocketName: string;
        LocationOffset: Vector;
        RotationOffset: Rotator;
        bDestroyAtEnd: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_TimedNiagaraEffect;

        static Load(InName: string): AnimNotifyState_TimedNiagaraEffect;
    }

    export class AnimNotifyState_TimedParticleEffect extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PSTemplate: ParticleSystem;
        SocketName: string;
        LocationOffset: Vector;
        RotationOffset: Rotator;
        bDestroyAtEnd: boolean;
        PreviousPSTemplates: TArray<ParticleSystem>;
        PreviousSocketNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_TimedParticleEffect;

        static Load(InName: string): AnimNotifyState_TimedParticleEffect;
    }

    export class AnimNotifyState_Trail extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PSTemplate: ParticleSystem;
        FirstSocketName: string;
        SecondSocketName: string;
        WidthScaleMode: ETrailWidthMode;
        WidthScaleCurve: string;
        bRecycleSpawnedSystems: boolean;
        bRenderGeometry: boolean;
        bRenderSpawnPoints: boolean;
        bRenderTangents: boolean;
        bRenderTessellation: boolean;

        OverridePSTemplate(MeshComp: $Nullable<SkeletalMeshComponent>, Animation: $Nullable<AnimSequenceBase>): ParticleSystem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_Trail;

        static Load(InName: string): AnimNotifyState_Trail;
    }

    export class AnimPreviewAttacheInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimPreviewAttacheInstance;

        static Load(InName: string): AnimPreviewAttacheInstance;
    }

    export class AnimSingleNodeInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentAsset: AnimationAsset;
        PostEvaluateAnimEvent: $Delegate<() => void>;

        GetAnimationAsset(): AnimationAsset;

        GetLength(): number;

        PlayAnim(bIsLooping?: boolean /* = false */, InPlayRate?: number /* = 1.000000 */, InStartPosition?: number /* = 0.000000 */): void;

        SetAnimationAsset(NewAsset: $Nullable<AnimationAsset>, bIsLooping?: boolean /* = true */, InPlayRate?: number /* = 1.000000 */): void;

        SetBlendSpaceInput(InBlendInput: Vector): void;

        SetLooping(bIsLooping: boolean): void;

        SetPlaying(bIsPlaying: boolean): void;

        SetPlayRate(InPlayRate: number): void;

        SetPosition(InPosition: number, bFireNotifies?: boolean /* = true */): void;

        SetPositionWithPreviousTime(InPosition: number, InPreviousTime: number, bFireNotifies?: boolean /* = true */): void;

        SetPreviewCurveOverride(PoseName: string, Value: number, bRemoveIfZero: boolean): void;

        SetReverse(bInReverse: boolean): void;

        StopAnim(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSingleNodeInstance;

        static Load(InName: string): AnimSingleNodeInstance;
    }

    export enum EMontagePreviewType { EMPT_Normal, EMPT_AllSections, EMPT_MAX }

    export class AnimPreviewInstance extends AnimSingleNodeInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MontagePreviewType: EMontagePreviewType;
        MontagePreviewStartSectionIdx: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimPreviewInstance;

        static Load(InName: string): AnimPreviewInstance;
    }

    export class AnimSeqExportOption extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bExportTransforms: boolean;
        bExportCurves: boolean;
        bRecordInWorldSpace: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSeqExportOption;

        static Load(InName: string): AnimSeqExportOption;
    }

    export class AssetExportTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Object: Object;
        Exporter: Exporter;
        Filename: string;
        bSelected: boolean;
        bReplaceIdentical: boolean;
        bPrompt: boolean;
        bAutomated: boolean;
        bUseFileArchive: boolean;
        bWriteEmptyFiles: boolean;
        IgnoreObjectList: TArray<Object>;
        Options: Object;
        Errors: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetExportTask;

        static Load(InName: string): AssetExportTask;
    }

    export class Exporter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SupportedClass: Class;
        ExportRootScope: Object;
        FormatExtension: TArray<string>;
        FormatDescription: TArray<string>;
        PreferredFormatIndex: number;
        TextIndent: number;
        bText: boolean;
        bSelectedOnly: boolean;
        bForceFileOperations: boolean;
        ExportTask: AssetExportTask;

        ScriptRunAssetExportTask(Task: $Nullable<AssetExportTask>): boolean;

        static RunAssetExportTask(Task: $Nullable<AssetExportTask>): boolean;

        static RunAssetExportTasks(ExportTasks: TArray<AssetExportTask>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Exporter;

        static Load(InName: string): Exporter;
    }

    export class ExporterFBX extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ExporterFBX;

        static Load(InName: string): ExporterFBX;
    }

    export class AnimSequenceExporterFBX extends ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSequenceExporterFBX;

        static Load(InName: string): AnimSequenceExporterFBX;
    }

    export class AnimSequenceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSequenceFactory;

        static Load(InName: string): AnimSequenceFactory;
    }

    export class AnimSequenceLevelSequenceLink extends AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SkelTrackGuid: Guid;
        PathToLevelSequence: SoftObjectPath;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSequenceLevelSequenceLink;

        static Load(InName: string): AnimSequenceLevelSequenceLink;
    }

    export class AnimSequencerInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSequencerInstance;

        static Load(InName: string): AnimSequencerInstance;
    }

    export class AnimSequenceThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSequenceThumbnailRenderer;

        static Load(InName: string): AnimSequenceThumbnailRenderer;
    }

    export class AnimSetMeshLinkup {
        constructor();
        constructor(BoneToTrackTable: TArray<number>);

        BoneToTrackTable: TArray<number>;

        static StaticClass(): Class;
    }

    export class AnimSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAnimRotationOnly: boolean;
        TrackBoneNames: TArray<string>;
        Sequences: TArray<AnimSequence>;
        LinkupCache: TArray<AnimSetMeshLinkup>;
        BoneUseAnimTranslation: TArray<number>;
        ForceUseMeshTranslation: TArray<number>;
        UseTranslationBoneNames: TArray<string>;
        ForceMeshTranslationBoneNames: TArray<string>;
        PreviewSkelMeshName: string;
        BestRatioSkelMeshName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimSet;

        static Load(InName: string): AnimSet;
    }

    export class AnimStateNodeBase extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimStateNodeBase;

        static Load(InName: string): AnimStateNodeBase;
    }

    export class AnimStateConduitNode extends AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoundGraph: EdGraph;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimStateConduitNode;

        static Load(InName: string): AnimStateConduitNode;
    }

    export class AnimStateMachineTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimStateMachineTypes;

        static Load(InName: string): AnimStateMachineTypes;
    }

    export enum EAnimStateType { AST_SingleAnimation, AST_BlendGraph, AST_MAX }

    export class AnimStateNode extends AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoundGraph: EdGraph;
        StateType: EAnimStateType;
        StateEntered: AnimNotifyEvent;
        StateLeft: AnimNotifyEvent;
        StateFullyBlended: AnimNotifyEvent;
        bAlwaysResetOnEntry: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimStateNode;

        static Load(InName: string): AnimStateNode;
    }

    export enum ETransitionBlendMode { TBM_Linear, TBM_Cubic, TBM_MAX }

    export class AnimStateTransitionNode extends AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoundGraph: EdGraph;
        CustomTransitionGraph: EdGraph;
        PriorityOrder: number;
        CrossfadeDuration: number;
        CrossfadeMode: ETransitionBlendMode;
        BlendMode: EAlphaBlendOption;
        CustomBlendCurve: CurveFloat;
        BlendProfile: BlendProfile;
        bAutomaticRuleBasedOnSequencePlayerInState: boolean;
        LogicType: ETransitionLogicType;
        TransitionStart: AnimNotifyEvent;
        TransitionEnd: AnimNotifyEvent;
        TransitionInterrupt: AnimNotifyEvent;
        Bidirectional: boolean;
        bSharedRules: boolean;
        bSharedCrossfade: boolean;
        SharedRulesName: string;
        SharedRulesGuid: Guid;
        SharedColor: LinearColor;
        SharedCrossfadeName: string;
        SharedCrossfadeGuid: Guid;
        SharedCrossfadeIdx: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimStateTransitionNode;

        static Load(InName: string): AnimStateTransitionNode;
    }

    export class RawAnimSequenceTrack {
        constructor();
        constructor(PosKeys: TArray<Vector>, RotKeys: TArray<Quat>, ScaleKeys: TArray<Vector>);

        PosKeys: TArray<Vector>;
        RotKeys: TArray<Quat>;
        ScaleKeys: TArray<Vector>;

        static StaticClass(): Class;
    }

    export class AnimStreamable extends AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumFrames: number;
        Interpolation: EAnimInterpolationType;
        RetargetSource: string;
        SourceSequence: AnimSequence;
        RawDataGuid: Guid;
        RawAnimationData: TArray<RawAnimSequenceTrack>;
        TrackToSkeletonMapTable: TArray<TrackToSkeletonMap>;
        AnimationTrackNames: TArray<string>;
        BoneCompressionSettings: AnimBoneCompressionSettings;
        CurveCompressionSettings: AnimCurveCompressionSettings;
        bEnableRootMotion: boolean;
        RootMotionRootLock: ERootMotionRootLock;
        bForceRootLock: boolean;
        bUseNormalizedRootMotionScale: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimStreamable;

        static Load(InName: string): AnimStreamable;
    }

    export class AnimStreamableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeleton: Skeleton;
        SourceAnimation: AnimSequence;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnimStreamableFactory;

        static Load(InName: string): AnimStreamableFactory;
    }

    export class InputBehavior extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputBehavior;

        static Load(InName: string): InputBehavior;
    }

    export class AnyButtonInputBehavior extends InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AnyButtonInputBehavior;

        static Load(InName: string): AnyButtonInputBehavior;
    }

    export enum ETemperatureSeverityType {
        Unknown,
        Good,
        Bad,
        Serious,
        Critical,
        NumSeverities,
        ETemperatureSeverityType_MAX
    }

    export class ApplicationLifecycleComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ApplicationWillDeactivateDelegate: $MulticastDelegate<() => void>;
        ApplicationHasReactivatedDelegate: $MulticastDelegate<() => void>;
        ApplicationWillEnterBackgroundDelegate: $MulticastDelegate<() => void>;
        ApplicationHasEnteredForegroundDelegate: $MulticastDelegate<() => void>;
        ApplicationWillTerminateDelegate: $MulticastDelegate<() => void>;
        ApplicationShouldUnloadResourcesDelegate: $MulticastDelegate<() => void>;
        ApplicationReceivedStartupArgumentsDelegate: $MulticastDelegate<(StartupArguments: TArray<string>) => void>;
        OnTemperatureChangeDelegate: $MulticastDelegate<(Severity: ETemperatureSeverityType) => void>;
        OnLowPowerModeDelegate: $MulticastDelegate<(bInLowPowerMode: boolean) => void>;

        ApplicationLifetimeDelegate__DelegateSignature(): void;

        ApplicationStartupArgumentsDelegate__DelegateSignature(StartupArguments: TArray<string>): void;

        OnLowPowerModeDelegate__DelegateSignature(bInLowPowerMode: boolean): void;

        OnTemperatureChangeDelegate__DelegateSignature(Severity: ETemperatureSeverityType): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ApplicationLifecycleComponent;

        static Load(InName: string): ApplicationLifecycleComponent;
    }

    export class MRMeshComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Material: MaterialInterface;
        WireframeMaterial: MaterialInterface;
        bCreateMeshProxySections: boolean;
        bUpdateNavMeshOnMeshUpdate: boolean;
        bNeverCreateCollisionMesh: boolean;
        CachedBodySetup: BodySetup;
        BodySetups: TArray<BodySetup>;

        Clear(): void;

        ForceNavMeshUpdate(): void;

        GetEnableMeshOcclusion(): boolean;

        GetUseWireframe(): boolean;

        GetWireframeColor(): LinearColor;

        IsConnected(): boolean;

        SetEnableMeshOcclusion(bEnable: boolean): void;

        SetUseWireframe(bUseWireframe: boolean): void;

        SetWireframeColor(InColor: LinearColor): void;

        SetWireframeMaterial(InMaterial: $Nullable<MaterialInterface>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MRMeshComponent;

        static Load(InName: string): MRMeshComponent;
    }

    export enum EARTrackingState { Unknown, Tracking, NotTracking, StoppedTracking, EARTrackingState_MAX }

    export enum EARObjectClassification {
        NotApplicable,
        Unknown,
        Wall,
        Ceiling,
        Floor,
        Table,
        Seat,
        Face,
        Image,
        World,
        SceneObject,
        HandMesh,
        Door,
        Window,
        EARObjectClassification_MAX
    }

    export class ARTrackedGeometry extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UniqueId: Guid;
        LocalToTrackingTransform: Transform;
        LocalToAlignedTrackingTransform: Transform;
        TrackingState: EARTrackingState;
        UnderlyingMesh: MRMeshComponent;
        ObjectClassification: EARObjectClassification;
        LastUpdateFrameNumber: number;
        DebugName: string;

        GetDebugName(): string;

        GetLastUpdateFrameNumber(): number;

        GetLastUpdateTimestamp(): number;

        GetLocalToTrackingTransform(): Transform;

        GetLocalToWorldTransform(): Transform;

        GetName(): string;

        GetObjectClassification(): EARObjectClassification;

        GetTrackingState(): EARTrackingState;

        GetUnderlyingMesh(): MRMeshComponent;

        IsTracked(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTrackedGeometry;

        static Load(InName: string): ARTrackedGeometry;
    }

    export class ARComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NativeID: Guid;
        bUseDefaultReplication: boolean;
        DefaultMeshMaterial: MaterialInterface;
        DefaultWireframeMeshMaterial: MaterialInterface;
        MRMeshComponent: MRMeshComponent;
        MyTrackedGeometry: ARTrackedGeometry;

        GetMRMesh(): MRMeshComponent;

        OnRep_Payload(): void;

        ReceiveRemove(): void;

        SetNativeID(NativeID: Guid): void;

        UpdateVisualization(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARComponent;

        static Load(InName: string): ARComponent;
    }

    export class ARActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddARComponent(InComponentClass: $Nullable<Class>, NativeID: Guid): ARComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARActor;

        static Load(InName: string): ARActor;
    }

    export class ARBaseAsyncTaskBlueprintProxy extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARBaseAsyncTaskBlueprintProxy;

        static Load(InName: string): ARBaseAsyncTaskBlueprintProxy;
    }

    export class ARLightEstimate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARLightEstimate;

        static Load(InName: string): ARLightEstimate;
    }

    export class ARBasicLightEstimate extends ARLightEstimate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AmbientIntensityLumens: number;
        AmbientColorTemperatureKelvin: number;
        AmbientColor: LinearColor;

        GetAmbientColor(): LinearColor;

        GetAmbientColorTemperatureKelvin(): number;

        GetAmbientIntensityLumens(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARBasicLightEstimate;

        static Load(InName: string): ARBasicLightEstimate;
    }

    export enum EARCaptureType { Camera, QRCode, SpatialMapping, SceneUnderstanding, EARCaptureType_MAX }

    export enum EARWorldAlignment { Gravity, GravityAndHeading, Camera, EARWorldAlignment_MAX }

    export enum EARSessionType {
        None,
        Orientation,
        World,
        Face,
        Image,
        ObjectScanning,
        PoseTracking,
        GeoTracking,
        EARSessionType_MAX
    }

    export enum EARPlaneDetectionMode {
        None,
        HorizontalPlaneDetection,
        VerticalPlaneDetection,
        EARPlaneDetectionMode_MAX
    }

    export enum EARLightEstimationMode {
        None,
        AmbientLightEstimate,
        DirectionalLightEstimate,
        EARLightEstimationMode_MAX
    }

    export enum EARFrameSyncMode { SyncTickWithCameraImage, SyncTickWithoutCameraImage, EARFrameSyncMode_MAX }

    export enum EARCandidateImageOrientation { Landscape, Portrait, EARCandidateImageOrientation_MAX }

    export class ARCandidateImage extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CandidateTexture: Texture2D;
        FriendlyName: string;
        Width: number;
        Height: number;
        Orientation: EARCandidateImageOrientation;

        GetCandidateTexture(): Texture2D;

        GetFriendlyName(): string;

        GetOrientation(): EARCandidateImageOrientation;

        GetPhysicalHeight(): number;

        GetPhysicalWidth(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARCandidateImage;

        static Load(InName: string): ARCandidateImage;
    }

    export enum EAREnvironmentCaptureProbeType { None, Manual, Automatic, EAREnvironmentCaptureProbeType_MAX }

    export class ARCandidateObject extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CandidateObjectData: TArray<number>;
        FriendlyName: string;
        BoundingBox: Box;

        GetBoundingBox(): Box;

        GetCandidateObjectData(): TArray<number>;

        GetFriendlyName(): string;

        SetBoundingBox(InBoundingBox: Box): void;

        SetCandidateObjectData(InCandidateObject: TArray<number>): void;

        SetFriendlyName(NewName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARCandidateObject;

        static Load(InName: string): ARCandidateObject;
    }

    export class ARVideoFormat {
        constructor();
        constructor(FPS: number, Width: number, Height: number);

        FPS: number;
        Width: number;
        Height: number;

        static StaticClass(): Class;
    }

    export enum EARFaceTrackingDirection { FaceRelative, FaceMirrored, EARFaceTrackingDirection_MAX }

    export enum EARFaceTrackingUpdate { CurvesAndGeo, CurvesOnly, EARFaceTrackingUpdate_MAX }

    export enum EARSessionTrackingFeature {
        None,
        PoseDetection2D,
        PersonSegmentation,
        PersonSegmentationWithDepth,
        SceneDepth,
        SmoothedSceneDepth,
        EARSessionTrackingFeature_MAX
    }

    export enum EARSceneReconstruction { None, MeshOnly, MeshWithClassification, EARSceneReconstruction_MAX }

    export class ARSessionConfig extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bGenerateMeshDataFromTrackedGeometry: boolean;
        bGenerateCollisionForMeshData: boolean;
        bGenerateNavMeshForMeshData: boolean;
        bUseMeshDataForOcclusion: boolean;
        bRenderMeshDataInWireframe: boolean;
        bTrackSceneObjects: boolean;
        bUsePersonSegmentationForOcclusion: boolean;
        bUseSceneDepthForOcclusion: boolean;
        bUseAutomaticImageScaleEstimation: boolean;
        bUseStandardOnboardingUX: boolean;
        WorldAlignment: EARWorldAlignment;
        SessionType: EARSessionType;
        PlaneDetectionMode: EARPlaneDetectionMode;
        bHorizontalPlaneDetection: boolean;
        bVerticalPlaneDetection: boolean;
        bEnableAutoFocus: boolean;
        LightEstimationMode: EARLightEstimationMode;
        FrameSyncMode: EARFrameSyncMode;
        bEnableAutomaticCameraOverlay: boolean;
        bEnableAutomaticCameraTracking: boolean;
        bResetCameraTracking: boolean;
        bResetTrackedObjects: boolean;
        CandidateImages: TArray<ARCandidateImage>;
        MaxNumSimultaneousImagesTracked: number;
        EnvironmentCaptureProbeType: EAREnvironmentCaptureProbeType;
        WorldMapData: TArray<number>;
        CandidateObjects: TArray<ARCandidateObject>;
        DesiredVideoFormat: ARVideoFormat;
        bUseOptimalVideoFormat: boolean;
        FaceTrackingDirection: EARFaceTrackingDirection;
        FaceTrackingUpdate: EARFaceTrackingUpdate;
        MaxNumberOfTrackedFaces: number;
        SerializedARCandidateImageDatabase: TArray<number>;
        EnabledSessionTrackingFeature: EARSessionTrackingFeature;
        SceneReconstructionMethod: EARSceneReconstruction;
        PlaneComponentClass: Class;
        PointComponentClass: Class;
        FaceComponentClass: Class;
        ImageComponentClass: Class;
        QRCodeComponentClass: Class;
        PoseComponentClass: Class;
        EnvironmentProbeComponentClass: Class;
        ObjectComponentClass: Class;
        MeshComponentClass: Class;
        GeoAnchorComponentClass: Class;
        DefaultMeshMaterial: MaterialInterface;
        DefaultWireframeMeshMaterial: MaterialInterface;

        AddCandidateImage(NewCandidateImage: $Nullable<ARCandidateImage>): void;

        AddCandidateObject(CandidateObject: $Nullable<ARCandidateObject>): void;

        GetCandidateImageList(): TArray<ARCandidateImage>;

        GetCandidateObjectList(): TArray<ARCandidateObject>;

        GetDesiredVideoFormat(): ARVideoFormat;

        GetEnabledSessionTrackingFeature(): EARSessionTrackingFeature;

        GetEnvironmentCaptureProbeType(): EAREnvironmentCaptureProbeType;

        GetFaceTrackingDirection(): EARFaceTrackingDirection;

        GetFaceTrackingUpdate(): EARFaceTrackingUpdate;

        GetFrameSyncMode(): EARFrameSyncMode;

        GetLightEstimationMode(): EARLightEstimationMode;

        GetMaxNumSimultaneousImagesTracked(): number;

        GetPlaneDetectionMode(): EARPlaneDetectionMode;

        GetSceneReconstructionMethod(): EARSceneReconstruction;

        GetSessionType(): EARSessionType;

        GetWorldAlignment(): EARWorldAlignment;

        GetWorldMapData(): TArray<number>;

        SetCandidateObjectList(InCandidateObjects: TArray<ARCandidateObject>): void;

        SetDesiredVideoFormat(NewFormat: ARVideoFormat): void;

        SetEnableAutoFocus(bNewValue: boolean): void;

        SetFaceTrackingDirection(InDirection: EARFaceTrackingDirection): void;

        SetFaceTrackingUpdate(InUpdate: EARFaceTrackingUpdate): void;

        SetResetCameraTracking(bNewValue: boolean): void;

        SetResetTrackedObjects(bNewValue: boolean): void;

        SetSceneReconstructionMethod(InSceneReconstructionMethod: EARSceneReconstruction): void;

        SetSessionTrackingFeatureToEnable(InSessionTrackingFeature: EARSessionTrackingFeature): void;

        SetWorldMapData(WorldMapData: TArray<number>): void;

        ShouldEnableAutoFocus(): boolean;

        ShouldEnableCameraTracking(): boolean;

        ShouldRenderCameraOverlay(): boolean;

        ShouldResetCameraTracking(): boolean;

        ShouldResetTrackedObjects(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARSessionConfig;

        static Load(InName: string): ARSessionConfig;
    }

    export class ARPin extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TrackedGeometry: ARTrackedGeometry;
        PinnedComponent: SceneComponent;
        LocalToTrackingTransform: Transform;
        LocalToAlignedTrackingTransform: Transform;
        TrackingState: EARTrackingState;
        OnARTrackingStateChanged: $MulticastDelegate<(NewTrackingState: EARTrackingState) => void>;
        OnARTransformUpdated: $MulticastDelegate<(OldToNewTransform: Transform) => void>;

        DebugDraw(World: $Nullable<World>, Color: LinearColor, Scale: number, PersistForSeconds: number): void;

        GetDebugName(): string;

        GetLocalToTrackingTransform(): Transform;

        GetLocalToWorldTransform(): Transform;

        GetPinnedComponent(): SceneComponent;

        GetTrackedGeometry(): ARTrackedGeometry;

        GetTrackingState(): EARTrackingState;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARPin;

        static Load(InName: string): ARPin;
    }

    export enum EARLineTraceChannels {
        None,
        FeaturePoint,
        GroundPlane,
        PlaneUsingExtent,
        PlaneUsingBoundaryPolygon,
        EARLineTraceChannels_MAX
    }

    export class ARTraceResult {
        constructor();
        constructor(DistanceFromCamera: number, TraceChannel: EARLineTraceChannels, LocalTransform: Transform, TrackedGeometry: ARTrackedGeometry);

        DistanceFromCamera: number;
        TraceChannel: EARLineTraceChannels;
        LocalTransform: Transform;
        TrackedGeometry: ARTrackedGeometry;

        static StaticClass(): Class;
    }

    export enum EARWorldMappingState {
        NotAvailable,
        StillMappingNotRelocalizable,
        StillMappingRelocalizable,
        Mapped,
        EARWorldMappingState_MAX
    }

    export enum EARTrackingQualityReason {
        None,
        Initializing,
        Relocalizing,
        ExcessiveMotion,
        InsufficientFeatures,
        InsufficientLight,
        BadState,
        EARTrackingQualityReason_MAX
    }

    export enum EARTrackingQuality { NotTracking, OrientationOnly, OrientationAndPosition, EARTrackingQuality_MAX }

    export enum EARTextureType {
        Unknown,
        CameraImage,
        CameraDepth,
        EnvironmentCapture,
        PersonSegmentationImage,
        PersonSegmentationDepth,
        SceneDepthMap,
        SceneDepthConfidenceMap,
        EARTextureType_MAX
    }

    export class ARTexture extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureType: EARTextureType;
        Timestamp: number;
        ExternalTextureGuid: Guid;
        Size: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTexture;

        static Load(InName: string): ARTexture;
    }

    export class ARCameraIntrinsics {
        constructor();
        constructor(ImageResolution: IntPoint, FocalLength: Vector2D, PrincipalPoint: Vector2D);

        ImageResolution: IntPoint;
        FocalLength: Vector2D;
        PrincipalPoint: Vector2D;

        static StaticClass(): Class;
    }

    export class ARTextureCameraImage extends ARTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTextureCameraImage;

        static Load(InName: string): ARTextureCameraImage;
    }

    export enum EARDepthQuality { Unkown, Low, High, EARDepthQuality_MAX }

    export enum EARDepthAccuracy { Unkown, Approximate, Accurate, EARDepthAccuracy_MAX }

    export class ARTextureCameraDepth extends ARTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DepthQuality: EARDepthQuality;
        DepthAccuracy: EARDepthAccuracy;
        bIsTemporallySmoothed: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTextureCameraDepth;

        static Load(InName: string): ARTextureCameraDepth;
    }

    export enum EARSessionStatus {
        NotStarted,
        Running,
        NotSupported,
        FatalError,
        PermissionNotGranted,
        UnsupportedConfiguration,
        Other,
        EARSessionStatus_MAX
    }

    export class ARSessionStatus {
        constructor();
        constructor(AdditionalInfo: string, Status: EARSessionStatus);

        AdditionalInfo: string;
        Status: EARSessionStatus;

        static StaticClass(): Class;
    }

    export class ARSkeletonDefinition {
        constructor();
        constructor(NumJoints: number, JointNames: TArray<string>, ParentIndices: TArray<number>);

        NumJoints: number;
        JointNames: TArray<string>;
        ParentIndices: TArray<number>;

        static StaticClass(): Class;
    }

    export enum EARJointTransformSpace { Model, ParentJoint, EARJointTransformSpace_MAX }

    export class ARPose3D {
        constructor();
        constructor(SkeletonDefinition: ARSkeletonDefinition, JointTransforms: TArray<Transform>, IsJointTracked: TArray<boolean>, JointTransformSpace: EARJointTransformSpace);

        SkeletonDefinition: ARSkeletonDefinition;
        JointTransforms: TArray<Transform>;
        IsJointTracked: TArray<boolean>;
        JointTransformSpace: EARJointTransformSpace;

        static StaticClass(): Class;
    }

    export class ARTrackedPose extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TrackedPose: ARPose3D;

        GetTrackedPoseData(): ARPose3D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTrackedPose;

        static Load(InName: string): ARTrackedPose;
    }

    export class ARTrackedPoint extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTrackedPoint;

        static Load(InName: string): ARTrackedPoint;
    }

    export enum EARPlaneOrientation { Horizontal, Vertical, Diagonal, EARPlaneOrientation_MAX }

    export class ARPlaneGeometry extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Orientation: EARPlaneOrientation;
        Center: Vector;
        Extent: Vector;
        BoundaryPolygon: TArray<Vector>;
        SubsumedBy: ARPlaneGeometry;

        GetBoundaryPolygonInLocalSpace(): TArray<Vector>;

        GetCenter(): Vector;

        GetExtent(): Vector;

        GetOrientation(): EARPlaneOrientation;

        GetSubsumedBy(): ARPlaneGeometry;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARPlaneGeometry;

        static Load(InName: string): ARPlaneGeometry;
    }

    export class ARTrackedImage extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DetectedImage: ARCandidateImage;
        EstimatedSize: Vector2D;

        GetDetectedImage(): ARCandidateImage;

        GetEstimateSize(): Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTrackedImage;

        static Load(InName: string): ARTrackedImage;
    }

    export class AREnvironmentCaptureProbeTexture extends TextureCube {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureType: EARTextureType;
        Timestamp: number;
        ExternalTextureGuid: Guid;
        Size: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AREnvironmentCaptureProbeTexture;

        static Load(InName: string): AREnvironmentCaptureProbeTexture;
    }

    export class AREnvironmentCaptureProbe extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Extent: Vector;
        EnvironmentCaptureTexture: AREnvironmentCaptureProbeTexture;

        GetEnvironmentCaptureTexture(): AREnvironmentCaptureProbeTexture;

        GetExtent(): Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AREnvironmentCaptureProbe;

        static Load(InName: string): AREnvironmentCaptureProbe;
    }

    export class ARPose2D {
        constructor();
        constructor(SkeletonDefinition: ARSkeletonDefinition, JointLocations: TArray<Vector2D>, IsJointTracked: TArray<boolean>);

        SkeletonDefinition: ARSkeletonDefinition;
        JointLocations: TArray<Vector2D>;
        IsJointTracked: TArray<boolean>;

        static StaticClass(): Class;
    }

    export class ARBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddManualEnvironmentCaptureProbe(Location: Vector, Extent: Vector): boolean;

        static AddRuntimeCandidateImage(SessionConfig: $Nullable<ARSessionConfig>, CandidateTexture: $Nullable<Texture2D>, FriendlyName: string, PhysicalWidth: number): ARCandidateImage;

        static AddTrackedPointWithName(WorldTransform: Transform, PointName: string, bDeletePointsWithSameName?: boolean /* = true */): boolean;

        static CalculateAlignmentTransform(TransformInFirstCoordinateSystem: Transform, TransformInSecondCoordinateSystem: Transform, AlignmentTransform: $Ref<Transform>): void;

        static CalculateClosestIntersection(StartPoints: TArray<Vector>, EndPoints: TArray<Vector>, ClosestIntersection: $Ref<Vector>): void;

        static DebugDrawPin(ARPin: $Nullable<ARPin>, WorldContextObject: $Nullable<Object>, Color?: LinearColor /* = (R=1.000000,G=1.000000,B=0.000000,A=0.750000) */, Scale?: number /* = 5.000000 */, PersistForSeconds?: number /* = 0.000000 */): void;

        static DebugDrawTrackedGeometry(TrackedGeometry: $Nullable<ARTrackedGeometry>, WorldContextObject: $Nullable<Object>, Color?: LinearColor /* = (R=1.000000,G=1.000000,B=0.000000,A=0.750000) */, OutlineThickness?: number /* = 5.000000 */, PersistForSeconds?: number /* = 0.000000 */): void;

        static FindTrackedPointsByName(PointName: string): TArray<ARTrackedPoint>;

        static GetAlignmentTransform(): Transform;

        static GetAllGeometries(): TArray<ARTrackedGeometry>;

        static GetAllGeometriesByClass(GeometryClass: $Nullable<Class>): TArray<ARTrackedGeometry>;

        static GetAllPins(): TArray<ARPin>;

        static GetAllTracked2DPoses(): TArray<ARPose2D>;

        static GetAllTrackedEnvironmentCaptureProbes(): TArray<AREnvironmentCaptureProbe>;

        static GetAllTrackedImages(): TArray<ARTrackedImage>;

        static GetAllTrackedPlanes(): TArray<ARPlaneGeometry>;

        static GetAllTrackedPoints(): TArray<ARTrackedPoint>;

        static GetAllTrackedPoses(): TArray<ARTrackedPose>;

        static GetARSessionStatus(): ARSessionStatus;

        static GetARTexture(TextureType: EARTextureType): ARTexture;

        static GetARWorldScale(): number;

        static GetCameraDepth(): ARTextureCameraDepth;

        static GetCameraImage(): ARTextureCameraImage;

        static GetCameraIntrinsics(OutCameraIntrinsics: $Ref<ARCameraIntrinsics>): boolean;

        static GetCurrentLightEstimate(): ARLightEstimate;

        static GetNumberOfTrackedFacesSupported(): number;

        static GetObjectClassificationAtLocation(InWorldLocation: Vector, OutClassification: $Ref<EARObjectClassification>, OutClassificationLocation: $Ref<Vector>, MaxLocationDiff?: number /* = 10.000000 */): boolean;

        static GetPersonSegmentationDepthImage(): ARTexture;

        static GetPersonSegmentationImage(): ARTexture;

        static GetPointCloud(): TArray<Vector>;

        static GetSessionConfig(): ARSessionConfig;

        static GetSupportedVideoFormats(SessionType: EARSessionType): TArray<ARVideoFormat>;

        static GetTrackingQuality(): EARTrackingQuality;

        static GetTrackingQualityReason(): EARTrackingQualityReason;

        static GetWorldMappingStatus(): EARWorldMappingState;

        static IsARPinLocalStoreReady(): boolean;

        static IsARPinLocalStoreSupported(): boolean;

        static IsARSupported(): boolean;

        static IsSceneReconstructionSupported(SessionType: EARSessionType, SceneReconstructionMethod: EARSceneReconstruction): boolean;

        static IsSessionTrackingFeatureSupported(SessionType: EARSessionType, SessionTrackingFeature: EARSessionTrackingFeature): boolean;

        static IsSessionTypeSupported(SessionType: EARSessionType): boolean;

        static LineTraceTrackedObjects(ScreenCoord: Vector2D, bTestFeaturePoints?: boolean /* = true */, bTestGroundPlane?: boolean /* = true */, bTestPlaneExtents?: boolean /* = true */, bTestPlaneBoundaryPolygon?: boolean /* = true */): TArray<ARTraceResult>;

        static LineTraceTrackedObjects3D(Start: Vector, End: Vector, bTestFeaturePoints?: boolean /* = true */, bTestGroundPlane?: boolean /* = true */, bTestPlaneExtents?: boolean /* = true */, bTestPlaneBoundaryPolygon?: boolean /* = true */): TArray<ARTraceResult>;

        static LoadARPinsFromLocalStore(): TMap<string, ARPin>;

        static PauseARSession(): void;

        static PinComponent(ComponentToPin: $Nullable<SceneComponent>, PinToWorldTransform: Transform, TrackedGeometry?: ARTrackedGeometry /* = None */, DebugName?: string /* = "None" */): ARPin;

        static PinComponentToARPin(ComponentToPin: $Nullable<SceneComponent>, Pin: $Nullable<ARPin>): boolean;

        static PinComponentToTraceResult(ComponentToPin: $Nullable<SceneComponent>, TraceResult: ARTraceResult, DebugName?: string /* = "None" */): ARPin;

        static RemoveAllARPinsFromLocalStore(): void;

        static RemoveARPinFromLocalStore(InSaveName: string): void;

        static RemovePin(PinToRemove: $Nullable<ARPin>): void;

        static ResizeXRCamera(InSize: IntPoint): IntPoint;

        static SaveARPinToLocalStore(InSaveName: string, InPin: $Nullable<ARPin>): boolean;

        static SetAlignmentTransform(InAlignmentTransform: Transform): void;

        static SetARWorldOriginLocationAndRotation(OriginLocation: Vector, OriginRotation: Rotator, bIsTransformInWorldSpace?: boolean /* = true */, bMaintainUpDirection?: boolean /* = true */): void;

        static SetARWorldScale(InWorldScale: number): void;

        static SetEnabledXRCamera(bOnOff: boolean): void;

        static StartARSession(SessionConfig: $Nullable<ARSessionConfig>): void;

        static StopARSession(): void;

        static ToggleARCapture(bOnOff: boolean, CaptureType: EARCaptureType): boolean;

        static UnpinComponent(ComponentToUnpin: $Nullable<SceneComponent>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARBlueprintLibrary;

        static Load(InName: string): ARBlueprintLibrary;
    }

    export enum EShapeAddMode { AppendAfter, AppendBefore, InsertAfter, InsertBefore, EShapeAddMode_MAX }

    export class SplineGeneratorBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShapeAddMode: EShapeAddMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SplineGeneratorBase;

        static Load(InName: string): SplineGeneratorBase;
    }

    export class ArcSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumberOfPoints: number;
        Radius: number;
        Degrees: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ArcSplineGenerator;

        static Load(InName: string): ArcSplineGenerator;
    }

    export enum EARServicePermissionRequestResult { Granted, Denied, EARServicePermissionRequestResult_MAX }

    export enum EARServiceInstallRequestResult {
        Installed,
        DeviceNotCompatible,
        UserDeclinedInstallation,
        FatalError,
        EARServiceInstallRequestResult_MAX
    }

    export enum EARServiceAvailability {
        UnknownError,
        UnknownChecking,
        UnknownTimedOut,
        UnsupportedDeviceNotCapable,
        SupportedNotInstalled,
        SupportedVersionTooOld,
        SupportedInstalled,
        EARServiceAvailability_MAX
    }

    export class ARDependencyHandler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CheckARServiceAvailability(WorldContextObject: $Nullable<Object>, LatentInfo: LatentActionInfo, OutAvailability: $Ref<EARServiceAvailability>): void;

        InstallARService(WorldContextObject: $Nullable<Object>, LatentInfo: LatentActionInfo, OutInstallResult: $Ref<EARServiceInstallRequestResult>): void;

        RequestARSessionPermission(WorldContextObject: $Nullable<Object>, SessionConfig: $Nullable<ARSessionConfig>, LatentInfo: LatentActionInfo, OutPermissionResult: $Ref<EARServicePermissionRequestResult>): void;

        StartARSessionLatent(WorldContextObject: $Nullable<Object>, SessionConfig: $Nullable<ARSessionConfig>, LatentInfo: LatentActionInfo): void;

        static GetARDependencyHandler(): ARDependencyHandler;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARDependencyHandler;

        static Load(InName: string): ARDependencyHandler;
    }

    export class AREnvironmentProbeUpdatePayload {
        constructor();
        constructor(WorldTransform: Transform);

        WorldTransform: Transform;

        static StaticClass(): Class;
    }

    export class AREnvironmentProbeComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: AREnvironmentProbeUpdatePayload;

        ReceiveAdd(Payload: AREnvironmentProbeUpdatePayload): void;

        ReceiveUpdate(Payload: AREnvironmentProbeUpdatePayload): void;

        ServerUpdatePayload(NewPayload: AREnvironmentProbeUpdatePayload): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AREnvironmentProbeComponent;

        static Load(InName: string): AREnvironmentProbeComponent;
    }

    export enum EARFaceTransformMixing {
        ComponentOnly,
        ComponentLocationTrackedRotation,
        ComponentWithTracked,
        TrackingOnly,
        EARFaceTransformMixing_MAX
    }

    export class ARSessionPayload {
        constructor();
        constructor(ConfigFlags: number, DefaultMeshMaterial: MaterialInterface, DefaultWireframeMeshMaterial: MaterialInterface);

        ConfigFlags: number;
        DefaultMeshMaterial: MaterialInterface;
        DefaultWireframeMeshMaterial: MaterialInterface;

        static StaticClass(): Class;
    }

    export class ARFaceUpdatePayload {
        constructor();
        constructor(SessionPayload: ARSessionPayload, LeftEyePosition: Vector, RightEyePosition: Vector, LookAtTarget: Vector);

        SessionPayload: ARSessionPayload;
        LeftEyePosition: Vector;
        RightEyePosition: Vector;
        LookAtTarget: Vector;

        static StaticClass(): Class;
    }

    export enum EFaceComponentDebugMode { None, ShowEyeVectors, ShowFaceMesh, EFaceComponentDebugMode_MAX }

    export class ARFaceComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TransformSetting: EARFaceTransformMixing;
        bUpdateVertexNormal: boolean;
        bFaceOutOfScreen: boolean;
        ReplicatedPayload: ARFaceUpdatePayload;

        ReceiveAdd(Payload: ARFaceUpdatePayload): void;

        ReceiveUpdate(Payload: ARFaceUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARFaceUpdatePayload): void;

        static SetFaceComponentDebugMode(NewDebugMode: EFaceComponentDebugMode): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARFaceComponent;

        static Load(InName: string): ARFaceComponent;
    }

    export enum EARFaceBlendShape {
        EyeBlinkLeft,
        EyeLookDownLeft,
        EyeLookInLeft,
        EyeLookOutLeft,
        EyeLookUpLeft,
        EyeSquintLeft,
        EyeWideLeft,
        EyeBlinkRight,
        EyeLookDownRight,
        EyeLookInRight,
        EyeLookOutRight,
        EyeLookUpRight,
        EyeSquintRight,
        EyeWideRight,
        JawForward,
        JawLeft,
        JawRight,
        JawOpen,
        MouthClose,
        MouthFunnel,
        MouthPucker,
        MouthLeft,
        MouthRight,
        MouthSmileLeft,
        MouthSmileRight,
        MouthFrownLeft,
        MouthFrownRight,
        MouthDimpleLeft,
        MouthDimpleRight,
        MouthStretchLeft,
        MouthStretchRight,
        MouthRollLower,
        MouthRollUpper,
        MouthShrugLower,
        MouthShrugUpper,
        MouthPressLeft,
        MouthPressRight,
        MouthLowerDownLeft,
        MouthLowerDownRight,
        MouthUpperUpLeft,
        MouthUpperUpRight,
        BrowDownLeft,
        BrowDownRight,
        BrowInnerUp,
        BrowOuterUpLeft,
        BrowOuterUpRight,
        CheekPuff,
        CheekSquintLeft,
        CheekSquintRight,
        NoseSneerLeft,
        NoseSneerRight,
        TongueOut,
        HeadYaw,
        HeadPitch,
        HeadRoll,
        LeftEyeYaw,
        LeftEyePitch,
        LeftEyeRoll,
        RightEyeYaw,
        RightEyePitch,
        RightEyeRoll,
        MAX
    }

    export enum EAREye { LeftEye, RightEye, EAREye_MAX }

    export class ARFaceGeometry extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LookAtTarget: Vector;
        bIsTracked: boolean;
        BlendShapes: TMap<EARFaceBlendShape, number>;
        LeftEyeTransform: Transform;
        RightEyeTransform: Transform;

        GetBlendShapes(): TMap<EARFaceBlendShape, number>;

        GetBlendShapeValue(BlendShape: EARFaceBlendShape): number;

        GetLocalSpaceEyeTransform(Eye: EAREye): Transform;

        GetWorldSpaceEyeTransform(Eye: EAREye): Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARFaceGeometry;

        static Load(InName: string): ARFaceGeometry;
    }

    export enum EARAltitudeSource { Precise, Coarse, UserDefined, Unknown, EARAltitudeSource_MAX }

    export class ARGeoAnchor extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetAltitudeMeters(): number;

        GetAltitudeSource(): EARAltitudeSource;

        GetLatitude(): number;

        GetLongitude(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARGeoAnchor;

        static Load(InName: string): ARGeoAnchor;
    }

    export class ARGeoAnchorUpdatePayload {
        constructor();
        constructor(SessionPayload: ARSessionPayload, WorldTransform: Transform, Longitude: number, Latitude: number, AltitudeMeters: number, AltitudeSource: EARAltitudeSource, AnchorName: string);

        SessionPayload: ARSessionPayload;
        WorldTransform: Transform;
        Longitude: number;
        Latitude: number;
        AltitudeMeters: number;
        AltitudeSource: EARAltitudeSource;
        AnchorName: string;

        static StaticClass(): Class;
    }

    export enum EGeoAnchorComponentDebugMode { None, ShowGeoData, EGeoAnchorComponentDebugMode_MAX }

    export class ARGeoAnchorComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: ARGeoAnchorUpdatePayload;

        ReceiveAdd(Payload: ARGeoAnchorUpdatePayload): void;

        ReceiveUpdate(Payload: ARGeoAnchorUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARGeoAnchorUpdatePayload): void;

        static SetGeoAnchorComponentDebugMode(NewDebugMode: EGeoAnchorComponentDebugMode): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARGeoAnchorComponent;

        static Load(InName: string): ARGeoAnchorComponent;
    }

    export enum EARGeoTrackingStateReason {
        None,
        NotAvailableAtLocation,
        NeedLocationPermissions,
        DevicePointedTooLow,
        WorldTrackingUnstable,
        WaitingForLocation,
        GeoDataNotLoaded,
        VisualLocalizationFailed,
        WaitingForAvailabilityCheck,
        EARGeoTrackingStateReason_MAX
    }

    export enum EARGeoTrackingState { Initializing, Localized, Localizing, NotAvailable, EARGeoTrackingState_MAX }

    export enum EARGeoTrackingAccuracy { Undetermined, Low, Medium, High, EARGeoTrackingAccuracy_MAX }

    export class ARGeoTrackingSupport extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddGeoAnchorAtLocation(Longitude: number, Latitude: number, OptionalAnchorName: string): boolean;

        AddGeoAnchorAtLocationWithAltitude(Longitude: number, Latitude: number, AltitudeMeters: number, OptionalAnchorName: string): boolean;

        GetGeoTrackingAccuracy(): EARGeoTrackingAccuracy;

        GetGeoTrackingState(): EARGeoTrackingState;

        GetGeoTrackingStateReason(): EARGeoTrackingStateReason;

        static GetGeoTrackingSupport(): ARGeoTrackingSupport;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARGeoTrackingSupport;

        static Load(InName: string): ARGeoTrackingSupport;
    }

    export class ARGetCandidateObjectAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(SavedObject: $Nullable<ARCandidateObject>) => void>;
        OnFailed: $MulticastDelegate<(SavedObject: $Nullable<ARCandidateObject>) => void>;

        static ARGetCandidateObject(WorldContextObject: $Nullable<Object>, Location: Vector, Extent: Vector): ARGetCandidateObjectAsyncTaskBlueprintProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARGetCandidateObjectAsyncTaskBlueprintProxy;

        static Load(InName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
    }

    export class ARImageUpdatePayload {
        constructor();
        constructor(SessionPayload: ARSessionPayload, WorldTransform: Transform, DetectedImage: ARCandidateImage, EstimatedSize: Vector2D);

        SessionPayload: ARSessionPayload;
        WorldTransform: Transform;
        DetectedImage: ARCandidateImage;
        EstimatedSize: Vector2D;

        static StaticClass(): Class;
    }

    export enum EImageComponentDebugMode { None, ShowDetectedImage, EImageComponentDebugMode_MAX }

    export class ARImageComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: ARImageUpdatePayload;

        ReceiveAdd(Payload: ARImageUpdatePayload): void;

        ReceiveUpdate(Payload: ARImageUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARImageUpdatePayload): void;

        static SetImageComponentDebugMode(NewDebugMode: EImageComponentDebugMode): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARImageComponent;

        static Load(InName: string): ARImageComponent;
    }

    export class ARLifeCycleComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnARActorSpawnedDelegate: $MulticastDelegate<(ComponentClass: $Nullable<Class>, NativeID: Guid, SpawnedActor: $Nullable<ARActor>) => void>;
        OnARActorToBeDestroyedDelegate: $MulticastDelegate<(Actor: $Nullable<ARActor>) => void>;

        InstanceARActorSpawnedDelegate__DelegateSignature(ComponentClass: $Nullable<Class>, NativeID: Guid, SpawnedActor: $Nullable<ARActor>): void;

        InstanceARActorToBeDestroyedDelegate__DelegateSignature(Actor: $Nullable<ARActor>): void;

        ServerDestroyARActor(Actor: $Nullable<ARActor>): void;

        ServerSpawnARActor(ComponentClass: $Nullable<Class>, NativeID: Guid): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARLifeCycleComponent;

        static Load(InName: string): ARLifeCycleComponent;
    }

    export class ARMeshUpdatePayload {
        constructor();
        constructor(SessionPayload: ARSessionPayload, WorldTransform: Transform, ObjectClassification: EARObjectClassification);

        SessionPayload: ARSessionPayload;
        WorldTransform: Transform;
        ObjectClassification: EARObjectClassification;

        static StaticClass(): Class;
    }

    export class ARMeshComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: ARMeshUpdatePayload;

        ReceiveAdd(Payload: ARMeshUpdatePayload): void;

        ReceiveUpdate(Payload: ARMeshUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARMeshUpdatePayload): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARMeshComponent;

        static Load(InName: string): ARMeshComponent;
    }

    export class ARMeshGeometry extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetObjectClassificationAtLocation(InWorldLocation: Vector, OutClassification: $Ref<EARObjectClassification>, OutClassificationLocation: $Ref<Vector>, MaxLocationDiff?: number /* = 10.000000 */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARMeshGeometry;

        static Load(InName: string): ARMeshGeometry;
    }

    export class ARObjectUpdatePayload {
        constructor();
        constructor(WorldTransform: Transform);

        WorldTransform: Transform;

        static StaticClass(): Class;
    }

    export class ARObjectComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: ARObjectUpdatePayload;

        ReceiveAdd(Payload: ARObjectUpdatePayload): void;

        ReceiveUpdate(Payload: ARObjectUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARObjectUpdatePayload): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARObjectComponent;

        static Load(InName: string): ARObjectComponent;
    }

    export class AROriginActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AROriginActor;

        static Load(InName: string): AROriginActor;
    }

    export class ARPlaneUpdatePayload {
        constructor();
        constructor(SessionPayload: ARSessionPayload, WorldTransform: Transform, Center: Vector, Extents: Vector, BoundaryVertices: TArray<Vector>, ObjectClassification: EARObjectClassification);

        SessionPayload: ARSessionPayload;
        WorldTransform: Transform;
        Center: Vector;
        Extents: Vector;
        BoundaryVertices: TArray<Vector>;
        ObjectClassification: EARObjectClassification;

        static StaticClass(): Class;
    }

    export enum EPlaneComponentDebugMode { None, ShowNetworkRole, ShowClassification, EPlaneComponentDebugMode_MAX }

    export class ARPlaneComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: ARPlaneUpdatePayload;

        ReceiveAdd(Payload: ARPlaneUpdatePayload): void;

        ReceiveUpdate(Payload: ARPlaneUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARPlaneUpdatePayload): void;

        static GetObjectClassificationDebugColors(): TMap<EARObjectClassification, LinearColor>;

        static SetObjectClassificationDebugColors(InColors: TMap<EARObjectClassification, LinearColor>): void;

        static SetPlaneComponentDebugMode(NewDebugMode: EPlaneComponentDebugMode): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARPlaneComponent;

        static Load(InName: string): ARPlaneComponent;
    }

    export class ARPointUpdatePayload {
        constructor();

        static StaticClass(): Class;
    }

    export class ARPointComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: ARPointUpdatePayload;

        ReceiveAdd(Payload: ARPointUpdatePayload): void;

        ReceiveUpdate(Payload: ARPointUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARPointUpdatePayload): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARPointComponent;

        static Load(InName: string): ARPointComponent;
    }

    export class ARPoseUpdatePayload {
        constructor();
        constructor(WorldTransform: Transform, JointTransforms: TArray<Transform>);

        WorldTransform: Transform;
        JointTransforms: TArray<Transform>;

        static StaticClass(): Class;
    }

    export enum EPoseComponentDebugMode { None, ShowSkeleton, EPoseComponentDebugMode_MAX }

    export class ARPoseComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: ARPoseUpdatePayload;

        ReceiveAdd(Payload: ARPoseUpdatePayload): void;

        ReceiveUpdate(Payload: ARPoseUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARPoseUpdatePayload): void;

        static SetPoseComponentDebugMode(NewDebugMode: EPoseComponentDebugMode): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARPoseComponent;

        static Load(InName: string): ARPoseComponent;
    }

    export class ARQRCodeUpdatePayload {
        constructor();
        constructor(SessionPayload: ARSessionPayload, WorldTransform: Transform, Extents: Vector, QRCode: string);

        SessionPayload: ARSessionPayload;
        WorldTransform: Transform;
        Extents: Vector;
        QRCode: string;

        static StaticClass(): Class;
    }

    export enum EQRCodeComponentDebugMode { None, ShowQRCode, EQRCodeComponentDebugMode_MAX }

    export class ARQRCodeComponent extends ARComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReplicatedPayload: ARQRCodeUpdatePayload;

        ReceiveAdd(Payload: ARQRCodeUpdatePayload): void;

        ReceiveUpdate(Payload: ARQRCodeUpdatePayload): void;

        ServerUpdatePayload(NewPayload: ARQRCodeUpdatePayload): void;

        static SetQRCodeComponentDebugMode(NewDebugMode: EQRCodeComponentDebugMode): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARQRCodeComponent;

        static Load(InName: string): ARQRCodeComponent;
    }

    export class ArrayProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ArrayProperty;

        static Load(InName: string): ArrayProperty;
    }

    export class ARSaveWorldAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(SavedWorld: TArray<number>) => void>;
        OnFailed: $MulticastDelegate<(SavedWorld: TArray<number>) => void>;

        static ARSaveWorld(WorldContextObject: $Nullable<Object>): ARSaveWorldAsyncTaskBlueprintProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARSaveWorldAsyncTaskBlueprintProxy;

        static Load(InName: string): ARSaveWorldAsyncTaskBlueprintProxy;
    }

    export class GameMode extends GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MatchState: string;
        bDelayedStart: boolean;
        NumSpectators: number;
        NumPlayers: number;
        NumBots: number;
        MinRespawnDelay: number;
        NumTravellingPlayers: number;
        EngineMessageClass: Class;
        InactivePlayerArray: TArray<PlayerState>;
        InactivePlayerStateLifeSpan: number;
        MaxInactivePlayers: number;
        bHandleDedicatedServerReplays: boolean;

        AbortMatch(): void;

        EndMatch(): void;

        GetMatchState(): string;

        IsMatchInProgress(): boolean;

        K2_OnSetMatchState(NewState: string): void;

        ReadyToEndMatch(): boolean;

        ReadyToStartMatch(): boolean;

        RestartGame(): void;

        Say(Msg: string): void;

        SetBandwidthLimit(AsyncIOBandwidthLimit: number): void;

        StartMatch(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameMode;

        static Load(InName: string): GameMode;
    }

    export class GameState extends GameStateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MatchState: string;
        PreviousMatchState: string;
        ElapsedTime: number;

        OnRep_ElapsedTime(): void;

        OnRep_MatchState(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameState;

        static Load(InName: string): GameState;
    }

    export class ARSharedWorldGameState extends GameState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PreviewImageData: TArray<number>;
        ARWorldData: TArray<number>;
        PreviewImageBytesTotal: number;
        ARWorldBytesTotal: number;
        PreviewImageBytesDelivered: number;
        ARWorldBytesDelivered: number;

        K2_OnARWorldMapIsReady(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARSharedWorldGameState;

        static Load(InName: string): ARSharedWorldGameState;
    }

    export class ARSharedWorldGameMode extends GameMode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BufferSizePerChunk: number;

        GetARSharedWorldGameState(): ARSharedWorldGameState;

        SetARSharedWorldData(ARWorldData: TArray<number>): void;

        SetARWorldSharingIsReady(): void;

        SetPreviewImageData(ImageData: TArray<number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARSharedWorldGameMode;

        static Load(InName: string): ARSharedWorldGameMode;
    }

    export class ARSharedWorldPlayerController extends PlayerController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ClientInitSharedWorld(PreviewImageSize: number, ARWorldDataSize: number): void;

        ClientUpdateARWorldData(Offset: number, Buffer: TArray<number>): void;

        ClientUpdatePreviewImageData(Offset: number, Buffer: TArray<number>): void;

        ServerMarkReadyForReceiving(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARSharedWorldPlayerController;

        static Load(InName: string): ARSharedWorldPlayerController;
    }

    export class LightComponentBase extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LightGuid: Guid;
        Brightness: number;
        Intensity: number;
        LightColor: Color;
        bAffectsWorld: boolean;
        CastShadows: boolean;
        CastStaticShadows: boolean;
        CastDynamicShadows: boolean;
        bAffectTranslucentLighting: boolean;
        bTransmission: boolean;
        bCastVolumetricShadow: boolean;
        bCastDeepShadow: boolean;
        bCastRaytracedShadow: boolean;
        bAffectReflection: boolean;
        bAffectGlobalIllumination: boolean;
        DeepShadowLayerDistribution: number;
        IndirectLightingIntensity: number;
        VolumetricScatteringIntensity: number;
        SamplesPerPixel: number;
        StaticEditorTexture: Texture2D;
        StaticEditorTextureScale: number;
        DynamicEditorTexture: Texture2D;
        DynamicEditorTextureScale: number;

        GetLightColor(): LinearColor;

        SetAffectGlobalIllumination(bNewValue: boolean): void;

        SetAffectReflection(bNewValue: boolean): void;

        SetCastDeepShadow(bNewValue: boolean): void;

        SetCastRaytracedShadow(bNewValue: boolean): void;

        SetCastShadows(bNewValue: boolean): void;

        SetCastVolumetricShadow(bNewValue: boolean): void;

        SetSamplesPerPixel(NewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightComponentBase;

        static Load(InName: string): LightComponentBase;
    }

    export enum ESkyLightSourceType { SLS_CapturedScene, SLS_SpecifiedCubemap, SLS_MAX }

    export enum EOcclusionCombineMode { OCM_Minimum, OCM_Multiply, OCM_MAX }

    export class SkyLightComponent extends LightComponentBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bRealTimeCapture: boolean;
        SourceType: ESkyLightSourceType;
        Cubemap: TextureCube;
        SourceCubemapAngle: number;
        CubemapResolution: number;
        SkyDistanceThreshold: number;
        bCaptureEmissiveOnly: boolean;
        bLowerHemisphereIsBlack: boolean;
        LowerHemisphereColor: LinearColor;
        OcclusionMaxDistance: number;
        Contrast: number;
        OcclusionExponent: number;
        MinOcclusion: number;
        OcclusionTint: Color;
        bCloudAmbientOcclusion: boolean;
        CloudAmbientOcclusionStrength: number;
        CloudAmbientOcclusionExtent: number;
        CloudAmbientOcclusionMapResolutionScale: number;
        CloudAmbientOcclusionApertureScale: number;
        OcclusionCombineMode: EOcclusionCombineMode;
        BlendDestinationCubemap: TextureCube;

        RecaptureSky(): void;

        SetCubemap(NewCubemap: $Nullable<TextureCube>): void;

        SetCubemapBlend(SourceCubemap: $Nullable<TextureCube>, DestinationCubemap: $Nullable<TextureCube>, InBlendFraction: number): void;

        SetIndirectLightingIntensity(NewIntensity: number): void;

        SetIntensity(NewIntensity: number): void;

        SetLightColor(NewLightColor: LinearColor): void;

        SetLowerHemisphereColor(InLowerHemisphereColor: LinearColor): void;

        SetMinOcclusion(InMinOcclusion: number): void;

        SetOcclusionContrast(InOcclusionContrast: number): void;

        SetOcclusionExponent(InOcclusionExponent: number): void;

        SetOcclusionTint(InTint: Color): void;

        SetVolumetricScatteringIntensity(NewIntensity: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkyLightComponent;

        static Load(InName: string): SkyLightComponent;
    }

    export class SkyLight extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LightComponent: SkyLightComponent;
        bEnabled: boolean;

        OnRep_bEnabled(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkyLight;

        static Load(InName: string): SkyLight;
    }

    export class ARSkyLight extends SkyLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CaptureProbe: AREnvironmentCaptureProbe;

        SetEnvironmentCaptureProbe(InCaptureProbe: $Nullable<AREnvironmentCaptureProbe>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARSkyLight;

        static Load(InName: string): ARSkyLight;
    }

    export class ARTraceResultDummy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTraceResultDummy;

        static Load(InName: string): ARTraceResultDummy;
    }

    export class ARTraceResultLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetDistanceFromCamera(TraceResult: ARTraceResult): number;

        static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;

        static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;

        static GetLocalTransform(TraceResult: ARTraceResult): Transform;

        static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;

        static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTraceResultLibrary;

        static Load(InName: string): ARTraceResultLibrary;
    }

    export class ARTrackedObject extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DetectedObject: ARCandidateObject;

        GetDetectedObject(): ARCandidateObject;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTrackedObject;

        static Load(InName: string): ARTrackedObject;
    }

    export class ARTrackableNotifyComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnAddTrackedGeometry: $MulticastDelegate<(TrackedGeometry: $Nullable<ARTrackedGeometry>) => void>;
        OnUpdateTrackedGeometry: $MulticastDelegate<(TrackedGeometry: $Nullable<ARTrackedGeometry>) => void>;
        OnRemoveTrackedGeometry: $MulticastDelegate<(TrackedGeometry: $Nullable<ARTrackedGeometry>) => void>;
        OnAddTrackedPlane: $MulticastDelegate<(TrackedPlane: $Nullable<ARPlaneGeometry>) => void>;
        OnUpdateTrackedPlane: $MulticastDelegate<(TrackedPlane: $Nullable<ARPlaneGeometry>) => void>;
        OnRemoveTrackedPlane: $MulticastDelegate<(TrackedPlane: $Nullable<ARPlaneGeometry>) => void>;
        OnAddTrackedPoint: $MulticastDelegate<(TrackedPoint: $Nullable<ARTrackedPoint>) => void>;
        OnUpdateTrackedPoint: $MulticastDelegate<(TrackedPoint: $Nullable<ARTrackedPoint>) => void>;
        OnRemoveTrackedPoint: $MulticastDelegate<(TrackedPoint: $Nullable<ARTrackedPoint>) => void>;
        OnAddTrackedImage: $MulticastDelegate<(TrackedImage: $Nullable<ARTrackedImage>) => void>;
        OnUpdateTrackedImage: $MulticastDelegate<(TrackedImage: $Nullable<ARTrackedImage>) => void>;
        OnRemoveTrackedImage: $MulticastDelegate<(TrackedImage: $Nullable<ARTrackedImage>) => void>;
        OnAddTrackedFace: $MulticastDelegate<(TrackedFace: $Nullable<ARFaceGeometry>) => void>;
        OnUpdateTrackedFace: $MulticastDelegate<(TrackedFace: $Nullable<ARFaceGeometry>) => void>;
        OnRemoveTrackedFace: $MulticastDelegate<(TrackedFace: $Nullable<ARFaceGeometry>) => void>;
        OnAddTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: $Nullable<AREnvironmentCaptureProbe>) => void>;
        OnUpdateTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: $Nullable<AREnvironmentCaptureProbe>) => void>;
        OnRemoveTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: $Nullable<AREnvironmentCaptureProbe>) => void>;
        OnAddTrackedObject: $MulticastDelegate<(TrackedObject: $Nullable<ARTrackedObject>) => void>;
        OnUpdateTrackedObject: $MulticastDelegate<(TrackedObject: $Nullable<ARTrackedObject>) => void>;
        OnRemoveTrackedObject: $MulticastDelegate<(TrackedObject: $Nullable<ARTrackedObject>) => void>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTrackableNotifyComponent;

        static Load(InName: string): ARTrackableNotifyComponent;
    }

    export class ARTrackedQRCode extends ARTrackedImage {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QRCode: string;
        Version: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTrackedQRCode;

        static Load(InName: string): ARTrackedQRCode;
    }

    export class ARTypesDummyClass extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ARTypesDummyClass;

        static Load(InName: string): ARTypesDummyClass;
    }

    export class AssetActionUtility extends EditorUtilityObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetSupportedClass(): Class;

        IsActionForBlueprints(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetActionUtility;

        static Load(InName: string): AssetActionUtility;
    }

    export class AssetBakeOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetBakeOptions;

        static Load(InName: string): AssetBakeOptions;
    }

    export class AssetEditor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetEditor;

        static Load(InName: string): AssetEditor;
    }

    export class Subsystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Subsystem;

        static Load(InName: string): Subsystem;
    }

    export class DynamicSubsystem extends Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DynamicSubsystem;

        static Load(InName: string): DynamicSubsystem;
    }

    export class EditorSubsystem extends DynamicSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorSubsystem;

        static Load(InName: string): EditorSubsystem;
    }

    export class AssetEditorSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwnedAssetEditors: TArray<AssetEditor>;

        CloseAllEditorsForAsset(Asset: $Nullable<Object>): number;

        OpenEditorForAssets(Assets: TArray<Object>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetEditorSubsystem;

        static Load(InName: string): AssetEditorSubsystem;
    }

    export class AssetEditorToolkitMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetEditorToolkitMenuContext;

        static Load(InName: string): AssetEditorToolkitMenuContext;
    }

    export class IniStringValue {
        constructor();
        constructor(Section: string, Key: string, Value: string, Filename: string);

        Section: string;
        Key: string;
        Value: string;
        Filename: string;

        static StaticClass(): Class;
    }

    export class AssetGuideline extends AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Plugins: TArray<string>;
        ProjectSettings: TArray<IniStringValue>;
        GuidelineName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetGuideline;

        static Load(InName: string): AssetGuideline;
    }

    export class AssetManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ObjectReferenceList: TArray<Object>;
        bIsGlobalAsyncScanEnvironment: boolean;
        bShouldGuessTypeAndName: boolean;
        bShouldUseSynchronousLoad: boolean;
        bIsLoadingFromPakFiles: boolean;
        bShouldAcquireMissingChunksOnLoad: boolean;
        bOnlyCookProductionAssets: boolean;
        bIsBulkScanning: boolean;
        bIsPrimaryAssetDirectoryCurrent: boolean;
        bIsManagementDatabaseCurrent: boolean;
        bUpdateManagementDatabaseAfterScan: boolean;
        bIncludeOnlyOnDiskAssets: boolean;
        bHasCompletedInitialScan: boolean;
        NumberOfSpawnedNotifications: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetManager;

        static Load(InName: string): AssetManager;
    }

    export class DirectoryPath {
        constructor();
        constructor(Path: string);

        Path: string;

        static StaticClass(): Class;
    }

    export enum EPrimaryAssetCookRule {
        Unknown,
        NeverCook,
        DevelopmentCook,
        DevelopmentAlwaysCook,
        AlwaysCook,
        EPrimaryAssetCookRule_MAX
    }

    export class PrimaryAssetRules {
        constructor();
        constructor(Priority: number, ChunkId: number, bApplyRecursively: boolean, CookRule: EPrimaryAssetCookRule);

        Priority: number;
        ChunkId: number;
        bApplyRecursively: boolean;
        CookRule: EPrimaryAssetCookRule;

        static StaticClass(): Class;
    }

    export class PrimaryAssetTypeInfo {
        constructor();
        constructor(PrimaryAssetType: string, AssetBaseClass: TSoftClassPtr<Object>, AssetBaseClassLoaded: Class, bHasBlueprintClasses: boolean, bIsEditorOnly: boolean, Directories: TArray<DirectoryPath>, SpecificAssets: TArray<SoftObjectPath>, Rules: PrimaryAssetRules, AssetScanPaths: TArray<string>, bIsDynamicAsset: boolean, NumberOfAssets: number);

        PrimaryAssetType: string;
        AssetBaseClass: TSoftClassPtr<Object>;
        AssetBaseClassLoaded: Class;
        bHasBlueprintClasses: boolean;
        bIsEditorOnly: boolean;
        Directories: TArray<DirectoryPath>;
        SpecificAssets: TArray<SoftObjectPath>;
        Rules: PrimaryAssetRules;
        AssetScanPaths: TArray<string>;
        bIsDynamicAsset: boolean;
        NumberOfAssets: number;

        static StaticClass(): Class;
    }

    export class PrimaryAssetType {
        constructor();
        constructor(Name: string);

        Name: string;

        static StaticClass(): Class;
    }

    export class PrimaryAssetId {
        constructor();
        constructor(PrimaryAssetType: PrimaryAssetType, PrimaryAssetName: string);

        PrimaryAssetType: PrimaryAssetType;
        PrimaryAssetName: string;

        static StaticClass(): Class;
    }

    export class PrimaryAssetRulesOverride {
        constructor();
        constructor(PrimaryAssetId: PrimaryAssetId, Rules: PrimaryAssetRules);

        PrimaryAssetId: PrimaryAssetId;
        Rules: PrimaryAssetRules;

        static StaticClass(): Class;
    }

    export class PrimaryAssetRulesCustomOverride {
        constructor();
        constructor(PrimaryAssetType: PrimaryAssetType, FilterDirectory: DirectoryPath, FilterString: string, Rules: PrimaryAssetRules);

        PrimaryAssetType: PrimaryAssetType;
        FilterDirectory: DirectoryPath;
        FilterString: string;
        Rules: PrimaryAssetRules;

        static StaticClass(): Class;
    }

    export class AssetManagerRedirect {
        constructor();
        constructor(Old: string, New: string);

        Old: string;
        New: string;

        static StaticClass(): Class;
    }

    export class AssetManagerSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PrimaryAssetTypesToScan: TArray<PrimaryAssetTypeInfo>;
        DirectoriesToExclude: TArray<DirectoryPath>;
        PrimaryAssetRules: TArray<PrimaryAssetRulesOverride>;
        CustomPrimaryAssetRules: TArray<PrimaryAssetRulesCustomOverride>;
        bOnlyCookProductionAssets: boolean;
        bShouldManagerDetermineTypeAndName: boolean;
        bShouldGuessTypeAndNameInEditor: boolean;
        bShouldAcquireMissingChunksOnLoad: boolean;
        PrimaryAssetIdRedirects: TArray<AssetManagerRedirect>;
        PrimaryAssetTypeRedirects: TArray<AssetManagerRedirect>;
        AssetPathRedirects: TArray<AssetManagerRedirect>;
        MetaDataTagsForAssetRegistry: TSet<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetManagerSettings;

        static Load(InName: string): AssetManagerSettings;
    }

    export class AssetData {
        constructor();
        constructor(ObjectPath: string, PackageName: string, PackagePath: string, AssetName: string, AssetClass: string);

        ObjectPath: string;
        PackageName: string;
        PackagePath: string;
        AssetName: string;
        AssetClass: string;

        static StaticClass(): Class;
    }

    export class ARFilter {
        constructor();
        constructor(PackageNames: TArray<string>, PackagePaths: TArray<string>, ObjectPaths: TArray<string>, ClassNames: TArray<string>, RecursiveClassesExclusionSet: TSet<string>, bRecursivePaths: boolean, bRecursiveClasses: boolean, bIncludeOnlyOnDiskAssets: boolean);

        PackageNames: TArray<string>;
        PackagePaths: TArray<string>;
        ObjectPaths: TArray<string>;
        ClassNames: TArray<string>;
        RecursiveClassesExclusionSet: TSet<string>;
        bRecursivePaths: boolean;
        bRecursiveClasses: boolean;
        bIncludeOnlyOnDiskAssets: boolean;

        static StaticClass(): Class;
    }

    export class AssetRegistryDependencyOptions {
        constructor();
        constructor(bIncludeSoftPackageReferences: boolean, bIncludeHardPackageReferences: boolean, bIncludeSearchableNames: boolean, bIncludeSoftManagementReferences: boolean, bIncludeHardManagementReferences: boolean);

        bIncludeSoftPackageReferences: boolean;
        bIncludeHardPackageReferences: boolean;
        bIncludeSearchableNames: boolean;
        bIncludeSoftManagementReferences: boolean;
        bIncludeHardManagementReferences: boolean;

        static StaticClass(): Class;
    }

    export class AssetRegistry extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetAllAssets(OutAssetData: $Ref<TArray<AssetData>>, bIncludeOnlyOnDiskAssets?: boolean /* = false */): boolean;

        GetAllCachedPaths(OutPathList: $Ref<TArray<string>>): void;

        GetAssetByObjectPath(ObjectPath: string, bIncludeOnlyOnDiskAssets?: boolean /* = false */): AssetData;

        GetAssets(Filter: ARFilter, OutAssetData: $Ref<TArray<AssetData>>): boolean;

        GetAssetsByClass(ClassName: string, OutAssetData: $Ref<TArray<AssetData>>, bSearchSubClasses?: boolean /* = false */): boolean;

        GetAssetsByPackageName(PackageName: string, OutAssetData: $Ref<TArray<AssetData>>, bIncludeOnlyOnDiskAssets?: boolean /* = false */): boolean;

        GetAssetsByPath(PackagePath: string, OutAssetData: $Ref<TArray<AssetData>>, bRecursive?: boolean /* = false */, bIncludeOnlyOnDiskAssets?: boolean /* = false */): boolean;

        GetSubPaths(InBasePath: string, OutPathList: $Ref<TArray<string>>, bInRecurse: boolean): void;

        HasAssets(PackagePath: string, bRecursive?: boolean /* = false */): boolean;

        IsLoadingAssets(): boolean;

        K2_GetDependencies(PackageName: string, DependencyOptions: AssetRegistryDependencyOptions, OutDependencies: $Ref<TArray<string>>): boolean;

        K2_GetReferencers(PackageName: string, ReferenceOptions: AssetRegistryDependencyOptions, OutReferencers: $Ref<TArray<string>>): boolean;

        PrioritizeSearchPath(PathToPrioritize: string): void;

        RunAssetsThroughFilter(AssetDataList: $Ref<TArray<AssetData>>, Filter: ARFilter): void;

        ScanFilesSynchronous(InFilePaths: TArray<string>, bForceRescan?: boolean /* = false */): void;

        ScanModifiedAssetFiles(InFilePaths: TArray<string>): void;

        ScanPathsSynchronous(InPaths: TArray<string>, bForceRescan?: boolean /* = false */): void;

        SearchAllAssets(bSynchronousSearch: boolean): void;

        UseFilterToExcludeAssets(AssetDataList: $Ref<TArray<AssetData>>, Filter: ARFilter): void;

        WaitForCompletion(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetRegistry;

        static Load(InName: string): AssetRegistry;
    }

    export class Commandlet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HelpDescription: string;
        HelpUsage: string;
        HelpWebLink: string;
        HelpParamNames: TArray<string>;
        HelpParamDescriptions: TArray<string>;
        IsServer: boolean;
        IsClient: boolean;
        IsEditor: boolean;
        LogToConsole: boolean;
        ShowErrorCount: boolean;
        ShowProgress: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Commandlet;

        static Load(InName: string): Commandlet;
    }

    export class AssetRegistryDumpCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetRegistryDumpCommandlet;

        static Load(InName: string): AssetRegistryDumpCommandlet;
    }

    export class TagAndValue {
        constructor();
        constructor(Tag: string, Value: string);

        Tag: string;
        Value: string;

        static StaticClass(): Class;
    }

    export class AssetRegistryHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateAssetData(InAsset: $Nullable<Object>, bAllowBlueprintClass?: boolean /* = false */): AssetData;

        static GetAsset(InAssetData: AssetData): Object;

        static GetAssetRegistry(): AssetRegistry;

        static GetClass(InAssetData: AssetData): Class;

        static GetExportTextName(InAssetData: AssetData): string;

        static GetFullName(InAssetData: AssetData): string;

        static GetTagValue(InAssetData: AssetData, InTagName: string, OutTagValue: $Ref<string>): boolean;

        static IsAssetLoaded(InAssetData: AssetData): boolean;

        static IsRedirector(InAssetData: AssetData): boolean;

        static IsUAsset(InAssetData: AssetData): boolean;

        static IsValid(InAssetData: AssetData): boolean;

        static SetFilterTagsAndValues(InFilter: ARFilter, InTagsAndValues: TArray<TagAndValue>): ARFilter;

        static ToSoftObjectPath(InAssetData: AssetData): SoftObjectPath;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetRegistryHelpers;

        static Load(InName: string): AssetRegistryHelpers;
    }

    export class AssetRegistryImpl extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetRegistryImpl;

        static Load(InName: string): AssetRegistryImpl;
    }

    export class AssetRegUtilCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetRegUtilCommandlet;

        static Load(InName: string): AssetRegUtilCommandlet;
    }

    export class EngineSubsystem extends DynamicSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EngineSubsystem;

        static Load(InName: string): EngineSubsystem;
    }

    export enum ECollectionScriptingShareType { Local, Private, Shared, ECollectionScriptingShareType_MAX }

    export class AssetTagsSubsystem extends EngineSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddAssetDatasToCollection(Name: string, AssetDatas: TArray<AssetData>): boolean;

        AddAssetDataToCollection(Name: string, AssetData: AssetData): boolean;

        AddAssetPtrsToCollection(Name: string, AssetPtrs: TArray<Object>): boolean;

        AddAssetPtrToCollection(Name: string, AssetPtr: $Nullable<Object>): boolean;

        AddAssetsToCollection(Name: string, AssetPathNames: TArray<string>): boolean;

        AddAssetToCollection(Name: string, AssetPathName: string): boolean;

        CollectionExists(Name: string): boolean;

        CreateCollection(Name: string, ShareType: ECollectionScriptingShareType): boolean;

        DestroyCollection(Name: string): boolean;

        EmptyCollection(Name: string): boolean;

        GetAssetsInCollection(Name: string): TArray<AssetData>;

        GetCollections(): TArray<string>;

        GetCollectionsContainingAsset(AssetPathName: string): TArray<string>;

        GetCollectionsContainingAssetData(AssetData: AssetData): TArray<string>;

        GetCollectionsContainingAssetPtr(AssetPtr: $Nullable<Object>): TArray<string>;

        RemoveAssetDataFromCollection(Name: string, AssetData: AssetData): boolean;

        RemoveAssetDatasFromCollection(Name: string, AssetDatas: TArray<AssetData>): boolean;

        RemoveAssetFromCollection(Name: string, AssetPathName: string): boolean;

        RemoveAssetPtrFromCollection(Name: string, AssetPtr: $Nullable<Object>): boolean;

        RemoveAssetPtrsFromCollection(Name: string, AssetPtrs: TArray<Object>): boolean;

        RemoveAssetsFromCollection(Name: string, AssetPathNames: TArray<string>): boolean;

        RenameCollection(Name: string, NewName: string): boolean;

        ReparentCollection(Name: string, NewParentName: string): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetTagsSubsystem;

        static Load(InName: string): AssetTagsSubsystem;
    }

    export class AssetRenameData {
        constructor();
        constructor(Asset: TWeakObjectPtr<Object>, NewPackagePath: string, NewName: string, OldObjectPath: SoftObjectPath, NewObjectPath: SoftObjectPath, bOnlyFixSoftReferences: boolean);

        Asset: TWeakObjectPtr<Object>;
        NewPackagePath: string;
        NewName: string;
        OldObjectPath: SoftObjectPath;
        NewObjectPath: SoftObjectPath;
        bOnlyFixSoftReferences: boolean;

        static StaticClass(): Class;
    }

    export enum EAssetRenameResult { Failure, Success, Pending, EAssetRenameResult_MAX }

    export class AssetTools extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CreateAsset(AssetName: string, PackagePath: string, AssetClass: $Nullable<Class>, Factory: $Nullable<Factory>, CallingContext?: string /* = "None" */): Object;

        CreateAssetWithDialog(AssetName: string, PackagePath: string, AssetClass: $Nullable<Class>, Factory: $Nullable<Factory>, CallingContext?: string /* = "None" */): Object;

        CreateUniqueAssetName(InBasePackageName: string, InSuffix: string, OutPackageName: $Ref<string>, OutAssetName: $Ref<string>): void;

        DuplicateAsset(AssetName: string, PackagePath: string, OriginalObject: $Nullable<Object>): Object;

        DuplicateAssetWithDialog(AssetName: string, PackagePath: string, OriginalObject: $Nullable<Object>): Object;

        DuplicateAssetWithDialogAndTitle(AssetName: string, PackagePath: string, OriginalObject: $Nullable<Object>, DialogTitle: string): Object;

        ExportAssets(AssetsToExport: TArray<string>, ExportPath: string): void;

        ExportAssetsWithDialog(AssetsToExport: TArray<string>, bPromptForIndividualFilenames: boolean): void;

        FindSoftReferencesToObject(TargetObject: SoftObjectPath, ReferencingObjects: $Ref<TArray<Object>>): void;

        ImportAssetsAutomated(ImportData: $Nullable<AutomatedAssetImportData>): TArray<Object>;

        ImportAssetsWithDialog(DestinationPath: string): TArray<Object>;

        ImportAssetTasks(ImportTasks: TArray<AssetImportTask>): void;

        OpenEditorForAssets(Assets: TArray<Object>): void;

        RenameAssets(AssetsAndNames: TArray<AssetRenameData>): boolean;

        RenameAssetsWithDialog(AssetsAndNames: TArray<AssetRenameData>, bAutoCheckout?: boolean /* = false */): EAssetRenameResult;

        RenameReferencingSoftObjectPaths(PackagesToCheck: TArray<Package>, AssetRedirectorMap: TMap<SoftObjectPath, SoftObjectPath>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetTools;

        static Load(InName: string): AssetTools;
    }

    export class AssetToolsHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetAssetTools(): AssetTools;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetToolsHelpers;

        static Load(InName: string): AssetToolsHelpers;
    }

    export class AssetToolsImpl extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetToolsImpl;

        static Load(InName: string): AssetToolsImpl;
    }

    export class AdvancedCopyMap {
        constructor();
        constructor(ClassToCopy: SoftClassPath, AdvancedCopyCustomization: SoftClassPath);

        ClassToCopy: SoftClassPath;
        AdvancedCopyCustomization: SoftClassPath;

        static StaticClass(): Class;
    }

    export class AssetToolsSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AdvancedCopyCustomizations: TArray<AdvancedCopyMap>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetToolsSettings;

        static Load(InName: string): AssetToolsSettings;
    }

    export class PreviewSceneProfile {
        constructor();
        constructor(ProfileName: string, bSharedProfile: boolean, bUseSkyLighting: boolean, DirectionalLightIntensity: number, DirectionalLightColor: LinearColor, SkyLightIntensity: number, bRotateLightingRig: boolean, bShowEnvironment: boolean, bShowFloor: boolean, EnvironmentColor: LinearColor, EnvironmentIntensity: number, EnvironmentCubeMap: TSoftObjectPtr<TextureCube>, EnvironmentCubeMapPath: string, bPostProcessingEnabled: boolean, PostProcessingSettings: PostProcessSettings, LightingRigRotation: number, RotationSpeed: number, DirectionalLightRotation: Rotator);

        ProfileName: string;
        bSharedProfile: boolean;
        bUseSkyLighting: boolean;
        DirectionalLightIntensity: number;
        DirectionalLightColor: LinearColor;
        SkyLightIntensity: number;
        bRotateLightingRig: boolean;
        bShowEnvironment: boolean;
        bShowFloor: boolean;
        EnvironmentColor: LinearColor;
        EnvironmentIntensity: number;
        EnvironmentCubeMap: TSoftObjectPtr<TextureCube>;
        EnvironmentCubeMapPath: string;
        bPostProcessingEnabled: boolean;
        PostProcessingSettings: PostProcessSettings;
        LightingRigRotation: number;
        RotationSpeed: number;
        DirectionalLightRotation: Rotator;

        static StaticClass(): Class;
    }

    export class AssetViewerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Profiles: TArray<PreviewSceneProfile>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AssetViewerSettings;

        static Load(InName: string): AssetViewerSettings;
    }

    export class AsyncActionLoadPrimaryAssetBase extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetBase;

        static Load(InName: string): AsyncActionLoadPrimaryAssetBase;
    }

    export class AsyncActionChangePrimaryAssetBundles extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Completed: $MulticastDelegate<() => void>;

        static AsyncChangeBundleStateForMatchingPrimaryAssets(WorldContextObject: $Nullable<Object>, NewBundles: TArray<string>, OldBundles: TArray<string>): AsyncActionChangePrimaryAssetBundles;

        static AsyncChangeBundleStateForPrimaryAssetList(WorldContextObject: $Nullable<Object>, PrimaryAssetList: TArray<PrimaryAssetId>, AddBundles: TArray<string>, RemoveBundles: TArray<string>): AsyncActionChangePrimaryAssetBundles;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncActionChangePrimaryAssetBundles;

        static Load(InName: string): AsyncActionChangePrimaryAssetBundles;
    }

    export class SaveGame extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SaveGame;

        static Load(InName: string): SaveGame;
    }

    export class AsyncActionHandleSaveGame extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Completed: $MulticastDelegate<(SaveGame: $Nullable<SaveGame>, bSuccess: boolean) => void>;
        SaveGameObject: SaveGame;

        static AsyncLoadGameFromSlot(WorldContextObject: $Nullable<Object>, SlotName: string, UserIndex: number): AsyncActionHandleSaveGame;

        static AsyncSaveGameToSlot(WorldContextObject: $Nullable<Object>, SaveGameObject: $Nullable<SaveGame>, SlotName: string, UserIndex: number): AsyncActionHandleSaveGame;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncActionHandleSaveGame;

        static Load(InName: string): AsyncActionHandleSaveGame;
    }

    export class AsyncActionLoadPrimaryAsset extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Completed: $MulticastDelegate<(Loaded: $Nullable<Object>) => void>;

        static AsyncLoadPrimaryAsset(WorldContextObject: $Nullable<Object>, PrimaryAsset: PrimaryAssetId, LoadBundles: TArray<string>): AsyncActionLoadPrimaryAsset;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAsset;

        static Load(InName: string): AsyncActionLoadPrimaryAsset;
    }

    export class AsyncActionLoadPrimaryAssetClass extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Completed: $MulticastDelegate<(Loaded: $Nullable<Class>) => void>;

        static AsyncLoadPrimaryAssetClass(WorldContextObject: $Nullable<Object>, PrimaryAsset: PrimaryAssetId, LoadBundles: TArray<string>): AsyncActionLoadPrimaryAssetClass;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetClass;

        static Load(InName: string): AsyncActionLoadPrimaryAssetClass;
    }

    export class AsyncActionLoadPrimaryAssetClassList extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Completed: $MulticastDelegate<(Loaded: TArray<Class>) => void>;

        static AsyncLoadPrimaryAssetClassList(WorldContextObject: $Nullable<Object>, PrimaryAssetList: TArray<PrimaryAssetId>, LoadBundles: TArray<string>): AsyncActionLoadPrimaryAssetClassList;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetClassList;

        static Load(InName: string): AsyncActionLoadPrimaryAssetClassList;
    }

    export class AsyncActionLoadPrimaryAssetList extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Completed: $MulticastDelegate<(Loaded: TArray<Object>) => void>;

        static AsyncLoadPrimaryAssetList(WorldContextObject: $Nullable<Object>, PrimaryAssetList: TArray<PrimaryAssetId>, LoadBundles: TArray<string>): AsyncActionLoadPrimaryAssetList;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetList;

        static Load(InName: string): AsyncActionLoadPrimaryAssetList;
    }

    export class XRDeviceId {
        constructor();
        constructor(SystemName: string, DeviceId: number);

        SystemName: string;
        DeviceId: number;

        static StaticClass(): Class;
    }

    export class AsyncTask_LoadXRDeviceVisComponent extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnModelLoaded: $MulticastDelegate<(LoadedComponent: $Nullable<PrimitiveComponent>) => void>;
        OnLoadFailure: $MulticastDelegate<(LoadedComponent: $Nullable<PrimitiveComponent>) => void>;
        SpawnedComponent: PrimitiveComponent;

        static AddDeviceVisualizationComponentAsync(Target: $Nullable<Actor>, XRDeviceId: XRDeviceId, bManualAttachment: boolean, RelativeTransform: Transform, NewComponent: $Ref<PrimitiveComponent>): AsyncTask_LoadXRDeviceVisComponent;

        static AddNamedDeviceVisualizationComponentAsync(Target: $Nullable<Actor>, SystemName: string, DeviceName: string, bManualAttachment: boolean, RelativeTransform: Transform, XRDeviceId: $Ref<XRDeviceId>, NewComponent: $Ref<PrimitiveComponent>): AsyncTask_LoadXRDeviceVisComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncTask_LoadXRDeviceVisComponent;

        static Load(InName: string): AsyncTask_LoadXRDeviceVisComponent;
    }

    export enum EPixelFormat {
        PF_Unknown,
        PF_A32B32G32R32F,
        PF_B8G8R8A8,
        PF_G8,
        PF_G16,
        PF_DXT1,
        PF_DXT3,
        PF_DXT5,
        PF_UYVY,
        PF_FloatRGB,
        PF_FloatRGBA,
        PF_DepthStencil,
        PF_ShadowDepth,
        PF_R32_FLOAT,
        PF_G16R16,
        PF_G16R16F,
        PF_G16R16F_FILTER,
        PF_G32R32F,
        PF_A2B10G10R10,
        PF_A16B16G16R16,
        PF_D24,
        PF_R16F,
        PF_R16F_FILTER,
        PF_BC5,
        PF_V8U8,
        PF_A1,
        PF_FloatR11G11B10,
        PF_A8,
        PF_R32_UINT,
        PF_R32_SINT,
        PF_PVRTC2,
        PF_PVRTC4,
        PF_R16_UINT,
        PF_R16_SINT,
        PF_R16G16B16A16_UINT,
        PF_R16G16B16A16_SINT,
        PF_R5G6B5_UNORM,
        PF_R8G8B8A8,
        PF_A8R8G8B8,
        PF_BC4,
        PF_R8G8,
        PF_ATC_RGB,
        PF_ATC_RGBA_E,
        PF_ATC_RGBA_I,
        PF_X24_G8,
        PF_ETC1,
        PF_ETC2_RGB,
        PF_ETC2_RGBA,
        PF_R32G32B32A32_UINT,
        PF_R16G16_UINT,
        PF_ASTC_4x4,
        PF_ASTC_6x6,
        PF_ASTC_8x8,
        PF_ASTC_10x10,
        PF_ASTC_12x12,
        PF_BC6H,
        PF_BC7,
        PF_R8_UINT,
        PF_L8,
        PF_XGXR8,
        PF_R8G8B8A8_UINT,
        PF_R8G8B8A8_SNORM,
        PF_R16G16B16A16_UNORM,
        PF_R16G16B16A16_SNORM,
        PF_PLATFORM_HDR_0,
        PF_PLATFORM_HDR_1,
        PF_PLATFORM_HDR_2,
        PF_NV12,
        PF_R32G32_UINT,
        PF_ETC2_R11_EAC,
        PF_ETC2_RG11_EAC,
        PF_MAX
    }

    export class Texture2DDynamic extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Format: EPixelFormat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Texture2DDynamic;

        static Load(InName: string): Texture2DDynamic;
    }

    export class AsyncTaskDownloadImage extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(Texture: $Nullable<Texture2DDynamic>) => void>;
        OnFail: $MulticastDelegate<(Texture: $Nullable<Texture2DDynamic>) => void>;

        static DownloadImage(URL: string): AsyncTaskDownloadImage;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AsyncTaskDownloadImage;

        static Load(InName: string): AsyncTaskDownloadImage;
    }

    export class AtmospherePrecomputeParameters {
        constructor();
        constructor(DensityHeight: number, DecayHeight: number, MaxScatteringOrder: number, TransmittanceTexWidth: number, TransmittanceTexHeight: number, IrradianceTexWidth: number, IrradianceTexHeight: number, InscatterAltitudeSampleNum: number, InscatterMuNum: number, InscatterMuSNum: number, InscatterNuNum: number);

        DensityHeight: number;
        DecayHeight: number;
        MaxScatteringOrder: number;
        TransmittanceTexWidth: number;
        TransmittanceTexHeight: number;
        IrradianceTexWidth: number;
        IrradianceTexHeight: number;
        InscatterAltitudeSampleNum: number;
        InscatterMuNum: number;
        InscatterMuSNum: number;
        InscatterNuNum: number;

        static StaticClass(): Class;
    }

    export class AtmosphericFogComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SunMultiplier: number;
        FogMultiplier: number;
        DensityMultiplier: number;
        DensityOffset: number;
        DistanceScale: number;
        AltitudeScale: number;
        DistanceOffset: number;
        GroundOffset: number;
        StartDistance: number;
        SunDiscScale: number;
        DefaultBrightness: number;
        DefaultLightColor: Color;
        bDisableSunDisk: boolean;
        bAtmosphereAffectsSunIlluminance: boolean;
        bDisableGroundScattering: boolean;
        PrecomputeParams: AtmospherePrecomputeParameters;
        TransmittanceTexture: Texture2D;
        IrradianceTexture: Texture2D;

        DisableGroundScattering(NewGroundScattering: boolean): void;

        DisableSunDisk(NewSunDisk: boolean): void;

        SetAltitudeScale(NewAltitudeScale: number): void;

        SetDefaultBrightness(NewBrightness: number): void;

        SetDefaultLightColor(NewLightColor: LinearColor): void;

        SetDensityMultiplier(NewDensityMultiplier: number): void;

        SetDensityOffset(NewDensityOffset: number): void;

        SetDistanceOffset(NewDistanceOffset: number): void;

        SetDistanceScale(NewDistanceScale: number): void;

        SetFogMultiplier(NewFogMultiplier: number): void;

        SetPrecomputeParams(DensityHeight: number, MaxScatteringOrder: number, InscatterAltitudeSampleNum: number): void;

        SetStartDistance(NewStartDistance: number): void;

        SetSunMultiplier(NewSunMultiplier: number): void;

        StartPrecompute(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AtmosphericFogComponent;

        static Load(InName: string): AtmosphericFogComponent;
    }

    export class AtmosphericFog extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AtmosphericFogComponent: AtmosphericFogComponent;
        ArrowComponent: ArrowComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AtmosphericFog;

        static Load(InName: string): AtmosphericFog;
    }

    export class AudioBusFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioBusFactory;

        static Load(InName: string): AudioBusFactory;
    }

    export class AudioGenerator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioGenerator;

        static Load(InName: string): AudioGenerator;
    }

    export class AudioCaptureDeviceInfo {
        constructor();
        constructor(DeviceName: string, NumInputChannels: number, SampleRate: number);

        DeviceName: string;
        NumInputChannels: number;
        SampleRate: number;

        static StaticClass(): Class;
    }

    export class AudioCapture extends AudioGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetAudioCaptureDeviceInfo(OutInfo: $Ref<AudioCaptureDeviceInfo>): boolean;

        IsCapturingAudio(): boolean;

        StartCapturingAudio(): void;

        StopCapturingAudio(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioCapture;

        static Load(InName: string): AudioCapture;
    }

    export class SoundWaveProcedural extends SoundWave {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundWaveProcedural;

        static Load(InName: string): SoundWaveProcedural;
    }

    export class SynthSound extends SoundWaveProcedural {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwningSynthComponent: SynthComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SynthSound;

        static Load(InName: string): SynthSound;
    }

    export class SynthComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bAllowSpatialization: boolean;
        bOverrideAttenuation: boolean;
        bOutputToBusOnly: boolean;
        AttenuationSettings: SoundAttenuation;
        AttenuationOverrides: SoundAttenuationSettings;
        ConcurrencySettings: SoundConcurrency;
        ConcurrencySet: TSet<SoundConcurrency>;
        SoundClass: SoundClass;
        SourceEffectChain: SoundEffectSourcePresetChain;
        SoundSubmix: SoundSubmixBase;
        SoundSubmixSends: TArray<SoundSubmixSendInfo>;
        BusSends: TArray<SoundSourceBusSendInfo>;
        PreEffectBusSends: TArray<SoundSourceBusSendInfo>;
        bIsUISound: boolean;
        bIsPreviewSound: boolean;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        OnAudioEnvelopeValue: $MulticastDelegate<(EnvelopeValue: number) => void>;
        Synth: SynthSound;
        AudioComponent: AudioComponent;

        IsPlaying(): boolean;

        SetLowPassFilterEnabled(InLowPassFilterEnabled: boolean): void;

        SetLowPassFilterFrequency(InLowPassFilterFrequency: number): void;

        SetSubmixSend(Submix: $Nullable<SoundSubmixBase>, SendLevel: number): void;

        SetVolumeMultiplier(VolumeMultiplier: number): void;

        Start(): void;

        Stop(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SynthComponent;

        static Load(InName: string): SynthComponent;
    }

    export class AudioCaptureComponent extends SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        JitterLatencyFrames: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioCaptureComponent;

        static Load(InName: string): AudioCaptureComponent;
    }

    export class AudioCaptureFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateAudioCapture(): AudioCapture;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioCaptureFunctionLibrary;

        static Load(InName: string): AudioCaptureFunctionLibrary;
    }

    export class AudioEndpointSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioEndpointSettingsBase;

        static Load(InName: string): AudioEndpointSettingsBase;
    }

    export class SoundNode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChildNodes: TArray<SoundNode>;
        GraphNode: EdGraphNode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNode;

        static Load(InName: string): SoundNode;
    }

    export class SoundCue extends SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bPrimeOnLoad: boolean;
        FirstNode: SoundNode;
        VolumeMultiplier: number;
        PitchMultiplier: number;
        AttenuationOverrides: SoundAttenuationSettings;
        AllNodes: TArray<SoundNode>;
        SoundCueGraph: EdGraph;
        SubtitlePriority: number;
        bOverrideAttenuation: boolean;
        bExcludeFromRandomNodeBranchCulling: boolean;
        CookedQualityIndex: number;
        bHasPlayWhenSilent: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundCue;

        static Load(InName: string): SoundCue;
    }

    export enum EAudioSpectrumBandPresetType { KickDrum, SnareDrum, Voice, Cymbals, EAudioSpectrumBandPresetType_MAX }

    export enum EMusicalNoteName { C, Db, D, Eb, E, F, Gb, G, Ab, A, Bb, B, EMusicalNoteName_MAX }

    export class AudioMixerBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddMasterSubmixEffect(WorldContextObject: $Nullable<Object>, SubmixEffectPreset: $Nullable<SoundEffectSubmixPreset>): void;

        static AddSourceEffectToPresetChain(WorldContextObject: $Nullable<Object>, PresetChain: $Nullable<SoundEffectSourcePresetChain>, Entry: SourceEffectChainEntry): void;

        static AddSubmixEffect(WorldContextObject: $Nullable<Object>, SoundSubmix: $Nullable<SoundSubmix>, SubmixEffectPreset: $Nullable<SoundEffectSubmixPreset>): number;

        static ClearMasterSubmixEffects(WorldContextObject: $Nullable<Object>): void;

        static ClearSubmixEffectChainOverride(WorldContextObject: $Nullable<Object>, SoundSubmix: $Nullable<SoundSubmix>, FadeTimeSec: number): void;

        static ClearSubmixEffects(WorldContextObject: $Nullable<Object>, SoundSubmix: $Nullable<SoundSubmix>): void;

        static GetMagnitudeForFrequencies(WorldContextObject: $Nullable<Object>, Frequencies: TArray<number>, Magnitudes: $Ref<TArray<number>>, SubmixToAnalyze?: SoundSubmix /* = None */): void;

        static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: $Nullable<Object>, PresetChain: $Nullable<SoundEffectSourcePresetChain>): number;

        static GetPhaseForFrequencies(WorldContextObject: $Nullable<Object>, Frequencies: TArray<number>, Phases: $Ref<TArray<number>>, SubmixToAnalyze?: SoundSubmix /* = None */): void;

        static IsAudioBusActive(WorldContextObject: $Nullable<Object>, AudioBus: $Nullable<AudioBus>): boolean;

        static MakeFullSpectrumSpectralAnalysisBandSettings(InNumBands?: number /* = 30 */, InMinimumFrequency?: number /* = 40.000000 */, InMaximumFrequency?: number /* = 16000.000000 */, InAttackTimeMsec?: number /* = 10 */, InReleaseTimeMsec?: number /* = 10 */): TArray<SoundSubmixSpectralAnalysisBandSettings>;

        static MakeMusicalSpectralAnalysisBandSettings(InNumSemitones?: number /* = 60 */, InStartingMusicalNote?: EMusicalNoteName /* = C */, InStartingOctave?: number /* = 2 */, InAttackTimeMsec?: number /* = 10 */, InReleaseTimeMsec?: number /* = 10 */): TArray<SoundSubmixSpectralAnalysisBandSettings>;

        static MakePresetSpectralAnalysisBandSettings(InBandPresetType: EAudioSpectrumBandPresetType, InNumBands?: number /* = 10 */, InAttackTimeMsec?: number /* = 10 */, InReleaseTimeMsec?: number /* = 10 */): TArray<SoundSubmixSpectralAnalysisBandSettings>;

        static PauseRecordingOutput(WorldContextObject: $Nullable<Object>, SubmixToPause?: SoundSubmix /* = None */): void;

        static PrimeSoundCueForPlayback(SoundCue: $Nullable<SoundCue>): void;

        static PrimeSoundForPlayback(SoundWave: $Nullable<SoundWave>, OnLoadCompletion: $Delegate<(LoadedSoundWave: $Nullable<SoundWave>, WasCancelled: boolean) => void>): void;

        static RemoveMasterSubmixEffect(WorldContextObject: $Nullable<Object>, SubmixEffectPreset: $Nullable<SoundEffectSubmixPreset>): void;

        static RemoveSourceEffectFromPresetChain(WorldContextObject: $Nullable<Object>, PresetChain: $Nullable<SoundEffectSourcePresetChain>, EntryIndex: number): void;

        static RemoveSubmixEffectPreset(WorldContextObject: $Nullable<Object>, SoundSubmix: $Nullable<SoundSubmix>, SubmixEffectPreset: $Nullable<SoundEffectSubmixPreset>): void;

        static RemoveSubmixEffectPresetAtIndex(WorldContextObject: $Nullable<Object>, SoundSubmix: $Nullable<SoundSubmix>, SubmixChainIndex: number): void;

        static ReplaceSoundEffectSubmix(WorldContextObject: $Nullable<Object>, InSoundSubmix: $Nullable<SoundSubmix>, SubmixChainIndex: number, SubmixEffectPreset: $Nullable<SoundEffectSubmixPreset>): void;

        static ResumeRecordingOutput(WorldContextObject: $Nullable<Object>, SubmixToPause?: SoundSubmix /* = None */): void;

        static SetBypassSourceEffectChainEntry(WorldContextObject: $Nullable<Object>, PresetChain: $Nullable<SoundEffectSourcePresetChain>, EntryIndex: number, bBypassed: boolean): void;

        static SetSubmixEffectChainOverride(WorldContextObject: $Nullable<Object>, SoundSubmix: $Nullable<SoundSubmix>, SubmixEffectPresetChain: TArray<SoundEffectSubmixPreset>, FadeTimeSec: number): void;

        static StartAnalyzingOutput(WorldContextObject: $Nullable<Object>, SubmixToAnalyze?: SoundSubmix /* = None */, FFTSize?: EFFTSize /* = DefaultSize */, InterpolationMethod?: EFFTPeakInterpolationMethod /* = Linear */, WindowType?: EFFTWindowType /* = Hann */, HopSize?: number /* = 0.000000 */, SpectrumType?: EAudioSpectrumType /* = MagnitudeSpectrum */): void;

        static StartAudioBus(WorldContextObject: $Nullable<Object>, AudioBus: $Nullable<AudioBus>): void;

        static StartRecordingOutput(WorldContextObject: $Nullable<Object>, ExpectedDuration: number, SubmixToRecord?: SoundSubmix /* = None */): void;

        static StopAnalyzingOutput(WorldContextObject: $Nullable<Object>, SubmixToStopAnalyzing?: SoundSubmix /* = None */): void;

        static StopAudioBus(WorldContextObject: $Nullable<Object>, AudioBus: $Nullable<AudioBus>): void;

        static StopRecordingOutput(WorldContextObject: $Nullable<Object>, ExportType: EAudioRecordingExportType, Name: string, Path: string, SubmixToRecord?: SoundSubmix /* = None */, ExistingSoundWaveToOverwrite?: SoundWave /* = None */): SoundWave;

        static TrimAudioCache(InMegabytesToFree: number): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioMixerBlueprintLibrary;

        static Load(InName: string): AudioMixerBlueprintLibrary;
    }

    export class AudioMixerCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioMixerCommandlet;

        static Load(InName: string): AudioMixerCommandlet;
    }

    export enum EVoiceSampleRate { Low16000Hz, Normal24000Hz, EVoiceSampleRate_MAX }

    export class AudioQualitySettings {
        constructor();
        constructor(DisplayName: string, MaxChannels: number);

        DisplayName: string;
        MaxChannels: number;

        static StaticClass(): Class;
    }

    export enum EPanningMethod { Linear, EqualPower, EPanningMethod_MAX }

    export enum EMonoChannelUpmixMethod { Linear, EqualPower, FullVolume, EMonoChannelUpmixMethod_MAX }

    export class AudioSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultSoundClassName: SoftObjectPath;
        DefaultMediaSoundClassName: SoftObjectPath;
        DefaultSoundConcurrencyName: SoftObjectPath;
        DefaultBaseSoundMix: SoftObjectPath;
        VoiPSoundClass: SoftObjectPath;
        MasterSubmix: SoftObjectPath;
        ReverbSubmix: SoftObjectPath;
        EQSubmix: SoftObjectPath;
        VoiPSampleRate: EVoiceSampleRate;
        DefaultReverbSendLevel: number;
        MaximumConcurrentStreams: number;
        GlobalMinPitchScale: number;
        GlobalMaxPitchScale: number;
        QualityLevels: TArray<AudioQualitySettings>;
        bAllowPlayWhenSilent: boolean;
        bDisableMasterEQ: boolean;
        bAllowCenterChannel3DPanning: boolean;
        NumStoppingSources: number;
        PanningMethod: EPanningMethod;
        MonoChannelUpmixMethod: EMonoChannelUpmixMethod;
        DialogueFilenameFormat: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioSettings;

        static Load(InName: string): AudioSettings;
    }

    export class AudioTestCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioTestCommandlet;

        static Load(InName: string): AudioTestCommandlet;
    }

    export enum EAudioVolumeLocationState { InsideTheVolume, OutsideTheVolume, EAudioVolumeLocationState_MAX }

    export class AudioVolumeSubmixSendSettings {
        constructor();
        constructor(ListenerLocationState: EAudioVolumeLocationState, SourceLocationState: EAudioVolumeLocationState, SubmixSends: TArray<SoundSubmixSendInfo>);

        ListenerLocationState: EAudioVolumeLocationState;
        SourceLocationState: EAudioVolumeLocationState;
        SubmixSends: TArray<SoundSubmixSendInfo>;

        static StaticClass(): Class;
    }

    export class AudioVolumeSubmixOverrideSettings {
        constructor();
        constructor(Submix: SoundSubmix, SubmixEffectChain: TArray<SoundEffectSubmixPreset>, CrossfadeTime: number);

        Submix: SoundSubmix;
        SubmixEffectChain: TArray<SoundEffectSubmixPreset>;
        CrossfadeTime: number;

        static StaticClass(): Class;
    }

    export class AudioVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Priority: number;
        bEnabled: boolean;
        Settings: ReverbSettings;
        AmbientZoneSettings: InteriorSettings;
        SubmixSendSettings: TArray<AudioVolumeSubmixSendSettings>;
        SubmixOverrideSettings: TArray<AudioVolumeSubmixOverrideSettings>;

        OnRep_bEnabled(): void;

        SetEnabled(bNewEnabled: boolean): void;

        SetInteriorSettings(NewInteriorSettings: InteriorSettings): void;

        SetPriority(NewPriority: number): void;

        SetReverbSettings(NewReverbSettings: ReverbSettings): void;

        SetSubmixOverrideSettings(NewSubmixOverrideSettings: TArray<AudioVolumeSubmixOverrideSettings>): void;

        SetSubmixSendSettings(NewSubmixSendSettings: TArray<AudioVolumeSubmixSendSettings>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AudioVolume;

        static Load(InName: string): AudioVolume;
    }

    export class WorldSubsystem extends Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WorldSubsystem;

        static Load(InName: string): WorldSubsystem;
    }

    export class AutoDestroySubsystem extends WorldSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActorsToPoll: TArray<Actor>;

        OnActorEndPlay(Actor: $Nullable<Actor>, EndPlayReason: EEndPlayReason): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutoDestroySubsystem;

        static Load(InName: string): AutoDestroySubsystem;
    }

    export enum EMovieSceneCaptureProtocolState {
        Idle,
        Initialized,
        Capturing,
        Finalizing,
        EMovieSceneCaptureProtocolState_MAX
    }

    export class MovieSceneCaptureProtocolBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        State: EMovieSceneCaptureProtocolState;

        GetState(): EMovieSceneCaptureProtocolState;

        IsCapturing(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureProtocolBase;

        static Load(InName: string): MovieSceneCaptureProtocolBase;
    }

    export class MovieSceneImageCaptureProtocolBase extends MovieSceneCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneImageCaptureProtocolBase;

        static Load(InName: string): MovieSceneImageCaptureProtocolBase;
    }

    export class MovieSceneAudioCaptureProtocolBase extends MovieSceneCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioCaptureProtocolBase;

        static Load(InName: string): MovieSceneAudioCaptureProtocolBase;
    }

    export class CaptureResolution {
        constructor();
        constructor(ResX: number, ResY: number);

        ResX: number;
        ResY: number;

        static StaticClass(): Class;
    }

    export class MovieSceneCaptureSettings {
        constructor();
        constructor(OutputDirectory: DirectoryPath, GameModeOverride: Class, OutputFormat: string, bOverwriteExisting: boolean, bUseRelativeFrameNumbers: boolean, HandleFrames: number, MovieExtension: string, ZeroPadFrameNumbers: number, FrameRate: FrameRate, bUseCustomFrameRate: boolean, CustomFrameRate: FrameRate, Resolution: CaptureResolution, bEnableTextureStreaming: boolean, bCinematicEngineScalability: boolean, bCinematicMode: boolean, bAllowMovement: boolean, bAllowTurning: boolean, bShowPlayer: boolean, bShowHUD: boolean, bUsePathTracer: boolean, PathTracerSamplePerPixel: number);

        OutputDirectory: DirectoryPath;
        GameModeOverride: Class;
        OutputFormat: string;
        bOverwriteExisting: boolean;
        bUseRelativeFrameNumbers: boolean;
        HandleFrames: number;
        MovieExtension: string;
        ZeroPadFrameNumbers: number;
        FrameRate: FrameRate;
        bUseCustomFrameRate: boolean;
        CustomFrameRate: FrameRate;
        Resolution: CaptureResolution;
        bEnableTextureStreaming: boolean;
        bCinematicEngineScalability: boolean;
        bCinematicMode: boolean;
        bAllowMovement: boolean;
        bAllowTurning: boolean;
        bShowPlayer: boolean;
        bShowHUD: boolean;
        bUsePathTracer: boolean;
        PathTracerSamplePerPixel: number;

        static StaticClass(): Class;
    }

    export class MovieSceneCapture extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImageCaptureProtocolType: SoftClassPath;
        AudioCaptureProtocolType: SoftClassPath;
        ImageCaptureProtocol: MovieSceneImageCaptureProtocolBase;
        AudioCaptureProtocol: MovieSceneAudioCaptureProtocolBase;
        Settings: MovieSceneCaptureSettings;
        bUseSeparateProcess: boolean;
        bCloseEditorWhenCaptureStarts: boolean;
        AdditionalCommandLineArguments: string;
        InheritedCommandLineArguments: string;

        GetAudioCaptureProtocol(): MovieSceneCaptureProtocolBase;

        GetImageCaptureProtocol(): MovieSceneCaptureProtocolBase;

        SetAudioCaptureProtocolType(ProtocolType: $Nullable<Class>): void;

        SetImageCaptureProtocolType(ProtocolType: $Nullable<Class>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCapture;

        static Load(InName: string): MovieSceneCapture;
    }

    export class LevelSequenceBurnInInitSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnInInitSettings;

        static Load(InName: string): LevelSequenceBurnInInitSettings;
    }

    export class LevelSequenceBurnInOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseBurnIn: boolean;
        BurnInClass: SoftClassPath;
        Settings: LevelSequenceBurnInInitSettings;

        SetBurnIn(InBurnInClass: SoftClassPath): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnInOptions;

        static Load(InName: string): LevelSequenceBurnInOptions;
    }

    export class MovieSceneSequenceLoopCount {
        constructor();
        constructor(Value: number);

        Value: number;

        static StaticClass(): Class;
    }

    export class MovieSceneSequencePlaybackSettings {
        constructor();
        constructor(bAutoPlay: boolean, LoopCount: MovieSceneSequenceLoopCount, PlayRate: number, StartTime: number, bRandomStartTime: boolean, bRestoreState: boolean, bDisableMovementInput: boolean, bDisableLookAtInput: boolean, bHidePlayer: boolean, bHideHud: boolean, bDisableCameraCuts: boolean, bPauseAtEnd: boolean);

        bAutoPlay: boolean;
        LoopCount: MovieSceneSequenceLoopCount;
        PlayRate: number;
        StartTime: number;
        bRandomStartTime: boolean;
        bRestoreState: boolean;
        bDisableMovementInput: boolean;
        bDisableLookAtInput: boolean;
        bHidePlayer: boolean;
        bHideHud: boolean;
        bDisableCameraCuts: boolean;
        bPauseAtEnd: boolean;

        static StaticClass(): Class;
    }

    export enum EMovieScenePlayerStatus { Stopped, Playing, Recording, Scrubbing, Jumping, Stepping, Paused, MAX }

    export class MovieSceneSequenceReplProperties {
        constructor();
        constructor(LastKnownPosition: FrameTime, LastKnownStatus: EMovieScenePlayerStatus, LastKnownNumLoops: number);

        LastKnownPosition: FrameTime;
        LastKnownStatus: EMovieScenePlayerStatus;
        LastKnownNumLoops: number;

        static StaticClass(): Class;
    }

    export class MovieScenePlaybackClient extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePlaybackClient;

        static Load(InName: string): MovieScenePlaybackClient;
    }

    export class MovieSceneSequenceTickManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SequenceActors: TArray<Actor>;
        Linker: MovieSceneEntitySystemLinker;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSequenceTickManager;

        static Load(InName: string): MovieSceneSequenceTickManager;
    }

    export enum EMovieScenePositionType { Frame, Time, MarkedFrame, EMovieScenePositionType_MAX }

    export enum EUpdatePositionMethod { Play, Jump, Scrub, EUpdatePositionMethod_MAX }

    export class MovieSceneSequencePlaybackParams {
        constructor();
        constructor(Frame: FrameTime, Time: number, MarkedFrame: string, PositionType: EMovieScenePositionType, UpdateMethod: EUpdatePositionMethod);

        Frame: FrameTime;
        Time: number;
        MarkedFrame: string;
        PositionType: EMovieScenePositionType;
        UpdateMethod: EUpdatePositionMethod;

        static StaticClass(): Class;
    }

    export class QualifiedFrameTime {
        constructor();
        constructor(Time: FrameTime, Rate: FrameRate);

        Time: FrameTime;
        Rate: FrameRate;

        static StaticClass(): Class;
    }

    export class MovieSceneSequencePlayer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPlay: $MulticastDelegate<() => void>;
        OnPlayReverse: $MulticastDelegate<() => void>;
        OnStop: $MulticastDelegate<() => void>;
        OnPause: $MulticastDelegate<() => void>;
        OnFinished: $MulticastDelegate<() => void>;
        Status: EMovieScenePlayerStatus;
        bReversePlayback: boolean;
        Sequence: MovieSceneSequence;
        StartTime: FrameNumber;
        DurationFrames: number;
        DurationSubFrames: number;
        CurrentNumLoops: number;
        PlaybackSettings: MovieSceneSequencePlaybackSettings;
        RootTemplateInstance: MovieSceneRootEvaluationTemplateInstance;
        NetSyncProps: MovieSceneSequenceReplProperties;
        PlaybackClient: MovieScenePlaybackClient;
        TickManager: MovieSceneSequenceTickManager;

        ChangePlaybackDirection(): void;

        GetBoundObjects(ObjectBinding: MovieSceneObjectBindingID): TArray<Object>;

        GetCurrentTime(): QualifiedFrameTime;

        GetDisableCameraCuts(): boolean;

        GetDuration(): QualifiedFrameTime;

        GetEndTime(): QualifiedFrameTime;

        GetFrameDuration(): number;

        GetFrameRate(): FrameRate;

        GetObjectBindings(InObject: $Nullable<Object>): TArray<MovieSceneObjectBindingID>;

        GetPlayRate(): number;

        GetStartTime(): QualifiedFrameTime;

        GoToEndAndStop(): void;

        IsPaused(): boolean;

        IsPlaying(): boolean;

        IsReversed(): boolean;

        JumpToFrame(NewPosition: FrameTime): void;

        JumpToMarkedFrame(InLabel: string): boolean;

        JumpToSeconds(TimeInSeconds: number): void;

        Pause(): void;

        Play(): void;

        PlayLooping(NumLoops?: number /* = -1 */): void;

        PlayReverse(): void;

        PlayTo(PlaybackParams: MovieSceneSequencePlaybackParams): void;

        PlayToFrame(NewPosition: FrameTime): void;

        PlayToMarkedFrame(InLabel: string): boolean;

        PlayToSeconds(TimeInSeconds: number): void;

        RPC_ExplicitServerUpdateEvent(Method: EUpdatePositionMethod, RelevantTime: FrameTime): void;

        RPC_OnStopEvent(StoppedTime: FrameTime): void;

        Scrub(): void;

        ScrubToFrame(NewPosition: FrameTime): void;

        ScrubToMarkedFrame(InLabel: string): boolean;

        ScrubToSeconds(TimeInSeconds: number): void;

        SetDisableCameraCuts(bInDisableCameraCuts: boolean): void;

        SetFrameRange(StartFrame: number, Duration: number, SubFrames?: number /* = 0.000000 */): void;

        SetFrameRate(FrameRate: FrameRate): void;

        SetPlaybackPosition(PlaybackParams: MovieSceneSequencePlaybackParams): void;

        SetPlayRate(PlayRate: number): void;

        SetTimeRange(StartTime: number, Duration: number): void;

        Stop(): void;

        StopAtCurrentTime(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSequencePlayer;

        static Load(InName: string): MovieSceneSequencePlayer;
    }

    export class LevelSequencePlayer extends MovieSceneSequencePlayer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnCameraCut: $MulticastDelegate<(CameraComponent: $Nullable<CameraComponent>) => void>;

        GetActiveCameraComponent(): CameraComponent;

        static CreateLevelSequencePlayer(WorldContextObject: $Nullable<Object>, LevelSequence: $Nullable<LevelSequence>, Settings: MovieSceneSequencePlaybackSettings, OutActor: $Ref<LevelSequenceActor>): LevelSequencePlayer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequencePlayer;

        static Load(InName: string): LevelSequencePlayer;
    }

    export class LevelSequenceCameraSettings {
        constructor();
        constructor(bOverrideAspectRatioAxisConstraint: boolean, AspectRatioAxisConstraint: EAspectRatioAxisConstraint);

        bOverrideAspectRatioAxisConstraint: boolean;
        AspectRatioAxisConstraint: EAspectRatioAxisConstraint;

        static StaticClass(): Class;
    }

    export class MovieSceneBindingOverrideData {
        constructor();
        constructor(ObjectBindingId: MovieSceneObjectBindingID, Object: TWeakObjectPtr<Object>, bOverridesDefault: boolean);

        ObjectBindingId: MovieSceneObjectBindingID;
        Object: TWeakObjectPtr<Object>;
        bOverridesDefault: boolean;

        static StaticClass(): Class;
    }

    export class MovieSceneBindingOverrides extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BindingData: TArray<MovieSceneBindingOverrideData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneBindingOverrides;

        static Load(InName: string): MovieSceneBindingOverrides;
    }

    export class LevelSequenceSnapshotSettings {
        constructor();
        constructor(ZeroPadAmount: number, FrameRate: FrameRate);

        ZeroPadAmount: number;
        FrameRate: FrameRate;

        static StaticClass(): Class;
    }

    export class LevelSequencePlayerSnapshot {
        constructor();
        constructor(MasterName: string, MasterTime: QualifiedFrameTime, SourceTime: QualifiedFrameTime, CurrentShotName: string, CurrentShotLocalTime: QualifiedFrameTime, CurrentShotSourceTime: QualifiedFrameTime, SourceTimecode: string, CameraComponent: TSoftObjectPtr<CameraComponent>, Settings: LevelSequenceSnapshotSettings, ActiveShot: LevelSequence, ShotID: MovieSceneSequenceID);

        MasterName: string;
        MasterTime: QualifiedFrameTime;
        SourceTime: QualifiedFrameTime;
        CurrentShotName: string;
        CurrentShotLocalTime: QualifiedFrameTime;
        CurrentShotSourceTime: QualifiedFrameTime;
        SourceTimecode: string;
        CameraComponent: TSoftObjectPtr<CameraComponent>;
        Settings: LevelSequenceSnapshotSettings;
        ActiveShot: LevelSequence;
        ShotID: MovieSceneSequenceID;

        static StaticClass(): Class;
    }

    export class LevelSequenceBurnIn extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FrameInformation: LevelSequencePlayerSnapshot;
        LevelSequenceActor: LevelSequenceActor;

        GetSettingsClass(): Class;

        SetSettings(InSettings: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnIn;

        static Load(InName: string): LevelSequenceBurnIn;
    }

    export class LevelSequenceActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlaybackSettings: MovieSceneSequencePlaybackSettings;
        SequencePlayer: LevelSequencePlayer;
        LevelSequence: SoftObjectPath;
        CameraSettings: LevelSequenceCameraSettings;
        BurnInOptions: LevelSequenceBurnInOptions;
        BindingOverrides: MovieSceneBindingOverrides;
        bAutoPlay: boolean;
        bOverrideInstanceData: boolean;
        bReplicatePlayback: boolean;
        DefaultInstanceData: Object;
        BurnInInstance: LevelSequenceBurnIn;
        bShowBurnin: boolean;

        AddBinding(Binding: MovieSceneObjectBindingID, Actor: $Nullable<Actor>, bAllowBindingsFromAsset?: boolean /* = false */): void;

        AddBindingByTag(BindingTag: string, Actor: $Nullable<Actor>, bAllowBindingsFromAsset?: boolean /* = false */): void;

        FindNamedBinding(Tag: string): MovieSceneObjectBindingID;

        FindNamedBindings(Tag: string): TArray<MovieSceneObjectBindingID>;

        GetSequence(): LevelSequence;

        GetSequencePlayer(): LevelSequencePlayer;

        HideBurnin(): void;

        LoadSequence(): LevelSequence;

        OnLevelSequenceLoaded__DelegateSignature(): void;

        RemoveBinding(Binding: MovieSceneObjectBindingID, Actor: $Nullable<Actor>): void;

        RemoveBindingByTag(Tag: string, Actor: $Nullable<Actor>): void;

        ResetBinding(Binding: MovieSceneObjectBindingID): void;

        ResetBindings(): void;

        SetBinding(Binding: MovieSceneObjectBindingID, Actors: TArray<Actor>, bAllowBindingsFromAsset?: boolean /* = false */): void;

        SetBindingByTag(BindingTag: string, Actors: TArray<Actor>, bAllowBindingsFromAsset?: boolean /* = false */): void;

        SetReplicatePlayback(ReplicatePlayback: boolean): void;

        SetSequence(InSequence: $Nullable<LevelSequence>): void;

        ShowBurnin(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequenceActor;

        static Load(InName: string): LevelSequenceActor;
    }

    export class AutomatedLevelSequenceCapture extends MovieSceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LevelSequenceAsset: SoftObjectPath;
        ShotName: string;
        bUseCustomStartFrame: boolean;
        CustomStartFrame: FrameNumber;
        bUseCustomEndFrame: boolean;
        CustomEndFrame: FrameNumber;
        WarmUpFrameCount: number;
        DelayBeforeWarmUp: number;
        DelayBeforeShotWarmUp: number;
        DelayEveryFrame: number;
        BurnInOptions: LevelSequenceBurnInOptions;
        bWriteEditDecisionList: boolean;
        bWriteFinalCutProXML: boolean;
        LevelSequenceActor: TWeakObjectPtr<LevelSequenceActor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutomatedLevelSequenceCapture;

        static Load(InName: string): AutomatedLevelSequenceCapture;
    }

    export enum EComparisonTolerance { Zero, Low, Medium, High, Custom, EComparisonTolerance_MAX }

    export class AutomationEditorTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsTaskDone(): boolean;

        IsValidTask(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutomationEditorTask;

        static Load(InName: string): AutomationEditorTask;
    }

    export class AutomationViewSettings extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AntiAliasing: boolean;
        MotionBlur: boolean;
        TemporalAA: boolean;
        ScreenSpaceReflections: boolean;
        ScreenSpaceAO: boolean;
        DistanceFieldAO: boolean;
        ContactShadows: boolean;
        EyeAdaptation: boolean;
        Bloom: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutomationViewSettings;

        static Load(InName: string): AutomationViewSettings;
    }

    export class ComparisonToleranceAmount {
        constructor();
        constructor(Red: number, Green: number, Blue: number, Alpha: number, MinBrightness: number, MaxBrightness: number);

        Red: number;
        Green: number;
        Blue: number;
        Alpha: number;
        MinBrightness: number;
        MaxBrightness: number;

        static StaticClass(): Class;
    }

    export class AutomationScreenshotOptions {
        constructor();
        constructor(Resolution: Vector2D, Delay: number, bOverride_OverrideTimeTo: boolean, OverrideTimeTo: number, bDisableNoisyRenderingFeatures: boolean, bDisableTonemapping: boolean, ViewSettings: AutomationViewSettings, VisualizeBuffer: string, Tolerance: EComparisonTolerance, ToleranceAmount: ComparisonToleranceAmount, MaximumLocalError: number, MaximumGlobalError: number, bIgnoreAntiAliasing: boolean, bIgnoreColors: boolean);

        Resolution: Vector2D;
        Delay: number;
        bOverride_OverrideTimeTo: boolean;
        OverrideTimeTo: number;
        bDisableNoisyRenderingFeatures: boolean;
        bDisableTonemapping: boolean;
        ViewSettings: AutomationViewSettings;
        VisualizeBuffer: string;
        Tolerance: EComparisonTolerance;
        ToleranceAmount: ComparisonToleranceAmount;
        MaximumLocalError: number;
        MaximumGlobalError: number;
        bIgnoreAntiAliasing: boolean;
        bIgnoreColors: boolean;

        static StaticClass(): Class;
    }

    export class AutomationWaitForLoadingOptions {
        constructor();
        constructor(WaitForReplicationToSettle: boolean);

        WaitForReplicationToSettle: boolean;

        static StaticClass(): Class;
    }

    export class AutomationBlueprintFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddExpectedLogError(ExpectedPatternString: string, Occurrences?: number /* = 1 */, ExactMatch?: boolean /* = false */): void;

        static AreAutomatedTestsRunning(): boolean;

        static AutomationWaitForLoading(WorldContextObject: $Nullable<Object>, LatentInfo: LatentActionInfo, Options: AutomationWaitForLoadingOptions): void;

        static DisableStatGroup(WorldContextObject: $Nullable<Object>, GroupName: string): void;

        static EnableStatGroup(WorldContextObject: $Nullable<Object>, GroupName: string): void;

        static GetDefaultScreenshotOptionsForGameplay(Tolerance?: EComparisonTolerance /* = Low */, Delay?: number /* = 0.200000 */): AutomationScreenshotOptions;

        static GetDefaultScreenshotOptionsForRendering(Tolerance?: EComparisonTolerance /* = Low */, Delay?: number /* = 0.200000 */): AutomationScreenshotOptions;

        static GetStatCallCount(StatName: string): number;

        static GetStatExcAverage(StatName: string): number;

        static GetStatExcMax(StatName: string): number;

        static GetStatIncAverage(StatName: string): number;

        static GetStatIncMax(StatName: string): number;

        static SetScalabilityQualityLevelRelativeToMax(WorldContextObject: $Nullable<Object>, Value?: number /* = 1 */): void;

        static SetScalabilityQualityToEpic(WorldContextObject: $Nullable<Object>): void;

        static SetScalabilityQualityToLow(WorldContextObject: $Nullable<Object>): void;

        static TakeAutomationScreenshot(WorldContextObject: $Nullable<Object>, LatentInfo: LatentActionInfo, Name: string, Notes: string, Options: AutomationScreenshotOptions): void;

        static TakeAutomationScreenshotAtCamera(WorldContextObject: $Nullable<Object>, LatentInfo: LatentActionInfo, Camera: $Nullable<CameraActor>, NameOverride: string, Notes: string, Options: AutomationScreenshotOptions): void;

        static TakeAutomationScreenshotOfUI(WorldContextObject: $Nullable<Object>, LatentInfo: LatentActionInfo, Name: string, Options: AutomationScreenshotOptions): void;

        static TakeHighResScreenshot(ResX: number, ResY: number, Filename: string, Camera?: CameraActor /* = None */, bMaskEnabled?: boolean /* = false */, bCaptureHDR?: boolean /* = false */, ComparisonTolerance?: EComparisonTolerance /* = Low */, ComparisonNotes?: string /* = "" */, Delay?: number /* = 0.000000 */): AutomationEditorTask;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutomationBlueprintFunctionLibrary;

        static Load(InName: string): AutomationBlueprintFunctionLibrary;
    }

    export class AutomatedTestFilter {
        constructor();
        constructor(Contains: string, MatchFromStart: boolean);

        Contains: string;
        MatchFromStart: boolean;

        static StaticClass(): Class;
    }

    export class AutomatedTestGroup {
        constructor();
        constructor(Name: string, Filters: TArray<AutomatedTestFilter>);

        Name: string;
        Filters: TArray<AutomatedTestFilter>;

        static StaticClass(): Class;
    }

    export class AutomationControllerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Groups: TArray<AutomatedTestGroup>;
        bSuppressLogErrors: boolean;
        bSuppressLogWarnings: boolean;
        bTreatLogWarningsAsTestErrors: boolean;
        CheckTestIntervalSeconds: number;
        GameInstanceLostTimerSeconds: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutomationControllerSettings;

        static Load(InName: string): AutomationControllerSettings;
    }

    export class AutomationPerformaceHelper extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BeginRecording(RecordName: string, InGPUBudget: number, InRenderThreadBudget: number, InGameThreadBudget: number): void;

        BeginRecordingBaseline(RecordName: string): void;

        BeginStatsFile(RecordName: string): void;

        EndRecording(): void;

        EndRecordingBaseline(): void;

        EndStatsFile(): void;

        IsCurrentRecordWithinGameThreadBudget(): boolean;

        IsCurrentRecordWithinGPUBudget(): boolean;

        IsCurrentRecordWithinRenderThreadBudget(): boolean;

        IsRecording(): boolean;

        OnAllTestsComplete(): void;

        OnBeginTests(): void;

        Sample(DeltaSeconds: number): void;

        StartCPUProfiling(): void;

        StopCPUProfiling(): void;

        Tick(DeltaSeconds: number): void;

        TriggerGPUTraceIfRecordFallsBelowBudget(): void;

        WriteLogFile(CaptureDir: string, CaptureExtension: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutomationPerformaceHelper;

        static Load(InName: string): AutomationPerformaceHelper;
    }

    export class EditorMapPerformanceTestDefinition {
        constructor();
        constructor(PerformanceTestmap: SoftObjectPath, TestTimer: number);

        PerformanceTestmap: SoftObjectPath;
        TestTimer: number;

        static StaticClass(): Class;
    }

    export class FilePath {
        constructor();
        constructor(FilePath: string);

        FilePath: string;

        static StaticClass(): Class;
    }

    export class ImportFactorySettingValues {
        constructor();
        constructor(SettingName: string, Value: string);

        SettingName: string;
        Value: string;

        static StaticClass(): Class;
    }

    export class EditorImportWorkflowDefinition {
        constructor();
        constructor(ImportFilePath: FilePath, FactorySettings: TArray<ImportFactorySettingValues>);

        ImportFilePath: FilePath;
        FactorySettings: TArray<ImportFactorySettingValues>;

        static StaticClass(): Class;
    }

    export class BuildPromotionImportWorkflowSettings {
        constructor();
        constructor(Diffuse: EditorImportWorkflowDefinition, Normal: EditorImportWorkflowDefinition, StaticMesh: EditorImportWorkflowDefinition, ReimportStaticMesh: EditorImportWorkflowDefinition, BlendShapeMesh: EditorImportWorkflowDefinition, MorphMesh: EditorImportWorkflowDefinition, SkeletalMesh: EditorImportWorkflowDefinition, Animation: EditorImportWorkflowDefinition, Sound: EditorImportWorkflowDefinition, SurroundSound: EditorImportWorkflowDefinition, OtherAssetsToImport: TArray<EditorImportWorkflowDefinition>);

        Diffuse: EditorImportWorkflowDefinition;
        Normal: EditorImportWorkflowDefinition;
        StaticMesh: EditorImportWorkflowDefinition;
        ReimportStaticMesh: EditorImportWorkflowDefinition;
        BlendShapeMesh: EditorImportWorkflowDefinition;
        MorphMesh: EditorImportWorkflowDefinition;
        SkeletalMesh: EditorImportWorkflowDefinition;
        Animation: EditorImportWorkflowDefinition;
        Sound: EditorImportWorkflowDefinition;
        SurroundSound: EditorImportWorkflowDefinition;
        OtherAssetsToImport: TArray<EditorImportWorkflowDefinition>;

        static StaticClass(): Class;
    }

    export class BuildPromotionOpenAssetSettings {
        constructor();
        constructor(BlueprintAsset: FilePath, MaterialAsset: FilePath, ParticleSystemAsset: FilePath, SkeletalMeshAsset: FilePath, StaticMeshAsset: FilePath, TextureAsset: FilePath);

        BlueprintAsset: FilePath;
        MaterialAsset: FilePath;
        ParticleSystemAsset: FilePath;
        SkeletalMeshAsset: FilePath;
        StaticMeshAsset: FilePath;
        TextureAsset: FilePath;

        static StaticClass(): Class;
    }

    export class BuildPromotionNewProjectSettings {
        constructor();
        constructor(NewProjectFolderOverride: DirectoryPath, NewProjectNameOverride: string);

        NewProjectFolderOverride: DirectoryPath;
        NewProjectNameOverride: string;

        static StaticClass(): Class;
    }

    export class BuildPromotionTestSettings {
        constructor();
        constructor(DefaultStaticMeshAsset: FilePath, ImportWorkflow: BuildPromotionImportWorkflowSettings, OpenAssets: BuildPromotionOpenAssetSettings, NewProjectSettings: BuildPromotionNewProjectSettings, SourceControlMaterial: FilePath);

        DefaultStaticMeshAsset: FilePath;
        ImportWorkflow: BuildPromotionImportWorkflowSettings;
        OpenAssets: BuildPromotionOpenAssetSettings;
        NewProjectSettings: BuildPromotionNewProjectSettings;
        SourceControlMaterial: FilePath;

        static StaticClass(): Class;
    }

    export class MaterialEditorPromotionSettings {
        constructor();
        constructor(DefaultMaterialAsset: FilePath, DefaultDiffuseTexture: FilePath, DefaultNormalTexture: FilePath);

        DefaultMaterialAsset: FilePath;
        DefaultDiffuseTexture: FilePath;
        DefaultNormalTexture: FilePath;

        static StaticClass(): Class;
    }

    export class ParticleEditorPromotionSettings {
        constructor();
        constructor(DefaultParticleAsset: FilePath);

        DefaultParticleAsset: FilePath;

        static StaticClass(): Class;
    }

    export class BlueprintEditorPromotionSettings {
        constructor();
        constructor(FirstMeshPath: FilePath, SecondMeshPath: FilePath, DefaultParticleAsset: FilePath);

        FirstMeshPath: FilePath;
        SecondMeshPath: FilePath;
        DefaultParticleAsset: FilePath;

        static StaticClass(): Class;
    }

    export class ExternalToolDefinition {
        constructor();
        constructor(ToolName: string, ExecutablePath: FilePath, CommandLineOptions: string, WorkingDirectory: DirectoryPath, ScriptExtension: string, ScriptDirectory: DirectoryPath);

        ToolName: string;
        ExecutablePath: FilePath;
        CommandLineOptions: string;
        WorkingDirectory: DirectoryPath;
        ScriptExtension: string;
        ScriptDirectory: DirectoryPath;

        static StaticClass(): Class;
    }

    export class EditorImportExportTestDefinition {
        constructor();
        constructor(ImportFilePath: FilePath, ExportFileExtension: string, bSkipExport: boolean, FactorySettings: TArray<ImportFactorySettingValues>);

        ImportFilePath: FilePath;
        ExportFileExtension: string;
        bSkipExport: boolean;
        FactorySettings: TArray<ImportFactorySettingValues>;

        static StaticClass(): Class;
    }

    export class LaunchOnTestSettings {
        constructor();
        constructor(LaunchOnTestmap: FilePath, DeviceID: string);

        LaunchOnTestmap: FilePath;
        DeviceID: string;

        static StaticClass(): Class;
    }

    export class AutomationTestSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EngineTestModules: TArray<string>;
        EditorTestModules: TArray<string>;
        AutomationTestmap: SoftObjectPath;
        EditorPerformanceTestMaps: TArray<EditorMapPerformanceTestDefinition>;
        AssetsToOpen: TArray<SoftObjectPath>;
        MapsToPIETest: TArray<string>;
        BuildPromotionTest: BuildPromotionTestSettings;
        MaterialEditorPromotionTest: MaterialEditorPromotionSettings;
        ParticleEditorPromotionTest: ParticleEditorPromotionSettings;
        BlueprintEditorPromotionTest: BlueprintEditorPromotionSettings;
        TestLevelFolders: TArray<string>;
        ExternalTools: TArray<ExternalToolDefinition>;
        ImportExportTestDefinitions: TArray<EditorImportExportTestDefinition>;
        LaunchOnSettings: TArray<LaunchOnTestSettings>;
        DefaultScreenshotResolution: IntPoint;
        PIETestDuration: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutomationTestSettings;

        static Load(InName: string): AutomationTestSettings;
    }

    export class AutoReimportManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AutoReimportManager;

        static Load(InName: string): AutoReimportManager;
    }

    export class BehaviorInfo {
        constructor();
        constructor(Behavior: InputBehavior);

        Behavior: InputBehavior;

        static StaticClass(): Class;
    }

    export class InputBehaviorSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Behaviors: TArray<BehaviorInfo>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputBehaviorSet;

        static Load(InName: string): InputBehaviorSet;
    }

    export class InteractiveGizmo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputBehaviors: InputBehaviorSet;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveGizmo;

        static Load(InName: string): InteractiveGizmo;
    }

    export class GizmoAxisSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetDirection(): Vector;

        GetOrigin(): Vector;

        GetTangentVectors(TangentXOut: $Ref<Vector>, TangentYOut: $Ref<Vector>): void;

        HasTangentVectors(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoAxisSource;

        static Load(InName: string): GizmoAxisSource;
    }

    export class GizmoFloatParameterSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BeginModify(): void;

        EndModify(): void;

        GetParameter(): number;

        SetParameter(NewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoFloatParameterSource;

        static Load(InName: string): GizmoFloatParameterSource;
    }

    export class GizmoClickTarget extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UpdateHoverState(bHovering: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoClickTarget;

        static Load(InName: string): GizmoClickTarget;
    }

    export class GizmoStateTarget extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BeginUpdate(): void;

        EndUpdate(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoStateTarget;

        static Load(InName: string): GizmoStateTarget;
    }

    export class AxisAngleGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        AngleSource: GizmoFloatParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bInInteraction: boolean;
        RotationOrigin: Vector;
        RotationAxis: Vector;
        RotationPlaneX: Vector;
        RotationPlaneY: Vector;
        InteractionStartPoint: Vector;
        InteractionCurPoint: Vector;
        InteractionStartAngle: number;
        InteractionCurAngle: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AxisAngleGizmo;

        static Load(InName: string): AxisAngleGizmo;
    }

    export class InteractiveGizmoBuilder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveGizmoBuilder;

        static Load(InName: string): InteractiveGizmoBuilder;
    }

    export class AxisAngleGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AxisAngleGizmoBuilder;

        static Load(InName: string): AxisAngleGizmoBuilder;
    }

    export class AxisGizmoHandleGroup extends GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AxisGizmoHandleGroup;

        static Load(InName: string): AxisGizmoHandleGroup;
    }

    export class AxisPositionGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        ParameterSource: GizmoFloatParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bEnableSignedAxis: boolean;
        bInInteraction: boolean;
        InteractionOrigin: Vector;
        InteractionAxis: Vector;
        InteractionStartPoint: Vector;
        InteractionCurPoint: Vector;
        InteractionStartParameter: number;
        InteractionCurParameter: number;
        ParameterSign: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AxisPositionGizmo;

        static Load(InName: string): AxisPositionGizmo;
    }

    export class AxisPositionGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): AxisPositionGizmoBuilder;

        static Load(InName: string): AxisPositionGizmoBuilder;
    }

    export class ContentWidget extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetContent(): Widget;

        GetContentSlot(): PanelSlot;

        SetContent(Content: $Nullable<Widget>): PanelSlot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentWidget;

        static Load(InName: string): ContentWidget;
    }

    export enum EHorizontalAlignment { HAlign_Fill, HAlign_Left, HAlign_Center, HAlign_Right, HAlign_MAX }

    export enum EVerticalAlignment { VAlign_Fill, VAlign_Top, VAlign_Center, VAlign_Bottom, VAlign_MAX }

    export class BackgroundBlur extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;
        bApplyAlphaToBlur: boolean;
        BlurStrength: number;
        bOverrideAutoRadiusCalculation: boolean;
        BlurRadius: number;
        LowQualityFallbackBrush: SlateBrush;

        SetApplyAlphaToBlur(bInApplyAlphaToBlur: boolean): void;

        SetBlurRadius(InBlurRadius: number): void;

        SetBlurStrength(InStrength: number): void;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetLowQualityFallbackBrush(InBrush: SlateBrush): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BackgroundBlur;

        static Load(InName: string): BackgroundBlur;
    }

    export class BackgroundBlurSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BackgroundBlurSlot;

        static Load(InName: string): BackgroundBlurSlot;
    }

    export class BandwidthTestItem {
        constructor();
        constructor(Kilobyte: TArray<number>);

        Kilobyte: TArray<number>;

        static StaticClass(): Class;
    }

    export class BandwidthTestGenerator {
        constructor();
        constructor(ReplicatedBuffers: TArray<BandwidthTestItem>);

        ReplicatedBuffers: TArray<BandwidthTestItem>;

        static StaticClass(): Class;
    }

    export class BandwidthTestActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BandwidthGenerator: BandwidthTestGenerator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BandwidthTestActor;

        static Load(InName: string): BandwidthTestActor;
    }

    export class InteractiveTool extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputBehaviors: InputBehaviorSet;
        ToolPropertyObjects: TArray<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveTool;

        static Load(InName: string): InteractiveTool;
    }

    export class SingleSelectionTool extends InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SingleSelectionTool;

        static Load(InName: string): SingleSelectionTool;
    }

    export class MeshSurfacePointTool extends SingleSelectionTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshSurfacePointTool;

        static Load(InName: string): MeshSurfacePointTool;
    }

    export class InteractiveToolPropertySet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CachedProperties: InteractiveToolPropertySet;
        bIsPropertySetEnabled: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveToolPropertySet;

        static Load(InName: string): InteractiveToolPropertySet;
    }

    export class BrushBaseProperties extends InteractiveToolPropertySet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BrushSize: number;
        bSpecifyRadius: boolean;
        BrushRadius: number;
        BrushStrength: number;
        BrushFalloffAmount: number;
        bShowStrength: boolean;
        bShowFalloff: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushBaseProperties;

        static Load(InName: string): BrushBaseProperties;
    }

    export class BrushStampData {
        constructor();

        static StaticClass(): Class;
    }

    export class BrushStampIndicator extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BrushRadius: number;
        BrushFalloff: number;
        BrushPosition: Vector;
        BrushNormal: Vector;
        bDrawIndicatorLines: boolean;
        bDrawRadiusCircle: boolean;
        SampleStepCount: number;
        LineColor: LinearColor;
        LineThickness: number;
        bDepthTested: boolean;
        bDrawSecondaryLines: boolean;
        SecondaryLineThickness: number;
        SecondaryLineColor: LinearColor;
        AttachedComponent: PrimitiveComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushStampIndicator;

        static Load(InName: string): BrushStampIndicator;
    }

    export class BaseBrushTool extends MeshSurfacePointTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BrushProperties: BrushBaseProperties;
        bInBrushStroke: boolean;
        WorldToLocalScale: number;
        LastBrushStamp: BrushStampData;
        PropertyClass: TSoftClassPtr<BrushBaseProperties>;
        BrushStampIndicator: BrushStampIndicator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BaseBrushTool;

        static Load(InName: string): BaseBrushTool;
    }

    export class MediaSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetUrl(): string;

        SetMediaOptionBool(Key: string, Value: boolean): void;

        SetMediaOptionFloat(Key: string, Value: number): void;

        SetMediaOptionInt64(Key: string, Value: bigint): void;

        SetMediaOptionString(Key: string, Value: string): void;

        Validate(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MediaSource;

        static Load(InName: string): MediaSource;
    }

    export class BaseMediaSource extends MediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlatformPlayerNames: TMap<string, string>;
        PlayerName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BaseMediaSource;

        static Load(InName: string): BaseMediaSource;
    }

    export class BaseWidgetBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetTree: WidgetTree;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BaseWidgetBlueprint;

        static Load(InName: string): BaseWidgetBlueprint;
    }

    export class Overlays extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Overlays;

        static Load(InName: string): Overlays;
    }

    export class Timespan {
        constructor();

        static StaticClass(): Class;
    }

    export class OverlayItem {
        constructor();
        constructor(StartTime: Timespan, EndTime: Timespan, Text: string, Position: Vector2D);

        StartTime: Timespan;
        EndTime: Timespan;
        Text: string;
        Position: Vector2D;

        static StaticClass(): Class;
    }

    export class BasicOverlays extends Overlays {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Overlays: TArray<OverlayItem>;
        AssetImportData: AssetImportData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BasicOverlays;

        static Load(InName: string): BasicOverlays;
    }

    export class BasicOverlaysFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BasicOverlaysFactory;

        static Load(InName: string): BasicOverlaysFactory;
    }

    export class BasicOverlaysFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BasicOverlaysFactoryNew;

        static Load(InName: string): BasicOverlaysFactoryNew;
    }

    export class BehaviorTreeDecoratorGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraph;

        static Load(InName: string): BehaviorTreeDecoratorGraph;
    }

    export class BehaviorTreeDecoratorGraphNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode;

        static Load(InName: string): BehaviorTreeDecoratorGraphNode;
    }

    export class BehaviorTreeDecoratorGraphNode_Decorator extends BehaviorTreeDecoratorGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NodeInstance: Object;
        ClassData: GraphNodeClassData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode_Decorator;

        static Load(InName: string): BehaviorTreeDecoratorGraphNode_Decorator;
    }

    export enum EDecoratorLogicMode { Sink, And, Or, Not, EDecoratorLogicMode_MAX }

    export class BehaviorTreeDecoratorGraphNode_Logic extends BehaviorTreeDecoratorGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LogicMode: EDecoratorLogicMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode_Logic;

        static Load(InName: string): BehaviorTreeDecoratorGraphNode_Logic;
    }

    export class BehaviorTreeEditorTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeEditorTypes;

        static Load(InName: string): BehaviorTreeEditorTypes;
    }

    export class BehaviorTreeFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeFactory;

        static Load(InName: string): BehaviorTreeFactory;
    }

    export class BehaviorTreeGraph extends AIGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ModCounter: number;
        bIsUsingModCounter: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraph;

        static Load(InName: string): BehaviorTreeGraph;
    }

    export class BehaviorTreeGraphNode extends AIGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Decorators: TArray<BehaviorTreeGraphNode>;
        Services: TArray<BehaviorTreeGraphNode>;
        bInjectedNode: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode;

        static Load(InName: string): BehaviorTreeGraphNode;
    }

    export class BehaviorTreeGraphNode_Composite extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Composite;

        static Load(InName: string): BehaviorTreeGraphNode_Composite;
    }

    export class BehaviorTreeGraphNode_CompositeDecorator extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoundGraph: EdGraph;
        CompositeName: string;
        bShowOperations: boolean;
        bCanAbortFlow: boolean;
        ParentNodeInstance: BTCompositeNode;
        CachedDescription: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_CompositeDecorator;

        static Load(InName: string): BehaviorTreeGraphNode_CompositeDecorator;
    }

    export class BehaviorTreeGraphNode_Decorator extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Decorator;

        static Load(InName: string): BehaviorTreeGraphNode_Decorator;
    }

    export class BehaviorTreeGraphNode_Root extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlackboardAsset: BlackboardData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Root;

        static Load(InName: string): BehaviorTreeGraphNode_Root;
    }

    export class BehaviorTreeGraphNode_Service extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Service;

        static Load(InName: string): BehaviorTreeGraphNode_Service;
    }

    export class BehaviorTreeGraphNode_SimpleParallel extends BehaviorTreeGraphNode_Composite {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_SimpleParallel;

        static Load(InName: string): BehaviorTreeGraphNode_SimpleParallel;
    }

    export class BehaviorTreeGraphNode_Task extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Task;

        static Load(InName: string): BehaviorTreeGraphNode_Task;
    }

    export class BehaviorTreeGraphNode_SubtreeTask extends BehaviorTreeGraphNode_Task {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_SubtreeTask;

        static Load(InName: string): BehaviorTreeGraphNode_SubtreeTask;
    }

    export class BehaviorTreeTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BehaviorTreeTypes;

        static Load(InName: string): BehaviorTreeTypes;
    }

    export class MWAssetRecorder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWAssetRecorder;

        static Load(InName: string): MWAssetRecorder;
    }

    export class MWMaterialInstanceDynamic extends MaterialInstanceDynamic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Guid: string;
        SourceRecorder: MWAssetRecorder;
        SourceRecorderJson: MWAssetRecorder;
        TextureParameterRecorder: TArray<MWAssetRecorder>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMaterialInstanceDynamic;

        static Load(InName: string): MWMaterialInstanceDynamic;
    }

    export class BFL_Test extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static Test_Asset(InPakPath: string): void;

        static Test_AssetAnsycLoad(Target: $Nullable<StaticMeshComponent>, Guid?: string /* = "7735" */): void;

        static Test_AssetAnsycLoadSkeletalMesh(Target: $Nullable<SkeletalMeshComponent>): void;

        static Test_AssetAnsycLoadTex(): void;

        static Test_AssetJson(InJsonPath: string): void;

        static Test_AssetLoad(Guid?: string /* = "7735" */): MaterialInterface;

        static Test_AssetLoad1(): MaterialInterface;

        static Test_CreateMaterialInstanceDynamic(InMat: $Nullable<Material>): MWMaterialInstanceDynamic;

        static Test_DownloadAsset(InGuid: string): void;

        static Test_GetMaterialGUID(): TArray<string>;

        static Test_MaterialInstanceDynamicReplace(Taget: $Nullable<MWMaterialInstanceDynamic>, Obj: $Nullable<MWMaterialInstanceDynamic>, MI: $Nullable<MaterialInstance>): MWMaterialInstanceDynamic;

        static Test_MaterialInstanceDynamicReplace1(Taget: $Nullable<MWMaterialInstanceDynamic>, Obj: $Nullable<MWMaterialInstanceDynamic>): MWMaterialInstanceDynamic;

        static Test_MountPak(InPakPath: string, OutDirectory: $Ref<string>, OutAssetList: $Ref<TArray<string>>): boolean;

        static Test_Replace(selfMat: $Nullable<MaterialInstance>, TagetMat: $Nullable<MaterialInterface>): void;

        static Test_SetMaterialTexture(Taget: $Nullable<MWMaterialInstanceDynamic>, ColorName: string, Guid: string): void;

        static Test_SoundWaveReplace(Sound01: string, Sound02: string): SoundWave;

        static Test_SoundWaveReplace1(Sound01: string, Sound02: string): SoundWave;

        static Test_StaticLoad(InPath: string, InNamePath: string): Object;

        static Test_StaticLoad_Texture(InPath: string, InNamePath: string): Object;

        static Test_StreamLoad(InPath: string, InNamePath: string): void;

        static Test_StreamLoad_Handle(List: $Ref<TArray<Object>>): boolean;

        static Test_Update(Taget: $Nullable<StaticMeshComponent>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BFL_Test;

        static Load(InName: string): BFL_Test;
    }

    export class BlackboardAssetProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetBlackboardAsset(): BlackboardData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardAssetProvider;

        static Load(InName: string): BlackboardAssetProvider;
    }

    export class BlackboardDataFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardDataFactory;

        static Load(InName: string): BlackboardDataFactory;
    }

    export class BlackboardKeyType_Bool extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Bool;

        static Load(InName: string): BlackboardKeyType_Bool;
    }

    export class BlackboardKeyType_Class extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BaseClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Class;

        static Load(InName: string): BlackboardKeyType_Class;
    }

    export class BlackboardKeyType_Enum extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        enumType: Enum;
        enumName: string;
        bIsEnumNameValid: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Enum;

        static Load(InName: string): BlackboardKeyType_Enum;
    }

    export class BlackboardKeyType_Float extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Float;

        static Load(InName: string): BlackboardKeyType_Float;
    }

    export class BlackboardKeyType_Int extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Int;

        static Load(InName: string): BlackboardKeyType_Int;
    }

    export class BlackboardKeyType_Name extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Name;

        static Load(InName: string): BlackboardKeyType_Name;
    }

    export class BlackboardKeyType_NativeEnum extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        enumName: string;
        enumType: Enum;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_NativeEnum;

        static Load(InName: string): BlackboardKeyType_NativeEnum;
    }

    export class BlackboardKeyType_Object extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BaseClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Object;

        static Load(InName: string): BlackboardKeyType_Object;
    }

    export class BlackboardKeyType_Rotator extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Rotator;

        static Load(InName: string): BlackboardKeyType_Rotator;
    }

    export class BlackboardKeyType_String extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StringValue: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_String;

        static Load(InName: string): BlackboardKeyType_String;
    }

    export class BlackboardKeyType_Vector extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Vector;

        static Load(InName: string): BlackboardKeyType_Vector;
    }

    export class BlendSpaceThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlendSpaceThumbnailRenderer;

        static Load(InName: string): BlendSpaceThumbnailRenderer;
    }

    export class BlockingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlockingVolume;

        static Load(InName: string): BlockingVolume;
    }

    export class BlueprintNodeSpawner extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NodeClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintNodeSpawner;

        static Load(InName: string): BlueprintNodeSpawner;
    }

    export class BlueprintEventNodeSpawner extends BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventFunc: Function;
        CustomEventName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintEventNodeSpawner;

        static Load(InName: string): BlueprintEventNodeSpawner;
    }

    export class BlueprintBoundEventNodeSpawner extends BlueprintEventNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintBoundEventNodeSpawner;

        static Load(InName: string): BlueprintBoundEventNodeSpawner;
    }

    export class BlueprintBoundNodeSpawner extends BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintBoundNodeSpawner;

        static Load(InName: string): BlueprintBoundNodeSpawner;
    }

    export class BlueprintCompilerExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintCompilerExtension;

        static Load(InName: string): BlueprintCompilerExtension;
    }

    export class BlueprintComponentNodeSpawner extends BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ComponentClass: Class;
        ComponentName: string;
        ComponentAssetName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintComponentNodeSpawner;

        static Load(InName: string): BlueprintComponentNodeSpawner;
    }

    export class BlueprintFieldNodeSpawner extends BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwnerClass: Class;
        Field: Field;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintFieldNodeSpawner;

        static Load(InName: string): BlueprintFieldNodeSpawner;
    }

    export class BlueprintDelegateNodeSpawner extends BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintDelegateNodeSpawner;

        static Load(InName: string): BlueprintDelegateNodeSpawner;
    }

    export class BlueprintEditorProjectSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bForceAllDependenciesToRecompile: boolean;
        bValidateUnloadedSoftActorReferences: boolean;
        bEnableChildActorExpansionInTreeView: boolean;
        DisabledCompilerMessagesExceptEditor: TArray<string>;
        DisabledCompilerMessages: TArray<string>;
        NamespacesToAlwaysInclude: TArray<string>;
        DefaultChildActorTreeViewMode: EChildActorComponentTreeViewVisualizationMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintEditorProjectSettings;

        static Load(InName: string): BlueprintEditorProjectSettings;
    }

    export enum ESaveOnCompile { SoC_Never, SoC_SuccessOnly, SoC_Always, SoC_MAX }

    export class BlueprintEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDrawMidpointArrowsInBlueprints: boolean;
        bShowGraphInstructionText: boolean;
        bHideUnrelatedNodes: boolean;
        bShowShortTooltips: boolean;
        bSplitContextTargetSettings: boolean;
        bExposeAllMemberComponentFunctions: boolean;
        bShowContextualFavorites: boolean;
        bExposeDeprecatedFunctions: boolean;
        bCompactCallOnMemberNodes: boolean;
        bFlattenFavoritesMenus: boolean;
        bFavorPureCastNodes: boolean;
        bAutoCastObjectConnections: boolean;
        bShowViewportOnSimulate: boolean;
        bShowInheritedVariables: boolean;
        bAlwaysShowInterfacesInOverrides: boolean;
        bShowParentClassInOverrides: boolean;
        bShowEmptySections: boolean;
        bShowAccessSpecifier: boolean;
        bSpawnDefaultBlueprintNodes: boolean;
        bHideConstructionScriptComponentsInDetailsView: boolean;
        bHostFindInBlueprintsInGlobalTab: boolean;
        bNavigateToNativeFunctionsFromCallNodes: boolean;
        Bookmarks: TMap<Guid, EditedDocumentInfo>;
        BookmarkNodes: TArray<BPEditorBookmarkNode>;
        bIncludeCommentNodesInBookmarksTab: boolean;
        bShowBookmarksForCurrentDocumentOnlyInTab: boolean;
        GraphEditorQuickJumps: TMap<number, EditedDocumentInfo>;
        SaveOnCompile: ESaveOnCompile;
        bJumpToNodeErrors: boolean;
        bAllowExplicitImpureNodeDisabling: boolean;
        bShowActionMenuItemSignatures: boolean;
        bBlueprintNodeUniqueNames: boolean;
        NamespacesToAlwaysInclude: TArray<string>;
        bShowDetailedCompileResults: boolean;
        CompileEventDisplayThresholdMs: number;
        NodeTemplateCacheCapMB: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintEditorSettings;

        static Load(InName: string): BlueprintEditorSettings;
    }

    export class BlueprintEditorToolMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintEditorToolMenuContext;

        static Load(InName: string): BlueprintEditorToolMenuContext;
    }

    export class BlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParentClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintFactory;

        static Load(InName: string): BlueprintFactory;
    }

    export class BlueprintFunctionLibraryFactory extends BlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionLibraryFactory;

        static Load(InName: string): BlueprintFunctionLibraryFactory;
    }

    export class BlueprintFunctionNodeSpawner extends BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionNodeSpawner;

        static Load(InName: string): BlueprintFunctionNodeSpawner;
    }

    export class GameplayTagAssetInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetOwnedGameplayTags(TagContainer: $Ref<GameplayTagContainer>): void;

        HasAllMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;

        HasAnyMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;

        HasMatchingGameplayTag(TagToCheck: GameplayTag): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagAssetInterface;

        static Load(InName: string): GameplayTagAssetInterface;
    }

    export class BlueprintGameplayTagLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddGameplayTag(TagContainer: $Ref<GameplayTagContainer>, Tag: GameplayTag): void;

        static AppendGameplayTagContainers(InOutTagContainer: $Ref<GameplayTagContainer>, InTagContainer: GameplayTagContainer): void;

        static BreakGameplayTagContainer(GameplayTagContainer: GameplayTagContainer, GameplayTags: $Ref<TArray<GameplayTag>>): void;

        static DoesContainerMatchTagQuery(TagContainer: GameplayTagContainer, TagQuery: GameplayTagQuery): boolean;

        static DoesTagAssetInterfaceHaveTag(TagContainerInterface: GameplayTagAssetInterface, Tag: GameplayTag): boolean;

        static EqualEqual_GameplayTag(A: GameplayTag, B: GameplayTag): boolean;

        static EqualEqual_GameplayTagContainer(A: GameplayTagContainer, B: GameplayTagContainer): boolean;

        static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: $Nullable<Object>, ActorClass: $Nullable<Class>, GameplayTagQuery: GameplayTagQuery, OutActors: $Ref<TArray<Actor>>): void;

        static GetDebugStringFromGameplayTag(GameplayTag: GameplayTag): string;

        static GetDebugStringFromGameplayTagContainer(TagContainer: GameplayTagContainer): string;

        static GetNumGameplayTagsInContainer(TagContainer: GameplayTagContainer): number;

        static GetTagName(GameplayTag: GameplayTag): string;

        static HasAllMatchingGameplayTags(TagContainerInterface: GameplayTagAssetInterface, OtherContainer: GameplayTagContainer): boolean;

        static HasAllTags(TagContainer: GameplayTagContainer, OtherContainer: GameplayTagContainer, bExactMatch: boolean): boolean;

        static HasAnyTags(TagContainer: GameplayTagContainer, OtherContainer: GameplayTagContainer, bExactMatch: boolean): boolean;

        static HasTag(TagContainer: GameplayTagContainer, Tag: GameplayTag, bExactMatch: boolean): boolean;

        static IsGameplayTagValid(GameplayTag: GameplayTag): boolean;

        static IsTagQueryEmpty(TagQuery: GameplayTagQuery): boolean;

        static MakeGameplayTagContainerFromArray(GameplayTags: TArray<GameplayTag>): GameplayTagContainer;

        static MakeGameplayTagContainerFromTag(SingleTag: GameplayTag): GameplayTagContainer;

        static MakeGameplayTagQuery(TagQuery: GameplayTagQuery): GameplayTagQuery;

        static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;

        static MakeLiteralGameplayTagContainer(Value: GameplayTagContainer): GameplayTagContainer;

        static MatchesAnyTags(TagOne: GameplayTag, OtherContainer: GameplayTagContainer, bExactMatch: boolean): boolean;

        static MatchesTag(TagOne: GameplayTag, TagTwo: GameplayTag, bExactMatch: boolean): boolean;

        static NotEqual_GameplayTag(A: GameplayTag, B: GameplayTag): boolean;

        static NotEqual_GameplayTagContainer(A: GameplayTagContainer, B: GameplayTagContainer): boolean;

        static NotEqual_TagContainerTagContainer(A: GameplayTagContainer, B: string): boolean;

        static NotEqual_TagTag(A: GameplayTag, B: string): boolean;

        static RemoveGameplayTag(TagContainer: $Ref<GameplayTagContainer>, Tag: GameplayTag): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintGameplayTagLibrary;

        static Load(InName: string): BlueprintGameplayTagLibrary;
    }

    export class BlueprintInterfaceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintInterfaceFactory;

        static Load(InName: string): BlueprintInterfaceFactory;
    }

    export class BlueprintMacroFactory extends BlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintMacroFactory;

        static Load(InName: string): BlueprintMacroFactory;
    }

    export class BlueprintMapLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static Map_Add(TargetMap: TMap<number, number>, Key: number, Value: number): void;

        static Map_Clear(TargetMap: TMap<number, number>): void;

        static Map_Contains(TargetMap: TMap<number, number>, Key: number): boolean;

        static Map_Find(TargetMap: TMap<number, number>, Key: number, Value: $Ref<number>): boolean;

        static Map_Keys(TargetMap: TMap<number, number>, Keys: $Ref<TArray<number>>): void;

        static Map_Length(TargetMap: TMap<number, number>): number;

        static Map_Remove(TargetMap: TMap<number, number>, Key: number): boolean;

        static Map_Values(TargetMap: TMap<number, number>, Values: $Ref<TArray<number>>): void;

        static SetMapPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: TMap<number, number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintMapLibrary;

        static Load(InName: string): BlueprintMapLibrary;
    }

    export class FavoritedBlueprintPaletteItem {
        constructor();

        static StaticClass(): Class;
    }

    export class BlueprintPaletteFavorites extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CustomFavorites: TArray<string>;
        CurrentFavorites: TArray<FavoritedBlueprintPaletteItem>;
        CurrentProfile: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintPaletteFavorites;

        static Load(InName: string): BlueprintPaletteFavorites;
    }

    export class BlueprintPathsLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AutomationDir(): string;

        static AutomationLogDir(): string;

        static AutomationTransientDir(): string;

        static BugItDir(): string;

        static ChangeExtension(InPath: string, InNewExtension: string): string;

        static CloudDir(): string;

        static CollapseRelativeDirectories(InPath: string, OutPath: $Ref<string>): boolean;

        static Combine(InPaths: TArray<string>): string;

        static ConvertFromSandboxPath(InPath: string, InSandboxName: string): string;

        static ConvertRelativePathToFull(InPath: string, InBasePath?: string /* = "" */): string;

        static ConvertToSandboxPath(InPath: string, InSandboxName: string): string;

        static CreateTempFilename(Path: string, Prefix?: string /* = "" */, Extension?: string /* = ".tmp" */): string;

        static DiffDir(): string;

        static DirectoryExists(InPath: string): boolean;

        static EngineConfigDir(): string;

        static EngineContentDir(): string;

        static EngineDir(): string;

        static EngineIntermediateDir(): string;

        static EnginePluginsDir(): string;

        static EngineSavedDir(): string;

        static EngineSourceDir(): string;

        static EngineUserDir(): string;

        static EngineVersionAgnosticUserDir(): string;

        static EnterpriseDir(): string;

        static EnterpriseFeaturePackDir(): string;

        static EnterprisePluginsDir(): string;

        static FeaturePackDir(): string;

        static FileExists(InPath: string): boolean;

        static GameAgnosticSavedDir(): string;

        static GameDevelopersDir(): string;

        static GameSourceDir(): string;

        static GameUserDeveloperDir(): string;

        static GeneratedConfigDir(): string;

        static GetBaseFilename(InPath: string, bRemovePath?: boolean /* = true */): string;

        static GetCleanFilename(InPath: string): string;

        static GetEditorLocalizationPaths(): TArray<string>;

        static GetEngineLocalizationPaths(): TArray<string>;

        static GetExtension(InPath: string, bIncludeDot?: boolean /* = false */): string;

        static GetGameLocalizationPaths(): TArray<string>;

        static GetInvalidFileSystemChars(): string;

        static GetPath(InPath: string): string;

        static GetProjectFilePath(): string;

        static GetPropertyNameLocalizationPaths(): TArray<string>;

        static GetRelativePathToRoot(): string;

        static GetRestrictedFolderNames(): TArray<string>;

        static GetToolTipLocalizationPaths(): TArray<string>;

        static HasProjectPersistentDownloadDir(): boolean;

        static IsDrive(InPath: string): boolean;

        static IsProjectFilePathSet(): boolean;

        static IsRelative(InPath: string): boolean;

        static IsRestrictedPath(InPath: string): boolean;

        static IsSamePath(PathA: string, PathB: string): boolean;

        static LaunchDir(): string;

        static MakePathRelativeTo(InPath: string, InRelativeTo: string, OutPath: $Ref<string>): boolean;

        static MakePlatformFilename(InPath: string, OutPath: $Ref<string>): void;

        static MakeStandardFilename(InPath: string, OutPath: $Ref<string>): void;

        static MakeValidFileName(InString: string, InReplacementChar?: string /* = "" */): string;

        static NormalizeDirectoryName(InPath: string, OutPath: $Ref<string>): void;

        static NormalizeFilename(InPath: string, OutPath: $Ref<string>): void;

        static ProfilingDir(): string;

        static ProjectConfigDir(): string;

        static ProjectContentDir(): string;

        static ProjectDir(): string;

        static ProjectIntermediateDir(): string;

        static ProjectLogDir(): string;

        static ProjectModsDir(): string;

        static ProjectPersistentDownloadDir(): string;

        static ProjectPluginsDir(): string;

        static ProjectSavedDir(): string;

        static ProjectUserDir(): string;

        static RemoveDuplicateSlashes(InPath: string, OutPath: $Ref<string>): void;

        static RootDir(): string;

        static SandboxesDir(): string;

        static ScreenShotDir(): string;

        static SetExtension(InPath: string, InNewExtension: string): string;

        static SetProjectFilePath(NewGameProjectFilePath: string): void;

        static ShaderWorkingDir(): string;

        static ShouldSaveToUserDir(): boolean;

        static SourceConfigDir(): string;

        static Split(InPath: string, PathPart: $Ref<string>, FilenamePart: $Ref<string>, ExtensionPart: $Ref<string>): void;

        static ValidatePath(InPath: string, bDidSucceed: $Ref<boolean>, OutReason: $Ref<string>): void;

        static VideoCaptureDir(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintPathsLibrary;

        static Load(InName: string): BlueprintPathsLibrary;
    }

    export class DateTime {
        constructor();

        static StaticClass(): Class;
    }

    export enum EScreenOrientation {
        Unknown,
        Portrait,
        PortraitUpsideDown,
        LandscapeLeft,
        LandscapeRight,
        FaceUp,
        FaceDown,
        EScreenOrientation_MAX
    }

    export class BlueprintPlatformLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CancelLocalNotification(ActivationEvent: string): void;

        static CancelLocalNotificationById(NotificationId: number): void;

        static ClearAllLocalNotifications(): void;

        static GetDeviceOrientation(): EScreenOrientation;

        static GetLaunchNotification(NotificationLaunchedApp: $Ref<boolean>, ActivationEvent: $Ref<string>, FireDate: $Ref<number>): void;

        static ScheduleLocalNotificationAtTime(FireDateTime: DateTime, LocalTime: boolean, Title: string, Body: string, Action: string, ActivationEvent: string): number;

        static ScheduleLocalNotificationBadgeAtTime(FireDateTime: DateTime, LocalTime: boolean, ActivationEvent: string): number;

        static ScheduleLocalNotificationBadgeFromNow(inSecondsFromNow: number, ActivationEvent: string): void;

        static ScheduleLocalNotificationFromNow(inSecondsFromNow: number, Title: string, Body: string, Action: string, ActivationEvent: string): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintPlatformLibrary;

        static Load(InName: string): BlueprintPlatformLibrary;
    }

    export class BlueprintPropertyTestObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShouldBeHidden: number;
        ShouldBeVisible: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintPropertyTestObject;

        static Load(InName: string): BlueprintPropertyTestObject;
    }

    export class BlueprintPropertyContainerTestObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Array: TArray<BlueprintPropertyTestObject>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintPropertyContainerTestObject;

        static Load(InName: string): BlueprintPropertyContainerTestObject;
    }

    export class BlueprintSetLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static Set_Add(TargetSet: TSet<number>, NewItem: number): void;

        static Set_AddItems(TargetSet: TSet<number>, NewItems: TArray<number>): void;

        static Set_Clear(TargetSet: TSet<number>): void;

        static Set_Contains(TargetSet: TSet<number>, ItemToFind: number): boolean;

        static Set_Difference(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>): void;

        static Set_Intersection(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>): void;

        static Set_Length(TargetSet: TSet<number>): number;

        static Set_Remove(TargetSet: TSet<number>, Item: number): boolean;

        static Set_RemoveItems(TargetSet: TSet<number>, Items: TArray<number>): void;

        static Set_ToArray(A: TSet<number>, Result: $Ref<TArray<number>>): void;

        static Set_Union(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>): void;

        static SetSetPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: TSet<number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintSetLibrary;

        static Load(InName: string): BlueprintSetLibrary;
    }

    export class BlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintThumbnailRenderer;

        static Load(InName: string): BlueprintThumbnailRenderer;
    }

    export class BlueprintVariableNodeSpawner extends BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LocalVarOuter: EdGraph;
        LocalVarDesc: BPVariableDescription;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BlueprintVariableNodeSpawner;

        static Load(InName: string): BlueprintVariableNodeSpawner;
    }

    export class BoneMaskFilter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlendPoses: TArray<InputBlendPose>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoneMaskFilter;

        static Load(InName: string): BoneMaskFilter;
    }

    export class BoneReferenceSkeletonProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoneReferenceSkeletonProvider;

        static Load(InName: string): BoneReferenceSkeletonProvider;
    }

    export class BookMark2D extends BookmarkBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Zoom2D: number;
        Location: IntPoint;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BookMark2D;

        static Load(InName: string): BookMark2D;
    }

    export class BoolBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetValue(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoolBinding;

        static Load(InName: string): BoolBinding;
    }

    export class BoolChannelKeyProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Time: FrameNumber;
        bValue: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoolChannelKeyProxy;

        static Load(InName: string): BoolChannelKeyProxy;
    }

    export class BoolProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoolProperty;

        static Load(InName: string): BoolProperty;
    }

    export class SlateBrushAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Brush: SlateBrush;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateBrushAsset;

        static Load(InName: string): SlateBrushAsset;
    }

    export class Border extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;
        bShowEffectWhenDisabled: boolean;
        ContentColorAndOpacity: LinearColor;
        ContentColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        Padding: Margin;
        Background: SlateBrush;
        BackgroundDelegate: $Delegate<() => SlateBrush>;
        BrushColor: LinearColor;
        BrushColorDelegate: $Delegate<() => LinearColor>;
        DesiredSizeScale: Vector2D;
        bFlipForRightToLeftFlowDirection: boolean;
        OnMouseButtonDownEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        OnMouseButtonUpEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        OnMouseMoveEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        OnMouseDoubleClickEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        Brush: SlateBrushAsset;

        GetDynamicMaterial(): MaterialInstanceDynamic;

        SetBrush(InBrush: SlateBrush): void;

        SetBrushColor(InBrushColor: LinearColor): void;

        SetBrushFromAsset(Asset: $Nullable<SlateBrushAsset>): void;

        SetBrushFromMaterial(Material: $Nullable<MaterialInterface>): void;

        SetBrushFromTexture(Texture: $Nullable<Texture2D>): void;

        SetContentColorAndOpacity(InContentColorAndOpacity: LinearColor): void;

        SetDesiredSizeScale(InScale: Vector2D): void;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Border;

        static Load(InName: string): Border;
    }

    export class BorderSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BorderSlot;

        static Load(InName: string): BorderSlot;
    }

    export class BoundsCopyComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoundsSourceActor: TSoftObjectPtr<Actor>;
        bUseCollidingComponentsForSourceBounds: boolean;
        bKeepOwnBoundsScale: boolean;
        bUseCollidingComponentsForOwnBounds: boolean;
        PostTransform: Transform;
        bCopyXBounds: boolean;
        bCopyYBounds: boolean;
        bCopyZBounds: boolean;

        SetRotation(): void;

        SetTransformToBounds(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoundsCopyComponent;

        static Load(InName: string): BoundsCopyComponent;
    }

    export class BoxComponent extends ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoxExtent: Vector;
        LineThickness: number;

        GetScaledBoxExtent(): Vector;

        GetUnscaledBoxExtent(): Vector;

        SetBoxExtent(InBoxExtent: Vector, bUpdateOverlaps?: boolean /* = true */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoxComponent;

        static Load(InName: string): BoxComponent;
    }

    export class FieldNodeBase extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldNodeBase;

        static Load(InName: string): FieldNodeBase;
    }

    export class FieldNodeFloat extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldNodeFloat;

        static Load(InName: string): FieldNodeFloat;
    }

    export enum EFieldFalloffType {
        Field_FallOff_None,
        Field_Falloff_Linear,
        Field_Falloff_Inverse,
        Field_Falloff_Squared,
        Field_Falloff_Logarithmic,
        Field_Falloff_Max
    }

    export class BoxFalloff extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Transform: Transform;
        Falloff: EFieldFalloffType;

        SetBoxFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Transform: Transform, Falloff: EFieldFalloffType): BoxFalloff;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoxFalloff;

        static Load(InName: string): BoxFalloff;
    }

    export enum EReflectionSourceType { CapturedScene, SpecifiedCubemap, EReflectionSourceType_MAX }

    export enum EMobileReflectionCompression { Default, On, Off, EMobileReflectionCompression_MAX }

    export class ReflectionCaptureComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CaptureOffsetComponent: BillboardComponent;
        ReflectionSourceType: EReflectionSourceType;
        MobileReflectionCompression: EMobileReflectionCompression;
        Cubemap: TextureCube;
        SourceCubemapAngle: number;
        Brightness: number;
        bModifyMaxValueRGBM: boolean;
        MaxValueRGBM: number;
        CaptureOffset: Vector;
        MapBuildDataId: Guid;
        CachedEncodedHDRCubemap: TextureCube;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReflectionCaptureComponent;

        static Load(InName: string): ReflectionCaptureComponent;
    }

    export class ReflectionCapture extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CaptureComponent: ReflectionCaptureComponent;
        SpriteComponent: BillboardComponent;
        CaptureOffsetComponent: BillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReflectionCapture;

        static Load(InName: string): ReflectionCapture;
    }

    export class BoxReflectionCapture extends ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoxReflectionCapture;

        static Load(InName: string): BoxReflectionCapture;
    }

    export class BoxReflectionCaptureComponent extends ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoxTransitionDistance: number;
        PreviewInfluenceBox: BoxComponent;
        PreviewCaptureBox: BoxComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BoxReflectionCaptureComponent;

        static Load(InName: string): BoxReflectionCaptureComponent;
    }

    export class MWSysCharacterBase extends Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerID: number;

        GetPlayerID(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCharacterBase;

        static Load(InName: string): MWSysCharacterBase;
    }

    export class MWBasicStanceData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Ground: Class;
        Flying: Class;
        Swimming: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWBasicStanceData;

        static Load(InName: string): MWBasicStanceData;
    }

    export class MWSysAnimInstance_StanceBase extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _IsMoving: boolean;
        _LocomotionMovingSpeed_Horizontal: number;
        _LocomotionMovingSpeed_Vertical: number;
        Direction: number;
        Yaw: number;
        Pitch: number;
        BlendUpper: boolean;
        BlendLower: boolean;
        SlotNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAnimInstance_StanceBase;

        static Load(InName: string): MWSysAnimInstance_StanceBase;
    }

    export class BonesTransforms {
        constructor();
        constructor(BonesTranslation: Vector, BonesScale: Vector, BonesRotation: Rotator);

        BonesTranslation: Vector;
        BonesScale: Vector;
        BonesRotation: Rotator;

        static StaticClass(): Class;
    }

    export class AnimInstanceProxy {
        constructor();

        static StaticClass(): Class;
    }

    export class MWSysAnimInstanceProxy_Character extends AnimInstanceProxy {
        constructor();
        constructor(_IsMoving: boolean, _IsCrouched: boolean, _LocomotionMovingSpeed_Horizontal: number, _LocomotionMovingSpeed_Vertical: number, _Locomotion_Direction: number);

        _IsMoving: boolean;
        _IsCrouched: boolean;
        _LocomotionMovingSpeed_Horizontal: number;
        _LocomotionMovingSpeed_Vertical: number;
        _Locomotion_Direction: number;

        static StaticClass(): Class;
    }

    export enum EMWMoveState { None, GroundState, FlyingState, SwimmingState, EMWMoveState_MAX }

    export class MWSysAnimInstance_Character extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentBasicStance: MWBasicStanceData;
        CurrentBasicAnimInstance: Class;
        CurrentAnimInstance: AnimInstance;
        CurrentStance: MWSysAnimInstance_StanceBase;
        BonesTranslation: TArray<Vector>;
        BonesRotation: TArray<Rotator>;
        BonesScale: TArray<Vector>;
        BonesName: TArray<string>;
        BonesMap: TMap<string, BonesTransforms>;
        IsEnableModifyBone: boolean;
        HeadTransforms: BonesTransforms;
        Chest_01_RTransforms: BonesTransforms;
        _Proxy: MWSysAnimInstanceProxy_Character;
        _MoveState: EMWMoveState;

        GetCurrentStance(): MWSysAnimInstance_StanceBase;

        SetAnimationStance(StancePackageName: string): void;

        SetAnimInstance(AnimInstance: $Ref<Class>): void;

        SetAnimInstanceByClass(AnimInstance: $Nullable<Class>): void;

        SetBasicStance(InBasicStance: $Nullable<Class>): void;

        SetBasicStanceByPath(Path: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAnimInstance_Character;

        static Load(InName: string): MWSysAnimInstance_Character;
    }

    export class MWCharacterPropertyComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetAutoAdjustDir(AutoFollowCameraRotate: boolean): void;

        SetMaxFallingVelocity(InMaxFallingVelocity: number): void;

        SetMaxFlySpeed(MaxFlySpeed: number): void;

        SetMaxJumpHeight(TargetMaxJumpHeight: number): void;

        SetMaxStepHeight(InMaxStepHeight: number): void;

        SetMaxSwimSpeed(MaxSwimSpeed: number): void;

        SetMaxWalkSpeed(MaxSpeed: number): void;

        SetMovementMode(NewMovementMode: EMovementMode): void;

        SetRotateRate(YawRate: number): void;

        SetWalkableFloorAngle(bAngle: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWCharacterPropertyComponent;

        static Load(InName: string): MWCharacterPropertyComponent;
    }

    export class MWSysPhysicsBodyComponent extends CapsuleComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsBodyComponent;

        static Load(InName: string): MWSysPhysicsBodyComponent;
    }

    export enum EMoveFacingDirection {
        MovementDirection,
        FixedDirection,
        ControllerDirection,
        EMoveFacingDirection_MAX
    }

    export class MWSysMovementComponent extends CharacterMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MoveFacingDirection: EMoveFacingDirection;

        GetMoveFacingDirection(): EMoveFacingDirection;

        ListenedFromSmoothComponent(): void;

        SetMoveFacingDirection(InMoveFacingDirection: EMoveFacingDirection): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysMovementComponent;

        static Load(InName: string): MWSysMovementComponent;
    }

    export enum EMWBodyPartType { E_None, E_Hair, E_Face, E_Body, E_UpperHalf, E_LowerHalf, E_MAX }

    export class MWBodyPartComponent extends SkeletalMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialInstanceDynamicArray: TArray<MaterialInstanceDynamic>;
        PartType: EMWBodyPartType;
        ColorArray: TArray<LinearColor>;
        OnChangeMainMesh: $MulticastDelegate<(Type: string) => void>;

        ChangeMainMesh(BodyType: string): void;

        CharacterFaceShadow(DirectionalLightRotator: Rotator, TraceDistance: number): number;

        CreateDynamicMaterial(MeshMaterials: TArray<MaterialInstanceDynamic>): void;

        CustomSetSkeletalMesh(NewMesh: $Nullable<SkeletalMesh>, MeshMaterials: TArray<MaterialInstanceDynamic>, InPartType?: EMWBodyPartType /* = E_Body */, bReinitPose?: boolean /* = true */): void;

        GetColorArray(): TArray<LinearColor>;

        GetMaterialColor(MaterialIndex: number): LinearColor;

        GetMaterialsInstance(): TArray<MaterialInstanceDynamic>;

        GetPartType(): EMWBodyPartType;

        InitMainMeshCloth(Guid: string): void;

        SetMaterialColor(InColor: LinearColor, MaterialIndex?: number /* = -1 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWBodyPartComponent;

        static Load(InName: string): MWBodyPartComponent;
    }

    export class MWBodyParts extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PartsTable: TMap<EMWBodyPartType, MWBodyPartComponent>;
        DefaultHair: SkeletalMesh;
        DefaultFace: SkeletalMesh;

        AddOrExchangeBodyPartComponent(NewMesh: $Nullable<SkeletalMesh>, MeshMaterials: TArray<MaterialInstanceDynamic>, MeshType: EMWBodyPartType): void;

        GetPartComponentByType(MeshType: EMWBodyPartType): MWBodyPartComponent;

        GetPartComponents(): TMap<EMWBodyPartType, MWBodyPartComponent>;

        InitDefault(): void;

        RemoveBodyPartComponent(MeshType: EMWBodyPartType): boolean;

        SetBodyPartVisibility(InVisible: boolean, InPart?: EMWBodyPartType /* = E_None */): void;

        SetColor(InColor: LinearColor, MaterialIndex: number, InType?: EMWBodyPartType /* = E_None */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWBodyParts;

        static Load(InName: string): MWBodyParts;
    }

    export enum EMovementDirection { AxisDirection, ViewDirection, ControllerDirection, EMovementDirection_MAX }

    export class MWSKAssetData {
        constructor();
        constructor(Guid: string, MeshMaterials: TArray<MaterialInterface>, ParentSocket: string, bUseMasterPose: boolean, DynamicAssetPath: string);

        Guid: string;
        MeshMaterials: TArray<MaterialInterface>;
        ParentSocket: string;
        bUseMasterPose: boolean;
        DynamicAssetPath: string;

        static StaticClass(): Class;
    }

    export class MWClothAssetData {
        constructor();
        constructor(Guid: string, DependencyGuid: TArray<string>, ClothVersion: string, PartName: string);

        Guid: string;
        DependencyGuid: TArray<string>;
        ClothVersion: string;
        PartName: string;

        static StaticClass(): Class;
    }

    export class MWSysMaterialIndexData {
        constructor();
        constructor(Indexs: TArray<number>);

        Indexs: TArray<number>;

        static StaticClass(): Class;
    }

    export class MWClothMaterialData {
        constructor();
        constructor(MaterialID: number, PartName: string);

        MaterialID: number;
        PartName: string;

        static StaticClass(): Class;
    }

    export class MWCharacterAssetsManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HeroDataMap: TMap<string, Class>;
        MontageTable: DataTable;
        FashionTable: DataTable;
        FashionChangeColorTable: DataTable;
        StanceTable: DataTable;

        ClearAssetData(): void;

        GetClothMeshMaterialData(Guid: string): TArray<string>;

        GetHeroDataByName(HeroName: string, OutHeroData: $Ref<Class>): void;

        GetLowPolySkeletalMeshByPath(SKMesh: string): SkeletalMesh;

        GetMaterialData(FashionID: number): TArray<MWClothMaterialData>;

        GetMaterialIndexDatas(Guid: string, SlotName: string): TMap<string, MWSysMaterialIndexData>;

        GetMaterialTextureparameter(Guid: string, skindex: number, materialindex: number, ParamerName: string): TArray<string>;

        GetMWClothAssetData(Guid: string): MWClothAssetData;

        GetMWMaterialstFromSKGuid(SKGuid: string): TArray<MaterialInstanceDynamic>;

        GetMWSKAssetData(Guid: string): MWSKAssetData;

        GetUClassByGuid(Guid: string): Class;

        GetUObjectByGuid(Guid: string): Object;

        Init(): void;

        LoadUObjectByGuid(Guid: string): void;

        static Instance(): MWCharacterAssetsManager;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWCharacterAssetsManager;

        static Load(InName: string): MWCharacterAssetsManager;
    }

    export enum EMWCharacterSocketType {
        Hair,
        Head,
        Left_Head,
        Right_Head,
        Glasses,
        Eyes,
        FaceOrnamental,
        Mouse,
        Left_Shoulder,
        Right_Shoulder,
        Left_Glove,
        Right_Glove,
        BackOrnamental,
        Left_Back,
        Right_Back,
        Left_Hand,
        Right_Hand,
        Left_Foot,
        Right_Foot,
        Buns,
        Rings,
        Nameplate,
        ChatFrame,
        Root,
        Left_Lowerarm,
        Right_Lowerarm,
        Left_Thigh,
        Right_Thigh,
        Left_Calf,
        Right_Calf,
        EMWCharacterSocketType_MAX
    }

    export class MWSysCharacter extends MWSysCharacterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimInstanceRef: MWSysAnimInstance_Character;
        _PropertyComponent: MWCharacterPropertyComponent;
        PhysicsBodyCapsuleComponent: MWSysPhysicsBodyComponent;
        _MovementComponent: TWeakObjectPtr<MWSysMovementComponent>;
        bEnableMove: boolean;
        bEnableJump: boolean;
        _BaseMoveRate: number;
        _BoostMoveRate: number;
        _BaseTurnRate: number;
        _BaseLookUpRate: number;
        ControlRotator: Rotator;
        Orientation: Rotator;
        OnCharacterBeginPlay: $MulticastDelegate<(InCharacter: $Nullable<MWSysCharacter>) => void>;
        OnCharacterDestroyed: $MulticastDelegate<(InCharacter: $Nullable<MWSysCharacter>) => void>;
        OnAnimationStarted: $MulticastDelegate<(MontageUniqueId: number) => void>;
        OnAnimationEnded: $MulticastDelegate<(MontageUniqueId: number, bInterrupted: boolean) => void>;
        BodyPartsObj: MWBodyParts;
        AnimInstanceManager: MWSysAnimInstance_Character;
        MovementDirection: EMovementDirection;
        MovementAxisDirection: Rotator;
        MovementAxisDirection1: Transform;
        CurrentHeroName: string;
        AssetsManagerSubsystem: MWCharacterAssetsManager;
        bUseAimOffset: boolean;
        bAlreadyInit: boolean;
        bEnableScriptUpdate: boolean;
        ScriptPropertyList: TArray<string>;
        Guid: Guid;
        UEScriptDelegate: $Delegate<(EventType: string, EventContent: string) => void>;
        UEScriptUpdateDelegate: $Delegate<(DeltaTime: number) => void>;

        AddMoveInput(InMoveValue: Vector): void;

        ClearStance(): void;

        GetCapsuleHalfHeight(): number;

        GetCapsuleRadius(): number;

        GetCapsuleRelativeLocation(): Vector;

        GetCapsuleRelativeScale(): Vector;

        GetControlRotator(): Rotator;

        GetCurrentAnimInstance(): AnimInstance;

        GetEnableAimOffset(): boolean;

        GetEnableJump(): boolean;

        GetEnableMove(): boolean;

        GetGuid(): string;

        GetMainMesh(): MWBodyPartComponent;

        GetMovementDirection(): EMovementDirection;

        GetSocket(Type: EMWCharacterSocketType): SkeletalMeshSocket;

        GetSocketName(Type: EMWCharacterSocketType): string;

        GetSocketPositionWithOffset(SocketName: string, InOffset: Vector, InRotation: Rotator): Vector;

        IsDead(): boolean;

        IsPlayingAnimation(): boolean;

        LookAt(TargetPoint: Vector): void;

        OnMontageEnd(Montage: $Nullable<AnimMontage>, bInterrupted: boolean): void;

        OnMontageStart(Montage: $Nullable<AnimMontage>): void;

        OnRep_OrientationsChanged(): void;

        OnRep_ScriptPropertyList(): void;

        PlayMWAnimation(Montage: $Nullable<AnimMontage>, InPlayLength: number): void;

        PlayMWSlotAnimation(Montage: $Nullable<AnimMontage>, InPlayLength: number, LoopCount: number): void;

        RegisterReplicationProperty(InValue: string): number;

        ResetBonesMap(): void;

        ScriptObjectReady(): void;

        Server_SetControlRotation(Rotator: Rotator): void;

        Server_SetMovementMode(NewMovementMode: EMovementMode): void;

        Server_SetOrientation(Rotator: Rotator): void;

        SetAnimStance(AnimInstanceClass: $Nullable<Class>): void;

        SetAnimStanceByPath(Path: string): void;

        SetBoneValueViaModifyType(BoneName: string, ModifyType: string, NewValue: number): void;

        SetCapsuleHalfHeight(NewHalfHeight: number, bUpdateOverlaps?: boolean /* = true */): void;

        SetCapsuleRadius(NewRadius: number, bUpdateOverlaps?: boolean /* = true */): void;

        SetCapsuleRelativeLocation(Location: Vector): void;

        SetCapsuleRelativeScale(Scale: Vector): void;

        SetCapsuleSize(NewRadius: number, NewHalfHeight: number, bUpdateOverlaps?: boolean /* = true */): void;

        SetControlRotation(NewRotator: Rotator): void;

        SetEnableAimOffset(InUseAimOffset: boolean): void;

        SetEnableJump(bCanJump: boolean): void;

        SetEnableMove(bCanMove: boolean): void;

        SetMeshEnableExternalUpdate(IsEnable: boolean): void;

        SetModifyBone(IsEnable: boolean): void;

        SetMovementDirection(InMovementDirection: EMovementDirection): void;

        SetMovementMode(NewMovementMode: EMovementMode): void;

        StopMWAnimation(Montage: $Nullable<AnimMontage>): void;

        TestChangeHeroByName(HeroName: string): void;

        TestClearStance(): void;

        TestPlayAnimation(AnimationId: number): void;

        TestSetAnimationStance(AnimationId: number, IsUseFullBody: boolean): void;

        TestUseAimOffset(IsUseAimOffset: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCharacter;

        static Load(InName: string): MWSysCharacter;
    }

    export class LevelStreamingDynamic extends LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bInitiallyLoaded: boolean;
        bInitiallyVisible: boolean;

        static LoadLevelInstance(WorldContextObject: $Nullable<Object>, LevelName: string, Location: Vector, Rotation: Rotator, bOutSuccess: $Ref<boolean>, OptionalLevelNameOverride?: string /* = "" */): LevelStreamingDynamic;

        static LoadLevelInstanceBySoftObjectPtr(WorldContextObject: $Nullable<Object>, Level: TSoftObjectPtr<World>, Location: Vector, Rotation: Rotator, bOutSuccess: $Ref<boolean>, OptionalLevelNameOverride?: string /* = "" */): LevelStreamingDynamic;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelStreamingDynamic;

        static Load(InName: string): LevelStreamingDynamic;
    }

    export enum EMWWorldStatus { Joining, Matching, Idle, Playing, Pause, Stop, EMWWorldStatus_MAX }

    export class MWUpdateDelegate {
        constructor();

        static StaticClass(): Class;
    }

    export class MWWorld extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCleaning: boolean;
        World: World;
        GameInstance: GameInstance;
        Status: EMWWorldStatus;
        PersistentLevel: MWLevel;
        Levels: TArray<MWLevel>;
        Behaviors: TArray<TWeakObjectPtr<MWActor>>;
        BehaviorTable: TMap<string, TWeakObjectPtr<MWActor>>;
        MaterialTable: TMap<string, MWMaterialInstanceDynamic>;
        TickEvent: $Delegate<(DeltaSeconds: number) => void>;
        WaitingPlayBehaviors: TArray<TWeakObjectPtr<MWActor>>;
        WaitingStartBehaviors: TArray<TWeakObjectPtr<MWActor>>;
        WaitingUpdateBehaviors: TArray<TWeakObjectPtr<MWActor>>;
        UpdateDelegates: TArray<MWUpdateDelegate>;
        OnStatusChange: $MulticastDelegate<(InStatus: EMWWorldStatus) => void>;
        OnBeginSave: $MulticastDelegate<() => void>;
        OnMatchStartEvent: $MulticastDelegate<() => void>;
        OnMatchEndEvent: $MulticastDelegate<(IsSuccess: boolean) => void>;

        Clear(): void;

        FindBehavior(InActorGuid: string): MWActor;

        GetStatus(): EMWWorldStatus;

        Pause(): void;

        Play(): void;

        Resume(): void;

        SetStatus(InStatus: EMWWorldStatus): void;

        SpawnActor(InAssetId: string): Actor;

        Stop(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWorld;

        static Load(InName: string): MWWorld;
    }

    export enum EMWLevelStatus { NoLoad, Loading, Loaded, UnLoaded, EMWLevelStatus_MAX }

    export enum EMWLevelFlags { All, CanSave, EMWLevelFlags_MAX }

    export class MWLevel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Actors: TArray<MWActor>;
        StreamLevel: LevelStreamingDynamic;
        Level: Level;
        LevelName: string;
        MWWorld: MWWorld;
        MaterialTable: TMap<string, MWMaterialInstanceDynamic>;
        Name: string;
        Status: EMWLevelStatus;
        Flags: EMWLevelFlags;
        ActorClusteringDistance: number;
        HLODMeshMaterial: MaterialInterface;
        HLODMeshMaterial_Unlit: MaterialInterface;

        GetMWWorld(): MWWorld;

        OnLevelLoaded(): void;

        OnLevelUnloaded(): void;

        RegisterActor(Actor: $Nullable<MWActor>, InAtIndex: number): number;

        RemoveActor(Actor: $Nullable<MWActor>): void;

        SetUpHLODActorGroups(InBehavior: $Nullable<MWActor>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWLevel;

        static Load(InName: string): MWLevel;
    }

    export enum ENetStatus { Server, Client, ServerAndClient, None, ENetStatus_MAX }

    export enum ELifecycleStatus { Spwan, Init, Play, End, ELifecycleStatus_MAX }

    export enum EPropertyStatus { FromParent, On, Off, EPropertyStatus_MAX }

    export enum EActorStatus { Default, PrefabDefault, PrefabInstance, EActorStatus_MAX }

    export class MWSysTypeScriptPropertyRangeInfo {
        constructor();
        constructor(Min: number, Max: number, bShowSlider: boolean);

        Min: number;
        Max: number;
        bShowSlider: boolean;

        static StaticClass(): Class;
    }

    export class MWSysTypeScriptPropertyInfo {
        constructor();
        constructor(Key: string, Value: string, Type: string, DisplayName: string, ToolTip: string, Group: string, bHideInEditor: boolean, bCapture: boolean, bReadonly: boolean, Asset: string, SelectOptions: string, RangeInfo: MWSysTypeScriptPropertyRangeInfo);

        Key: string;
        Value: string;
        Type: string;
        DisplayName: string;
        ToolTip: string;
        Group: string;
        bHideInEditor: boolean;
        bCapture: boolean;
        bReadonly: boolean;
        Asset: string;
        SelectOptions: string;
        RangeInfo: MWSysTypeScriptPropertyRangeInfo;

        static StaticClass(): Class;
    }

    export class MWActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Tran: Transform;
        Guid: string;
        MWName: string;
        SourceAsset: MWAssetRecorder;
        MWLevel: MWLevel;
        MWLevelName: string;
        ParentGuid: string;
        bStaticStatus: boolean;
        NetStatus: ENetStatus;
        LifecycleStatus: ELifecycleStatus;
        VisibleStatus: EPropertyStatus;
        CollisionStatus: EPropertyStatus;
        bIsVisible: boolean;
        bEnableCollision: boolean;
        LifeSpan: number;
        ActorStatus: EActorStatus;
        OnVisibleChangedDelegate: $Delegate<(bInEnable: boolean) => void>;
        OnCollisionChangedDelegate: $Delegate<(bInEnable: boolean) => void>;
        OnNetStatusEvent: $MulticastDelegate<(InNetStatus: ENetStatus) => void>;
        OnAttachToParentEvent: $MulticastDelegate<(Actor: $Nullable<Actor>) => void>;
        AttachedChildren: TArray<MWActor>;
        AtParentIndex: number;
        bEnableScriptUpdate: boolean;
        ScriptPropertyList: TArray<string>;
        UEScriptDelegate: $Delegate<(EventType: string, EventContent: string) => void>;
        UEScriptUpdateDelegate: $Delegate<(DeltaTime: number) => void>;

        CanAttach(InActor: $Nullable<MWActor>): boolean;

        DeleteScriptProperty(InPath: string): void;

        DestroyAttachedActors(): void;

        GetActorStatus(): EActorStatus;

        GetChildren(): TArray<MWActor>;

        GetCollisionStatus(): EPropertyStatus;

        GetEnableCollision(): boolean;

        GetGuid(): string;

        GetIsPrefabActor(): boolean;

        GetIsVisible(): boolean;

        GetMWLevel(): MWLevel;

        GetMWName(): string;

        GetNetStatus(): ENetStatus;

        GetNonFolderParent(): MWActor;

        GetParent(): MWActor;

        GetParentGuid(): string;

        GetScriptPropertyInfo(InKey: string): MWSysTypeScriptPropertyInfo;

        GetScriptPropertyPaths(): TArray<string>;

        GetScriptPropertyUnSerializeData(): string;

        GetSourceAssetGuid(): string;

        GetStaticStatus(): boolean;

        GetTag(): string;

        GetVisibleStatus(): EPropertyStatus;

        HasScriptProperty(InPath: string): boolean;

        OnRep_EnableCollision(): void;

        OnRep_Guid(): void;

        OnRep_ScriptPropertyList(): void;

        RedefineScriptProperty(InPropertyInfo: MWSysTypeScriptPropertyInfo): void;

        RefreshScriptProperty(): void;

        RefreshState(): void;

        RegisterReplicationProperty(InValue: string): number;

        RegisterScriptProperty(InPropertyInfo: MWSysTypeScriptPropertyInfo): void;

        ScriptObjectReady(): void;

        SetActorScale3D_Fixed2(NewScale3D: Vector): void;

        SetActorStatus(InPrefabGuid: string, InActorStatus: EActorStatus): void;

        SetActorTransform_Fixed2(NewTransform: Transform): boolean;

        SetCollisionStatus(InCollisionStatus: EPropertyStatus): void;

        SetMWName(NewName: string): void;

        SetNetStatus(InNetStatus: ENetStatus): boolean;

        SetParent(NewParent: $Nullable<MWActor>, InKeepWorld?: boolean /* = true */, InAtIndex?: number /* = -1 */, SocketName?: string /* = "None" */): boolean;

        SetScriptPropertyIsDefault(PropertyPath: string, bIsDefault: boolean): void;

        SetStaticStatus(bIsStatic: boolean): boolean;

        SetTag(InTag: string): void;

        SetVisibleStatus(InVisibleStatus: EPropertyStatus): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWActor;

        static Load(InName: string): MWActor;
    }

    export class MWSysActor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Type: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysActor;

        static Load(InName: string): MWSysActor;
    }

    export class MWSysCharacterActor extends MWSysActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Character: MWSysCharacter;
        OnCharacterInit: $MulticastDelegate<(InCharacter: $Nullable<MWSysCharacter>) => void>;
        ChildCharacter: ChildActorComponent;
        CapsuleComponent: CapsuleComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCharacterActor;

        static Load(InName: string): MWSysCharacterActor;
    }

    export enum EClothVersionType { None, SakuraSchool, Cartoon, EClothVersionType_MAX }

    export class MWSysEditableActor extends MWSysCharacterActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CharacterAsset: string;
        CharacterVersion: EClothVersionType;
        ClothJson: string;
        OnCharacterCreated: $Delegate<() => void>;
        bOnReadReady: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysEditableActor;

        static Load(InName: string): MWSysEditableActor;
    }

    export class MWSysEditableCharacter extends MWSysCharacter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AINavProxy: AIAsyncTaskBlueprintProxy;
        EditableActor: MWSysEditableActor;
        LocalVelocity: Vector;
        bReady: boolean;

        MakeReady(): void;

        OnRep_EditableActor(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysEditableCharacter;

        static Load(InName: string): MWSysEditableCharacter;
    }

    export class MWSysAICharacter extends MWSysEditableCharacter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AINacProxy: AIAsyncTaskBlueprintProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAICharacter;

        static Load(InName: string): MWSysAICharacter;
    }

    export class BP_AICharacter_C extends MWSysAICharacter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BP_AICharacter_C;

        static Load(InName: string): BP_AICharacter_C;
    }

    export class MWSysAnimInstance_MoveBase extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LastMoveState: EMWMoveState;

        InitMovementState(Character: $Nullable<MWSysCharacter>): void;

        PostMovementState(Character: $Nullable<MWSysCharacter>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAnimInstance_MoveBase;

        static Load(InName: string): MWSysAnimInstance_MoveBase;
    }

    export class MWSysAnimInstanceProxy_Fly extends MWSysAnimInstanceProxy_Character {
        constructor();
        constructor(_LocomotionMovingSpeed_UpDown: number);

        _LocomotionMovingSpeed_UpDown: number;

        static StaticClass(): Class;
    }

    export class MWSysAnimInstance_Fly extends MWSysAnimInstance_MoveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _Proxy: MWSysAnimInstanceProxy_Fly;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAnimInstance_Fly;

        static Load(InName: string): MWSysAnimInstance_Fly;
    }

    export class PointerToUberGraphFrame {
        constructor();

        static StaticClass(): Class;
    }

    export class BP_Anim_Fly_C extends MWSysAnimInstance_Fly {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UberGraphFrame: PointerToUberGraphFrame;
        AnimGraphNode_Root: AnimNode_Root;
        AnimGraphNode_TransitionResult: AnimNode_TransitionResult;
        AnimGraphNode_TwoWayBlend: AnimNode_TwoWayBlend;
        AnimGraphNode_BlendSpacePlayer_1: AnimNode_BlendSpacePlayer;
        AnimGraphNode_BlendSpacePlayer: AnimNode_BlendSpacePlayer;
        AnimGraphNode_StateResult_1: AnimNode_StateResult;
        AnimGraphNode_SequencePlayer: AnimNode_SequencePlayer;
        AnimGraphNode_StateResult: AnimNode_StateResult;
        AnimGraphNode_StateMachine: AnimNode_StateMachine;
        AnimGraphNode_SaveCachedPose: AnimNode_SaveCachedPose;
        AnimGraphNode_UseCachedPose: AnimNode_UseCachedPose;
        AnimGraphNode_RotationOffsetBlendSpace: AnimNode_RotationOffsetBlendSpace;
        ["Locomotion Moving Speed Up Down"]: number;
        ["Locomotion Moving Speed Horizontal"]: number;
        ["Locomotion Moving Speed Vertical"]: number;
        ["Locomotion Direction"]: number;
        ["Is Moving"]: boolean;
        IsDie: boolean;

        AnimGraph(AnimGraph: $Ref<PoseLink>): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Fly_AnimGraphNode_BlendSpacePlayer_A06E1AC248623B1BF91A829744ED475C(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Fly_AnimGraphNode_BlendSpacePlayer_F532A85740480687424052A13D525778(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Fly_AnimGraphNode_TransitionResult_43485FE841A863E035AE0694A5FA97A5(): void;

        ExecuteUbergraph_BP_Anim_Fly(EntryPoint: number): void;

        InitMovementState(Character: $Nullable<MWSysCharacter>): void;

        InitMovementStates(Character: $Nullable<MWSysCharacter>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BP_Anim_Fly_C;

        static Load(InName: string): BP_Anim_Fly_C;
    }

    export enum EMWAnim_JumpState { EJS_None, EJS_PreJump, EJS_JumpingUp, EJS_JumpingDown, EJS_MAX }

    export class MWSysAnimInstanceProxy_Ground extends MWSysAnimInstanceProxy_Character {
        constructor();
        constructor(_JumpState: EMWAnim_JumpState);

        _JumpState: EMWAnim_JumpState;

        static StaticClass(): Class;
    }

    export class MWSysAnimInstance_Ground extends MWSysAnimInstance_MoveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _Proxy: MWSysAnimInstanceProxy_Ground;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAnimInstance_Ground;

        static Load(InName: string): MWSysAnimInstance_Ground;
    }

    export class BP_Anim_Ground_C extends MWSysAnimInstance_Ground {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UberGraphFrame: PointerToUberGraphFrame;
        AnimGraphNode_Root: AnimNode_Root;
        AnimGraphNode_TransitionResult_10: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult_9: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult_8: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult_7: AnimNode_TransitionResult;
        AnimGraphNode_SequencePlayer_5: AnimNode_SequencePlayer;
        AnimGraphNode_StateResult_8: AnimNode_StateResult;
        AnimGraphNode_SequencePlayer_4: AnimNode_SequencePlayer;
        AnimGraphNode_StateResult_7: AnimNode_StateResult;
        AnimGraphNode_BlendSpacePlayer_1: AnimNode_BlendSpacePlayer;
        AnimGraphNode_StateResult_6: AnimNode_StateResult;
        AnimGraphNode_TransitionResult_6: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult_5: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult_4: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult_3: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult_2: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult_1: AnimNode_TransitionResult;
        AnimGraphNode_TransitionResult: AnimNode_TransitionResult;
        AnimGraphNode_SequencePlayer_3: AnimNode_SequencePlayer;
        AnimGraphNode_StateResult_5: AnimNode_StateResult;
        AnimGraphNode_SequencePlayer_2: AnimNode_SequencePlayer;
        AnimGraphNode_StateResult_4: AnimNode_StateResult;
        AnimGraphNode_SequencePlayer_1: AnimNode_SequencePlayer;
        AnimGraphNode_StateResult_3: AnimNode_StateResult;
        AnimGraphNode_SequencePlayer: AnimNode_SequencePlayer;
        AnimGraphNode_StateResult_2: AnimNode_StateResult;
        AnimGraphNode_StateMachine_1: AnimNode_StateMachine;
        AnimGraphNode_StateResult_1: AnimNode_StateResult;
        AnimGraphNode_BlendSpacePlayer: AnimNode_BlendSpacePlayer;
        AnimGraphNode_StateResult: AnimNode_StateResult;
        AnimGraphNode_StateMachine: AnimNode_StateMachine;
        AnimGraphNode_SaveCachedPose: AnimNode_SaveCachedPose;
        AnimGraphNode_UseCachedPose: AnimNode_UseCachedPose;
        MoveSpeedHorizontal: number;
        MoveSpeedVertical: number;
        IsFalling: boolean;
        InitiativeJump: boolean;
        JumpState: EMWAnim_JumpState;
        direction: number;
        ["Is Crouched"]: boolean;
        NewVar_0: boolean;

        AnimGraph(AnimGraph: $Ref<PoseLink>): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_BlendSpacePlayer_8360D3EA41D56AB5CBB675AF117CCA3F(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_BlendSpacePlayer_F678AF644DDBCC3D38E034A9CA193D25(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_045D9C0340EA580D6ECC4DB6C3F94A22(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_0EECFAE3491239E109B1A395DF1E7892(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_635F6C7D4508A53002D9EAAF929D618E(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_6BD80E4243F8B9BEC78DD18D81116BBC(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_6BEABBD64D4CB18CC0486182209BFEEC(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_8C8F4E7C4AB63E916169B98B33E94499(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_92078CD94520B08F858E6A97584B79B5(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_A8E104074A151DFD789A89924E5AAD4B(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_B577F0954E407415BB875F90997910C0(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_C80FEFDC4E232E734AF1718BF1EFD0B7(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Ground_AnimGraphNode_TransitionResult_D6F93DB24788C9D6435A0686F887E895(): void;

        ExecuteUbergraph_BP_Anim_Ground(EntryPoint: number): void;

        InitMovementState(Character: $Nullable<MWSysCharacter>): void;

        InitMovementStates(Character: $Nullable<MWSysCharacter>): void;

        PostMovementState(Character: $Nullable<MWSysCharacter>): void;

        PostMovementStates(Character: $Nullable<MWSysCharacter>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BP_Anim_Ground_C;

        static Load(InName: string): BP_Anim_Ground_C;
    }

    export class MWSysAnimInstanceProxy_Swim extends MWSysAnimInstanceProxy_Character {
        constructor();
        constructor(_LocomotionMovingSpeed_UpDown: number, bIsFullyImmersed: boolean);

        _LocomotionMovingSpeed_UpDown: number;
        bIsFullyImmersed: boolean;

        static StaticClass(): Class;
    }

    export class MWSysAnimInstance_Swim extends MWSysAnimInstance_MoveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _Proxy: MWSysAnimInstanceProxy_Swim;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAnimInstance_Swim;

        static Load(InName: string): MWSysAnimInstance_Swim;
    }

    export class BP_Anim_Swim_C extends MWSysAnimInstance_Swim {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UberGraphFrame: PointerToUberGraphFrame;
        AnimGraphNode_Root: AnimNode_Root;
        AnimGraphNode_TransitionResult: AnimNode_TransitionResult;
        AnimGraphNode_SequencePlayer: AnimNode_SequencePlayer;
        AnimGraphNode_StateResult_1: AnimNode_StateResult;
        AnimGraphNode_BlendSpacePlayer: AnimNode_BlendSpacePlayer;
        AnimGraphNode_StateResult: AnimNode_StateResult;
        AnimGraphNode_StateMachine: AnimNode_StateMachine;
        AnimGraphNode_SaveCachedPose: AnimNode_SaveCachedPose;
        AnimGraphNode_UseCachedPose: AnimNode_UseCachedPose;
        ["Locomotion Moving Speed Up Down"]: number;
        ["Locomotion Moving Speed Horizontal"]: number;
        ["Locomotion Moving Speed Vertical"]: number;
        ["Locomotion Direction"]: number;

        AnimGraph(AnimGraph: $Ref<PoseLink>): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Swim_AnimGraphNode_BlendSpacePlayer_8194E6834F8772EA4E60C69482A7C87C(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_BP_Anim_Swim_AnimGraphNode_TransitionResult_CA880E3C40942D3B1D41F68BC6A7BF36(): void;

        ExecuteUbergraph_BP_Anim_Swim(EntryPoint: number): void;

        InitMovementState(Character: $Nullable<MWSysCharacter>): void;

        InitMovementStates(Character: $Nullable<MWSysCharacter>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BP_Anim_Swim_C;

        static Load(InName: string): BP_Anim_Swim_C;
    }

    export class BP_EditableCharacter_C extends MWSysEditableCharacter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BP_EditableCharacter_C;

        static Load(InName: string): BP_EditableCharacter_C;
    }

    export class MWSysLowPolyActor extends MWSysEditableActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SKPath: string;
        SKPackageName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysLowPolyActor;

        static Load(InName: string): MWSysLowPolyActor;
    }

    export class BP_HumanoidObject_C extends MWSysLowPolyActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BP_HumanoidObject_C;

        static Load(InName: string): BP_HumanoidObject_C;
    }

    export class MWHumanoidActor extends MWSysEditableActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHumanoidActor;

        static Load(InName: string): MWHumanoidActor;
    }

    export class BP_HumanoidObject_V2_C extends MWHumanoidActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BP_HumanoidObject_V2_C;

        static Load(InName: string): BP_HumanoidObject_V2_C;
    }

    export class MaterialInstanceConstant extends MaterialInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterStateId: Guid;
        PhysMaterialMask: PhysicalMaterialMask;

        K2_GetScalarParameterValue(ParameterName: string): number;

        K2_GetTextureParameterValue(ParameterName: string): Texture;

        K2_GetVectorParameterValue(ParameterName: string): LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialInstanceConstant;

        static Load(InName: string): MaterialInstanceConstant;
    }

    export class BPF_MultiPass extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddOutlineEffect(bSuccess: $Ref<boolean>, OutOutlinePass: $Ref<number>, InMeshComponent?: MeshComponent /* = None */, OutlineColor?: LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */, OutlineWidth?: number /* = 2.000000 */, OutlineDepthOffset?: number /* = 0.000000 */, OutlineClampValue?: number /* = 0.930000 */, bConsiderCameraPosition?: boolean /* = false */, bOutlineSilhouetteOnly?: boolean /* = true */): void;

        static AddOutlineEffectLazy(bSuccess: $Ref<boolean>, OutOutlinePass: $Ref<number>, InMeshComponent?: MeshComponent /* = None */, OutlineColor?: LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */, OutlineWidth?: number /* = 2.000000 */, OutlineMaterialType?: EOutlineMaterialType /* = OMT_Common */): void;

        static AddOutlineEffectSuperLazy(bSuccess: $Ref<boolean>, OutOutlinePass: $Ref<number>, InMeshComponent?: MeshComponent /* = None */, OutlineMaterialType?: EOutlineMaterialType /* = OMT_Common */): void;

        static CheckMaterialUsage(MeshComponent: $Nullable<MeshComponent>, InMaterialInterface?: MaterialInterface /* = None */): MaterialInterface;

        static ContainsOutlinePass(InMeshComponent: $Nullable<MeshComponent>): boolean;

        static FillPassArrayMaterialNum(MeshComponent: $Nullable<MeshComponent>): void;

        static GetOutlineMaterialInstanceConstant(OutlineMaterialType?: EOutlineMaterialType /* = OMT_Common */): MaterialInstanceConstant;

        static GetOutlinePassIndex(InMeshComponent: $Nullable<MeshComponent>): number;

        static GetPassArrayNum(bSuccess: $Ref<boolean>, OutPassArrayNum: $Ref<number>, MeshComponent: $Nullable<MeshComponent>): void;

        static PassArrayAdd(MeshComponent: $Nullable<MeshComponent>, InPassMeshMaterialParam: MultiPassMeshMaterialParam): number;

        static PassArrayRemoveAll(MeshComponent: $Nullable<MeshComponent>): void;

        static PassArrayRemoveAt(MeshComponent: $Nullable<MeshComponent>, InPassIndex?: number /* = 0 */): boolean;

        static PassArraySetMaterialParam(MeshComponent: $Nullable<MeshComponent>, InPassMeshMaterialParam: MultiPassMeshMaterialParam, InPassIndex?: number /* = 0 */, MaterialIndex?: number /* = 0 */): boolean;

        static PassArraySetMaterialParams(MeshComponent: $Nullable<MeshComponent>, InPassMeshMaterialParamArray: TArray<MultiPassMeshMaterialParam>, InPassIndex?: number /* = 0 */): boolean;

        static PassArraySetSameMaterialParams(MeshComponent: $Nullable<MeshComponent>, InPassMeshMaterialParam: MultiPassMeshMaterialParam, InPassIndex?: number /* = 0 */): boolean;

        static RemoveOutlineEffect(bSuccess: $Ref<boolean>, InMeshComponent?: MeshComponent /* = None */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BPF_MultiPass;

        static Load(InName: string): BPF_MultiPass;
    }

    export class BrushBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetValue(): SlateBrush;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushBinding;

        static Load(InName: string): BrushBinding;
    }

    export class BrushEditingSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushEditingSubsystem;

        static Load(InName: string): BrushEditingSubsystem;
    }

    export class BrushEditingSubsystemImpl extends BrushEditingSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushEditingSubsystemImpl;

        static Load(InName: string): BrushEditingSubsystemImpl;
    }

    export class BrushShape extends Brush {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushShape;

        static Load(InName: string): BrushShape;
    }

    export class BrushStampIndicatorBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BrushStampIndicatorBuilder;

        static Load(InName: string): BrushStampIndicatorBuilder;
    }

    export class BTComposite_Selector extends BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTComposite_Selector;

        static Load(InName: string): BTComposite_Selector;
    }

    export class BTComposite_Sequence extends BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTComposite_Sequence;

        static Load(InName: string): BTComposite_Sequence;
    }

    export enum EBTParallelMode { AbortBackground, WaitForBackground, EBTParallelMode_MAX }

    export class BTComposite_SimpleParallel extends BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FinishMode: EBTParallelMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTComposite_SimpleParallel;

        static Load(InName: string): BTComposite_SimpleParallel;
    }

    export class BlackboardKeySelector {
        constructor();
        constructor(AllowedTypes: TArray<BlackboardKeyType>, SelectedKeyName: string, SelectedKeyType: Class, SelectedKeyID: number, bNoneIsAllowedValue: boolean);

        AllowedTypes: TArray<BlackboardKeyType>;
        SelectedKeyName: string;
        SelectedKeyType: Class;
        SelectedKeyID: number;
        bNoneIsAllowedValue: boolean;

        static StaticClass(): Class;
    }

    export class BTDecorator_BlackboardBase extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlackboardKey: BlackboardKeySelector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_BlackboardBase;

        static Load(InName: string): BTDecorator_BlackboardBase;
    }

    export enum EBTBlackboardRestart { ValueChange, ResultChange, EBTBlackboardRestart_MAX }

    export enum EBasicKeyOperation { Set, NotSet, EBasicKeyOperation_MAX }

    export enum EArithmeticKeyOperation {
        Equal,
        NotEqual,
        Less,
        LessOrEqual,
        Greater,
        GreaterOrEqual,
        EArithmeticKeyOperation_MAX
    }

    export enum ETextKeyOperation { Equal, NotEqual, Contain, NotContain, ETextKeyOperation_MAX }

    export class BTDecorator_Blackboard extends BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IntValue: number;
        FloatValue: number;
        StringValue: string;
        CachedDescription: string;
        OperationType: number;
        NotifyObserver: EBTBlackboardRestart;
        BasicOperation: EBasicKeyOperation;
        ArithmeticOperation: EArithmeticKeyOperation;
        TextOperation: ETextKeyOperation;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_Blackboard;

        static Load(InName: string): BTDecorator_Blackboard;
    }

    export enum EBTNodeResult { Succeeded, Failed, Aborted, InProgress, EBTNodeResult_MAX }

    export class BTDecorator_BlueprintBase extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AIOwner: AIController;
        ActorOwner: Actor;
        ObservedKeyNames: TArray<string>;
        CustomDescription: string;
        bShowPropertyDetails: boolean;
        bCheckConditionOnlyBlackBoardChanges: boolean;
        bIsObservingBB: boolean;

        IsDecoratorExecutionActive(): boolean;

        IsDecoratorObserverActive(): boolean;

        PerformConditionCheck(OwnerActor: $Nullable<Actor>): boolean;

        PerformConditionCheckAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): boolean;

        ReceiveExecutionFinish(OwnerActor: $Nullable<Actor>, NodeResult: EBTNodeResult): void;

        ReceiveExecutionFinishAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>, NodeResult: EBTNodeResult): void;

        ReceiveExecutionStart(OwnerActor: $Nullable<Actor>): void;

        ReceiveExecutionStartAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): void;

        ReceiveObserverActivated(OwnerActor: $Nullable<Actor>): void;

        ReceiveObserverActivatedAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): void;

        ReceiveObserverDeactivated(OwnerActor: $Nullable<Actor>): void;

        ReceiveObserverDeactivatedAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): void;

        ReceiveTick(OwnerActor: $Nullable<Actor>, DeltaSeconds: number): void;

        ReceiveTickAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>, DeltaSeconds: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_BlueprintBase;

        static Load(InName: string): BTDecorator_BlueprintBase;
    }

    export enum EGameplayContainerMatchType { Any, All, EGameplayContainerMatchType_MAX }

    export class BTDecorator_CheckGameplayTagsOnActor extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActorToCheck: BlackboardKeySelector;
        TagsToMatch: EGameplayContainerMatchType;
        GameplayTags: GameplayTagContainer;
        CachedDescription: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_CheckGameplayTagsOnActor;

        static Load(InName: string): BTDecorator_CheckGameplayTagsOnActor;
    }

    export enum EBlackBoardEntryComparison { Equal, NotEqual, EBlackBoardEntryComparison_MAX }

    export class BTDecorator_CompareBBEntries extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Operator: EBlackBoardEntryComparison;
        BlackboardKeyA: BlackboardKeySelector;
        BlackboardKeyB: BlackboardKeySelector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_CompareBBEntries;

        static Load(InName: string): BTDecorator_CompareBBEntries;
    }

    export class BTDecorator_ConditionalLoop extends BTDecorator_Blackboard {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_ConditionalLoop;

        static Load(InName: string): BTDecorator_ConditionalLoop;
    }

    export class BTDecorator_ConeCheck extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConeHalfAngle: number;
        ConeOrigin: BlackboardKeySelector;
        ConeDirection: BlackboardKeySelector;
        Observed: BlackboardKeySelector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_ConeCheck;

        static Load(InName: string): BTDecorator_ConeCheck;
    }

    export class BTDecorator_Cooldown extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CoolDownTime: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_Cooldown;

        static Load(InName: string): BTDecorator_Cooldown;
    }

    export enum EPathExistanceQueryType {
        NavmeshRaycast2D,
        HierarchicalQuery,
        RegularPathFinding,
        EPathExistanceQueryType_MAX
    }

    export class BTDecorator_DoesPathExist extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlackboardKeyA: BlackboardKeySelector;
        BlackboardKeyB: BlackboardKeySelector;
        bUseSelf: boolean;
        PathQueryType: EPathExistanceQueryType;
        FilterClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_DoesPathExist;

        static Load(InName: string): BTDecorator_DoesPathExist;
    }

    export class BTDecorator_ForceSuccess extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_ForceSuccess;

        static Load(InName: string): BTDecorator_ForceSuccess;
    }

    export enum FAIDistanceType { Distance3D, Distance2D, DistanceZ, MAX }

    export class BTDecorator_IsAtLocation extends BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AcceptableRadius: number;
        ParametrizedAcceptableRadius: AIDataProviderFloatValue;
        GeometricDistanceType: FAIDistanceType;
        bUseParametrizedRadius: boolean;
        bUseNavAgentGoalLocation: boolean;
        bPathFindingBasedTest: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_IsAtLocation;

        static Load(InName: string): BTDecorator_IsAtLocation;
    }

    export class BTDecorator_IsBBEntryOfClass extends BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_IsBBEntryOfClass;

        static Load(InName: string): BTDecorator_IsBBEntryOfClass;
    }

    export class BTDecorator_KeepInCone extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConeHalfAngle: number;
        ConeOrigin: BlackboardKeySelector;
        Observed: BlackboardKeySelector;
        bUseSelfAsOrigin: boolean;
        bUseSelfAsObserved: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_KeepInCone;

        static Load(InName: string): BTDecorator_KeepInCone;
    }

    export class BTDecorator_Loop extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumLoops: number;
        bInfiniteLoop: boolean;
        InfiniteLoopTimeoutTime: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_Loop;

        static Load(InName: string): BTDecorator_Loop;
    }

    export class BTDecorator_ReachedMoveGoal extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_ReachedMoveGoal;

        static Load(InName: string): BTDecorator_ReachedMoveGoal;
    }

    export class BTDecorator_SetTagCooldown extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CooldownTag: GameplayTag;
        CooldownDuration: number;
        bAddToExistingDuration: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_SetTagCooldown;

        static Load(InName: string): BTDecorator_SetTagCooldown;
    }

    export class BTDecorator_TagCooldown extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CooldownTag: GameplayTag;
        CooldownDuration: number;
        bAddToExistingDuration: boolean;
        bActivatesCooldown: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_TagCooldown;

        static Load(InName: string): BTDecorator_TagCooldown;
    }

    export class BTDecorator_TimeLimit extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TimeLimit: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTDecorator_TimeLimit;

        static Load(InName: string): BTDecorator_TimeLimit;
    }

    export class BTFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ClearBlackboardValue(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): void;

        static ClearBlackboardValueAsVector(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): void;

        static GetBlackboardValueAsActor(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): Actor;

        static GetBlackboardValueAsBool(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): boolean;

        static GetBlackboardValueAsClass(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): Class;

        static GetBlackboardValueAsEnum(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): number;

        static GetBlackboardValueAsFloat(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): number;

        static GetBlackboardValueAsInt(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): number;

        static GetBlackboardValueAsName(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): string;

        static GetBlackboardValueAsObject(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): Object;

        static GetBlackboardValueAsRotator(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): Rotator;

        static GetBlackboardValueAsString(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): string;

        static GetBlackboardValueAsVector(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector): Vector;

        static GetOwnerComponent(NodeOwner: $Nullable<BTNode>): BehaviorTreeComponent;

        static GetOwnersBlackboard(NodeOwner: $Nullable<BTNode>): BlackboardComponent;

        static SetBlackboardValueAsBool(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: boolean): void;

        static SetBlackboardValueAsClass(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: $Nullable<Class>): void;

        static SetBlackboardValueAsEnum(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: number): void;

        static SetBlackboardValueAsFloat(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: number): void;

        static SetBlackboardValueAsInt(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: number): void;

        static SetBlackboardValueAsName(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: string): void;

        static SetBlackboardValueAsObject(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: $Nullable<Object>): void;

        static SetBlackboardValueAsRotator(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: Rotator): void;

        static SetBlackboardValueAsString(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: string): void;

        static SetBlackboardValueAsVector(NodeOwner: $Nullable<BTNode>, Key: BlackboardKeySelector, Value: Vector): void;

        static StartUsingExternalEvent(NodeOwner: $Nullable<BTNode>, OwningActor: $Nullable<Actor>): void;

        static StopUsingExternalEvent(NodeOwner: $Nullable<BTNode>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTFunctionLibrary;

        static Load(InName: string): BTFunctionLibrary;
    }

    export class BTService_BlackboardBase extends BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlackboardKey: BlackboardKeySelector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTService_BlackboardBase;

        static Load(InName: string): BTService_BlackboardBase;
    }

    export class BTService_BlueprintBase extends BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AIOwner: AIController;
        ActorOwner: Actor;
        CustomDescription: string;
        bShowPropertyDetails: boolean;
        bShowEventDetails: boolean;

        IsServiceActive(): boolean;

        ReceiveActivation(OwnerActor: $Nullable<Actor>): void;

        ReceiveActivationAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): void;

        ReceiveDeactivation(OwnerActor: $Nullable<Actor>): void;

        ReceiveDeactivationAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): void;

        ReceiveSearchStart(OwnerActor: $Nullable<Actor>): void;

        ReceiveSearchStartAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): void;

        ReceiveTick(OwnerActor: $Nullable<Actor>, DeltaSeconds: number): void;

        ReceiveTickAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>, DeltaSeconds: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTService_BlueprintBase;

        static Load(InName: string): BTService_BlueprintBase;
    }

    export class BTService_DefaultFocus extends BTService_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FocusPriority: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTService_DefaultFocus;

        static Load(InName: string): BTService_DefaultFocus;
    }

    export enum EAIParamType { Float, Int, Bool, MAX }

    export class AIDynamicParam {
        constructor();
        constructor(ParamName: string, ParamType: EAIParamType, Value: number, BBKey: BlackboardKeySelector);

        ParamName: string;
        ParamType: EAIParamType;
        Value: number;
        BBKey: BlackboardKeySelector;

        static StaticClass(): Class;
    }

    export class EQSParametrizedQueryExecutionRequest {
        constructor();
        constructor(QueryTemplate: EnvQuery, QueryConfig: TArray<AIDynamicParam>, EQSQueryBlackboardKey: BlackboardKeySelector, RunMode: EEnvQueryRunMode, bUseBBKeyForQueryTemplate: boolean);

        QueryTemplate: EnvQuery;
        QueryConfig: TArray<AIDynamicParam>;
        EQSQueryBlackboardKey: BlackboardKeySelector;
        RunMode: EEnvQueryRunMode;
        bUseBBKeyForQueryTemplate: boolean;

        static StaticClass(): Class;
    }

    export class BTService_RunEQS extends BTService_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EQSRequest: EQSParametrizedQueryExecutionRequest;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTService_RunEQS;

        static Load(InName: string): BTService_RunEQS;
    }

    export class BTTask_BlackboardBase extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlackboardKey: BlackboardKeySelector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_BlackboardBase;

        static Load(InName: string): BTTask_BlackboardBase;
    }

    export class IntervalCountdown {
        constructor();
        constructor(Interval: number);

        Interval: number;

        static StaticClass(): Class;
    }

    export class BTTask_BlueprintBase extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AIOwner: AIController;
        ActorOwner: Actor;
        TickInterval: IntervalCountdown;
        CustomDescription: string;
        bShowPropertyDetails: boolean;

        FinishAbort(): void;

        FinishExecute(bSuccess: boolean): void;

        IsTaskAborting(): boolean;

        IsTaskExecuting(): boolean;

        ReceiveAbort(OwnerActor: $Nullable<Actor>): void;

        ReceiveAbortAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): void;

        ReceiveExecute(OwnerActor: $Nullable<Actor>): void;

        ReceiveExecuteAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>): void;

        ReceiveTick(OwnerActor: $Nullable<Actor>, DeltaSeconds: number): void;

        ReceiveTickAI(OwnerController: $Nullable<AIController>, ControlledPawn: $Nullable<Pawn>, DeltaSeconds: number): void;

        SetFinishOnMessage(MessageName: string): void;

        SetFinishOnMessageWithId(MessageName: string, RequestID?: number /* = -1 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_BlueprintBase;

        static Load(InName: string): BTTask_BlueprintBase;
    }

    export class BTTask_FinishWithResult extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Result: EBTNodeResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_FinishWithResult;

        static Load(InName: string): BTTask_FinishWithResult;
    }

    export class BTTask_GameplayTaskBase extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bWaitForGameplayTask: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_GameplayTaskBase;

        static Load(InName: string): BTTask_GameplayTaskBase;
    }

    export class BTTask_MakeNoise extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Loudnes: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_MakeNoise;

        static Load(InName: string): BTTask_MakeNoise;
    }

    export class BTTask_MoveTo extends BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AcceptableRadius: number;
        FilterClass: Class;
        ObservedBlackboardValueTolerance: number;
        bObserveBlackboardValue: boolean;
        bAllowStrafe: boolean;
        bAllowPartialPath: boolean;
        bTrackMovingGoal: boolean;
        bProjectGoalLocation: boolean;
        bReachTestIncludesAgentRadius: boolean;
        bReachTestIncludesGoalRadius: boolean;
        bStopOnOverlap: boolean;
        bStopOnOverlapNeedsUpdate: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_MoveTo;

        static Load(InName: string): BTTask_MoveTo;
    }

    export class BTTask_MoveDirectlyToward extends BTTask_MoveTo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDisablePathUpdateOnGoalLocationChange: boolean;
        bProjectVectorGoalToNavigation: boolean;
        bUpdatedDeprecatedProperties: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_MoveDirectlyToward;

        static Load(InName: string): BTTask_MoveDirectlyToward;
    }

    export class BTTask_PawnActionBase extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_PawnActionBase;

        static Load(InName: string): BTTask_PawnActionBase;
    }

    export class BTTask_PlayAnimation extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimationToPlay: AnimationAsset;
        bLooping: boolean;
        bNonBlocking: boolean;
        MyOwnerComp: BehaviorTreeComponent;
        CachedSkelMesh: SkeletalMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_PlayAnimation;

        static Load(InName: string): BTTask_PlayAnimation;
    }

    export class BTTask_PlaySound extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundToPlay: SoundCue;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_PlaySound;

        static Load(InName: string): BTTask_PlaySound;
    }

    export class BTTask_PushPawnAction extends BTTask_PawnActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Action: PawnAction;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_PushPawnAction;

        static Load(InName: string): BTTask_PushPawnAction;
    }

    export class BTTask_RotateToFaceBBEntry extends BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Precision: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_RotateToFaceBBEntry;

        static Load(InName: string): BTTask_RotateToFaceBBEntry;
    }

    export class BTTask_RunBehavior extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BehaviorAsset: BehaviorTree;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_RunBehavior;

        static Load(InName: string): BTTask_RunBehavior;
    }

    export class BTTask_RunBehaviorDynamic extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InjectionTag: GameplayTag;
        DefaultBehaviorAsset: BehaviorTree;
        BehaviorAsset: BehaviorTree;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_RunBehaviorDynamic;

        static Load(InName: string): BTTask_RunBehaviorDynamic;
    }

    export class EnvNamedValue {
        constructor();
        constructor(ParamName: string, ParamType: EAIParamType, Value: number);

        ParamName: string;
        ParamType: EAIParamType;
        Value: number;

        static StaticClass(): Class;
    }

    export class BTTask_RunEQSQuery extends BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QueryTemplate: EnvQuery;
        QueryParams: TArray<EnvNamedValue>;
        QueryConfig: TArray<AIDynamicParam>;
        RunMode: EEnvQueryRunMode;
        EQSQueryBlackboardKey: BlackboardKeySelector;
        bUseBBKey: boolean;
        EQSRequest: EQSParametrizedQueryExecutionRequest;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_RunEQSQuery;

        static Load(InName: string): BTTask_RunEQSQuery;
    }

    export class BTTask_SetTagCooldown extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CooldownTag: GameplayTag;
        bAddToExistingDuration: boolean;
        CooldownDuration: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_SetTagCooldown;

        static Load(InName: string): BTTask_SetTagCooldown;
    }

    export class BTTask_Wait extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WaitTime: number;
        RandomDeviation: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_Wait;

        static Load(InName: string): BTTask_Wait;
    }

    export class BTTask_WaitBlackboardTime extends BTTask_Wait {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlackboardKey: BlackboardKeySelector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BTTask_WaitBlackboardTime;

        static Load(InName: string): BTTask_WaitBlackboardTime;
    }

    export class SHAHashData {
        constructor();
        constructor(Hash: FixSizeArray<number>);

        Hash: FixSizeArray<number>;

        static StaticClass(): Class;
    }

    export class ChunkPartData {
        constructor();
        constructor(Guid: Guid, Offset: number, Size: number);

        Guid: Guid;
        Offset: number;
        Size: number;

        static StaticClass(): Class;
    }

    export class FileManifestData {
        constructor();
        constructor(Filename: string, FileHash: SHAHashData, FileChunkParts: TArray<ChunkPartData>, InstallTags: TArray<string>, bIsUnixExecutable: boolean, SymlinkTarget: string, bIsReadOnly: boolean, bIsCompressed: boolean);

        Filename: string;
        FileHash: SHAHashData;
        FileChunkParts: TArray<ChunkPartData>;
        InstallTags: TArray<string>;
        bIsUnixExecutable: boolean;
        SymlinkTarget: string;
        bIsReadOnly: boolean;
        bIsCompressed: boolean;

        static StaticClass(): Class;
    }

    export class ChunkInfoData {
        constructor();
        constructor(Guid: Guid, Hash: bigint, ShaHash: SHAHashData, FileSize: bigint, GroupNumber: number);

        Guid: Guid;
        Hash: bigint;
        ShaHash: SHAHashData;
        FileSize: bigint;
        GroupNumber: number;

        static StaticClass(): Class;
    }

    export class CustomFieldData {
        constructor();
        constructor(Key: string, Value: string);

        Key: string;
        Value: string;

        static StaticClass(): Class;
    }

    export class BuildPatchManifest extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ManifestFileVersion: number;
        bIsFileData: boolean;
        AppID: number;
        AppName: string;
        BuildVersion: string;
        LaunchExe: string;
        LaunchCommand: string;
        PrereqIds: TSet<string>;
        PrereqName: string;
        PrereqPath: string;
        PrereqArgs: string;
        FileManifestList: TArray<FileManifestData>;
        ChunkList: TArray<ChunkInfoData>;
        CustomFields: TArray<CustomFieldData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): BuildPatchManifest;

        static Load(InName: string): BuildPatchManifest;
    }

    export class SlateWidgetStyleContainerBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleContainerBase;

        static Load(InName: string): SlateWidgetStyleContainerBase;
    }

    export class SlateWidgetStyleAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CustomStyle: SlateWidgetStyleContainerBase;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleAsset;

        static Load(InName: string): SlateWidgetStyleAsset;
    }

    export class SlateWidgetStyle {
        constructor();

        static StaticClass(): Class;
    }

    export class SlateSound {
        constructor();
        constructor(ResourceObject: Object);

        ResourceObject: Object;

        static StaticClass(): Class;
    }

    export class ButtonStyle extends SlateWidgetStyle {
        constructor();
        constructor(Normal: SlateBrush, Hovered: SlateBrush, Pressed: SlateBrush, Disabled: SlateBrush, NormalPadding: Margin, PressedPadding: Margin, PressedSlateSound: SlateSound, HoveredSlateSound: SlateSound, PressedSound: string, HoveredSound: string);

        Normal: SlateBrush;
        Hovered: SlateBrush;
        Pressed: SlateBrush;
        Disabled: SlateBrush;
        NormalPadding: Margin;
        PressedPadding: Margin;
        PressedSlateSound: SlateSound;
        HoveredSlateSound: SlateSound;
        PressedSound: string;
        HoveredSound: string;

        static StaticClass(): Class;
    }

    export enum EButtonClickMethod { DownAndUp, MouseDown, MouseUp, PreciseClick, EButtonClickMethod_MAX }

    export enum EButtonTouchMethod { DownAndUp, Down, PreciseTap, EButtonTouchMethod_MAX }

    export enum EButtonPressMethod { DownAndUp, ButtonPress, ButtonRelease, EButtonPressMethod_MAX }

    export class Button extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Style: SlateWidgetStyleAsset;
        WidgetStyle: ButtonStyle;
        ColorAndOpacity: LinearColor;
        BackgroundColor: LinearColor;
        ClickMethod: EButtonClickMethod;
        TouchMethod: EButtonTouchMethod;
        PressMethod: EButtonPressMethod;
        IsFocusable: boolean;
        OnClicked: $MulticastDelegate<() => void>;
        OnPressed: $MulticastDelegate<() => void>;
        OnReleased: $MulticastDelegate<() => void>;
        OnHovered: $MulticastDelegate<() => void>;
        OnUnhovered: $MulticastDelegate<() => void>;

        IsPressed(): boolean;

        SetBackgroundColor(InBackgroundColor: LinearColor): void;

        SetClickMethod(InClickMethod: EButtonClickMethod): void;

        SetColorAndOpacity(InColorAndOpacity: LinearColor): void;

        SetPressMethod(InPressMethod: EButtonPressMethod): void;

        SetStyle(InStyle: ButtonStyle): void;

        SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Button;

        static Load(InName: string): Button;
    }

    export class ButtonSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ButtonSlot;

        static Load(InName: string): ButtonSlot;
    }

    export class ButtonStyleAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ButtonStyle: ButtonStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ButtonStyleAsset;

        static Load(InName: string): ButtonStyleAsset;
    }

    export class ButtonWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ButtonStyle: ButtonStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ButtonWidgetStyle;

        static Load(InName: string): ButtonWidgetStyle;
    }

    export class NumericProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NumericProperty;

        static Load(InName: string): NumericProperty;
    }

    export class ByteProperty extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ByteProperty;

        static Load(InName: string): ByteProperty;
    }

    export class CameraAnimFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraAnimFactory;

        static Load(InName: string): CameraAnimFactory;
    }

    export class CameraBlockingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraBlockingVolume;

        static Load(InName: string): CameraBlockingVolume;
    }

    export class MWEdToolBarSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdToolBarSettingsBase;

        static Load(InName: string): MWEdToolBarSettingsBase;
    }

    export class CameraMoveEditorSettings extends MWEdToolBarSettingsBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NormalSpeed: number;
        AccelerateSpeed: number;
        SlowdownSpeed: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraMoveEditorSettings;

        static Load(InName: string): CameraMoveEditorSettings;
    }

    export class CameraRig_Crane extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CranePitch: number;
        CraneYaw: number;
        CraneArmLength: number;
        bLockMountPitch: boolean;
        bLockMountYaw: boolean;
        TransformComponent: SceneComponent;
        CraneYawControl: SceneComponent;
        CranePitchControl: SceneComponent;
        CraneCameraMount: SceneComponent;
        PreviewMesh_CraneArm: StaticMeshComponent;
        PreviewMesh_CraneBase: StaticMeshComponent;
        PreviewMesh_CraneMount: StaticMeshComponent;
        PreviewMesh_CraneCounterWeight: StaticMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraRig_Crane;

        static Load(InName: string): CameraRig_Crane;
    }

    export class InterpCurvePointQuat {
        constructor();
        constructor(InVal: number, OutVal: Quat, ArriveTangent: Quat, LeaveTangent: Quat, InterpMode: EInterpCurveMode);

        InVal: number;
        OutVal: Quat;
        ArriveTangent: Quat;
        LeaveTangent: Quat;
        InterpMode: EInterpCurveMode;

        static StaticClass(): Class;
    }

    export class InterpCurveQuat {
        constructor();
        constructor(Points: TArray<InterpCurvePointQuat>, bIsLooped: boolean, LoopKeyOffset: number);

        Points: TArray<InterpCurvePointQuat>;
        bIsLooped: boolean;
        LoopKeyOffset: number;

        static StaticClass(): Class;
    }

    export class InterpCurvePointFloat {
        constructor();
        constructor(InVal: number, OutVal: number, ArriveTangent: number, LeaveTangent: number, InterpMode: EInterpCurveMode);

        InVal: number;
        OutVal: number;
        ArriveTangent: number;
        LeaveTangent: number;
        InterpMode: EInterpCurveMode;

        static StaticClass(): Class;
    }

    export class InterpCurveFloat {
        constructor();
        constructor(Points: TArray<InterpCurvePointFloat>, bIsLooped: boolean, LoopKeyOffset: number);

        Points: TArray<InterpCurvePointFloat>;
        bIsLooped: boolean;
        LoopKeyOffset: number;

        static StaticClass(): Class;
    }

    export class SplineMetadata extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SplineMetadata;

        static Load(InName: string): SplineMetadata;
    }

    export class SplineCurves {
        constructor();
        constructor(Position: InterpCurveVector, Rotation: InterpCurveQuat, Scale: InterpCurveVector, ReparamTable: InterpCurveFloat, Metadata: SplineMetadata, Version: number);

        Position: InterpCurveVector;
        Rotation: InterpCurveQuat;
        Scale: InterpCurveVector;
        ReparamTable: InterpCurveFloat;
        Metadata: SplineMetadata;
        Version: number;

        static StaticClass(): Class;
    }

    export enum ESplineCoordinateSpace { Local, World, ESplineCoordinateSpace_MAX }

    export enum ESplinePointType { Linear, Curve, Constant, CurveClamped, CurveCustomTangent, ESplinePointType_MAX }

    export class SplinePoint {
        constructor();
        constructor(InputKey: number, Position: Vector, ArriveTangent: Vector, LeaveTangent: Vector, Rotation: Rotator, Scale: Vector, Type: ESplinePointType);

        InputKey: number;
        Position: Vector;
        ArriveTangent: Vector;
        LeaveTangent: Vector;
        Rotation: Rotator;
        Scale: Vector;
        Type: ESplinePointType;

        static StaticClass(): Class;
    }

    export class SplineComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SplineCurves: SplineCurves;
        SplineInfo: InterpCurveVector;
        SplineRotInfo: InterpCurveQuat;
        SplineScaleInfo: InterpCurveVector;
        SplineReparamTable: InterpCurveFloat;
        bAllowSplineEditingPerInstance: boolean;
        ReparamStepsPerSegment: number;
        Duration: number;
        bStationaryEndpoints: boolean;
        bSplineHasBeenEdited: boolean;
        bModifiedByConstructionScript: boolean;
        bInputSplinePointsToConstructionScript: boolean;
        bDrawDebug: boolean;
        bClosedLoop: boolean;
        bLoopPositionOverride: boolean;
        LoopPosition: number;
        DefaultUpVector: Vector;
        EditorUnselectedSplineSegmentColor: LinearColor;
        EditorSelectedSplineSegmentColor: LinearColor;
        EditorTangentColor: LinearColor;
        bAllowDiscontinuousSpline: boolean;
        bShouldVisualizeScale: boolean;
        ScaleVisualizationWidth: number;

        AddPoint(Point: SplinePoint, bUpdateSpline?: boolean /* = true */): void;

        AddPoints(Points: TArray<SplinePoint>, bUpdateSpline?: boolean /* = true */): void;

        AddSplineLocalPoint(Position: Vector): void;

        AddSplinePoint(Position: Vector, CoordinateSpace: ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */): void;

        AddSplinePointAtIndex(Position: Vector, Index: number, CoordinateSpace: ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */): void;

        AddSplineWorldPoint(Position: Vector): void;

        ClearSplinePoints(bUpdateSpline?: boolean /* = true */): void;

        FindDirectionClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: ESplineCoordinateSpace): Vector;

        FindInputKeyClosestToWorldLocation(WorldLocation: Vector): number;

        FindLocationClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: ESplineCoordinateSpace): Vector;

        FindRightVectorClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: ESplineCoordinateSpace): Vector;

        FindRollClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: ESplineCoordinateSpace): number;

        FindRotationClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: ESplineCoordinateSpace): Rotator;

        FindScaleClosestToWorldLocation(WorldLocation: Vector): Vector;

        FindTangentClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: ESplineCoordinateSpace): Vector;

        FindTransformClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: ESplineCoordinateSpace, bUseScale?: boolean /* = false */): Transform;

        FindUpVectorClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetArriveTangentAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetDefaultUpVector(CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetDirectionAtDistanceAlongSpline(Distance: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetDirectionAtSplineInputKey(InKey: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetDirectionAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetDirectionAtTime(Time: number, CoordinateSpace: ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */): Vector;

        GetDistanceAlongSplineAtSplineInputKey(InKey: number): number;

        GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;

        GetFloatPropertyAtSplineInputKey(InKey: number, PropertyName: string): number;

        GetFloatPropertyAtSplinePoint(Index: number, PropertyName: string): number;

        GetInputKeyAtDistanceAlongSpline(Distance: number): number;

        GetLeaveTangentAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetLocalLocationAndTangentAtSplinePoint(PointIndex: number, LocalLocation: $Ref<Vector>, LocalTangent: $Ref<Vector>): void;

        GetLocationAndTangentAtSplinePoint(PointIndex: number, Location: $Ref<Vector>, Tangent: $Ref<Vector>, CoordinateSpace: ESplineCoordinateSpace): void;

        GetLocationAtDistanceAlongSpline(Distance: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetLocationAtSplineInputKey(InKey: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetLocationAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetLocationAtTime(Time: number, CoordinateSpace: ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */): Vector;

        GetNumberOfSplinePoints(): number;

        GetNumberOfSplineSegments(): number;

        GetRightVectorAtDistanceAlongSpline(Distance: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetRightVectorAtSplineInputKey(InKey: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetRightVectorAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetRightVectorAtTime(Time: number, CoordinateSpace: ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */): Vector;

        GetRollAtDistanceAlongSpline(Distance: number, CoordinateSpace: ESplineCoordinateSpace): number;

        GetRollAtSplineInputKey(InKey: number, CoordinateSpace: ESplineCoordinateSpace): number;

        GetRollAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): number;

        GetRollAtTime(Time: number, CoordinateSpace: ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */): number;

        GetRotationAtDistanceAlongSpline(Distance: number, CoordinateSpace: ESplineCoordinateSpace): Rotator;

        GetRotationAtSplineInputKey(InKey: number, CoordinateSpace: ESplineCoordinateSpace): Rotator;

        GetRotationAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): Rotator;

        GetRotationAtTime(Time: number, CoordinateSpace: ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */): Rotator;

        GetScaleAtDistanceAlongSpline(Distance: number): Vector;

        GetScaleAtSplineInputKey(InKey: number): Vector;

        GetScaleAtSplinePoint(PointIndex: number): Vector;

        GetScaleAtTime(Time: number, bUseConstantVelocity?: boolean /* = false */): Vector;

        GetSplineLength(): number;

        GetSplinePointType(PointIndex: number): ESplinePointType;

        GetTangentAtDistanceAlongSpline(Distance: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetTangentAtSplineInputKey(InKey: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetTangentAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetTangentAtTime(Time: number, CoordinateSpace: ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */): Vector;

        GetTransformAtDistanceAlongSpline(Distance: number, CoordinateSpace: ESplineCoordinateSpace, bUseScale?: boolean /* = false */): Transform;

        GetTransformAtSplineInputKey(InKey: number, CoordinateSpace: ESplineCoordinateSpace, bUseScale?: boolean /* = false */): Transform;

        GetTransformAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace, bUseScale?: boolean /* = false */): Transform;

        GetTransformAtTime(Time: number, CoordinateSpace: ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */, bUseScale?: boolean /* = false */): Transform;

        GetUpVectorAtDistanceAlongSpline(Distance: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetUpVectorAtSplineInputKey(InKey: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetUpVectorAtSplinePoint(PointIndex: number, CoordinateSpace: ESplineCoordinateSpace): Vector;

        GetUpVectorAtTime(Time: number, CoordinateSpace: ESplineCoordinateSpace, bUseConstantVelocity?: boolean /* = false */): Vector;

        GetVectorPropertyAtSplineInputKey(InKey: number, PropertyName: string): Vector;

        GetVectorPropertyAtSplinePoint(Index: number, PropertyName: string): Vector;

        GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;

        GetWorldDirectionAtTime(Time: number, bUseConstantVelocity?: boolean /* = false */): Vector;

        GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;

        GetWorldLocationAtSplinePoint(PointIndex: number): Vector;

        GetWorldLocationAtTime(Time: number, bUseConstantVelocity?: boolean /* = false */): Vector;

        GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;

        GetWorldRotationAtTime(Time: number, bUseConstantVelocity?: boolean /* = false */): Rotator;

        GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;

        IsClosedLoop(): boolean;

        RemoveSplinePoint(Index: number, bUpdateSpline?: boolean /* = true */): void;

        SetClosedLoop(bInClosedLoop: boolean, bUpdateSpline?: boolean /* = true */): void;

        SetClosedLoopAtPosition(bInClosedLoop: boolean, Key: number, bUpdateSpline?: boolean /* = true */): void;

        SetDefaultUpVector(UpVector: Vector, CoordinateSpace: ESplineCoordinateSpace): void;

        SetDrawDebug(bShow: boolean): void;

        SetLocationAtSplinePoint(PointIndex: number, InLocation: Vector, CoordinateSpace: ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */): void;

        SetRotationAtSplinePoint(PointIndex: number, InRotation: Rotator, CoordinateSpace: ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */): void;

        SetScaleAtSplinePoint(PointIndex: number, InScaleVector: Vector, bUpdateSpline?: boolean /* = true */): void;

        SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;

        SetSplineLocalPoints(Points: TArray<Vector>): void;

        SetSplinePoints(Points: TArray<Vector>, CoordinateSpace: ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */): void;

        SetSplinePointType(PointIndex: number, Type: ESplinePointType, bUpdateSpline?: boolean /* = true */): void;

        SetSplineWorldPoints(Points: TArray<Vector>): void;

        SetTangentAtSplinePoint(PointIndex: number, InTangent: Vector, CoordinateSpace: ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */): void;

        SetTangentColor(TangentColor: LinearColor): void;

        SetTangentsAtSplinePoint(PointIndex: number, InArriveTangent: Vector, InLeaveTangent: Vector, CoordinateSpace: ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */): void;

        SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;

        SetUpVectorAtSplinePoint(PointIndex: number, InUpVector: Vector, CoordinateSpace: ESplineCoordinateSpace, bUpdateSpline?: boolean /* = true */): void;

        SetWorldLocationAtSplinePoint(PointIndex: number, InLocation: Vector): void;

        UpdateSpline(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SplineComponent;

        static Load(InName: string): SplineComponent;
    }

    export class SplineMeshParams {
        constructor();
        constructor(StartPos: Vector, StartTangent: Vector, StartScale: Vector2D, StartRoll: number, StartOffset: Vector2D, EndPos: Vector, EndScale: Vector2D, EndTangent: Vector, EndRoll: number, EndOffset: Vector2D);

        StartPos: Vector;
        StartTangent: Vector;
        StartScale: Vector2D;
        StartRoll: number;
        StartOffset: Vector2D;
        EndPos: Vector;
        EndScale: Vector2D;
        EndTangent: Vector;
        EndRoll: number;
        EndOffset: Vector2D;

        static StaticClass(): Class;
    }

    export enum ESplineMeshAxis { X, Y, Z, ESplineMeshAxis_MAX }

    export class SplineMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SplineParams: SplineMeshParams;
        SplineUpDir: Vector;
        SplineBoundaryMin: number;
        CachedMeshBodySetupGuid: Guid;
        BodySetup: BodySetup;
        SplineBoundaryMax: number;
        bAllowSplineEditingPerInstance: boolean;
        bSmoothInterpRollScale: boolean;
        bMeshDirty: boolean;
        ForwardAxis: ESplineMeshAxis;
        VirtualTextureMainPassMaxDrawDistance: number;
        bSelected: boolean;

        GetBoundaryMax(): number;

        GetBoundaryMin(): number;

        GetEndOffset(): Vector2D;

        GetEndPosition(): Vector;

        GetEndRoll(): number;

        GetEndScale(): Vector2D;

        GetEndTangent(): Vector;

        GetForwardAxis(): ESplineMeshAxis;

        GetSplineUpDir(): Vector;

        GetStartOffset(): Vector2D;

        GetStartPosition(): Vector;

        GetStartRoll(): number;

        GetStartScale(): Vector2D;

        GetStartTangent(): Vector;

        SetBoundaryMax(InBoundaryMax: number, bUpdateMesh?: boolean /* = true */): void;

        SetBoundaryMin(InBoundaryMin: number, bUpdateMesh?: boolean /* = true */): void;

        SetEndOffset(EndOffset: Vector2D, bUpdateMesh?: boolean /* = true */): void;

        SetEndPosition(EndPos: Vector, bUpdateMesh?: boolean /* = true */): void;

        SetEndRoll(EndRoll: number, bUpdateMesh?: boolean /* = true */): void;

        SetEndScale(EndScale?: Vector2D /* = (X=1.000,Y=1.000) */, bUpdateMesh?: boolean /* = true */): void;

        SetEndTangent(EndTangent: Vector, bUpdateMesh?: boolean /* = true */): void;

        SetForwardAxis(InForwardAxis: ESplineMeshAxis, bUpdateMesh?: boolean /* = true */): void;

        SetSplineUpDir(InSplineUpDir: Vector, bUpdateMesh?: boolean /* = true */): void;

        SetStartAndEnd(StartPos: Vector, StartTangent: Vector, EndPos: Vector, EndTangent: Vector, bUpdateMesh?: boolean /* = true */): void;

        SetStartOffset(StartOffset: Vector2D, bUpdateMesh?: boolean /* = true */): void;

        SetStartPosition(StartPos: Vector, bUpdateMesh?: boolean /* = true */): void;

        SetStartRoll(StartRoll: number, bUpdateMesh?: boolean /* = true */): void;

        SetStartScale(StartScale?: Vector2D /* = (X=1.000,Y=1.000) */, bUpdateMesh?: boolean /* = true */): void;

        SetStartTangent(StartTangent: Vector, bUpdateMesh?: boolean /* = true */): void;

        UpdateMesh(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SplineMeshComponent;

        static Load(InName: string): SplineMeshComponent;
    }

    export class CameraRig_Rail extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentPositionOnRail: number;
        bLockOrientationToRail: boolean;
        bShowRailVisualization: boolean;
        PreviewMeshScale: number;
        TransformComponent: SceneComponent;
        RailSplineComponent: SplineComponent;
        RailCameraMount: SceneComponent;
        PreviewMesh_Rail: SplineMeshComponent;
        PreviewRailMeshSegments: TArray<SplineMeshComponent>;
        PreviewRailStaticMesh: StaticMesh;
        PreviewMesh_Mount: StaticMeshComponent;

        GetRailSplineComponent(): SplineComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraRig_Rail;

        static Load(InName: string): CameraRig_Rail;
    }

    export class CameraShakeSourceActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraShakeSourceComponent: CameraShakeSourceComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CameraShakeSourceActor;

        static Load(InName: string): CameraShakeSourceActor;
    }

    export class AnchorData {
        constructor();
        constructor(Offsets: Margin, Anchors: Anchors, Alignment: Vector2D);

        Offsets: Margin;
        Anchors: Anchors;
        Alignment: Vector2D;

        static StaticClass(): Class;
    }

    export class CanvasPanelSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LayoutData: AnchorData;
        bAutoSize: boolean;
        ZOrder: number;

        GetAlignment(): Vector2D;

        GetAnchors(): Anchors;

        GetAutoSize(): boolean;

        GetLayout(): AnchorData;

        GetOffsets(): Margin;

        GetPosition(): Vector2D;

        GetSize(): Vector2D;

        GetZOrder(): number;

        SetAlignment(InAlignment: Vector2D): void;

        SetAnchors(InAnchors: Anchors): void;

        SetAutoSize(InbAutoSize: boolean): void;

        SetLayout(InLayoutData: AnchorData): void;

        SetMaximum(InMaximumAnchors: Vector2D): void;

        SetMinimum(InMinimumAnchors: Vector2D): void;

        SetOffsets(InOffset: Margin): void;

        SetPosition(InPosition: Vector2D): void;

        SetSize(InSize: Vector2D): void;

        SetZOrder(InZOrder: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CanvasPanelSlot;

        static Load(InName: string): CanvasPanelSlot;
    }

    export class CanvasPanel extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddChildToCanvas(Content: $Nullable<Widget>): CanvasPanelSlot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CanvasPanel;

        static Load(InName: string): CanvasPanel;
    }

    export enum ETextureRenderTargetFormat {
        RTF_R8,
        RTF_RG8,
        RTF_RGBA8,
        RTF_RGBA8_SRGB,
        RTF_R16f,
        RTF_RG16f,
        RTF_RGBA16f,
        RTF_R32f,
        RTF_RG32f,
        RTF_RGBA32f,
        RTF_RGB10A2,
        RTF_MAX
    }

    export class TextureRenderTarget2D extends TextureRenderTarget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SizeX: number;
        SizeY: number;
        ClearColor: LinearColor;
        AddressX: TextureAddress;
        AddressY: TextureAddress;
        bForceLinearGamma: boolean;
        bHDR: boolean;
        bGPUSharedFlag: boolean;
        RenderTargetFormat: ETextureRenderTargetFormat;
        bAutoGenerateMips: boolean;
        MipsSamplerFilter: TextureFilter;
        MipsAddressU: TextureAddress;
        MipsAddressV: TextureAddress;
        OverrideFormat: EPixelFormat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTarget2D;

        static Load(InName: string): TextureRenderTarget2D;
    }

    export class CanvasRenderTarget2D extends TextureRenderTarget2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnCanvasRenderTargetUpdate: $MulticastDelegate<(Canvas: $Nullable<Canvas>, Width: number, Height: number) => void>;
        World: TWeakObjectPtr<World>;
        bShouldClearRenderTargetOnReceiveUpdate: boolean;

        GetSize(Width: $Ref<number>, Height: $Ref<number>): void;

        ReceiveUpdate(Canvas: $Nullable<Canvas>, Width: number, Height: number): void;

        UpdateResource(): void;

        static CreateCanvasRenderTarget2D(WorldContextObject: $Nullable<Object>, CanvasRenderTarget2DClass: $Nullable<Class>, Width?: number /* = 1024 */, Height?: number /* = 1024 */): CanvasRenderTarget2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CanvasRenderTarget2D;

        static Load(InName: string): CanvasRenderTarget2D;
    }

    export class CanvasRenderTarget2DFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Width: number;
        Height: number;
        Format: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CanvasRenderTarget2DFactoryNew;

        static Load(InName: string): CanvasRenderTarget2DFactoryNew;
    }

    export class CascadeOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bShowModuleDump: boolean;
        BackgroundColor: Color;
        bUseSubMenus: boolean;
        bUseSpaceBarReset: boolean;
        bUseSpaceBarResetInLevel: boolean;
        Empty_Background: Color;
        Emitter_Background: Color;
        Emitter_Unselected: Color;
        Emitter_Selected: Color;
        ModuleColor_General_Unselected: Color;
        ModuleColor_General_Selected: Color;
        ModuleColor_TypeData_Unselected: Color;
        ModuleColor_TypeData_Selected: Color;
        ModuleColor_Beam_Unselected: Color;
        ModuleColor_Beam_Selected: Color;
        ModuleColor_Trail_Unselected: Color;
        ModuleColor_Trail_Selected: Color;
        ModuleColor_Spawn_Unselected: Color;
        ModuleColor_Spawn_Selected: Color;
        ModuleColor_Light_Unselected: Color;
        ModuleColor_Light_Selected: Color;
        ModuleColor_SubUV_Unselected: Color;
        ModuleColor_SubUV_Selected: Color;
        ModuleColor_Required_Unselected: Color;
        ModuleColor_Required_Selected: Color;
        ModuleColor_Event_Unselected: Color;
        ModuleColor_Event_Selected: Color;
        bShowGrid: boolean;
        GridColor_Hi: Color;
        GridColor_Low: Color;
        GridPerspectiveSize: number;
        bShowParticleCounts: boolean;
        bShowParticleEvents: boolean;
        bShowParticleTimes: boolean;
        bShowParticleDistance: boolean;
        bShowParticleMemory: boolean;
        ParticleMemoryUpdateTime: number;
        bShowFloor: boolean;
        FloorMesh: string;
        FloorPosition: Vector;
        FloorRotation: Rotator;
        FloorScale: number;
        FloorScale3D: Vector;
        ShowPPFlags: number;
        bUseSlimCascadeDraw: boolean;
        SlimCascadeDrawHeight: number;
        bCenterCascadeModuleText: boolean;
        Cascade_MouseMoveThreshold: number;
        MotionModeRadius: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CascadeOptions;

        static Load(InName: string): CascadeOptions;
    }

    export class MaterialExpressionCustomOutput extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCustomOutput;

        static Load(InName: string): MaterialExpressionCustomOutput;
    }

    export class CelluloidShadingModel extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InBaseColor: ExpressionInput;
        InDarkColor: ExpressionInput;
        InBrightColor: ExpressionInput;
        InSpecularColor: ExpressionInput;
        InIsNoLBack: ExpressionInput;
        InIsNoHSpecular: ExpressionInput;
        InIsFaceArea: ExpressionInput;
        InIsFaceShadowCSP: ExpressionInput;
        InIsHeadShadow: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CelluloidShadingModel;

        static Load(InName: string): CelluloidShadingModel;
    }

    export class ChaosDebugDrawComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosDebugDrawComponent;

        static Load(InName: string): ChaosDebugDrawComponent;
    }

    export enum EChaosCollisionSortMethod {
        SortNone,
        SortByHighestMass,
        SortByHighestSpeed,
        SortByHighestImpulse,
        SortByNearestFirst,
        Count,
        EChaosCollisionSortMethod_MAX
    }

    export class ChaosCollisionEventRequestSettings {
        constructor();
        constructor(MaxNumberResults: number, MinMass: number, MinSpeed: number, MinImpulse: number, MaxDistance: number, SortMethod: EChaosCollisionSortMethod);

        MaxNumberResults: number;
        MinMass: number;
        MinSpeed: number;
        MinImpulse: number;
        MaxDistance: number;
        SortMethod: EChaosCollisionSortMethod;

        static StaticClass(): Class;
    }

    export enum EChaosBreakingSortMethod {
        SortNone,
        SortByHighestMass,
        SortByHighestSpeed,
        SortByNearestFirst,
        Count,
        EChaosBreakingSortMethod_MAX
    }

    export class ChaosBreakingEventRequestSettings {
        constructor();
        constructor(MaxNumberOfResults: number, MinRadius: number, MinSpeed: number, MinMass: number, MaxDistance: number, SortMethod: EChaosBreakingSortMethod);

        MaxNumberOfResults: number;
        MinRadius: number;
        MinSpeed: number;
        MinMass: number;
        MaxDistance: number;
        SortMethod: EChaosBreakingSortMethod;

        static StaticClass(): Class;
    }

    export enum EChaosTrailingSortMethod {
        SortNone,
        SortByHighestMass,
        SortByHighestSpeed,
        SortByNearestFirst,
        Count,
        EChaosTrailingSortMethod_MAX
    }

    export class ChaosTrailingEventRequestSettings {
        constructor();
        constructor(MaxNumberOfResults: number, MinMass: number, MinSpeed: number, MinAngularSpeed: number, MaxDistance: number, SortMethod: EChaosTrailingSortMethod);

        MaxNumberOfResults: number;
        MinMass: number;
        MinSpeed: number;
        MinAngularSpeed: number;
        MaxDistance: number;
        SortMethod: EChaosTrailingSortMethod;

        static StaticClass(): Class;
    }

    export enum EClusterUnionMethod {
        PointImplicit,
        DelaunayTriangulation,
        MinimalSpanningSubsetDelaunayTriangulation,
        PointImplicitAugmentedWithMinimalDelaunay,
        None,
        EClusterUnionMethod_MAX
    }

    export class SolverCollisionFilterSettings {
        constructor();
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinImpulse: number);

        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinImpulse: number;

        static StaticClass(): Class;
    }

    export class SolverBreakingFilterSettings {
        constructor();
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinVolume: number);

        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinVolume: number;

        static StaticClass(): Class;
    }

    export class SolverTrailingFilterSettings {
        constructor();
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinVolume: number);

        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinVolume: number;

        static StaticClass(): Class;
    }

    export class ChaosSolverConfiguration {
        constructor();
        constructor(Iterations: number, CollisionPairIterations: number, PushOutIterations: number, CollisionPushOutPairIterations: number, CollisionMarginFraction: number, CollisionMarginMax: number, CollisionCullDistance: number, JointPairIterations: number, JointPushOutPairIterations: number, ClusterConnectionFactor: number, ClusterUnionConnectionType: EClusterUnionMethod, bGenerateCollisionData: boolean, CollisionFilterSettings: SolverCollisionFilterSettings, bGenerateBreakData: boolean, BreakingFilterSettings: SolverBreakingFilterSettings, bGenerateTrailingData: boolean, TrailingFilterSettings: SolverTrailingFilterSettings, bGenerateContactGraph: boolean);

        Iterations: number;
        CollisionPairIterations: number;
        PushOutIterations: number;
        CollisionPushOutPairIterations: number;
        CollisionMarginFraction: number;
        CollisionMarginMax: number;
        CollisionCullDistance: number;
        JointPairIterations: number;
        JointPushOutPairIterations: number;
        ClusterConnectionFactor: number;
        ClusterUnionConnectionType: EClusterUnionMethod;
        bGenerateCollisionData: boolean;
        CollisionFilterSettings: SolverCollisionFilterSettings;
        bGenerateBreakData: boolean;
        BreakingFilterSettings: SolverBreakingFilterSettings;
        bGenerateTrailingData: boolean;
        TrailingFilterSettings: SolverTrailingFilterSettings;
        bGenerateContactGraph: boolean;

        static StaticClass(): Class;
    }

    export enum EClusterConnectionTypeEnum {
        Chaos_PointImplicit,
        Chaos_DelaunayTriangulation,
        Chaos_MinimalSpanningSubsetDelaunayTriangulation,
        Chaos_PointImplicitAugmentedWithMinimalDelaunay,
        Chaos_None,
        Chaos_EClsuterCreationParameters_Max,
        Chaos_MAX
    }

    export class ChaosDebugSubstepControl {
        constructor();
        constructor(bPause: boolean, bSubstep: boolean, bStep: boolean);

        bPause: boolean;
        bSubstep: boolean;
        bStep: boolean;

        static StaticClass(): Class;
    }

    export class ChaosEventListenerComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosEventListenerComponent;

        static Load(InName: string): ChaosEventListenerComponent;
    }

    export class ChaosHandlerSet {
        constructor();
        constructor(ChaosHandlers: TSet<Object>);

        ChaosHandlers: TSet<Object>;

        static StaticClass(): Class;
    }

    export class BreakEventCallbackWrapper {
        constructor();

        static StaticClass(): Class;
    }

    export class ChaosGameplayEventDispatcher extends ChaosEventListenerComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CollisionEventRegistrations: TMap<PrimitiveComponent, ChaosHandlerSet>;
        BreakEventRegistrations: TMap<PrimitiveComponent, BreakEventCallbackWrapper>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosGameplayEventDispatcher;

        static Load(InName: string): ChaosGameplayEventDispatcher;
    }

    export class ChaosSolverActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Properties: ChaosSolverConfiguration;
        TimeStepMultiplier: number;
        CollisionIterations: number;
        PushOutIterations: number;
        PushOutPairIterations: number;
        ClusterConnectionFactor: number;
        ClusterUnionConnectionType: EClusterConnectionTypeEnum;
        DoGenerateCollisionData: boolean;
        CollisionFilterSettings: SolverCollisionFilterSettings;
        DoGenerateBreakingData: boolean;
        BreakingFilterSettings: SolverBreakingFilterSettings;
        DoGenerateTrailingData: boolean;
        TrailingFilterSettings: SolverTrailingFilterSettings;
        MassScale: number;
        bGenerateContactGraph: boolean;
        bHasFloor: boolean;
        FloorHeight: number;
        ChaosDebugSubstepControl: ChaosDebugSubstepControl;
        SpriteComponent: BillboardComponent;
        GameplayEventDispatcherComponent: ChaosGameplayEventDispatcher;

        SetAsCurrentWorldSolver(): void;

        SetSolverActive(bActive: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosSolverActor;

        static Load(InName: string): ChaosSolverActor;
    }

    export class GeometryCollectionSource {
        constructor();
        constructor(SourceGeometryObject: SoftObjectPath, LocalTransform: Transform, SourceMaterial: TArray<MaterialInterface>);

        SourceGeometryObject: SoftObjectPath;
        LocalTransform: Transform;
        SourceMaterial: TArray<MaterialInterface>;

        static StaticClass(): Class;
    }

    export enum ECollisionTypeEnum { Chaos_Volumetric, Chaos_Surface_Volumetric, Chaos_Max, Chaos_MAX }

    export enum EImplicitTypeEnum {
        Chaos_Implicit_Box,
        Chaos_Implicit_Sphere,
        Chaos_Implicit_Capsule,
        Chaos_Implicit_LevelSet,
        Chaos_Implicit_None,
        Chaos_Max,
        Chaos_MAX
    }

    export class GeometryCollectionSizeSpecificData {
        constructor();
        constructor(MaxSize: number, CollisionType: ECollisionTypeEnum, ImplicitType: EImplicitTypeEnum, MinLevelSetResolution: number, MaxLevelSetResolution: number, MinClusterLevelSetResolution: number, MaxClusterLevelSetResolution: number, CollisionObjectReductionPercentage: number, CollisionParticlesFraction: number, MaximumCollisionParticles: number);

        MaxSize: number;
        CollisionType: ECollisionTypeEnum;
        ImplicitType: EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        MinClusterLevelSetResolution: number;
        MaxClusterLevelSetResolution: number;
        CollisionObjectReductionPercentage: number;
        CollisionParticlesFraction: number;
        MaximumCollisionParticles: number;

        static StaticClass(): Class;
    }

    export class GeometryCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GeometrySource: TArray<GeometryCollectionSource>;
        Materials: TArray<MaterialInterface>;
        CollisionType: ECollisionTypeEnum;
        ImplicitType: EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        MinClusterLevelSetResolution: number;
        MaxClusterLevelSetResolution: number;
        CollisionObjectReductionPercentage: number;
        bMassAsDensity: boolean;
        Mass: number;
        MinimumMassClamp: number;
        CollisionParticlesFraction: number;
        MaximumCollisionParticles: number;
        SizeSpecificData: TArray<GeometryCollectionSizeSpecificData>;
        EnableRemovePiecesOnFracture: boolean;
        RemoveOnFractureMaterials: TArray<MaterialInterface>;
        ThumbnailInfo: ThumbnailInfo;
        PersistentGuid: Guid;
        StateGuid: Guid;
        BoneSelectedMaterialIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeometryCollection;

        static Load(InName: string): GeometryCollection;
    }

    export class FieldSystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldSystem;

        static Load(InName: string): FieldSystem;
    }

    export enum EFieldPhysicsType {
        Field_None,
        Field_DynamicState,
        Field_LinearForce,
        Field_ExternalClusterStrain,
        Field_Kill,
        Field_LinearVelocity,
        Field_AngularVelociy,
        Field_AngularTorque,
        Field_InternalClusterStrain,
        Field_DisableThreshold,
        Field_SleepingThreshold,
        Field_PositionStatic,
        Field_PositionAnimated,
        Field_PositionTarget,
        Field_DynamicConstraint,
        Field_CollisionGroup,
        Field_ActivateDisabled,
        Field_PhysicsType_Max
    }

    export class FieldSystemMetaData extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaData;

        static Load(InName: string): FieldSystemMetaData;
    }

    export class FieldSystemComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FieldSystem: FieldSystem;
        SupportedSolvers: TArray<TSoftObjectPtr<ChaosSolverActor>>;

        AddFieldCommand(Enabled: boolean, Target: EFieldPhysicsType, MetaData: $Nullable<FieldSystemMetaData>, Field: $Nullable<FieldNodeBase>): void;

        ApplyLinearForce(Enabled: boolean, Direction: Vector, Magnitude: number): void;

        ApplyPhysicsField(Enabled: boolean, Target: EFieldPhysicsType, MetaData: $Nullable<FieldSystemMetaData>, Field: $Nullable<FieldNodeBase>): void;

        ApplyRadialForce(Enabled: boolean, Position: Vector, Magnitude: number): void;

        ApplyRadialVectorFalloffForce(Enabled: boolean, Position: Vector, Radius: number, Magnitude: number): void;

        ApplyStayDynamicField(Enabled: boolean, Position: Vector, Radius: number): void;

        ApplyStrainField(Enabled: boolean, Position: Vector, Radius: number, Magnitude: number, Iterations: number): void;

        ApplyUniformVectorFalloffForce(Enabled: boolean, Position: Vector, Direction: Vector, Radius: number, Magnitude: number): void;

        ResetFieldSystem(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldSystemComponent;

        static Load(InName: string): FieldSystemComponent;
    }

    export class FieldSystemActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FieldSystemComponent: FieldSystemComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldSystemActor;

        static Load(InName: string): FieldSystemActor;
    }

    export enum EObjectStateTypeEnum {
        Chaos_NONE,
        Chaos_Object_Sleeping,
        Chaos_Object_Kinematic,
        Chaos_Object_Static,
        Chaos_Object_Dynamic,
        Chaos_Object_UserDefined,
        Chaos_Max,
        Chaos_MAX
    }

    export class ChaosPhysicalMaterial extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Friction: number;
        StaticFriction: number;
        Restitution: number;
        LinearEtherDrag: number;
        AngularEtherDrag: number;
        SleepingLinearVelocityThreshold: number;
        SleepingAngularVelocityThreshold: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosPhysicalMaterial;

        static Load(InName: string): ChaosPhysicalMaterial;
    }

    export enum EInitialVelocityTypeEnum {
        Chaos_Initial_Velocity_User_Defined,
        Chaos_Initial_Velocity_None,
        Chaos_Max,
        Chaos_MAX
    }

    export enum EGeometryCollectionCacheType { None, Record, Play, RecordAndPlay, EGeometryCollectionCacheType_MAX }

    export class SolverCollisionData {
        constructor();
        constructor(Location: Vector, AccumulatedImpulse: Vector, Normal: Vector, Velocity1: Vector, Velocity2: Vector, AngularVelocity1: Vector, AngularVelocity2: Vector, Mass1: number, Mass2: number, ParticleIndex: number, LevelsetIndex: number, ParticleIndexMesh: number, LevelsetIndexMesh: number);

        Location: Vector;
        AccumulatedImpulse: Vector;
        Normal: Vector;
        Velocity1: Vector;
        Velocity2: Vector;
        AngularVelocity1: Vector;
        AngularVelocity2: Vector;
        Mass1: number;
        Mass2: number;
        ParticleIndex: number;
        LevelsetIndex: number;
        ParticleIndexMesh: number;
        LevelsetIndexMesh: number;

        static StaticClass(): Class;
    }

    export class SolverBreakingData {
        constructor();
        constructor(Location: Vector, Velocity: Vector, AngularVelocity: Vector, Mass: number, ParticleIndex: number, ParticleIndexMesh: number);

        Location: Vector;
        Velocity: Vector;
        AngularVelocity: Vector;
        Mass: number;
        ParticleIndex: number;
        ParticleIndexMesh: number;

        static StaticClass(): Class;
    }

    export class SolverTrailingData {
        constructor();
        constructor(Location: Vector, Velocity: Vector, AngularVelocity: Vector, Mass: number, ParticleIndex: number, ParticleIndexMesh: number);

        Location: Vector;
        Velocity: Vector;
        AngularVelocity: Vector;
        Mass: number;
        ParticleIndex: number;
        ParticleIndexMesh: number;

        static StaticClass(): Class;
    }

    export class RecordedFrame {
        constructor();
        constructor(Transforms: TArray<Transform>, TransformIndices: TArray<number>, PreviousTransformIndices: TArray<number>, DisabledFlags: TArray<boolean>, Collisions: TArray<SolverCollisionData>, Breakings: TArray<SolverBreakingData>, Trailings: TSet<SolverTrailingData>, Timestamp: number);

        Transforms: TArray<Transform>;
        TransformIndices: TArray<number>;
        PreviousTransformIndices: TArray<number>;
        DisabledFlags: TArray<boolean>;
        Collisions: TArray<SolverCollisionData>;
        Breakings: TArray<SolverBreakingData>;
        Trailings: TSet<SolverTrailingData>;
        Timestamp: number;

        static StaticClass(): Class;
    }

    export class RecordedTransformTrack {
        constructor();
        constructor(Records: TArray<RecordedFrame>);

        Records: TArray<RecordedFrame>;

        static StaticClass(): Class;
    }

    export class GeometryCollectionCache extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RecordedData: RecordedTransformTrack;
        SupportedCollection: GeometryCollection;
        CompatibleCollectionState: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeometryCollectionCache;

        static Load(InName: string): GeometryCollectionCache;
    }

    export class GeomComponentCacheParameters {
        constructor();
        constructor(CacheMode: EGeometryCollectionCacheType, TargetCache: GeometryCollectionCache, ReverseCacheBeginTime: number, SaveCollisionData: boolean, DoGenerateCollisionData: boolean, CollisionDataSizeMax: number, DoCollisionDataSpatialHash: boolean, CollisionDataSpatialHashRadius: number, MaxCollisionPerCell: number, SaveBreakingData: boolean, DoGenerateBreakingData: boolean, BreakingDataSizeMax: number, DoBreakingDataSpatialHash: boolean, BreakingDataSpatialHashRadius: number, MaxBreakingPerCell: number, SaveTrailingData: boolean, DoGenerateTrailingData: boolean, TrailingDataSizeMax: number, TrailingMinSpeedThreshold: number, TrailingMinVolumeThreshold: number);

        CacheMode: EGeometryCollectionCacheType;
        TargetCache: GeometryCollectionCache;
        ReverseCacheBeginTime: number;
        SaveCollisionData: boolean;
        DoGenerateCollisionData: boolean;
        CollisionDataSizeMax: number;
        DoCollisionDataSpatialHash: boolean;
        CollisionDataSpatialHashRadius: number;
        MaxCollisionPerCell: number;
        SaveBreakingData: boolean;
        DoGenerateBreakingData: boolean;
        BreakingDataSizeMax: number;
        DoBreakingDataSpatialHash: boolean;
        BreakingDataSpatialHashRadius: number;
        MaxBreakingPerCell: number;
        SaveTrailingData: boolean;
        DoGenerateTrailingData: boolean;
        TrailingDataSizeMax: number;
        TrailingMinSpeedThreshold: number;
        TrailingMinVolumeThreshold: number;

        static StaticClass(): Class;
    }

    export class ChaosBreakEvent {
        constructor();
        constructor(Component: PrimitiveComponent, Location: Vector, Velocity: Vector, AngularVelocity: Vector, Mass: number);

        Component: PrimitiveComponent;
        Location: Vector;
        Velocity: Vector;
        AngularVelocity: Vector;
        Mass: number;

        static StaticClass(): Class;
    }

    export class ChaosPhysicsCollisionInfo {
        constructor();
        constructor(Component: PrimitiveComponent, OtherComponent: PrimitiveComponent, Location: Vector, Normal: Vector, AccumulatedImpulse: Vector, Velocity: Vector, OtherVelocity: Vector, AngularVelocity: Vector, OtherAngularVelocity: Vector, Mass: number, OtherMass: number);

        Component: PrimitiveComponent;
        OtherComponent: PrimitiveComponent;
        Location: Vector;
        Normal: Vector;
        AccumulatedImpulse: Vector;
        Velocity: Vector;
        OtherVelocity: Vector;
        AngularVelocity: Vector;
        OtherAngularVelocity: Vector;
        Mass: number;
        OtherMass: number;

        static StaticClass(): Class;
    }

    export class GeometryCollectionRepData {
        constructor();

        static StaticClass(): Class;
    }

    export enum EGeometryCollectionPhysicsTypeEnum {
        Chaos_AngularVelocity,
        Chaos_DynamicState,
        Chaos_LinearVelocity,
        Chaos_InitialAngularVelocity,
        Chaos_InitialLinearVelocity,
        Chaos_CollisionGroup,
        Chaos_LinearForce,
        Chaos_AngularTorque,
        Chaos_Max,
        Chaos_MAX
    }

    export class GeometryCollectionComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChaosSolverActor: ChaosSolverActor;
        RestCollection: GeometryCollection;
        InitializationFields: TArray<FieldSystemActor>;
        Simulating: boolean;
        ObjectType: EObjectStateTypeEnum;
        EnableClustering: boolean;
        ClusterGroupIndex: number;
        MaxClusterLevel: number;
        DamageThreshold: TArray<number>;
        ClusterConnectionType: EClusterConnectionTypeEnum;
        CollisionGroup: number;
        CollisionSampleFraction: number;
        LinearEtherDrag: number;
        AngularEtherDrag: number;
        PhysicalMaterial: ChaosPhysicalMaterial;
        InitialVelocityType: EInitialVelocityTypeEnum;
        InitialLinearVelocity: Vector;
        InitialAngularVelocity: Vector;
        PhysicalMaterialOverride: PhysicalMaterial;
        CacheParameters: GeomComponentCacheParameters;
        NotifyGeometryCollectionPhysicsStateChange: $MulticastDelegate<(FracturedComponent: $Nullable<GeometryCollectionComponent>) => void>;
        NotifyGeometryCollectionPhysicsLoadingStateChange: $MulticastDelegate<(FracturedComponent: $Nullable<GeometryCollectionComponent>) => void>;
        OnChaosBreakEvent: $MulticastDelegate<(BreakEvent: ChaosBreakEvent) => void>;
        DesiredCacheTime: number;
        CachePlayback: boolean;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
        bNotifyBreaks: boolean;
        bNotifyCollisions: boolean;
        bEnableReplication: boolean;
        bEnableAbandonAfterLevel: boolean;
        ReplicationAbandonClusterLevel: number;
        RepData: GeometryCollectionRepData;
        SelectedBones: TArray<number>;
        HighlightedBones: TArray<number>;
        DummyBodySetup: BodySetup;
        EditorActor: Actor;

        ApplyKinematicField(Radius: number, Position: Vector): void;

        ApplyPhysicsField(Enabled: boolean, Target: EGeometryCollectionPhysicsTypeEnum, MetaData: $Nullable<FieldSystemMetaData>, Field: $Nullable<FieldNodeBase>): void;

        NetAbandonCluster(TransformIndex: number): void;

        NotifyGeometryCollectionPhysicsLoadingStateChange__DelegateSignature(FracturedComponent: $Nullable<GeometryCollectionComponent>): void;

        NotifyGeometryCollectionPhysicsStateChange__DelegateSignature(FracturedComponent: $Nullable<GeometryCollectionComponent>): void;

        OnRep_RepData(OldData: GeometryCollectionRepData): void;

        ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;

        SetNotifyBreaks(bNewNotifyBreaks: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeometryCollectionComponent;

        static Load(InName: string): GeometryCollectionComponent;
    }

    export class GeometryCollectionDebugDrawWarningMessage {
        constructor();

        static StaticClass(): Class;
    }

    export class GeometryCollectionDebugDrawActorSelectedRigidBody {
        constructor();
        constructor(Id: number, Solver: ChaosSolverActor, GeometryCollection: GeometryCollectionActor);

        Id: number;
        Solver: ChaosSolverActor;
        GeometryCollection: GeometryCollectionActor;

        static StaticClass(): Class;
    }

    export enum EGeometryCollectionDebugDrawActorHideGeometry {
        HideNone,
        HideWithCollision,
        HideSelected,
        HideWholeCollection,
        HideAll,
        EGeometryCollectionDebugDrawActorHideGeometry_MAX
    }

    export class GeometryCollectionDebugDrawActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WarningMessage: GeometryCollectionDebugDrawWarningMessage;
        SelectedRigidBody: GeometryCollectionDebugDrawActorSelectedRigidBody;
        bDebugDrawWholeCollection: boolean;
        bDebugDrawHierarchy: boolean;
        bDebugDrawClustering: boolean;
        HideGeometry: EGeometryCollectionDebugDrawActorHideGeometry;
        bShowRigidBodyId: boolean;
        bShowRigidBodyCollision: boolean;
        bCollisionAtOrigin: boolean;
        bShowRigidBodyTransform: boolean;
        bShowRigidBodyInertia: boolean;
        bShowRigidBodyVelocity: boolean;
        bShowRigidBodyForce: boolean;
        bShowRigidBodyInfos: boolean;
        bShowTransformIndex: boolean;
        bShowTransform: boolean;
        bShowParent: boolean;
        bShowLevel: boolean;
        bShowConnectivityEdges: boolean;
        bShowGeometryIndex: boolean;
        bShowGeometryTransform: boolean;
        bShowBoundingBox: boolean;
        bShowFaces: boolean;
        bShowFaceIndices: boolean;
        bShowFaceNormals: boolean;
        bShowSingleFace: boolean;
        SingleFaceIndex: number;
        bShowVertices: boolean;
        bShowVertexIndices: boolean;
        bShowVertexNormals: boolean;
        bUseActiveVisualization: boolean;
        PointThickness: number;
        LineThickness: number;
        bTextShadow: boolean;
        TextScale: number;
        NormalScale: number;
        AxisScale: number;
        ArrowScale: number;
        RigidBodyIdColor: Color;
        RigidBodyTransformScale: number;
        RigidBodyCollisionColor: Color;
        RigidBodyInertiaColor: Color;
        RigidBodyVelocityColor: Color;
        RigidBodyForceColor: Color;
        RigidBodyInfoColor: Color;
        TransformIndexColor: Color;
        TransformScale: number;
        LevelColor: Color;
        ParentColor: Color;
        ConnectivityEdgeThickness: number;
        GeometryIndexColor: Color;
        GeometryTransformScale: number;
        BoundingBoxColor: Color;
        FaceColor: Color;
        FaceIndexColor: Color;
        FaceNormalColor: Color;
        SingleFaceColor: Color;
        VertexColor: Color;
        VertexIndexColor: Color;
        VertexNormalColor: Color;
        SpriteComponent: BillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeometryCollectionDebugDrawActor;

        static Load(InName: string): GeometryCollectionDebugDrawActor;
    }

    export class VolumeTexture extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Source2DTexture: Texture2D;
        SourceLightingGuid: Guid;
        Source2DTileSizeX: number;
        Source2DTileSizeY: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VolumeTexture;

        static Load(InName: string): VolumeTexture;
    }

    export class GeometryCollectionRenderLevelSetActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetVolumeTexture: VolumeTexture;
        RayMarchMaterial: Material;
        SurfaceTolerance: number;
        Isovalue: number;
        Enabled: boolean;
        RenderVolumeBoundingBox: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeometryCollectionRenderLevelSetActor;

        static Load(InName: string): GeometryCollectionRenderLevelSetActor;
    }

    export class GeometryCollectionDebugDrawComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GeometryCollectionDebugDrawActor: GeometryCollectionDebugDrawActor;
        GeometryCollectionRenderLevelSetActor: GeometryCollectionRenderLevelSetActor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeometryCollectionDebugDrawComponent;

        static Load(InName: string): GeometryCollectionDebugDrawComponent;
    }

    export class GeometryCollectionActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GeometryCollectionComponent: GeometryCollectionComponent;
        GeometryCollectionDebugDrawComponent: GeometryCollectionDebugDrawComponent;

        RaycastSingle(Start: Vector, End: Vector, OutHit: $Ref<HitResult>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeometryCollectionActor;

        static Load(InName: string): GeometryCollectionActor;
    }

    export class ChaosCollisionEventData {
        constructor();
        constructor(Location: Vector, Normal: Vector, Velocity1: Vector, Velocity2: Vector, Mass1: number, Mass2: number, Impulse: Vector);

        Location: Vector;
        Normal: Vector;
        Velocity1: Vector;
        Velocity2: Vector;
        Mass1: number;
        Mass2: number;
        Impulse: Vector;

        static StaticClass(): Class;
    }

    export class ChaosBreakingEventData {
        constructor();
        constructor(Location: Vector, Velocity: Vector, Mass: number);

        Location: Vector;
        Velocity: Vector;
        Mass: number;

        static StaticClass(): Class;
    }

    export class ChaosTrailingEventData {
        constructor();
        constructor(Location: Vector, Velocity: Vector, AngularVelocity: Vector, Mass: number, ParticleIndex: number);

        Location: Vector;
        Velocity: Vector;
        AngularVelocity: Vector;
        Mass: number;
        ParticleIndex: number;

        static StaticClass(): Class;
    }

    export class ChaosDestructionListener extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsCollisionEventListeningEnabled: boolean;
        bIsBreakingEventListeningEnabled: boolean;
        bIsTrailingEventListeningEnabled: boolean;
        CollisionEventRequestSettings: ChaosCollisionEventRequestSettings;
        BreakingEventRequestSettings: ChaosBreakingEventRequestSettings;
        TrailingEventRequestSettings: ChaosTrailingEventRequestSettings;
        ChaosSolverActors: TSet<ChaosSolverActor>;
        GeometryCollectionActors: TSet<GeometryCollectionActor>;
        OnCollisionEvents: $MulticastDelegate<(CollisionEvents: TArray<ChaosCollisionEventData>) => void>;
        OnBreakingEvents: $MulticastDelegate<(BreakingEvents: TArray<ChaosBreakingEventData>) => void>;
        OnTrailingEvents: $MulticastDelegate<(TrailingEvents: TArray<ChaosTrailingEventData>) => void>;

        AddChaosSolverActor(ChaosSolverActor: $Nullable<ChaosSolverActor>): void;

        AddGeometryCollectionActor(GeometryCollectionActor: $Nullable<GeometryCollectionActor>): void;

        IsEventListening(): boolean;

        RemoveChaosSolverActor(ChaosSolverActor: $Nullable<ChaosSolverActor>): void;

        RemoveGeometryCollectionActor(GeometryCollectionActor: $Nullable<GeometryCollectionActor>): void;

        SetBreakingEventEnabled(bIsEnabled: boolean): void;

        SetBreakingEventRequestSettings(InSettings: ChaosBreakingEventRequestSettings): void;

        SetCollisionEventEnabled(bIsEnabled: boolean): void;

        SetCollisionEventRequestSettings(InSettings: ChaosCollisionEventRequestSettings): void;

        SetTrailingEventEnabled(bIsEnabled: boolean): void;

        SetTrailingEventRequestSettings(InSettings: ChaosTrailingEventRequestSettings): void;

        SortBreakingEvents(BreakingEvents: $Ref<TArray<ChaosBreakingEventData>>, SortMethod: EChaosBreakingSortMethod): void;

        SortCollisionEvents(CollisionEvents: $Ref<TArray<ChaosCollisionEventData>>, SortMethod: EChaosCollisionSortMethod): void;

        SortTrailingEvents(TrailingEvents: $Ref<TArray<ChaosTrailingEventData>>, SortMethod: EChaosTrailingSortMethod): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosDestructionListener;

        static Load(InName: string): ChaosDestructionListener;
    }

    export class ChaosNotifyHandlerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosNotifyHandlerInterface;

        static Load(InName: string): ChaosNotifyHandlerInterface;
    }

    export class ChaosPhysicalMaterialFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosPhysicalMaterialFactory;

        static Load(InName: string): ChaosPhysicalMaterialFactory;
    }

    export class ChaosSolver extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosSolver;

        static Load(InName: string): ChaosSolver;
    }

    export class ChaosSolverEngineBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosSolverEngineBlueprintLibrary;

        static Load(InName: string): ChaosSolverEngineBlueprintLibrary;
    }

    export class ChaosSolverSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultChaosSolverActorClass: SoftClassPath;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChaosSolverSettings;

        static Load(InName: string): ChaosSolverSettings;
    }

    export enum ESlateCheckBoxType { CheckBox, ToggleButton, ESlateCheckBoxType_MAX }

    export class CheckBoxStyle extends SlateWidgetStyle {
        constructor();
        constructor(CheckBoxType: ESlateCheckBoxType, UncheckedImage: SlateBrush, UncheckedHoveredImage: SlateBrush, UncheckedPressedImage: SlateBrush, CheckedImage: SlateBrush, CheckedHoveredImage: SlateBrush, CheckedPressedImage: SlateBrush, UndeterminedImage: SlateBrush, UndeterminedHoveredImage: SlateBrush, UndeterminedPressedImage: SlateBrush, Padding: Margin, ForegroundColor: SlateColor, BorderBackgroundColor: SlateColor, CheckedSlateSound: SlateSound, UncheckedSlateSound: SlateSound, HoveredSlateSound: SlateSound, CheckedSound: string, UncheckedSound: string, HoveredSound: string);

        CheckBoxType: ESlateCheckBoxType;
        UncheckedImage: SlateBrush;
        UncheckedHoveredImage: SlateBrush;
        UncheckedPressedImage: SlateBrush;
        CheckedImage: SlateBrush;
        CheckedHoveredImage: SlateBrush;
        CheckedPressedImage: SlateBrush;
        UndeterminedImage: SlateBrush;
        UndeterminedHoveredImage: SlateBrush;
        UndeterminedPressedImage: SlateBrush;
        Padding: Margin;
        ForegroundColor: SlateColor;
        BorderBackgroundColor: SlateColor;
        CheckedSlateSound: SlateSound;
        UncheckedSlateSound: SlateSound;
        HoveredSlateSound: SlateSound;
        CheckedSound: string;
        UncheckedSound: string;
        HoveredSound: string;

        static StaticClass(): Class;
    }

    export class CheckBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CheckedState: ECheckBoxState;
        CheckedStateDelegate: $Delegate<() => ECheckBoxState>;
        WidgetStyle: CheckBoxStyle;
        Style: SlateWidgetStyleAsset;
        UncheckedImage: SlateBrushAsset;
        UncheckedHoveredImage: SlateBrushAsset;
        UncheckedPressedImage: SlateBrushAsset;
        CheckedImage: SlateBrushAsset;
        CheckedHoveredImage: SlateBrushAsset;
        CheckedPressedImage: SlateBrushAsset;
        UndeterminedImage: SlateBrushAsset;
        UndeterminedHoveredImage: SlateBrushAsset;
        UndeterminedPressedImage: SlateBrushAsset;
        HorizontalAlignment: EHorizontalAlignment;
        Padding: Margin;
        BorderBackgroundColor: SlateColor;
        ClickMethod: EButtonClickMethod;
        TouchMethod: EButtonTouchMethod;
        PressMethod: EButtonPressMethod;
        IsFocusable: boolean;
        OnCheckStateChanged: $MulticastDelegate<(bIsChecked: boolean) => void>;

        GetCheckedState(): ECheckBoxState;

        IsChecked(): boolean;

        IsPressed(): boolean;

        SetCheckedState(InCheckedState: ECheckBoxState): void;

        SetClickMethod(InClickMethod: EButtonClickMethod): void;

        SetIsChecked(InIsChecked: boolean): void;

        SetPressMethod(InPressMethod: EButtonPressMethod): void;

        SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CheckBox;

        static Load(InName: string): CheckBox;
    }

    export class CheckBoxStyleAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CheckBoxStyle: CheckBoxStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CheckBoxStyleAsset;

        static Load(InName: string): CheckBoxStyleAsset;
    }

    export class CheckBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CheckBoxStyle: CheckBoxStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CheckBoxWidgetStyle;

        static Load(InName: string): CheckBoxWidgetStyle;
    }

    export class CheckedStateBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetValue(): ECheckBoxState;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CheckedStateBinding;

        static Load(InName: string): CheckedStateBinding;
    }

    export class CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(bIsAvailable: boolean, Error: string) => void>;
        OnFailed: $MulticastDelegate<(bIsAvailable: boolean, Error: string) => void>;

        GeoTrackingAvailabilityDelegate__DelegateSignature(bIsAvailable: boolean, Error: string): void;

        static CheckGeoTrackingAvailability(WorldContextObject: $Nullable<Object>): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;

        static CheckGeoTrackingAvailabilityAtLocation(WorldContextObject: $Nullable<Object>, Longitude: number, Latitude: number): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;

        static Load(InName: string): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
    }

    export class ChunkDependency {
        constructor();
        constructor(ChunkID: number, ParentChunkID: number);

        ChunkID: number;
        ParentChunkID: number;

        static StaticClass(): Class;
    }

    export class ChunkDependencyInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DependencyArray: TArray<ChunkDependency>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ChunkDependencyInfo;

        static Load(InName: string): ChunkDependencyInfo;
    }

    export class CameraLookatTrackingSettings {
        constructor();
        constructor(bEnableLookAtTracking: boolean, bDrawDebugLookAtTrackingPosition: boolean, LookAtTrackingInterpSpeed: number, ActorToTrack: TSoftObjectPtr<Actor>, RelativeOffset: Vector, bAllowRoll: boolean);

        bEnableLookAtTracking: boolean;
        bDrawDebugLookAtTrackingPosition: boolean;
        LookAtTrackingInterpSpeed: number;
        ActorToTrack: TSoftObjectPtr<Actor>;
        RelativeOffset: Vector;
        bAllowRoll: boolean;

        static StaticClass(): Class;
    }

    export class CameraFilmbackSettings {
        constructor();
        constructor(SensorWidth: number, SensorHeight: number, SensorAspectRatio: number);

        SensorWidth: number;
        SensorHeight: number;
        SensorAspectRatio: number;

        static StaticClass(): Class;
    }

    export class CameraLensSettings {
        constructor();
        constructor(MinFocalLength: number, MaxFocalLength: number, MinFStop: number, MaxFStop: number, MinimumFocusDistance: number, DiaphragmBladeCount: number);

        MinFocalLength: number;
        MaxFocalLength: number;
        MinFStop: number;
        MaxFStop: number;
        MinimumFocusDistance: number;
        DiaphragmBladeCount: number;

        static StaticClass(): Class;
    }

    export enum ECameraFocusMethod { DoNotOverride, Manual, Tracking, Disable, MAX }

    export class CameraTrackingFocusSettings {
        constructor();
        constructor(ActorToTrack: TSoftObjectPtr<Actor>, RelativeOffset: Vector, bDrawDebugTrackingFocusPoint: boolean);

        ActorToTrack: TSoftObjectPtr<Actor>;
        RelativeOffset: Vector;
        bDrawDebugTrackingFocusPoint: boolean;

        static StaticClass(): Class;
    }

    export class CameraFocusSettings {
        constructor();
        constructor(FocusMethod: ECameraFocusMethod, ManualFocusDistance: number, TrackingFocusSettings: CameraTrackingFocusSettings, bDrawDebugFocusPlane: boolean, DebugFocusPlaneColor: Color, bSmoothFocusChanges: boolean, FocusSmoothingInterpSpeed: number, FocusOffset: number);

        FocusMethod: ECameraFocusMethod;
        ManualFocusDistance: number;
        TrackingFocusSettings: CameraTrackingFocusSettings;
        bDrawDebugFocusPlane: boolean;
        DebugFocusPlaneColor: Color;
        bSmoothFocusChanges: boolean;
        FocusSmoothingInterpSpeed: number;
        FocusOffset: number;

        static StaticClass(): Class;
    }

    export class NamedFilmbackPreset {
        constructor();
        constructor(Name: string, FilmbackSettings: CameraFilmbackSettings);

        Name: string;
        FilmbackSettings: CameraFilmbackSettings;

        static StaticClass(): Class;
    }

    export class NamedLensPreset {
        constructor();
        constructor(Name: string, LensSettings: CameraLensSettings);

        Name: string;
        LensSettings: CameraLensSettings;

        static StaticClass(): Class;
    }

    export class CineCameraComponent extends CameraComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FilmbackSettings: CameraFilmbackSettings;
        Filmback: CameraFilmbackSettings;
        LensSettings: CameraLensSettings;
        FocusSettings: CameraFocusSettings;
        CurrentFocalLength: number;
        CurrentAperture: number;
        CurrentFocusDistance: number;
        CurrentHorizontalFOV: number;
        FocusPlaneVisualizationMesh: StaticMesh;
        FocusPlaneVisualizationMaterial: Material;
        DebugFocusPlaneComponent: StaticMeshComponent;
        DebugFocusPlaneMID: MaterialInstanceDynamic;
        FilmbackPresets: TArray<NamedFilmbackPreset>;
        LensPresets: TArray<NamedLensPreset>;
        DefaultFilmbackPresetName: string;
        DefaultFilmbackPreset: string;
        DefaultLensPresetName: string;
        DefaultLensFocalLength: number;
        DefaultLensFStop: number;

        GetDefaultFilmbackPresetName(): string;

        GetFilmbackPresetName(): string;

        GetHorizontalFieldOfView(): number;

        GetLensPresetName(): string;

        GetVerticalFieldOfView(): number;

        SetCurrentFocalLength(InFocalLength: number): void;

        SetFilmbackPresetByName(InPresetName: string): void;

        SetLensPresetByName(InPresetName: string): void;

        static GetFilmbackPresetsCopy(): TArray<NamedFilmbackPreset>;

        static GetLensPresetsCopy(): TArray<NamedLensPreset>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CineCameraComponent;

        static Load(InName: string): CineCameraComponent;
    }

    export class CineCameraActor extends CameraActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LookatTrackingSettings: CameraLookatTrackingSettings;

        GetCineCameraComponent(): CineCameraComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CineCameraActor;

        static Load(InName: string): CineCameraActor;
    }

    export class CircleSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumberOfPoints: number;
        Radius: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CircleSplineGenerator;

        static Load(InName: string): CircleSplineGenerator;
    }

    export class CircularThrobber extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumberOfPieces: number;
        Period: number;
        Radius: number;
        PieceImage: SlateBrushAsset;
        Image: SlateBrush;
        bEnableRadius: boolean;

        SetNumberOfPieces(InNumberOfPieces: number): void;

        SetPeriod(InPeriod: number): void;

        SetRadius(InRadius: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CircularThrobber;

        static Load(InName: string): CircularThrobber;
    }

    export class ObjectPropertyBase extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ObjectPropertyBase;

        static Load(InName: string): ObjectPropertyBase;
    }

    export class ObjectProperty extends ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ObjectProperty;

        static Load(InName: string): ObjectProperty;
    }

    export class ClassProperty extends ObjectProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClassProperty;

        static Load(InName: string): ClassProperty;
    }

    export class ClassTemplate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GeneratedBaseClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClassTemplate;

        static Load(InName: string): ClassTemplate;
    }

    export class ClassTemplateEditorSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClassTemplateEditorSubsystem;

        static Load(InName: string): ClassTemplateEditorSubsystem;
    }

    export class ClassThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClassThumbnailRenderer;

        static Load(InName: string): ClassThumbnailRenderer;
    }

    export class ClassVariableCreator extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClassVariableCreator;

        static Load(InName: string): ClassVariableCreator;
    }

    export class ClassViewerProjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InternalOnlyPaths: TArray<DirectoryPath>;
        InternalOnlyClasses: TArray<SoftClassPath>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClassViewerProjectSettings;

        static Load(InName: string): ClassViewerProjectSettings;
    }

    export enum EClassViewerDeveloperType { CVDT_None, CVDT_CurrentUser, CVDT_All, CVDT_Max, CVDT_MAX }

    export class ClassViewerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AllowedClasses: TArray<string>;
        DisplayInternalClasses: boolean;
        DeveloperFolderType: EClassViewerDeveloperType;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClassViewerSettings;

        static Load(InName: string): ClassViewerSettings;
    }

    export class ClickDragInputBehavior extends AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUpdateModifiersDuringDrag: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClickDragInputBehavior;

        static Load(InName: string): ClickDragInputBehavior;
    }

    export class ClickDragTool extends InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClickDragTool;

        static Load(InName: string): ClickDragTool;
    }

    export class InteractiveToolBuilder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveToolBuilder;

        static Load(InName: string): InteractiveToolBuilder;
    }

    export class ClickDragToolBuilder extends InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClickDragToolBuilder;

        static Load(InName: string): ClickDragToolBuilder;
    }

    export class ClothConfigBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothConfigBase;

        static Load(InName: string): ClothConfigBase;
    }

    export class ClothConfigCommon extends ClothConfigBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothConfigCommon;

        static Load(InName: string): ClothConfigCommon;
    }

    export enum EClothingWindMethodNv { Legacy, Accurate, EClothingWindMethodNv_MAX }

    export class ClothConstraintSetupNv {
        constructor();
        constructor(Stiffness: number, StiffnessMultiplier: number, StretchLimit: number, CompressionLimit: number);

        Stiffness: number;
        StiffnessMultiplier: number;
        StretchLimit: number;
        CompressionLimit: number;

        static StaticClass(): Class;
    }

    export enum EClothingWindMethod_Legacy { Legacy, Accurate, EClothingWindMethod_MAX }

    export class ClothConstraintSetup_Legacy {
        constructor();
        constructor(Stiffness: number, StiffnessMultiplier: number, StretchLimit: number, CompressionLimit: number);

        Stiffness: number;
        StiffnessMultiplier: number;
        StretchLimit: number;
        CompressionLimit: number;

        static StaticClass(): Class;
    }

    export class ClothConfigNv extends ClothConfigCommon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ClothingWindMethod: EClothingWindMethodNv;
        VerticalConstraint: ClothConstraintSetupNv;
        HorizontalConstraint: ClothConstraintSetupNv;
        BendConstraint: ClothConstraintSetupNv;
        ShearConstraint: ClothConstraintSetupNv;
        SelfCollisionRadius: number;
        SelfCollisionStiffness: number;
        SelfCollisionCullScale: number;
        Damping: Vector;
        Friction: number;
        WindDragCoefficient: number;
        WindLiftCoefficient: number;
        LinearDrag: Vector;
        AngularDrag: Vector;
        LinearInertiaScale: Vector;
        AngularInertiaScale: Vector;
        CentrifugalInertiaScale: Vector;
        SolverFrequency: number;
        StiffnessFrequency: number;
        GravityScale: number;
        GravityOverride: Vector;
        bUseGravityOverride: boolean;
        TetherStiffness: number;
        TetherLimit: number;
        CollisionThickness: number;
        AnimDriveSpringStiffness: number;
        AnimDriveDamperStiffness: number;
        WindMethod: EClothingWindMethod_Legacy;
        VerticalConstraintConfig: ClothConstraintSetup_Legacy;
        HorizontalConstraintConfig: ClothConstraintSetup_Legacy;
        BendConstraintConfig: ClothConstraintSetup_Legacy;
        ShearConstraintConfig: ClothConstraintSetup_Legacy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothConfigNv;

        static Load(InName: string): ClothConfigNv;
    }

    export class ClothVertBoneData {
        constructor();
        constructor(NumInfluences: number, BoneIndices: FixSizeArray<number>, BoneWeights: FixSizeArray<number>);

        NumInfluences: number;
        BoneIndices: FixSizeArray<number>;
        BoneWeights: FixSizeArray<number>;

        static StaticClass(): Class;
    }

    export class ClothPhysicalMeshDataBase_Legacy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Vertices: TArray<Vector>;
        Normals: TArray<Vector>;
        VertexColors: TArray<Color>;
        Indices: TArray<number>;
        InverseMasses: TArray<number>;
        BoneData: TArray<ClothVertBoneData>;
        NumFixedVerts: number;
        MaxBoneWeights: number;
        SelfCollisionIndices: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothPhysicalMeshDataBase_Legacy;

        static Load(InName: string): ClothPhysicalMeshDataBase_Legacy;
    }

    export class PointWeightMap {
        constructor();
        constructor(Values: TArray<number>, Name: string, CurrentTarget: number, bEnabled: boolean);

        Values: TArray<number>;
        Name: string;
        CurrentTarget: number;
        bEnabled: boolean;

        static StaticClass(): Class;
    }

    export class ClothPhysicalMeshData {
        constructor();
        constructor(Vertices: TArray<Vector>, Normals: TArray<Vector>, VertexColors: TArray<Color>, Indices: TArray<number>, WeightMaps: TMap<number, PointWeightMap>, InverseMasses: TArray<number>, BoneData: TArray<ClothVertBoneData>, MaxBoneWeights: number, NumFixedVerts: number, SelfCollisionIndices: TArray<number>, MaxDistances: TArray<number>, BackstopDistances: TArray<number>, BackstopRadiuses: TArray<number>, AnimDriveMultipliers: TArray<number>);

        Vertices: TArray<Vector>;
        Normals: TArray<Vector>;
        VertexColors: TArray<Color>;
        Indices: TArray<number>;
        WeightMaps: TMap<number, PointWeightMap>;
        InverseMasses: TArray<number>;
        BoneData: TArray<ClothVertBoneData>;
        MaxBoneWeights: number;
        NumFixedVerts: number;
        SelfCollisionIndices: TArray<number>;
        MaxDistances: TArray<number>;
        BackstopDistances: TArray<number>;
        BackstopRadiuses: TArray<number>;
        AnimDriveMultipliers: TArray<number>;

        static StaticClass(): Class;
    }

    export class ClothCollisionPrim_Sphere {
        constructor();
        constructor(BoneIndex: number, Radius: number, LocalPosition: Vector);

        BoneIndex: number;
        Radius: number;
        LocalPosition: Vector;

        static StaticClass(): Class;
    }

    export class ClothCollisionPrim_SphereConnection {
        constructor();
        constructor(SphereIndices: FixSizeArray<number>);

        SphereIndices: FixSizeArray<number>;

        static StaticClass(): Class;
    }

    export class ClothCollisionPrim_Convex {
        constructor();
        constructor(Planes: TArray<Plane>, SurfacePoints: TArray<Vector>, BoneIndex: number);

        Planes: TArray<Plane>;
        SurfacePoints: TArray<Vector>;
        BoneIndex: number;

        static StaticClass(): Class;
    }

    export class ClothCollisionPrim_Box {
        constructor();
        constructor(LocalPosition: Vector, LocalRotation: Quat, HalfExtents: Vector, BoneIndex: number);

        LocalPosition: Vector;
        LocalRotation: Quat;
        HalfExtents: Vector;
        BoneIndex: number;

        static StaticClass(): Class;
    }

    export class ClothCollisionData {
        constructor();
        constructor(Spheres: TArray<ClothCollisionPrim_Sphere>, SphereConnections: TArray<ClothCollisionPrim_SphereConnection>, Convexes: TArray<ClothCollisionPrim_Convex>, Boxes: TArray<ClothCollisionPrim_Box>);

        Spheres: TArray<ClothCollisionPrim_Sphere>;
        SphereConnections: TArray<ClothCollisionPrim_SphereConnection>;
        Convexes: TArray<ClothCollisionPrim_Convex>;
        Boxes: TArray<ClothCollisionPrim_Box>;

        static StaticClass(): Class;
    }

    export class ClothLODDataCommon_Legacy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicalMeshData: ClothPhysicalMeshDataBase_Legacy;
        ClothPhysicalMeshData: ClothPhysicalMeshData;
        CollisionData: ClothCollisionData;
        ParameterMasks: TArray<PointWeightMap>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothLODDataCommon_Legacy;

        static Load(InName: string): ClothLODDataCommon_Legacy;
    }

    export enum EWeightMapTargetCommon {
        None,
        MaxDistance,
        BackstopDistance,
        BackstopRadius,
        AnimDriveMultiplier,
        EWeightMapTargetCommon_MAX
    }

    export class ClothParameterMask_Legacy {
        constructor();
        constructor(MaskName: string, CurrentTarget: EWeightMapTargetCommon, MaxValue: number, MinValue: number, Values: TArray<number>, bEnabled: boolean);

        MaskName: string;
        CurrentTarget: EWeightMapTargetCommon;
        MaxValue: number;
        MinValue: number;
        Values: TArray<number>;
        bEnabled: boolean;

        static StaticClass(): Class;
    }

    export class ClothLODDataCommon {
        constructor();
        constructor(PhysicalMeshData: ClothPhysicalMeshData, CollisionData: ClothCollisionData, bUseMultipleInfluences: boolean, SkinningKernelRadius: number, ParameterMasks: TArray<ClothParameterMask_Legacy>, PointWeightMaps: TArray<PointWeightMap>);

        PhysicalMeshData: ClothPhysicalMeshData;
        CollisionData: ClothCollisionData;
        bUseMultipleInfluences: boolean;
        SkinningKernelRadius: number;
        ParameterMasks: TArray<ClothParameterMask_Legacy>;
        PointWeightMaps: TArray<PointWeightMap>;

        static StaticClass(): Class;
    }

    export class ClothingAssetCustomData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingAssetCustomData;

        static Load(InName: string): ClothingAssetCustomData;
    }

    export class ClothConfig_Legacy {
        constructor();
        constructor(WindMethod: EClothingWindMethod_Legacy, VerticalConstraintConfig: ClothConstraintSetup_Legacy, HorizontalConstraintConfig: ClothConstraintSetup_Legacy, BendConstraintConfig: ClothConstraintSetup_Legacy, ShearConstraintConfig: ClothConstraintSetup_Legacy, SelfCollisionRadius: number, SelfCollisionStiffness: number, SelfCollisionCullScale: number, Damping: Vector, Friction: number, WindDragCoefficient: number, WindLiftCoefficient: number, LinearDrag: Vector, AngularDrag: Vector, LinearInertiaScale: Vector, AngularInertiaScale: Vector, CentrifugalInertiaScale: Vector, SolverFrequency: number, StiffnessFrequency: number, GravityScale: number, GravityOverride: Vector, bUseGravityOverride: boolean, TetherStiffness: number, TetherLimit: number, CollisionThickness: number, AnimDriveSpringStiffness: number, AnimDriveDamperStiffness: number);

        WindMethod: EClothingWindMethod_Legacy;
        VerticalConstraintConfig: ClothConstraintSetup_Legacy;
        HorizontalConstraintConfig: ClothConstraintSetup_Legacy;
        BendConstraintConfig: ClothConstraintSetup_Legacy;
        ShearConstraintConfig: ClothConstraintSetup_Legacy;
        SelfCollisionRadius: number;
        SelfCollisionStiffness: number;
        SelfCollisionCullScale: number;
        Damping: Vector;
        Friction: number;
        WindDragCoefficient: number;
        WindLiftCoefficient: number;
        LinearDrag: Vector;
        AngularDrag: Vector;
        LinearInertiaScale: Vector;
        AngularInertiaScale: Vector;
        CentrifugalInertiaScale: Vector;
        SolverFrequency: number;
        StiffnessFrequency: number;
        GravityScale: number;
        GravityOverride: Vector;
        bUseGravityOverride: boolean;
        TetherStiffness: number;
        TetherLimit: number;
        CollisionThickness: number;
        AnimDriveSpringStiffness: number;
        AnimDriveDamperStiffness: number;

        static StaticClass(): Class;
    }

    export class ClothingAssetCommon extends ClothingAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicsAsset: PhysicsAsset;
        ClothConfigs: TMap<string, ClothConfigBase>;
        ClothSharedSimConfig: ClothConfigBase;
        ClothSimConfig: ClothConfigBase;
        ChaosClothSimConfig: ClothConfigBase;
        ClothLodData: TArray<ClothLODDataCommon_Legacy>;
        LodData: TArray<ClothLODDataCommon>;
        LodMap: TArray<number>;
        UsedBoneNames: TArray<string>;
        UsedBoneIndices: TArray<number>;
        ReferenceBoneIndex: number;
        CustomData: ClothingAssetCustomData;
        ClothConfig: ClothConfig_Legacy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingAssetCommon;

        static Load(InName: string): ClothingAssetCommon;
    }

    export class ClothingAssetFactoryBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingAssetFactoryBase;

        static Load(InName: string): ClothingAssetFactoryBase;
    }

    export class ClothingAssetFactory extends ClothingAssetFactoryBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingAssetFactory;

        static Load(InName: string): ClothingAssetFactory;
    }

    export class ClothingSimulationFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingSimulationFactory;

        static Load(InName: string): ClothingSimulationFactory;
    }

    export class ClothingSimulationFactoryNv extends ClothingSimulationFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingSimulationFactoryNv;

        static Load(InName: string): ClothingSimulationFactoryNv;
    }

    export class ClothingSimulationInteractorNv extends ClothingSimulationInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetAnimDriveDamperStiffness(InStiffness: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothingSimulationInteractorNv;

        static Load(InName: string): ClothingSimulationInteractorNv;
    }

    export class ClothMesh extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Meshes: TArray<Class>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothMesh;

        static Load(InName: string): ClothMesh;
    }

    export class ClothPhysicalMeshDataNv_Legacy extends ClothPhysicalMeshDataBase_Legacy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxDistances: TArray<number>;
        BackstopDistances: TArray<number>;
        BackstopRadiuses: TArray<number>;
        AnimDriveMultipliers: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothPhysicalMeshDataNv_Legacy;

        static Load(InName: string): ClothPhysicalMeshDataNv_Legacy;
    }

    export class ClothSharedConfigCommon extends ClothConfigCommon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothSharedConfigCommon;

        static Load(InName: string): ClothSharedConfigCommon;
    }

    export class ClothSharedSimConfigBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ClothSharedSimConfigBase;

        static Load(InName: string): ClothSharedSimConfigBase;
    }

    export enum EPlatformInterfaceDataType {
        PIDT_None,
        PIDT_Int,
        PIDT_Float,
        PIDT_String,
        PIDT_Object,
        PIDT_Custom,
        PIDT_MAX
    }

    export class PlatformInterfaceData {
        constructor();
        constructor(DataName: string, Type: EPlatformInterfaceDataType, IntValue: number, FloatValue: number, StringValue: string, ObjectValue: Object);

        DataName: string;
        Type: EPlatformInterfaceDataType;
        IntValue: number;
        FloatValue: number;
        StringValue: string;
        ObjectValue: Object;

        static StaticClass(): Class;
    }

    export class PlatformInterfaceDelegateResult {
        constructor();
        constructor(bSuccessful: boolean, Data: PlatformInterfaceData);

        bSuccessful: boolean;
        Data: PlatformInterfaceData;

        static StaticClass(): Class;
    }

    export class DelegateArray {
        constructor();
        constructor(Delegates: TArray<$Delegate<(Result: PlatformInterfaceDelegateResult) => void>>);

        Delegates: TArray<$Delegate<(Result: PlatformInterfaceDelegateResult) => void>>;

        static StaticClass(): Class;
    }

    export class PlatformInterfaceBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AllDelegates: TArray<DelegateArray>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlatformInterfaceBase;

        static Load(InName: string): PlatformInterfaceBase;
    }

    export class CloudStorageBase extends PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LocalCloudFiles: TArray<string>;
        bSuppressDelegateCalls: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CloudStorageBase;

        static Load(InName: string): CloudStorageBase;
    }

    export class CodeGenerator extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Gen(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CodeGenerator;

        static Load(InName: string): CodeGenerator;
    }

    export class CollisionResponseTemplate {
        constructor();
        constructor(Name: string, CollisionEnabled: ECollisionEnabled, bCanModify: boolean, ObjectTypeName: string, CustomResponses: TArray<ResponseChannel>, HelpMessage: string);

        Name: string;
        CollisionEnabled: ECollisionEnabled;
        bCanModify: boolean;
        ObjectTypeName: string;
        CustomResponses: TArray<ResponseChannel>;
        HelpMessage: string;

        static StaticClass(): Class;
    }

    export class CustomChannelSetup {
        constructor();
        constructor(Channel: ECollisionChannel, DefaultResponse: ECollisionResponse, bTraceType: boolean, bStaticObject: boolean, Name: string);

        Channel: ECollisionChannel;
        DefaultResponse: ECollisionResponse;
        bTraceType: boolean;
        bStaticObject: boolean;
        Name: string;

        static StaticClass(): Class;
    }

    export class CustomProfile {
        constructor();
        constructor(Name: string, CustomResponses: TArray<ResponseChannel>);

        Name: string;
        CustomResponses: TArray<ResponseChannel>;

        static StaticClass(): Class;
    }

    export class Redirector {
        constructor();
        constructor(OldName: string, NewName: string);

        OldName: string;
        NewName: string;

        static StaticClass(): Class;
    }

    export class CollisionProfile extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Profiles: TArray<CollisionResponseTemplate>;
        DefaultChannelResponses: TArray<CustomChannelSetup>;
        EditProfiles: TArray<CustomProfile>;
        ProfileRedirects: TArray<Redirector>;
        CollisionChannelRedirects: TArray<Redirector>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CollisionProfile;

        static Load(InName: string): CollisionProfile;
    }

    export class ColorBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetLinearValue(): LinearColor;

        GetSlateValue(): SlateColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ColorBinding;

        static Load(InName: string): ColorBinding;
    }

    export class CombMesh extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SkMesh: SkeletalMesh;

        Use(Com: $Nullable<SkeletalMeshComponent>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CombMesh;

        static Load(InName: string): CombMesh;
    }

    export class CombMeshComponent extends SkeletalMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CombMesh: CombMesh;
        ParentComponent: SceneComponent;

        GetParentComponent(): SceneComponent;

        SetCombMesh(combMesh: $Nullable<CombMesh>): void;

        SetParentComponent(InParentComponent: $Nullable<SceneComponent>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CombMeshComponent;

        static Load(InName: string): CombMeshComponent;
    }

    export class ComboBox extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Items: TArray<Object>;
        OnGenerateWidgetEvent: $Delegate<(Item: $Nullable<Object>) => Widget>;
        bIsFocusable: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ComboBox;

        static Load(InName: string): ComboBox;
    }

    export class ComboButtonStyle extends SlateWidgetStyle {
        constructor();
        constructor(ButtonStyle: ButtonStyle, DownArrowImage: SlateBrush, ShadowOffset: Vector2D, ShadowColorAndOpacity: LinearColor, MenuBorderBrush: SlateBrush, MenuBorderPadding: Margin);

        ButtonStyle: ButtonStyle;
        DownArrowImage: SlateBrush;
        ShadowOffset: Vector2D;
        ShadowColorAndOpacity: LinearColor;
        MenuBorderBrush: SlateBrush;
        MenuBorderPadding: Margin;

        static StaticClass(): Class;
    }

    export class ComboBoxStyle extends SlateWidgetStyle {
        constructor();
        constructor(ComboButtonStyle: ComboButtonStyle, PressedSlateSound: SlateSound, SelectionChangeSlateSound: SlateSound, PressedSound: string, SelectionChangeSound: string);

        ComboButtonStyle: ComboButtonStyle;
        PressedSlateSound: SlateSound;
        SelectionChangeSlateSound: SlateSound;
        PressedSound: string;
        SelectionChangeSound: string;

        static StaticClass(): Class;
    }

    export class TableRowStyle extends SlateWidgetStyle {
        constructor();
        constructor(SelectorFocusedBrush: SlateBrush, ActiveHoveredBrush: SlateBrush, ActiveBrush: SlateBrush, InactiveHoveredBrush: SlateBrush, InactiveBrush: SlateBrush, EvenRowBackgroundHoveredBrush: SlateBrush, EvenRowBackgroundBrush: SlateBrush, OddRowBackgroundHoveredBrush: SlateBrush, OddRowBackgroundBrush: SlateBrush, TextColor: SlateColor, SelectedTextColor: SlateColor, DropIndicator_Above: SlateBrush, DropIndicator_Onto: SlateBrush, DropIndicator_Below: SlateBrush, ActiveHighlightedBrush: SlateBrush, InactiveHighlightedBrush: SlateBrush);

        SelectorFocusedBrush: SlateBrush;
        ActiveHoveredBrush: SlateBrush;
        ActiveBrush: SlateBrush;
        InactiveHoveredBrush: SlateBrush;
        InactiveBrush: SlateBrush;
        EvenRowBackgroundHoveredBrush: SlateBrush;
        EvenRowBackgroundBrush: SlateBrush;
        OddRowBackgroundHoveredBrush: SlateBrush;
        OddRowBackgroundBrush: SlateBrush;
        TextColor: SlateColor;
        SelectedTextColor: SlateColor;
        DropIndicator_Above: SlateBrush;
        DropIndicator_Onto: SlateBrush;
        DropIndicator_Below: SlateBrush;
        ActiveHighlightedBrush: SlateBrush;
        InactiveHighlightedBrush: SlateBrush;

        static StaticClass(): Class;
    }

    export class FontOutlineSettings {
        constructor();
        constructor(OutlineSize: number, bSeparateFillAlpha: boolean, bApplyOutlineToDropShadows: boolean, OutlineMaterial: Object, OutlineColor: LinearColor);

        OutlineSize: number;
        bSeparateFillAlpha: boolean;
        bApplyOutlineToDropShadows: boolean;
        OutlineMaterial: Object;
        OutlineColor: LinearColor;

        static StaticClass(): Class;
    }

    export class SlateFontInfo {
        constructor();
        constructor(FontObject: Object, FontMaterial: Object, OutlineSettings: FontOutlineSettings, TypefaceFontName: string, Size: number, LetterSpacing: number, FontName: string, Hinting: EFontHinting);

        FontObject: Object;
        FontMaterial: Object;
        OutlineSettings: FontOutlineSettings;
        TypefaceFontName: string;
        Size: number;
        LetterSpacing: number;
        FontName: string;
        Hinting: EFontHinting;

        static StaticClass(): Class;
    }

    export enum ESelectInfo { OnKeyPress, OnNavigation, OnMouseClick, Direct, ESelectInfo_MAX }

    export class ComboBoxString extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultOptions: TArray<string>;
        SelectedOption: string;
        WidgetStyle: ComboBoxStyle;
        ItemStyle: TableRowStyle;
        ContentPadding: Margin;
        MaxListHeight: number;
        HasDownArrow: boolean;
        EnableGamepadNavigationMode: boolean;
        Font: SlateFontInfo;
        ForegroundColor: SlateColor;
        bIsFocusable: boolean;
        OnGenerateWidgetEvent: $Delegate<(Item: string) => Widget>;
        OnSelectionChanged: $MulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
        OnOpening: $MulticastDelegate<() => void>;

        AddOption(Option: string): void;

        ClearOptions(): void;

        ClearSelection(): void;

        FindOptionIndex(Option: string): number;

        GetOptionAtIndex(Index: number): string;

        GetOptionCount(): number;

        GetSelectedIndex(): number;

        GetSelectedOption(): string;

        IsOpen(): boolean;

        OnOpeningEvent__DelegateSignature(): void;

        OnSelectionChangedEvent__DelegateSignature(SelectedItem: string, SelectionType: ESelectInfo): void;

        RefreshOptions(): void;

        RemoveOption(Option: string): boolean;

        SetSelectedIndex(Index: number): void;

        SetSelectedOption(Option: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ComboBoxString;

        static Load(InName: string): ComboBoxString;
    }

    export class ComboBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ComboBoxStyle: ComboBoxStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ComboBoxWidgetStyle;

        static Load(InName: string): ComboBoxWidgetStyle;
    }

    export class ComboButtonWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ComboButtonStyle: ComboButtonStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ComboButtonWidgetStyle;

        static Load(InName: string): ComboButtonWidgetStyle;
    }

    export class CommonMesh extends CombMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseMasterPose: boolean;
        ParentSocketName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CommonMesh;

        static Load(InName: string): CommonMesh;
    }

    export class ToolMenuContextBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenuContextBase;

        static Load(InName: string): ToolMenuContextBase;
    }

    export class CommonResolutionMenuContext extends ToolMenuContextBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CommonResolutionMenuContext;

        static Load(InName: string): CommonResolutionMenuContext;
    }

    export class CompileAllBlueprintsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CompileAllBlueprintsCommandlet;

        static Load(InName: string): CompileAllBlueprintsCommandlet;
    }

    export class BlueprintComponentDelegateBinding {
        constructor();
        constructor(ComponentPropertyName: string, DelegatePropertyName: string, FunctionNameToBind: string);

        ComponentPropertyName: string;
        DelegatePropertyName: string;
        FunctionNameToBind: string;

        static StaticClass(): Class;
    }

    export class ComponentDelegateBinding extends DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ComponentDelegateBindings: TArray<BlueprintComponentDelegateBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ComponentDelegateBinding;

        static Load(InName: string): ComponentDelegateBinding;
    }

    export class CompositeCurveTable extends CurveTable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParentTables: TArray<CurveTable>;
        OldParentTables: TArray<CurveTable>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CompositeCurveTable;

        static Load(InName: string): CompositeCurveTable;
    }

    export class CompositeCurveTableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CompositeCurveTableFactory;

        static Load(InName: string): CompositeCurveTableFactory;
    }

    export class CompositeDataTable extends DataTable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParentTables: TArray<DataTable>;
        OldParentTables: TArray<DataTable>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CompositeDataTable;

        static Load(InName: string): CompositeDataTable;
    }

    export class DataTableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Struct: ScriptStruct;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DataTableFactory;

        static Load(InName: string): DataTableFactory;
    }

    export class CompositeDataTableFactory extends DataTableFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CompositeDataTableFactory;

        static Load(InName: string): CompositeDataTableFactory;
    }

    export class CompositionGraphCapturePasses {
        constructor();
        constructor(Value: TArray<string>);

        Value: TArray<string>;

        static StaticClass(): Class;
    }

    export enum EHDRCaptureGamut {
        HCGM_Rec709,
        HCGM_P3DCI,
        HCGM_Rec2020,
        HCGM_ACES,
        HCGM_ACEScg,
        HCGM_Linear,
        HCGM_MAX
    }

    export class CompositionGraphCaptureProtocol extends MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IncludeRenderPasses: CompositionGraphCapturePasses;
        bCaptureFramesInHDR: boolean;
        HDRCompressionQuality: number;
        CaptureGamut: EHDRCaptureGamut;
        PostProcessingMaterial: SoftObjectPath;
        bDisableScreenPercentage: boolean;
        PostProcessingMaterialPtr: MaterialInterface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CompositionGraphCaptureProtocol;

        static Load(InName: string): CompositionGraphCaptureProtocol;
    }

    export class CompressAnimationsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CompressAnimationsCommandlet;

        static Load(InName: string): CompressAnimationsCommandlet;
    }

    export class FrameGrabberProtocol extends MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FrameGrabberProtocol;

        static Load(InName: string): FrameGrabberProtocol;
    }

    export class ImageSequenceProtocol extends FrameGrabberProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol;

        static Load(InName: string): ImageSequenceProtocol;
    }

    export class CompressedImageSequenceProtocol extends ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CompressionQuality: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CompressedImageSequenceProtocol;

        static Load(InName: string): CompressedImageSequenceProtocol;
    }

    export class EditorBrushBuilder extends BrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorBrushBuilder;

        static Load(InName: string): EditorBrushBuilder;
    }

    export class ConeBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Z: number;
        CapZ: number;
        OuterRadius: number;
        InnerRadius: number;
        Sides: number;
        GroupName: string;
        AlignToSide: boolean;
        Hollow: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ConeBuilder;

        static Load(InName: string): ConeBuilder;
    }

    export class PropertyConfigFileDisplayRow extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConfigFileName: string;
        bIsFileWritable: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyConfigFileDisplayRow;

        static Load(InName: string): PropertyConfigFileDisplayRow;
    }

    export class ConfigHierarchyPropertyView extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConfigFilePropertyObjects: TArray<PropertyConfigFileDisplayRow>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ConfigHierarchyPropertyView;

        static Load(InName: string): ConfigHierarchyPropertyView;
    }

    export class ConnectionCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(ErrorCode: number) => void>;
        OnFailure: $MulticastDelegate<(ErrorCode: number) => void>;

        static ConnectToService(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>): ConnectionCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ConnectionCallbackProxy;

        static Load(InName: string): ConnectionCallbackProxy;
    }

    export class AutoCompleteCommand {
        constructor();
        constructor(Command: string, Desc: string);

        Command: string;
        Desc: string;

        static StaticClass(): Class;
    }

    export class ConsoleSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxScrollbackSize: number;
        ManualAutoCompleteList: TArray<AutoCompleteCommand>;
        AutoCompleteMapPaths: TArray<string>;
        BackgroundOpacityPercentage: number;
        bOrderTopToBottom: boolean;
        bDisplayHelpInAutoComplete: boolean;
        InputColor: Color;
        HistoryColor: Color;
        AutoCompleteCommandColor: Color;
        AutoCompleteCVarColor: Color;
        AutoCompleteFadedColor: Color;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ConsoleSettings;

        static Load(InName: string): ConsoleSettings;
    }

    export class ContentBrowserAddNewContextMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserAddNewContextMenuContext;

        static Load(InName: string): ContentBrowserAddNewContextMenuContext;
    }

    export class ContentBrowserAssetContextMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SelectedObjects: TArray<TWeakObjectPtr<Object>>;
        CommonClass: Class;
        bCanBeModified: boolean;

        GetSelectedObjects(): TArray<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserAssetContextMenuContext;

        static Load(InName: string): ContentBrowserAssetContextMenuContext;
    }

    export class ContentBrowserDataSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserDataSource;

        static Load(InName: string): ContentBrowserDataSource;
    }

    export class ContentBrowserAssetDataSource extends ContentBrowserDataSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserAssetDataSource;

        static Load(InName: string): ContentBrowserAssetDataSource;
    }

    export class ContentBrowserAssetViewContextMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserAssetViewContextMenuContext;

        static Load(InName: string): ContentBrowserAssetViewContextMenuContext;
    }

    export class ContentBrowserClassDataSource extends ContentBrowserDataSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserClassDataSource;

        static Load(InName: string): ContentBrowserClassDataSource;
    }

    export enum EContentBrowserDataMenuContext_AddNewMenuDomain {
        Toolbar,
        AssetView,
        PathView,
        EContentBrowserDataMenuContext_MAX
    }

    export class ContentBrowserDataMenuContext_AddNewMenu extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SelectedPaths: TArray<string>;
        OwnerDomain: EContentBrowserDataMenuContext_AddNewMenuDomain;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserDataMenuContext_AddNewMenu;

        static Load(InName: string): ContentBrowserDataMenuContext_AddNewMenu;
    }

    export class ContentBrowserItem {
        constructor();

        static StaticClass(): Class;
    }

    export class ContentBrowserDataMenuContext_DragDropMenu extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DropTargetItem: ContentBrowserItem;
        DraggedItems: TArray<ContentBrowserItem>;
        bCanMove: boolean;
        bCanCopy: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserDataMenuContext_DragDropMenu;

        static Load(InName: string): ContentBrowserDataMenuContext_DragDropMenu;
    }

    export class ContentBrowserDataMenuContext_FileMenu extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SelectedItems: TArray<ContentBrowserItem>;
        bCanBeModified: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserDataMenuContext_FileMenu;

        static Load(InName: string): ContentBrowserDataMenuContext_FileMenu;
    }

    export class ContentBrowserDataMenuContext_FolderMenu extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SelectedItems: TArray<ContentBrowserItem>;
        bCanBeModified: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserDataMenuContext_FolderMenu;

        static Load(InName: string): ContentBrowserDataMenuContext_FolderMenu;
    }

    export enum EContentBrowserItemTypeFilter {
        IncludeNone,
        IncludeFolders,
        IncludeFiles,
        IncludeAll,
        EContentBrowserItemTypeFilter_MAX
    }

    export enum EContentBrowserItemCategoryFilter {
        IncludeNone,
        IncludeAssets,
        IncludeClasses,
        IncludeCollections,
        IncludeMisc,
        IncludeAll,
        EContentBrowserItemCategoryFilter_MAX
    }

    export enum EContentBrowserItemAttributeFilter {
        IncludeNone,
        IncludeProject,
        IncludeEngine,
        IncludePlugins,
        IncludeDeveloper,
        IncludeLocalized,
        IncludeAll,
        EContentBrowserItemAttributeFilter_MAX
    }

    export class ContentBrowserDataFilter {
        constructor();
        constructor(bRecursivePaths: boolean, ItemTypeFilter: EContentBrowserItemTypeFilter, ItemCategoryFilter: EContentBrowserItemCategoryFilter, ItemAttributeFilter: EContentBrowserItemAttributeFilter);

        bRecursivePaths: boolean;
        ItemTypeFilter: EContentBrowserItemTypeFilter;
        ItemCategoryFilter: EContentBrowserItemCategoryFilter;
        ItemAttributeFilter: EContentBrowserItemAttributeFilter;

        static StaticClass(): Class;
    }

    export class ContentBrowserDataSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EnabledDataSources: TArray<string>;

        ActivateAllDataSources(): void;

        ActivateDataSource(Name: string): boolean;

        DeactivateAllDataSources(): void;

        DeactivateDataSource(Name: string): boolean;

        GetActiveDataSources(): TArray<string>;

        GetAvailableDataSources(): TArray<string>;

        GetItemAtPath(InPath: string, InItemTypeFilter: EContentBrowserItemTypeFilter): ContentBrowserItem;

        GetItemsAtPath(InPath: string, InItemTypeFilter: EContentBrowserItemTypeFilter): TArray<ContentBrowserItem>;

        GetItemsUnderPath(InPath: string, InFilter: ContentBrowserDataFilter): TArray<ContentBrowserItem>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserDataSubsystem;

        static Load(InName: string): ContentBrowserDataSubsystem;
    }

    export class ContentBrowserFolderContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCanBeModified: boolean;
        NumAssetPaths: number;
        NumClassPaths: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserFolderContext;

        static Load(InName: string): ContentBrowserFolderContext;
    }

    export class ContentBrowserFrontEndFilterExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserFrontEndFilterExtension;

        static Load(InName: string): ContentBrowserFrontEndFilterExtension;
    }

    export class ContentBrowserItemLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetDisplayName(Item: ContentBrowserItem): string;

        static GetVirtualPath(Item: ContentBrowserItem): string;

        static IsFile(Item: ContentBrowserItem): boolean;

        static IsFolder(Item: ContentBrowserItem): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserItemLibrary;

        static Load(InName: string): ContentBrowserItemLibrary;
    }

    export class ContentBrowserSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumObjectsToLoadBeforeWarning: number;
        bOpenSourcesPanelByDefault: boolean;
        RealTimeThumbnails: boolean;
        DisplayFolders: boolean;
        DisplayEmptyFolders: boolean;
        FilterRecursively: boolean;
        NumObjectsInRecentList: number;
        bShowFullCollectionNameInToolTip: boolean;
        bEnableRealtimeMaterialInstanceThumbnails: boolean;
        DisplayEngineFolder: boolean;
        DisplayDevelopersFolder: boolean;
        DisplayL10NFolder: boolean;
        DisplayPluginFolders: boolean;
        DisplayFavorites: boolean;
        DockCollections: boolean;
        DisplayCppFolders: boolean;
        IncludeClassNames: boolean;
        IncludeAssetPaths: boolean;
        IncludeCollectionNames: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ContentBrowserSettings;

        static Load(InName: string): ContentBrowserSettings;
    }

    export class ControlChannel extends Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ControlChannel;

        static Load(InName: string): ControlChannel;
    }

    export class ControlPointMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSelected: boolean;
        VirtualTextureMainPassMaxDrawDistance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ControlPointMeshComponent;

        static Load(InName: string): ControlPointMeshComponent;
    }

    export class ControlPointMeshActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ControlPointMeshComponent: ControlPointMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ControlPointMeshActor;

        static Load(InName: string): ControlPointMeshActor;
    }

    export class ConvertLevelsToExternalActorsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ConvertLevelsToExternalActorsCommandlet;

        static Load(InName: string): ConvertLevelsToExternalActorsCommandlet;
    }

    export class CookCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FullGCAssetClassNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CookCommandlet;

        static Load(InName: string): CookCommandlet;
    }

    export enum ECookProgressDisplayMode {
        Nothing,
        RemainingPackages,
        PackageNames,
        NamesAndRemainingPackages,
        Max,
        ECookProgressDisplayMode_MAX
    }

    export enum EBlueprintComponentDataCookingMethod {
        Disabled,
        AllBlueprints,
        EnabledBlueprintsOnly,
        EBlueprintComponentDataCookingMethod_MAX
    }

    export class CookerSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bEnableCookOnTheSide: boolean;
        bEnableBuildDDCInBackground: boolean;
        bIterativeCookingForLaunchOn: boolean;
        bIterativeCookingForFileCookContent: boolean;
        bCookOnTheFlyForLaunchOn: boolean;
        CookProgressDisplayMode: ECookProgressDisplayMode;
        bIgnoreIniSettingsOutOfDateForIteration: boolean;
        bIgnoreScriptPackagesOutOfDateForIteration: boolean;
        bCompileBlueprintsInDevelopmentMode: boolean;
        BlueprintComponentDataCookingMethod: EBlueprintComponentDataCookingMethod;
        ClassesExcludedOnDedicatedServer: TArray<string>;
        ModulesExcludedOnDedicatedServer: TArray<string>;
        ClassesExcludedOnDedicatedClient: TArray<string>;
        ModulesExcludedOnDedicatedClient: TArray<string>;
        VersionedIntRValues: TArray<string>;
        DefaultPVRTCQuality: number;
        DefaultASTCQualityBySpeed: number;
        DefaultASTCQualityBySize: number;
        bAllowCookedDataInEditorBuilds: boolean;
        bCookBlueprintComponentTemplateData: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CookerSettings;

        static Load(InName: string): CookerSettings;
    }

    export class CookerStats extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Assets: TArray<TWeakObjectPtr<Object>>;
        SizeBefore: number;
        SizeAfter: number;
        Path: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CookerStats;

        static Load(InName: string): CookerStats;
    }

    export class CookGlobalShadersCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CookGlobalShadersCommandlet;

        static Load(InName: string): CookGlobalShadersCommandlet;
    }

    export class CookGlobalShadersDeviceHelperBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CookGlobalShadersDeviceHelperBase;

        static Load(InName: string): CookGlobalShadersDeviceHelperBase;
    }

    export class CookGlobalShadersDeviceHelperStaged extends CookGlobalShadersDeviceHelperBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CookGlobalShadersDeviceHelperStaged;

        static Load(InName: string): CookGlobalShadersDeviceHelperStaged;
    }

    export class CookOnTheFlyServer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CookOnTheFlyServer;

        static Load(InName: string): CookOnTheFlyServer;
    }

    export class CrashReporterSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UploadSymbolsPath: string;
        DownstreamStorage: string;
        RemoteStorage: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CrashReporterSettings;

        static Load(InName: string): CrashReporterSettings;
    }

    export class CrashReportsPrivacySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSendUnattendedBugReports: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CrashReportsPrivacySettings;

        static Load(InName: string): CrashReportsPrivacySettings;
    }

    export class CreateSessionCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;

        static CreateSession(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, PublicConnections: number, bUseLAN: boolean): CreateSessionCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CreateSessionCallbackProxy;

        static Load(InName: string): CreateSessionCallbackProxy;
    }

    export class CrowdAgentInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CrowdAgentInterface;

        static Load(InName: string): CrowdAgentInterface;
    }

    export class CrowdFollowingComponent extends PathFollowingComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CrowdAgentMoveDirection: Vector;
        CharacterMovement: CharacterMovementComponent;
        AvoidanceGroup: NavAvoidanceMask;
        GroupsToAvoid: NavAvoidanceMask;
        GroupsToIgnore: NavAvoidanceMask;

        SuspendCrowdSteering(bSuspend: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CrowdFollowingComponent;

        static Load(InName: string): CrowdFollowingComponent;
    }

    export class CrowdManagerBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CrowdManagerBase;

        static Load(InName: string): CrowdManagerBase;
    }

    export class CrowdAvoidanceConfig {
        constructor();
        constructor(VelocityBias: number, DesiredVelocityWeight: number, CurrentVelocityWeight: number, SideBiasWeight: number, ImpactTimeWeight: number, ImpactTimeRange: number, CustomPatternIdx: number, AdaptiveDivisions: number, AdaptiveRings: number, AdaptiveDepth: number);

        VelocityBias: number;
        DesiredVelocityWeight: number;
        CurrentVelocityWeight: number;
        SideBiasWeight: number;
        ImpactTimeWeight: number;
        ImpactTimeRange: number;
        CustomPatternIdx: number;
        AdaptiveDivisions: number;
        AdaptiveRings: number;
        AdaptiveDepth: number;

        static StaticClass(): Class;
    }

    export class CrowdAvoidanceSamplingPattern {
        constructor();
        constructor(Angles: TArray<number>, Radii: TArray<number>);

        Angles: TArray<number>;
        Radii: TArray<number>;

        static StaticClass(): Class;
    }

    export class CrowdManager extends CrowdManagerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MyNavData: NavigationData;
        AvoidanceConfig: TArray<CrowdAvoidanceConfig>;
        SamplingPatterns: TArray<CrowdAvoidanceSamplingPattern>;
        MaxAgents: number;
        MaxAgentRadius: number;
        MaxAvoidedAgents: number;
        MaxAvoidedWalls: number;
        NavmeshCheckInterval: number;
        PathOptimizationInterval: number;
        SeparationDirClamp: number;
        PathOffsetRadiusMultiplier: number;
        bResolveCollisions: boolean;
        DebugDrawingWorld: World;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CrowdManager;

        static Load(InName: string): CrowdManager;
    }

    export enum ECSVImportType {
        ECSV_DataTable,
        ECSV_CurveTable,
        ECSV_CurveFloat,
        ECSV_CurveVector,
        ECSV_CurveLinearColor,
        ECSV_MAX
    }

    export class CSVImportSettings {
        constructor();
        constructor(ImportRowStruct: ScriptStruct, ImportType: ECSVImportType, ImportCurveInterpMode: ERichCurveInterpMode);

        ImportRowStruct: ScriptStruct;
        ImportType: ECSVImportType;
        ImportCurveInterpMode: ERichCurveInterpMode;

        static StaticClass(): Class;
    }

    export class CSVImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AutomatedImportSettings: CSVImportSettings;
        DataTableImportOptions: DataTable;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CSVImportFactory;

        static Load(InName: string): CSVImportFactory;
    }

    export class CubeBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: number;
        Y: number;
        Z: number;
        WallThickness: number;
        GroupName: string;
        Hollow: boolean;
        Tessellated: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CubeBuilder;

        static Load(InName: string): CubeBuilder;
    }

    export class CullDistanceSizePair {
        constructor();
        constructor(Size: number, CullDistance: number);

        Size: number;
        CullDistance: number;

        static StaticClass(): Class;
    }

    export class CullDistanceVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CullDistances: TArray<CullDistanceSizePair>;
        bEnabled: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CullDistanceVolume;

        static Load(InName: string): CullDistanceVolume;
    }

    export enum EFieldCullingOperationType {
        Field_Culling_Inside,
        Field_Culling_Outside,
        Field_Culling_Operation_Max,
        Field_Culling_MAX
    }

    export class CullingField extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Culling: FieldNodeBase;
        Field: FieldNodeBase;
        Operation: EFieldCullingOperationType;

        SetCullingField(Culling: $Nullable<FieldNodeBase>, Field: $Nullable<FieldNodeBase>, Operation: EFieldCullingOperationType): CullingField;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CullingField;

        static Load(InName: string): CullingField;
    }

    export class CurvedStairBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InnerRadius: number;
        StepHeight: number;
        StepWidth: number;
        AngleOfCurve: number;
        NumSteps: number;
        AddToFirstStep: number;
        GroupName: string;
        CounterClockwise: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurvedStairBuilder;

        static Load(InName: string): CurvedStairBuilder;
    }

    export class CurveEditorFilterBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorFilterBase;

        static Load(InName: string): CurveEditorFilterBase;
    }

    export class CurveEditorBakeFilter extends CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseSnapRateForInterval: boolean;
        BakeInterval: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorBakeFilter;

        static Load(InName: string): CurveEditorBakeFilter;
    }

    export class KeyPosition {
        constructor();
        constructor(InputValue: number, OutputValue: number);

        InputValue: number;
        OutputValue: number;

        static StaticClass(): Class;
    }

    export class KeyAttributes {
        constructor();
        constructor(bHasArriveTangent: boolean, bHasLeaveTangent: boolean, bHasInterpMode: boolean, bHasTangentMode: boolean, bHasTangentWeightMode: boolean, bHasArriveTangentWeight: boolean, bHasLeaveTangentWeight: boolean, ArriveTangent: number, LeaveTangent: number, InterpMode: ERichCurveInterpMode, TangentMode: ERichCurveTangentMode, TangentWeightMode: ERichCurveTangentWeightMode, ArriveTangentWeight: number, LeaveTangentWeight: number);

        bHasArriveTangent: boolean;
        bHasLeaveTangent: boolean;
        bHasInterpMode: boolean;
        bHasTangentMode: boolean;
        bHasTangentWeightMode: boolean;
        bHasArriveTangentWeight: boolean;
        bHasLeaveTangentWeight: boolean;
        ArriveTangent: number;
        LeaveTangent: number;
        InterpMode: ERichCurveInterpMode;
        TangentMode: ERichCurveTangentMode;
        TangentWeightMode: ERichCurveTangentWeightMode;
        ArriveTangentWeight: number;
        LeaveTangentWeight: number;

        static StaticClass(): Class;
    }

    export class CurveEditorCopyableCurveKeys extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        KeyPositions: TArray<KeyPosition>;
        KeyAttributes: TArray<KeyAttributes>;
        ShortDisplayName: string;
        LongDisplayName: string;
        IntentionName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorCopyableCurveKeys;

        static Load(InName: string): CurveEditorCopyableCurveKeys;
    }

    export class CurveEditorCopyBuffer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Curves: TArray<CurveEditorCopyableCurveKeys>;
        TimeOffset: number;
        bAbsolutePosition: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorCopyBuffer;

        static Load(InName: string): CurveEditorCopyBuffer;
    }

    export class CurveEditorEulerFilter extends CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorEulerFilter;

        static Load(InName: string): CurveEditorEulerFilter;
    }

    export enum ECurveEditorFFTFilterType { Lowpass, Highpass, ECurveEditorFFTFilterType_MAX }

    export enum ECurveEditorFFTFilterClass { Butterworth, Chebyshev, ECurveEditorFFTFilterClass_MAX }

    export class CurveEditorFFTFilter extends CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CutoffFrequency: number;
        Type: ECurveEditorFFTFilterType;
        Response: ECurveEditorFFTFilterClass;
        Order: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorFFTFilter;

        static Load(InName: string): CurveEditorFFTFilter;
    }

    export class CurveEditorKeyProxy extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorKeyProxy;

        static Load(InName: string): CurveEditorKeyProxy;
    }

    export class CurveEditorReduceFilter extends CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Tolerance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorReduceFilter;

        static Load(InName: string): CurveEditorReduceFilter;
    }

    export class CurveEditorRetimeAnchor {
        constructor();
        constructor(ValueInSeconds: number, bIsSelected: boolean);

        ValueInSeconds: number;
        bIsSelected: boolean;

        static StaticClass(): Class;
    }

    export class CurveEditorRetimeToolData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RetimingAnchors: TArray<CurveEditorRetimeAnchor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorRetimeToolData;

        static Load(InName: string): CurveEditorRetimeToolData;
    }

    export enum ECurveEditorTangentVisibility {
        AllTangents,
        SelectedKeys,
        NoTangents,
        ECurveEditorTangentVisibility_MAX
    }

    export enum ECurveEditorZoomPosition { CurrentTime, MousePosition, ECurveEditorZoomPosition_MAX }

    export class CurveEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoFrameCurveEditor: boolean;
        bShowCurveEditorCurveToolTips: boolean;
        TangentVisibility: ECurveEditorTangentVisibility;
        ZoomPosition: ECurveEditorZoomPosition;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEditorSettings;

        static Load(InName: string): CurveEditorSettings;
    }

    export class CurveEdOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MinViewRange: number;
        MaxViewRange: number;
        BackgroundColor: LinearColor;
        LabelColor: LinearColor;
        SelectedLabelColor: LinearColor;
        GridColor: LinearColor;
        GridTextColor: LinearColor;
        LabelBlockBkgColor: LinearColor;
        SelectedKeyColor: LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEdOptions;

        static Load(InName: string): CurveEdOptions;
    }

    export class CurveEdPresetCurve extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveEdPresetCurve;

        static Load(InName: string): CurveEdPresetCurve;
    }

    export class CurveFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurveClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveFactory;

        static Load(InName: string): CurveFactory;
    }

    export class CurveFloatFactory extends CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveFloatFactory;

        static Load(InName: string): CurveFloatFactory;
    }

    export class CurveImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveImportFactory;

        static Load(InName: string): CurveImportFactory;
    }

    export class CurveLinearColorAtlasFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Width: number;
        Height: number;
        Format: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveLinearColorAtlasFactory;

        static Load(InName: string): CurveLinearColorAtlasFactory;
    }

    export class CurveLinearColorFactory extends CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveLinearColorFactory;

        static Load(InName: string): CurveLinearColorFactory;
    }

    export class CurveLinearColorThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveLinearColorThumbnailRenderer;

        static Load(InName: string): CurveLinearColorThumbnailRenderer;
    }

    export class CurveVectorFactory extends CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CurveVectorFactory;

        static Load(InName: string): CurveVectorFactory;
    }

    export class CustomMeshTriangle {
        constructor();
        constructor(Vertex0: Vector, Vertex1: Vector, Vertex2: Vector);

        Vertex0: Vector;
        Vertex1: Vector;
        Vertex2: Vector;

        static StaticClass(): Class;
    }

    export class CustomMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddCustomMeshTriangles(Triangles: TArray<CustomMeshTriangle>): void;

        ClearCustomMeshTriangles(): void;

        SetCustomMeshTriangles(Triangles: TArray<CustomMeshTriangle>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CustomMeshComponent;

        static Load(InName: string): CustomMeshComponent;
    }

    export class CylinderBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Z: number;
        OuterRadius: number;
        InnerRadius: number;
        Sides: number;
        GroupName: string;
        AlignToSide: boolean;
        Hollow: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): CylinderBuilder;

        static Load(InName: string): CylinderBuilder;
    }

    export class DataAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DataAssetClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DataAssetFactory;

        static Load(InName: string): DataAssetFactory;
    }

    export class TableRowBase {
        constructor();

        static StaticClass(): Class;
    }

    export enum EEvaluateCurveTableResult { RowFound, RowNotFound, EEvaluateCurveTableResult_MAX }

    export class DataTableFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static DoesDataTableRowExist(Table: $Nullable<DataTable>, RowName: string): boolean;

        static EvaluateCurveTableRow(CurveTable: $Nullable<CurveTable>, RowName: string, InXY: number, OutResult: $Ref<EEvaluateCurveTableResult>, OutXY: $Ref<number>, ContextString: string): void;

        static FillDataTableFromCSVFile(DataTable: $Nullable<DataTable>, CSVFilePath: string): boolean;

        static FillDataTableFromCSVString(DataTable: $Nullable<DataTable>, CSVString: string): boolean;

        static FillDataTableFromJSONFile(DataTable: $Nullable<DataTable>, JSONFilePath: string, ImportRowStruct?: ScriptStruct /* = None */): boolean;

        static FillDataTableFromJSONString(DataTable: $Nullable<DataTable>, JSONString: string): boolean;

        static GetDataTableColumnAsString(DataTable: $Nullable<DataTable>, PropertyName: string): TArray<string>;

        static GetDataTableRowFromName(Table: $Nullable<DataTable>, RowName: string, OutRow: $Ref<TableRowBase>): boolean;

        static GetDataTableRowNames(Table: $Nullable<DataTable>, OutRowNames: $Ref<TArray<string>>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DataTableFunctionLibrary;

        static Load(InName: string): DataTableFunctionLibrary;
    }

    export class DDCCleanupCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DDCCleanupCommandlet;

        static Load(InName: string): DDCCleanupCommandlet;
    }

    export enum EViewModeIndex {
        VMI_BrushWireframe,
        VMI_Wireframe,
        VMI_Unlit,
        VMI_Lit,
        VMI_Lit_DetailLighting,
        VMI_LightingOnly,
        VMI_LightComplexity,
        VMI_ShaderComplexity,
        VMI_LightmapDensity,
        VMI_LitLightmapDensity,
        VMI_ReflectionOverride,
        VMI_VisualizeBuffer,
        VMI_StationaryLightOverlap,
        VMI_CollisionPawn,
        VMI_CollisionVisibility,
        VMI_LODColoration,
        VMI_QuadOverdraw,
        VMI_PrimitiveDistanceAccuracy,
        VMI_MeshUVDensityAccuracy,
        VMI_ShaderComplexityWithQuadOverdraw,
        VMI_HLODColoration,
        VMI_GroupLODColoration,
        VMI_MaterialTextureScaleAccuracy,
        VMI_RequiredTextureResolution,
        VMI_PathTracing,
        VMI_RayTracingDebug,
        VMI_Max,
        VMI_Unknown,
        VMI_MAX
    }

    export class DebugCameraControllerSettingsViewModeIndex {
        constructor();
        constructor(ViewModeIndex: EViewModeIndex);

        ViewModeIndex: EViewModeIndex;

        static StaticClass(): Class;
    }

    export class DebugCameraControllerSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CycleViewModes: TArray<DebugCameraControllerSettingsViewModeIndex>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DebugCameraControllerSettings;

        static Load(InName: string): DebugCameraControllerSettings;
    }

    export class DebugCameraHUD extends HUD {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DebugCameraHUD;

        static Load(InName: string): DebugCameraHUD;
    }

    export class DebugDrawService extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DebugDrawService;

        static Load(InName: string): DebugDrawService;
    }

    export class DebugSkelMeshComponent extends SkeletalMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bRenderRawSkeleton: boolean;
        bDrawMesh: boolean;
        bShowBoneNames: boolean;
        bDrawBoneInfluences: boolean;
        bDrawMorphTargetVerts: boolean;
        bDrawNormals: boolean;
        bDrawTangents: boolean;
        bDrawBinormals: boolean;
        bDrawSockets: boolean;
        bSkeletonSocketsVisible: boolean;
        bMeshSocketsVisible: boolean;
        bDisplayRawAnimation: boolean;
        bDisplayNonRetargetedPose: boolean;
        bDisplayAdditiveBasePose: boolean;
        bDisplayBakedAnimation: boolean;
        bDisplaySourceAnimation: boolean;
        bDisplayBound: boolean;
        bDisplayVertexColors: boolean;
        bPreviewRootMotion: boolean;
        bShowClothData: boolean;
        MinClothPropertyView: number;
        MaxClothPropertyView: number;
        ClothMeshOpacity: number;
        bClothFlipNormal: boolean;
        bClothCullBackface: boolean;
        bRequiredBonesUpToDateDuringTick: boolean;
        BonesOfInterest: TArray<number>;
        MorphTargetOfInterests: TArray<MorphTarget>;
        SkelMaterials: TArray<MaterialInterface>;
        PreviewInstance: AnimPreviewInstance;
        SavedAnimScriptInstance: AnimInstance;
        bIsUsingInGameBounds: boolean;
        bIsUsingPreSkinnedBounds: boolean;
        bPerformSingleClothingTick: boolean;
        bPauseClothingSimulationWithAnim: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DebugSkelMeshComponent;

        static Load(InName: string): DebugSkelMeshComponent;
    }

    export class DecalComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DecalMaterial: MaterialInterface;
        SortOrder: number;
        FadeScreenSize: number;
        FadeStartDelay: number;
        FadeDuration: number;
        FadeInDuration: number;
        FadeInStartDelay: number;
        bDestroyOwnerAfterFade: boolean;
        DecalSize: Vector;

        CreateDynamicMaterialInstance(): MaterialInstanceDynamic;

        GetDecalMaterial(): MaterialInterface;

        GetFadeDuration(): number;

        GetFadeInDuration(): number;

        GetFadeInStartDelay(): number;

        GetFadeStartDelay(): number;

        SetDecalMaterial(NewDecalMaterial: $Nullable<MaterialInterface>): void;

        SetFadeIn(StartDelay: number, Duaration: number): void;

        SetFadeOut(StartDelay: number, Duration: number, DestroyOwnerAfterFade?: boolean /* = true */): void;

        SetFadeScreenSize(NewFadeScreenSize: number): void;

        SetSortOrder(Value: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DecalComponent;

        static Load(InName: string): DecalComponent;
    }

    export class DecalActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Decal: DecalComponent;
        ArrowComponent: ArrowComponent;
        SpriteComponent: BillboardComponent;
        BoxComponent: BoxComponent;

        CreateDynamicMaterialInstance(): MaterialInstanceDynamic;

        GetDecalMaterial(): MaterialInterface;

        SetDecalMaterial(NewDecalMaterial: $Nullable<MaterialInterface>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DecalActor;

        static Load(InName: string): DecalActor;
    }

    export class DEditorParameterValue extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bOverride: boolean;
        ParameterInfo: MaterialParameterInfo;
        ExpressionId: Guid;
        SortPriority: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorParameterValue;

        static Load(InName: string): DEditorParameterValue;
    }

    export class DFontParameters {
        constructor();
        constructor(FontValue: Font, FontPage: number);

        FontValue: Font;
        FontPage: number;

        static StaticClass(): Class;
    }

    export class DEditorFontParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterValue: DFontParameters;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorFontParameterValue;

        static Load(InName: string): DEditorFontParameterValue;
    }

    export class DEditorMaterialLayersParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterValue: MaterialLayersFunctions;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorMaterialLayersParameterValue;

        static Load(InName: string): DEditorMaterialLayersParameterValue;
    }

    export class DEditorRuntimeVirtualTextureParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterValue: RuntimeVirtualTexture;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorRuntimeVirtualTextureParameterValue;

        static Load(InName: string): DEditorRuntimeVirtualTextureParameterValue;
    }

    export class ScalarParameterAtlasData {
        constructor();
        constructor(bIsUsedAsAtlasPosition: boolean, Curve: TSoftObjectPtr<CurveLinearColor>, Atlas: TSoftObjectPtr<CurveLinearColorAtlas>);

        bIsUsedAsAtlasPosition: boolean;
        Curve: TSoftObjectPtr<CurveLinearColor>;
        Atlas: TSoftObjectPtr<CurveLinearColorAtlas>;

        static StaticClass(): Class;
    }

    export class DEditorScalarParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterValue: number;
        AtlasData: ScalarParameterAtlasData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorScalarParameterValue;

        static Load(InName: string): DEditorScalarParameterValue;
    }

    export class DComponentMaskParameter {
        constructor();
        constructor(R: boolean, G: boolean, B: boolean, A: boolean);

        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;

        static StaticClass(): Class;
    }

    export class DEditorStaticComponentMaskParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterValue: DComponentMaskParameter;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorStaticComponentMaskParameterValue;

        static Load(InName: string): DEditorStaticComponentMaskParameterValue;
    }

    export class DEditorStaticSwitchParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterValue: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorStaticSwitchParameterValue;

        static Load(InName: string): DEditorStaticSwitchParameterValue;
    }

    export class DEditorTextureParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterValue: Texture;
        ChannelNames: ParameterChannelNames;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorTextureParameterValue;

        static Load(InName: string): DEditorTextureParameterValue;
    }

    export class DEditorVectorParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterValue: LinearColor;
        bIsUsedAsChannelMask: boolean;
        ChannelNames: ParameterChannelNames;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DEditorVectorParameterValue;

        static Load(InName: string): DEditorVectorParameterValue;
    }

    export class Default_AnimBlueprint_C extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UberGraphFrame: PointerToUberGraphFrame;
        AnimGraphNode_Root: AnimNode_Root;
        AnimGraphNode_SequencePlayer: AnimNode_SequencePlayer;
        AnimGraphNode_Slot: AnimNode_Slot;

        AnimGraph(AnimGraph: $Ref<PoseLink>): void;

        ExecuteUbergraph_Default_AnimBlueprint(EntryPoint: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Default_AnimBlueprint_C;

        static Load(InName: string): Default_AnimBlueprint_C;
    }

    export class DefaultLevelSequenceInstanceData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TransformOriginActor: Actor;
        TransformOrigin: Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DefaultLevelSequenceInstanceData;

        static Load(InName: string): DefaultLevelSequenceInstanceData;
    }

    export class DefaultPhysicsVolume extends PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DefaultPhysicsVolume;

        static Load(InName: string): DefaultPhysicsVolume;
    }

    export class LocalizedTemplateString {
        constructor();
        constructor(Language: string, Text: string);

        Language: string;
        Text: string;

        static StaticClass(): Class;
    }

    export class TemplateFolderRename {
        constructor();
        constructor(From: string, To: string);

        From: string;
        To: string;

        static StaticClass(): Class;
    }

    export class TemplateReplacement {
        constructor();
        constructor(Extensions: TArray<string>, From: string, To: string, bCaseSensitive: boolean);

        Extensions: TArray<string>;
        From: string;
        To: string;
        bCaseSensitive: boolean;

        static StaticClass(): Class;
    }

    export enum ETemplateSetting {
        Languages,
        HardwareTarget,
        GraphicsPreset,
        StarterContent,
        XR,
        Raytracing,
        All,
        ETemplateSetting_MAX
    }

    export enum EFeaturePackDetailLevel { Standard, High, EFeaturePackDetailLevel_MAX }

    export class FeaturePackLevelSet {
        constructor();
        constructor(DetailLevels: TArray<EFeaturePackDetailLevel>, MountName: string);

        DetailLevels: TArray<EFeaturePackDetailLevel>;
        MountName: string;

        static StaticClass(): Class;
    }

    export class TemplateProjectDefs extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LocalizedDisplayNames: TArray<LocalizedTemplateString>;
        LocalizedDescriptions: TArray<LocalizedTemplateString>;
        FoldersToIgnore: TArray<string>;
        FilesToIgnore: TArray<string>;
        FolderRenames: TArray<TemplateFolderRename>;
        FilenameReplacements: TArray<TemplateReplacement>;
        ReplacementsInFiles: TArray<TemplateReplacement>;
        SortKey: string;
        Categories: TArray<string>;
        ClassTypes: string;
        AssetTypes: string;
        bAllowProjectCreation: boolean;
        bIsEnterprise: boolean;
        bIsBlank: boolean;
        HiddenSettings: TArray<ETemplateSetting>;
        PacksToInclude: TArray<string>;
        EditDetailLevelPreference: EFeaturePackDetailLevel;
        SharedContentPacks: TArray<FeaturePackLevelSet>;
        StarterContent: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TemplateProjectDefs;

        static Load(InName: string): TemplateProjectDefs;
    }

    export class DefaultTemplateProjectDefs extends TemplateProjectDefs {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DefaultTemplateProjectDefs;

        static Load(InName: string): DefaultTemplateProjectDefs;
    }

    export class DelegateFunction extends Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DelegateFunction;

        static Load(InName: string): DelegateFunction;
    }

    export class DelegateProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DelegateProperty;

        static Load(InName: string): DelegateProperty;
    }

    export class DemoNetConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DemoNetConnection;

        static Load(InName: string): DemoNetConnection;
    }

    export class PendingNetGame extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NetDriver: NetDriver;
        DemoNetDriver: DemoNetDriver;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PendingNetGame;

        static Load(InName: string): PendingNetGame;
    }

    export class DemoPendingNetGame extends PendingNetGame {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DemoPendingNetGame;

        static Load(InName: string): DemoPendingNetGame;
    }

    export class DerivedDataCacheCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DerivedDataCacheCommandlet;

        static Load(InName: string): DerivedDataCacheCommandlet;
    }

    export class DestroySessionCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;

        static DestroySession(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>): DestroySessionCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DestroySessionCallbackProxy;

        static Load(InName: string): DestroySessionCallbackProxy;
    }

    export class DestructibleInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DestructibleInterface;

        static Load(InName: string): DestructibleInterface;
    }

    export class PropertyViewBase extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LazyObject: TLazyObjectPtr<Object>;
        SoftObjectPath: SoftObjectPath;
        bAutoLoadAsset: boolean;
        OnPropertyChanged: $MulticastDelegate<(PropertyName: string) => void>;

        GetObject(): Object;

        SetObject(NewObject: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyViewBase;

        static Load(InName: string): PropertyViewBase;
    }

    export class DetailsView extends PropertyViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAllowFiltering: boolean;
        bAllowFavoriteSystem: boolean;
        bShowModifiedPropertiesOption: boolean;
        bShowKeyablePropertiesOption: boolean;
        bShowAnimatedPropertiesOption: boolean;
        ColumnWidth: number;
        bShowScrollBar: boolean;
        bForceHiddenPropertyVisibility: boolean;
        ViewIdentifier: string;
        CategoriesToShow: TArray<string>;
        PropertiesToShow: TArray<string>;
        bShowOnlyWhitelisted: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DetailsView;

        static Load(InName: string): DetailsView;
    }

    export class DetourCrowdAIController extends AIController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DetourCrowdAIController;

        static Load(InName: string): DetourCrowdAIController;
    }

    export class TextureLODGroup {
        constructor();
        constructor(Group: TextureGroup, LODBias: number, LODBias_Smaller: number, LODBias_Smallest: number, NumStreamedMips: number, MipGenSettings: TextureMipGenSettings, MinLODSize: number, MaxLODSize: number, MaxLODSize_Smaller: number, MaxLODSize_Smallest: number, OptionalLODBias: number, OptionalMaxLODSize: number, MinMagFilter: string, MipFilter: string, MipLoadOptions: ETextureMipLoadOptions, DuplicateNonOptionalMips: boolean, Downscale: number, DownscaleOptions: ETextureDownscaleOptions, VirtualTextureTileCountBias: number, VirtualTextureTileSizeBias: number);

        Group: TextureGroup;
        LODBias: number;
        LODBias_Smaller: number;
        LODBias_Smallest: number;
        NumStreamedMips: number;
        MipGenSettings: TextureMipGenSettings;
        MinLODSize: number;
        MaxLODSize: number;
        MaxLODSize_Smaller: number;
        MaxLODSize_Smallest: number;
        OptionalLODBias: number;
        OptionalMaxLODSize: number;
        MinMagFilter: string;
        MipFilter: string;
        MipLoadOptions: ETextureMipLoadOptions;
        DuplicateNonOptionalMips: boolean;
        Downscale: number;
        DownscaleOptions: ETextureDownscaleOptions;
        VirtualTextureTileCountBias: number;
        VirtualTextureTileSizeBias: number;

        static StaticClass(): Class;
    }

    export class TextureLODSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureLODGroups: TArray<TextureLODGroup>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureLODSettings;

        static Load(InName: string): TextureLODSettings;
    }

    export class DeviceProfile extends TextureLODSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DeviceType: string;
        BaseProfileName: string;
        Parent: Object;
        CVars: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DeviceProfile;

        static Load(InName: string): DeviceProfile;
    }

    export class DeviceProfileFragment extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DeviceProfileFragment;

        static Load(InName: string): DeviceProfileFragment;
    }

    export class DeviceProfileManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Profiles: TArray<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DeviceProfileManager;

        static Load(InName: string): DeviceProfileManager;
    }

    export class DialogueSoundWaveProxy extends SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DialogueSoundWaveProxy;

        static Load(InName: string): DialogueSoundWaveProxy;
    }

    export enum EGrammaticalGender { Neuter, Masculine, Feminine, Mixed, EGrammaticalGender_MAX }

    export enum EGrammaticalNumber { Singular, Plural, EGrammaticalNumber_MAX }

    export class DialogueVoice extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Gender: EGrammaticalGender;
        Plurality: EGrammaticalNumber;
        LocalizationGUID: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DialogueVoice;

        static Load(InName: string): DialogueVoice;
    }

    export class DialogueVoiceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DialogueVoiceFactory;

        static Load(InName: string): DialogueVoiceFactory;
    }

    export class DialogueContext {
        constructor();
        constructor(Speaker: DialogueVoice, Targets: TArray<DialogueVoice>);

        Speaker: DialogueVoice;
        Targets: TArray<DialogueVoice>;

        static StaticClass(): Class;
    }

    export class DialogueContextMapping {
        constructor();
        constructor(Context: DialogueContext, SoundWave: SoundWave, LocalizationKeyFormat: string, Proxy: DialogueSoundWaveProxy);

        Context: DialogueContext;
        SoundWave: SoundWave;
        LocalizationKeyFormat: string;
        Proxy: DialogueSoundWaveProxy;

        static StaticClass(): Class;
    }

    export class DialogueWave extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bMature: boolean;
        bOverride_SubtitleOverride: boolean;
        SpokenText: string;
        SubtitleOverride: string;
        VoiceActorDirection: string;
        ContextMappings: TArray<DialogueContextMapping>;
        LocalizationGUID: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DialogueWave;

        static Load(InName: string): DialogueWave;
    }

    export class DialogueWaveFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialSoundWave: SoundWave;
        InitialSpeakerVoice: DialogueVoice;
        HasSetInitialTargetVoice: boolean;
        InitialTargetVoices: TArray<DialogueVoice>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DialogueWaveFactory;

        static Load(InName: string): DialogueWaveFactory;
    }

    export class DiffAssetRegistriesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssetRegistrySearchPath: TArray<string>;
        P4Repository: string;
        P4EngineBasePath: string;
        P4EngineAssetPath: string;
        P4GameBasePath: string;
        P4GameAssetPath: string;
        RegexBranchCL: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DiffAssetRegistriesCommandlet;

        static Load(InName: string): DiffAssetRegistriesCommandlet;
    }

    export class DiffAssetsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DiffAssetsCommandlet;

        static Load(InName: string): DiffAssetsCommandlet;
    }

    export class DiffFilesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DiffFilesCommandlet;

        static Load(InName: string): DiffFilesCommandlet;
    }

    export class DiffPackagesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Packages: FixSizeArray<Package>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DiffPackagesCommandlet;

        static Load(InName: string): DiffPackagesCommandlet;
    }

    export class TextureLightProfile extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Brightness: number;
        TextureMultiplier: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureLightProfile;

        static Load(InName: string): TextureLightProfile;
    }

    export class LightComponent extends LightComponentBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Temperature: number;
        MaxDrawDistance: number;
        MaxDistanceFadeRange: number;
        bUseTemperature: boolean;
        ShadowMapChannel: number;
        MinRoughness: number;
        SpecularScale: number;
        ShadowResolutionScale: number;
        ShadowBias: number;
        ShadowSlopeBias: number;
        ShadowSharpen: number;
        ContactShadowLength: number;
        ContactShadowLengthInWS: boolean;
        InverseSquaredFalloff: boolean;
        CastTranslucentShadows: boolean;
        bCastShadowsFromCinematicObjectsOnly: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bForceCachedShadowsForMovablePrimitives: boolean;
        LightingChannels: LightingChannels;
        LightFunctionMaterial: MaterialInterface;
        LightFunctionScale: Vector;
        IESTexture: TextureLightProfile;
        bUseIESBrightness: boolean;
        IESBrightnessScale: number;
        LightFunctionFadeDistance: number;
        DisabledBrightness: number;
        bEnableLightShaftBloom: boolean;
        BloomScale: number;
        BloomThreshold: number;
        BloomMaxBrightness: number;
        BloomTint: Color;
        bUseRayTracedDistanceFieldShadows: boolean;
        RayStartOffsetDepthScale: number;

        SetAffectDynamicIndirectLighting(bNewValue: boolean): void;

        SetAffectTranslucentLighting(bNewValue: boolean): void;

        SetBloomMaxBrightness(NewValue: number): void;

        SetBloomScale(NewValue: number): void;

        SetBloomThreshold(NewValue: number): void;

        SetBloomTint(NewValue: Color): void;

        SetEnableLightShaftBloom(bNewValue: boolean): void;

        SetForceCachedShadowsForMovablePrimitives(bNewValue: boolean): void;

        SetIESBrightnessScale(NewValue: number): void;

        SetIESTexture(NewValue: $Nullable<TextureLightProfile>): void;

        SetIndirectLightingIntensity(NewIntensity: number): void;

        SetIntensity(NewIntensity: number): void;

        SetLightColor(NewLightColor: LinearColor, bSRGB?: boolean /* = true */): void;

        SetLightFunctionDisabledBrightness(NewValue: number): void;

        SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number): void;

        SetLightFunctionMaterial(NewLightFunctionMaterial: $Nullable<MaterialInterface>): void;

        SetLightFunctionScale(NewLightFunctionScale: Vector): void;

        SetLightingChannels(bChannel0: boolean, bChannel1: boolean, bChannel2: boolean): void;

        SetShadowBias(NewValue: number): void;

        SetShadowSlopeBias(NewValue: number): void;

        SetSpecularScale(NewValue: number): void;

        SetTemperature(NewTemperature: number): void;

        SetTransmission(bNewValue: boolean): void;

        SetUseIESBrightness(bNewValue: boolean): void;

        SetVolumetricScatteringIntensity(NewIntensity: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightComponent;

        static Load(InName: string): LightComponent;
    }

    export class Light extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LightComponent: LightComponent;
        bEnabled: boolean;

        GetBrightness(): number;

        GetLightColor(): LinearColor;

        IsEnabled(): boolean;

        OnRep_bEnabled(): void;

        SetAffectTranslucentLighting(bNewValue: boolean): void;

        SetBrightness(NewBrightness: number): void;

        SetCastShadows(bNewValue: boolean): void;

        SetEnabled(bSetEnabled: boolean): void;

        SetLightColor(NewLightColor: LinearColor): void;

        SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number): void;

        SetLightFunctionMaterial(NewLightFunctionMaterial: $Nullable<MaterialInterface>): void;

        SetLightFunctionScale(NewLightFunctionScale: Vector): void;

        ToggleEnabled(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Light;

        static Load(InName: string): Light;
    }

    export class LightmassLightSettings {
        constructor();
        constructor(IndirectLightingSaturation: number, ShadowExponent: number, bUseAreaShadowsForStationaryLight: boolean);

        IndirectLightingSaturation: number;
        ShadowExponent: number;
        bUseAreaShadowsForStationaryLight: boolean;

        static StaticClass(): Class;
    }

    export class LightmassDirectionalLightSettings extends LightmassLightSettings {
        constructor();
        constructor(LightSourceAngle: number);

        LightSourceAngle: number;

        static StaticClass(): Class;
    }

    export class DirectionalLightComponent extends LightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShadowCascadeBiasDistribution: number;
        bEnableLightShaftOcclusion: boolean;
        OcclusionMaskDarkness: number;
        OcclusionDepthRange: number;
        LightShaftOverrideDirection: Vector;
        WholeSceneDynamicShadowRadius: number;
        DynamicShadowDistanceMovableLight: number;
        DynamicShadowDistanceStationaryLight: number;
        DynamicShadowCascades: number;
        CascadeDistributionExponent: number;
        CascadeTransitionFraction: number;
        ShadowDistanceFadeoutFraction: number;
        bUseInsetShadowsForMovableObjects: boolean;
        FarShadowCascadeCount: number;
        FarShadowDistance: number;
        DistanceFieldShadowDistance: number;
        LightSourceAngle: number;
        LightSourceSoftAngle: number;
        ShadowSourceAngleFactor: number;
        TraceDistance: number;
        bUsedAsAtmosphereSunLight: boolean;
        AtmosphereSunLightIndex: number;
        AtmosphereSunDiskColorScale: LinearColor;
        bPerPixelAtmosphereTransmittance: boolean;
        bCastShadowsOnClouds: boolean;
        bCastShadowsOnAtmosphere: boolean;
        bCastCloudShadows: boolean;
        CloudShadowStrength: number;
        CloudShadowOnAtmosphereStrength: number;
        CloudShadowOnSurfaceStrength: number;
        CloudShadowDepthBias: number;
        CloudShadowExtent: number;
        CloudShadowMapResolutionScale: number;
        CloudShadowRaySampleCountScale: number;
        CloudScatteredLuminanceScale: LinearColor;
        LightmassSettings: LightmassDirectionalLightSettings;
        bCastModulatedShadows: boolean;
        ModulatedShadowColor: Color;
        ShadowAmount: number;

        SetAtmosphereSunLight(bNewValue: boolean): void;

        SetAtmosphereSunLightIndex(NewValue: number): void;

        SetCascadeDistributionExponent(NewValue: number): void;

        SetCascadeTransitionFraction(NewValue: number): void;

        SetDynamicShadowCascades(NewValue: number): void;

        SetDynamicShadowDistanceMovableLight(NewValue: number): void;

        SetDynamicShadowDistanceStationaryLight(NewValue: number): void;

        SetEnableLightShaftOcclusion(bNewValue: boolean): void;

        SetLightShaftOverrideDirection(NewValue: Vector): void;

        SetOcclusionMaskDarkness(NewValue: number): void;

        SetShadowAmount(NewValue: number): void;

        SetShadowDistanceFadeoutFraction(NewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DirectionalLightComponent;

        static Load(InName: string): DirectionalLightComponent;
    }

    export class DirectionalLight extends Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ArrowComponent: ArrowComponent;
        DirectionalLightComponent: DirectionalLightComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DirectionalLight;

        static Load(InName: string): DirectionalLight;
    }

    export class DistributionFloatConstant extends DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Constant: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionFloatConstant;

        static Load(InName: string): DistributionFloatConstant;
    }

    export class DistributionFloatConstantCurve extends DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstantCurve: InterpCurveFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionFloatConstantCurve;

        static Load(InName: string): DistributionFloatConstantCurve;
    }

    export enum DistributionParamMode { DPM_Normal, DPM_Abs, DPM_Direct, DPM_MAX }

    export class DistributionFloatParameterBase extends DistributionFloatConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterName: string;
        MinInput: number;
        MaxInput: number;
        MinOutput: number;
        MaxOutput: number;
        ParamMode: DistributionParamMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionFloatParameterBase;

        static Load(InName: string): DistributionFloatParameterBase;
    }

    export class DistributionFloatParticleParameter extends DistributionFloatParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionFloatParticleParameter;

        static Load(InName: string): DistributionFloatParticleParameter;
    }

    export class DistributionFloatUniform extends DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: number;
        Max: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionFloatUniform;

        static Load(InName: string): DistributionFloatUniform;
    }

    export class InterpCurvePointVector2D {
        constructor();
        constructor(InVal: number, OutVal: Vector2D, ArriveTangent: Vector2D, LeaveTangent: Vector2D, InterpMode: EInterpCurveMode);

        InVal: number;
        OutVal: Vector2D;
        ArriveTangent: Vector2D;
        LeaveTangent: Vector2D;
        InterpMode: EInterpCurveMode;

        static StaticClass(): Class;
    }

    export class InterpCurveVector2D {
        constructor();
        constructor(Points: TArray<InterpCurvePointVector2D>, bIsLooped: boolean, LoopKeyOffset: number);

        Points: TArray<InterpCurvePointVector2D>;
        bIsLooped: boolean;
        LoopKeyOffset: number;

        static StaticClass(): Class;
    }

    export class DistributionFloatUniformCurve extends DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstantCurve: InterpCurveVector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionFloatUniformCurve;

        static Load(InName: string): DistributionFloatUniformCurve;
    }

    export enum EDistributionVectorLockFlags { EDVLF_None, EDVLF_XY, EDVLF_XZ, EDVLF_YZ, EDVLF_XYZ, EDVLF_MAX }

    export class DistributionVectorConstant extends DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Constant: Vector;
        bLockAxes: boolean;
        LockedAxes: EDistributionVectorLockFlags;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionVectorConstant;

        static Load(InName: string): DistributionVectorConstant;
    }

    export class DistributionVectorConstantCurve extends DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstantCurve: InterpCurveVector;
        bLockAxes: boolean;
        LockedAxes: EDistributionVectorLockFlags;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionVectorConstantCurve;

        static Load(InName: string): DistributionVectorConstantCurve;
    }

    export class DistributionVectorParameterBase extends DistributionVectorConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterName: string;
        MinInput: Vector;
        MaxInput: Vector;
        MinOutput: Vector;
        MaxOutput: Vector;
        ParamModes: FixSizeArray<DistributionParamMode>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionVectorParameterBase;

        static Load(InName: string): DistributionVectorParameterBase;
    }

    export class DistributionVectorParticleParameter extends DistributionVectorParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionVectorParticleParameter;

        static Load(InName: string): DistributionVectorParticleParameter;
    }

    export enum EDistributionVectorMirrorFlags { EDVMF_Same, EDVMF_Different, EDVMF_Mirror, EDVMF_MAX }

    export class DistributionVectorUniform extends DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Max: Vector;
        Min: Vector;
        bLockAxes: boolean;
        LockedAxes: EDistributionVectorLockFlags;
        MirrorFlags: FixSizeArray<EDistributionVectorMirrorFlags>;
        bUseExtremes: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionVectorUniform;

        static Load(InName: string): DistributionVectorUniform;
    }

    export class TwoVectors {
        constructor();
        constructor(v1: Vector, v2: Vector);

        v1: Vector;
        v2: Vector;

        static StaticClass(): Class;
    }

    export class InterpCurvePointTwoVectors {
        constructor();
        constructor(InVal: number, OutVal: TwoVectors, ArriveTangent: TwoVectors, LeaveTangent: TwoVectors, InterpMode: EInterpCurveMode);

        InVal: number;
        OutVal: TwoVectors;
        ArriveTangent: TwoVectors;
        LeaveTangent: TwoVectors;
        InterpMode: EInterpCurveMode;

        static StaticClass(): Class;
    }

    export class InterpCurveTwoVectors {
        constructor();
        constructor(Points: TArray<InterpCurvePointTwoVectors>, bIsLooped: boolean, LoopKeyOffset: number);

        Points: TArray<InterpCurvePointTwoVectors>;
        bIsLooped: boolean;
        LoopKeyOffset: number;

        static StaticClass(): Class;
    }

    export class DistributionVectorUniformCurve extends DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstantCurve: InterpCurveTwoVectors;
        bLockAxes1: boolean;
        bLockAxes2: boolean;
        LockedAxes: FixSizeArray<EDistributionVectorLockFlags>;
        MirrorFlags: FixSizeArray<EDistributionVectorMirrorFlags>;
        bUseExtremes: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DistributionVectorUniformCurve;

        static Load(InName: string): DistributionVectorUniformCurve;
    }

    export class DmgTypeBP_Environmental_C extends DamageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DmgTypeBP_Environmental_C;

        static Load(InName: string): DmgTypeBP_Environmental_C;
    }

    export class DockableWindowDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DockableWindowDragOperation;

        static Load(InName: string): DockableWindowDragOperation;
    }

    export class MaterialSpriteElement {
        constructor();
        constructor(Material: MaterialInterface, DistanceToOpacityCurve: CurveFloat, bSizeIsInScreenSpace: boolean, BaseSizeX: number, BaseSizeY: number, DistanceToSizeCurve: CurveFloat);

        Material: MaterialInterface;
        DistanceToOpacityCurve: CurveFloat;
        bSizeIsInScreenSpace: boolean;
        BaseSizeX: number;
        BaseSizeY: number;
        DistanceToSizeCurve: CurveFloat;

        static StaticClass(): Class;
    }

    export class MaterialBillboardComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Elements: TArray<MaterialSpriteElement>;

        AddElement(Material: $Nullable<MaterialInterface>, DistanceToOpacityCurve: $Nullable<CurveFloat>, bSizeIsInScreenSpace: boolean, BaseSizeX: number, BaseSizeY: number, DistanceToSizeCurve: $Nullable<CurveFloat>): void;

        SetElements(NewElements: TArray<MaterialSpriteElement>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialBillboardComponent;

        static Load(InName: string): MaterialBillboardComponent;
    }

    export class DocumentationActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DocumentLink: string;
        Billboard: MaterialBillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DocumentationActor;

        static Load(InName: string): DocumentationActor;
    }

    export class DoubleProperty extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DoubleProperty;

        static Load(InName: string): DoubleProperty;
    }

    export class DPICustomScalingRule extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DPICustomScalingRule;

        static Load(InName: string): DPICustomScalingRule;
    }

    export class PrefabDragPayload extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PrefabDragPayload;

        static Load(InName: string): PrefabDragPayload;
    }

    export class DragDropWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Payload: PrefabDragPayload;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DragDropWidget;

        static Load(InName: string): DragDropWidget;
    }

    export class DragWidget extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DragWidget;

        static Load(InName: string): DragWidget;
    }

    export class DrawSphereComponent extends SphereComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DrawSphereComponent;

        static Load(InName: string): DrawSphereComponent;
    }

    export class BonesTransfroms {
        constructor();
        constructor(BonesName: TArray<string>, BonesTranslation: TArray<Vector>, BonesScale: TArray<Vector>, BonesRotation: TArray<Rotator>);

        BonesName: TArray<string>;
        BonesTranslation: TArray<Vector>;
        BonesScale: TArray<Vector>;
        BonesRotation: TArray<Rotator>;

        static StaticClass(): Class;
    }

    export class AnimNode_DUTransformBone extends AnimNode_SkeletalControlBase {
        constructor();
        constructor(BonesTransfroms: BonesTransfroms, BoneToModify: BoneReference, Translation: Vector, Rotation: Rotator, Scale: Vector, TranslationMode: EBoneModificationMode, RotationMode: EBoneModificationMode, ScaleMode: EBoneModificationMode, TranslationSpace: EBoneControlSpace, RotationSpace: EBoneControlSpace, ScaleSpace: EBoneControlSpace);

        BonesTransfroms: BonesTransfroms;
        BoneToModify: BoneReference;
        Translation: Vector;
        Rotation: Rotator;
        Scale: Vector;
        TranslationMode: EBoneModificationMode;
        RotationMode: EBoneModificationMode;
        ScaleMode: EBoneModificationMode;
        TranslationSpace: EBoneControlSpace;
        RotationSpace: EBoneControlSpace;
        ScaleSpace: EBoneControlSpace;

        static StaticClass(): Class;
    }

    export class DUAnimGraphNode_ModifyBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: AnimNode_DUTransformBone;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DUAnimGraphNode_ModifyBone;

        static Load(InName: string): DUAnimGraphNode_ModifyBone;
    }

    export class DumpBlueprintsInfoCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DumpBlueprintsInfoCommandlet;

        static Load(InName: string): DumpBlueprintsInfoCommandlet;
    }

    export class DumpHiddenCategoriesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DumpHiddenCategoriesCommandlet;

        static Load(InName: string): DumpHiddenCategoriesCommandlet;
    }

    export class DynamicClass extends Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DynamicClass;

        static Load(InName: string): DynamicClass;
    }

    export class DynamicDelegateProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Fire(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DynamicDelegateProxy;

        static Load(InName: string): DynamicDelegateProxy;
    }

    export enum EDynamicBoxType { Horizontal, Vertical, Wrap, VerticalWrap, Radial, Overlay, EDynamicBoxType_MAX }

    export enum ESlateSizeRule { Automatic, Fill, ESlateSizeRule_MAX }

    export class SlateChildSize {
        constructor();
        constructor(Value: number, SizeRule: ESlateSizeRule);

        Value: number;
        SizeRule: ESlateSizeRule;

        static StaticClass(): Class;
    }

    export class RadialBoxSettings {
        constructor();
        constructor(bDistributeItemsEvenly: boolean, AngleBetweenItems: number, StartingAngle: number);

        bDistributeItemsEvenly: boolean;
        AngleBetweenItems: number;
        StartingAngle: number;

        static StaticClass(): Class;
    }

    export class UserWidgetPool {
        constructor();
        constructor(ActiveWidgets: TArray<UserWidget>, InactiveWidgets: TArray<UserWidget>);

        ActiveWidgets: TArray<UserWidget>;
        InactiveWidgets: TArray<UserWidget>;

        static StaticClass(): Class;
    }

    export class DynamicEntryBoxBase extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EntryBoxType: EDynamicBoxType;
        EntrySpacing: Vector2D;
        SpacingPattern: TArray<Vector2D>;
        EntrySizeRule: SlateChildSize;
        EntryHorizontalAlignment: EHorizontalAlignment;
        EntryVerticalAlignment: EVerticalAlignment;
        MaxElementSize: number;
        RadialBoxSettings: RadialBoxSettings;
        EntryWidgetPool: UserWidgetPool;

        GetAllEntries(): TArray<UserWidget>;

        GetNumEntries(): number;

        SetEntrySpacing(InEntrySpacing: Vector2D): void;

        SetRadialSettings(InSettings: RadialBoxSettings): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DynamicEntryBoxBase;

        static Load(InName: string): DynamicEntryBoxBase;
    }

    export class DynamicEntryBox extends DynamicEntryBoxBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumDesignerPreviewEntries: number;
        EntryWidgetClass: Class;

        BP_CreateEntry(): UserWidget;

        BP_CreateEntryOfClass(EntryClass: $Nullable<Class>): UserWidget;

        RemoveEntry(EntryWidget: $Nullable<UserWidget>): void;

        Reset(bDeleteWidgets?: boolean /* = false */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): DynamicEntryBox;

        static Load(InName: string): DynamicEntryBox;
    }

    export enum ECommentBoxMode { GroupMovement, NoGroupMovement, ECommentBoxMode_MAX }

    export class EdGraphNode_Comment extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CommentColor: LinearColor;
        FontSize: number;
        bCommentBubbleVisible_InDetailsPanel: boolean;
        bColorCommentBubble: boolean;
        MoveMode: ECommentBoxMode;
        CommentDepth: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphNode_Comment;

        static Load(InName: string): EdGraphNode_Comment;
    }

    export class EdGraphNode_Documentation extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Link: string;
        Excerpt: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphNode_Documentation;

        static Load(InName: string): EdGraphNode_Documentation;
    }

    export class EdGraphSchema_BehaviorTree extends AIGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_BehaviorTree;

        static Load(InName: string): EdGraphSchema_BehaviorTree;
    }

    export class EdGraphSchema_BehaviorTreeDecorator extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PC_Boolean: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_BehaviorTreeDecorator;

        static Load(InName: string): EdGraphSchema_BehaviorTreeDecorator;
    }

    export class EdGraphSchema_Niagara extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_Niagara;

        static Load(InName: string): EdGraphSchema_Niagara;
    }

    export class EdGraphSchema_NiagaraSystemOverview extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_NiagaraSystemOverview;

        static Load(InName: string): EdGraphSchema_NiagaraSystemOverview;
    }

    export class EditableGameplayTagQueryExpression extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression;

        static Load(InName: string): EditableGameplayTagQueryExpression;
    }

    export class EditableGameplayTagQuery extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UserDescription: string;
        RootExpression: EditableGameplayTagQueryExpression;
        TagQueryExportText_Helper: GameplayTagQuery;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQuery;

        static Load(InName: string): EditableGameplayTagQuery;
    }

    export class EditableGameplayTagQueryExpression_AllExprMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Expressions: TArray<EditableGameplayTagQueryExpression>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AllExprMatch;

        static Load(InName: string): EditableGameplayTagQueryExpression_AllExprMatch;
    }

    export class EditableGameplayTagQueryExpression_AllTagsMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Tags: GameplayTagContainer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AllTagsMatch;

        static Load(InName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
    }

    export class EditableGameplayTagQueryExpression_AnyExprMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Expressions: TArray<EditableGameplayTagQueryExpression>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AnyExprMatch;

        static Load(InName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
    }

    export class EditableGameplayTagQueryExpression_AnyTagsMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Tags: GameplayTagContainer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AnyTagsMatch;

        static Load(InName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
    }

    export class EditableGameplayTagQueryExpression_NoExprMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Expressions: TArray<EditableGameplayTagQueryExpression>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_NoExprMatch;

        static Load(InName: string): EditableGameplayTagQueryExpression_NoExprMatch;
    }

    export class EditableGameplayTagQueryExpression_NoTagsMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Tags: GameplayTagContainer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_NoTagsMatch;

        static Load(InName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
    }

    export class EditableMeshAdapter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableMeshAdapter;

        static Load(InName: string): EditableMeshAdapter;
    }

    export class EditableGeometryCollectionAdapter extends EditableMeshAdapter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GeometryCollection: GeometryCollection;
        OriginalGeometryCollection: GeometryCollection;
        GeometryCollectionLODIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableGeometryCollectionAdapter;

        static Load(InName: string): EditableGeometryCollectionAdapter;
    }

    export enum ETriangleTessellationMode { ThreeTriangles, FourTriangles, ETriangleTessellationMode_MAX }

    export enum EMeshModificationType { FirstInterim, Interim, Final, EMeshModificationType_MAX }

    export enum EMeshTopologyChange { NoTopologyChange, TopologyChange, EMeshTopologyChange_MAX }

    export class VertexPair {
        constructor();
        constructor(VertexID0: VertexID, VertexID1: VertexID);

        VertexID0: VertexID;
        VertexID1: VertexID;

        static StaticClass(): Class;
    }

    export class PolygonToSplit {
        constructor();
        constructor(PolygonID: PolygonID, VertexPairsToSplitAt: TArray<VertexPair>);

        PolygonID: PolygonID;
        VertexPairsToSplitAt: TArray<VertexPair>;

        static StaticClass(): Class;
    }

    export class MeshElementAttributeValue {
        constructor();

        static StaticClass(): Class;
    }

    export class MeshElementAttributeData {
        constructor();
        constructor(AttributeName: string, AttributeIndex: number, AttributeValue: MeshElementAttributeValue);

        AttributeName: string;
        AttributeIndex: number;
        AttributeValue: MeshElementAttributeValue;

        static StaticClass(): Class;
    }

    export class MeshElementAttributeList {
        constructor();
        constructor(Attributes: TArray<MeshElementAttributeData>);

        Attributes: TArray<MeshElementAttributeData>;

        static StaticClass(): Class;
    }

    export class AttributesForVertex {
        constructor();
        constructor(VertexID: VertexID, VertexAttributes: MeshElementAttributeList);

        VertexID: VertexID;
        VertexAttributes: MeshElementAttributeList;

        static StaticClass(): Class;
    }

    export class AttributesForVertexInstance {
        constructor();
        constructor(VertexInstanceID: VertexInstanceID, VertexInstanceAttributes: MeshElementAttributeList);

        VertexInstanceID: VertexInstanceID;
        VertexInstanceAttributes: MeshElementAttributeList;

        static StaticClass(): Class;
    }

    export class VertexAttributesForPolygonHole {
        constructor();
        constructor(VertexAttributeList: TArray<MeshElementAttributeList>);

        VertexAttributeList: TArray<MeshElementAttributeList>;

        static StaticClass(): Class;
    }

    export class VertexAttributesForPolygon {
        constructor();
        constructor(PolygonID: PolygonID, PerimeterVertexAttributeLists: TArray<MeshElementAttributeList>, VertexAttributeListsForEachHole: TArray<VertexAttributesForPolygonHole>);

        PolygonID: PolygonID;
        PerimeterVertexAttributeLists: TArray<MeshElementAttributeList>;
        VertexAttributeListsForEachHole: TArray<VertexAttributesForPolygonHole>;

        static StaticClass(): Class;
    }

    export class AttributesForEdge {
        constructor();
        constructor(EdgeID: EdgeID, EdgeAttributes: MeshElementAttributeList);

        EdgeID: EdgeID;
        EdgeAttributes: MeshElementAttributeList;

        static StaticClass(): Class;
    }

    export class VertexToMove {
        constructor();
        constructor(VertexID: VertexID, NewVertexPosition: Vector);

        VertexID: VertexID;
        NewVertexPosition: Vector;

        static StaticClass(): Class;
    }

    export enum EInsetPolygonsMode { All, CenterPolygonOnly, SidePolygonsOnly, EInsetPolygonsMode_MAX }

    export class SubdividedQuadVertex {
        constructor();
        constructor(VertexPositionIndex: number, TextureCoordinate0: Vector2D, TextureCoordinate1: Vector2D, VertexColor: Color, VertexNormal: Vector, VertexTangent: Vector, VertexBinormalSign: number);

        VertexPositionIndex: number;
        TextureCoordinate0: Vector2D;
        TextureCoordinate1: Vector2D;
        VertexColor: Color;
        VertexNormal: Vector;
        VertexTangent: Vector;
        VertexBinormalSign: number;

        static StaticClass(): Class;
    }

    export class SubdividedQuad {
        constructor();
        constructor(QuadVertex0: SubdividedQuadVertex, QuadVertex1: SubdividedQuadVertex, QuadVertex2: SubdividedQuadVertex, QuadVertex3: SubdividedQuadVertex);

        QuadVertex0: SubdividedQuadVertex;
        QuadVertex1: SubdividedQuadVertex;
        QuadVertex2: SubdividedQuadVertex;
        QuadVertex3: SubdividedQuadVertex;

        static StaticClass(): Class;
    }

    export class SubdivisionLimitSection {
        constructor();
        constructor(SubdividedQuads: TArray<SubdividedQuad>);

        SubdividedQuads: TArray<SubdividedQuad>;

        static StaticClass(): Class;
    }

    export class SubdividedWireEdge {
        constructor();
        constructor(EdgeVertex0PositionIndex: number, EdgeVertex1PositionIndex: number);

        EdgeVertex0PositionIndex: number;
        EdgeVertex1PositionIndex: number;

        static StaticClass(): Class;
    }

    export class SubdivisionLimitData {
        constructor();
        constructor(VertexPositions: TArray<Vector>, Sections: TArray<SubdivisionLimitSection>, SubdividedWireEdges: TArray<SubdividedWireEdge>);

        VertexPositions: TArray<Vector>;
        Sections: TArray<SubdivisionLimitSection>;
        SubdividedWireEdges: TArray<SubdividedWireEdge>;

        static StaticClass(): Class;
    }

    export class VertexToCreate {
        constructor();
        constructor(VertexAttributes: MeshElementAttributeList, OriginalVertexID: VertexID);

        VertexAttributes: MeshElementAttributeList;
        OriginalVertexID: VertexID;

        static StaticClass(): Class;
    }

    export class VertexInstanceToCreate {
        constructor();
        constructor(VertexID: VertexID, VertexInstanceAttributes: MeshElementAttributeList, OriginalVertexInstanceID: VertexInstanceID);

        VertexID: VertexID;
        VertexInstanceAttributes: MeshElementAttributeList;
        OriginalVertexInstanceID: VertexInstanceID;

        static StaticClass(): Class;
    }

    export class VertexAndAttributes {
        constructor();
        constructor(VertexInstanceID: VertexInstanceID, VertexID: VertexID, PolygonVertexAttributes: MeshElementAttributeList);

        VertexInstanceID: VertexInstanceID;
        VertexID: VertexID;
        PolygonVertexAttributes: MeshElementAttributeList;

        static StaticClass(): Class;
    }

    export enum EPolygonEdgeHardness {
        NewEdgesSoft,
        NewEdgesHard,
        AllEdgesSoft,
        AllEdgesHard,
        EPolygonEdgeHardness_MAX
    }

    export class PolygonToCreate {
        constructor();
        constructor(PolygonGroupID: PolygonGroupID, PerimeterVertices: TArray<VertexAndAttributes>, OriginalPolygonID: PolygonID, PolygonEdgeHardness: EPolygonEdgeHardness);

        PolygonGroupID: PolygonGroupID;
        PerimeterVertices: TArray<VertexAndAttributes>;
        OriginalPolygonID: PolygonID;
        PolygonEdgeHardness: EPolygonEdgeHardness;

        static StaticClass(): Class;
    }

    export class PolygonGroupToCreate {
        constructor();
        constructor(PolygonGroupAttributes: MeshElementAttributeList, OriginalPolygonGroupID: PolygonGroupID);

        PolygonGroupAttributes: MeshElementAttributeList;
        OriginalPolygonGroupID: PolygonGroupID;

        static StaticClass(): Class;
    }

    export class EdgeToCreate {
        constructor();
        constructor(VertexID0: VertexID, VertexID1: VertexID, EdgeAttributes: MeshElementAttributeList, OriginalEdgeID: EdgeID);

        VertexID0: VertexID;
        VertexID1: VertexID;
        EdgeAttributes: MeshElementAttributeList;
        OriginalEdgeID: EdgeID;

        static StaticClass(): Class;
    }

    export class VertexIndexAndInstanceID {
        constructor();
        constructor(ContourIndex: number, VertexInstanceID: VertexInstanceID);

        ContourIndex: number;
        VertexInstanceID: VertexInstanceID;

        static StaticClass(): Class;
    }

    export class VertexInstancesForPolygonHole {
        constructor();
        constructor(VertexIndicesAndInstanceIDs: TArray<VertexIndexAndInstanceID>);

        VertexIndicesAndInstanceIDs: TArray<VertexIndexAndInstanceID>;

        static StaticClass(): Class;
    }

    export class ChangeVertexInstancesForPolygon {
        constructor();
        constructor(PolygonID: PolygonID, PerimeterVertexIndicesAndInstanceIDs: TArray<VertexIndexAndInstanceID>, VertexIndicesAndInstanceIDsForEachHole: TArray<VertexInstancesForPolygonHole>);

        PolygonID: PolygonID;
        PerimeterVertexIndicesAndInstanceIDs: TArray<VertexIndexAndInstanceID>;
        VertexIndicesAndInstanceIDsForEachHole: TArray<VertexInstancesForPolygonHole>;

        static StaticClass(): Class;
    }

    export class PolygonGroupForPolygon {
        constructor();
        constructor(PolygonID: PolygonID, PolygonGroupID: PolygonGroupID);

        PolygonID: PolygonID;
        PolygonGroupID: PolygonGroupID;

        static StaticClass(): Class;
    }

    export class EditableMesh extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Adapters: TArray<EditableMeshAdapter>;
        TextureCoordinateCount: number;
        PendingCompactCounter: number;
        SubdivisionCount: number;

        AnyChangesToUndo(): boolean;

        AssignPolygonsToPolygonGroups(PolygonGroupForPolygons: TArray<PolygonGroupForPolygon>, bDeleteOrphanedPolygonGroups: boolean): void;

        BevelPolygons(PolygonIDs: TArray<PolygonID>, BevelFixedDistance: number, BevelProgressTowardCenter: number, OutNewCenterPolygonIDs: $Ref<TArray<PolygonID>>, OutNewSidePolygonIDs: $Ref<TArray<PolygonID>>): void;

        ChangePolygonsVertexInstances(VertexInstancesForPolygons: TArray<ChangeVertexInstancesForPolygon>): void;

        Commit(): void;

        CommitInstance(ComponentToInstanceTo: $Nullable<PrimitiveComponent>): EditableMesh;

        ComputeBoundingBox(): Box;

        ComputeBoundingBoxAndSphere(): BoxSphereBounds;

        ComputePolygonCenter(PolygonID: PolygonID): Vector;

        ComputePolygonNormal(PolygonID: PolygonID): Vector;

        ComputePolygonPlane(PolygonID: PolygonID): Plane;

        ComputePolygonsSharedEdges(PolygonIDs: TArray<PolygonID>, OutSharedEdgeIDs: $Ref<TArray<EdgeID>>): void;

        CreateEdges(EdgesToCreate: TArray<EdgeToCreate>, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;

        CreateEmptyVertexRange(NumVerticesToCreate: number, OutNewVertexIDs: $Ref<TArray<VertexID>>): void;

        CreateMissingPolygonPerimeterEdges(PolygonID: PolygonID, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;

        CreatePolygonGroups(PolygonGroupsToCreate: TArray<PolygonGroupToCreate>, OutNewPolygonGroupIDs: $Ref<TArray<PolygonGroupID>>): void;

        CreatePolygons(PolygonsToCreate: TArray<PolygonToCreate>, OutNewPolygonIDs: $Ref<TArray<PolygonID>>, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;

        CreateVertexInstances(VertexInstancesToCreate: TArray<VertexInstanceToCreate>, OutNewVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;

        CreateVertices(VerticesToCreate: TArray<VertexToCreate>, OutNewVertexIDs: $Ref<TArray<VertexID>>): void;

        DeleteEdgeAndConnectedPolygons(EdgeID: EdgeID, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean): void;

        DeleteEdges(EdgeIDsToDelete: TArray<EdgeID>, bDeleteOrphanedVertices: boolean): void;

        DeleteOrphanVertices(VertexIDsToDelete: TArray<VertexID>): void;

        DeletePolygonGroups(PolygonGroupIDs: TArray<PolygonGroupID>): void;

        DeletePolygons(PolygonIDsToDelete: TArray<PolygonID>, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean): void;

        DeleteVertexAndConnectedEdgesAndPolygons(VertexID: VertexID, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean): void;

        DeleteVertexInstances(VertexInstanceIDsToDelete: TArray<VertexInstanceID>, bDeleteOrphanedVertices: boolean): void;

        EndModification(bFromUndo?: boolean /* = false */): void;

        ExtendEdges(EdgeIDs: TArray<EdgeID>, bWeldNeighbors: boolean, OutNewExtendedEdgeIDs: $Ref<TArray<EdgeID>>): void;

        ExtendVertices(VertexIDs: TArray<VertexID>, bOnlyExtendClosestEdge: boolean, ReferencePosition: Vector, OutNewExtendedVertexIDs: $Ref<TArray<VertexID>>): void;

        ExtrudePolygons(Polygons: TArray<PolygonID>, ExtrudeDistance: number, bKeepNeighborsTogether: boolean, OutNewExtrudedFrontPolygons: $Ref<TArray<PolygonID>>): void;

        FindPolygonLoop(EdgeID: EdgeID, OutEdgeLoopEdgeIDs: $Ref<TArray<EdgeID>>, OutFlippedEdgeIDs: $Ref<TArray<EdgeID>>, OutReversedEdgeIDPathToTake: $Ref<TArray<EdgeID>>, OutPolygonIDsToSplit: $Ref<TArray<PolygonID>>): void;

        FindPolygonPerimeterEdgeNumberForVertices(PolygonID: PolygonID, EdgeVertexID0: VertexID, EdgeVertexID1: VertexID): number;

        FindPolygonPerimeterVertexNumberForVertex(PolygonID: PolygonID, VertexID: VertexID): number;

        FlipPolygons(PolygonIDs: TArray<PolygonID>): void;

        GeneratePolygonTangentsAndNormals(PolygonIDs: TArray<PolygonID>): void;

        GetEdgeConnectedPolygon(EdgeID: EdgeID, ConnectedPolygonNumber: number): PolygonID;

        GetEdgeConnectedPolygonCount(EdgeID: EdgeID): number;

        GetEdgeConnectedPolygons(EdgeID: EdgeID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;

        GetEdgeCount(): number;

        GetEdgeLoopElements(EdgeID: EdgeID, EdgeLoopIDs: $Ref<TArray<EdgeID>>): void;

        GetEdgeThatConnectsVertices(VertexID0: VertexID, VertexID1: VertexID): EdgeID;

        GetEdgeVertex(EdgeID: EdgeID, EdgeVertexNumber: number): VertexID;

        GetEdgeVertices(EdgeID: EdgeID, OutEdgeVertexID0: $Ref<VertexID>, OutEdgeVertexID1: $Ref<VertexID>): void;

        GetFirstValidPolygonGroup(): PolygonGroupID;

        GetGroupForPolygon(PolygonID: PolygonID): PolygonGroupID;

        GetPolygonAdjacentPolygons(PolygonID: PolygonID, OutAdjacentPolygons: $Ref<TArray<PolygonID>>): void;

        GetPolygonCount(): number;

        GetPolygonCountInGroup(PolygonGroupID: PolygonGroupID): number;

        GetPolygonGroupCount(): number;

        GetPolygonInGroup(PolygonGroupID: PolygonGroupID, PolygonNumber: number): PolygonID;

        GetPolygonPerimeterEdge(PolygonID: PolygonID, PerimeterEdgeNumber: number, bOutEdgeWindingIsReversedForPolygon: $Ref<boolean>): EdgeID;

        GetPolygonPerimeterEdgeCount(PolygonID: PolygonID): number;

        GetPolygonPerimeterEdges(PolygonID: PolygonID, OutPolygonPerimeterEdgeIDs: $Ref<TArray<EdgeID>>): void;

        GetPolygonPerimeterVertex(PolygonID: PolygonID, PolygonVertexNumber: number): VertexID;

        GetPolygonPerimeterVertexCount(PolygonID: PolygonID): number;

        GetPolygonPerimeterVertexInstance(PolygonID: PolygonID, PolygonVertexNumber: number): VertexInstanceID;

        GetPolygonPerimeterVertexInstances(PolygonID: PolygonID, OutPolygonPerimeterVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;

        GetPolygonPerimeterVertices(PolygonID: PolygonID, OutPolygonPerimeterVertexIDs: $Ref<TArray<VertexID>>): void;

        GetPolygonTriangulatedTriangle(PolygonID: PolygonID, PolygonTriangleNumber: number): TriangleID;

        GetPolygonTriangulatedTriangleCount(PolygonID: PolygonID): number;

        GetSubdivisionCount(): number;

        GetSubdivisionLimitData(): SubdivisionLimitData;

        GetTextureCoordinateCount(): number;

        GetVertexAdjacentVertices(VertexID: VertexID, OutAdjacentVertexIDs: $Ref<TArray<VertexID>>): void;

        GetVertexConnectedEdge(VertexID: VertexID, ConnectedEdgeNumber: number): EdgeID;

        GetVertexConnectedEdgeCount(VertexID: VertexID): number;

        GetVertexConnectedEdges(VertexID: VertexID, OutConnectedEdgeIDs: $Ref<TArray<EdgeID>>): void;

        GetVertexConnectedPolygons(VertexID: VertexID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;

        GetVertexCount(): number;

        GetVertexInstanceConnectedPolygon(VertexInstanceID: VertexInstanceID, ConnectedPolygonNumber: number): PolygonID;

        GetVertexInstanceConnectedPolygonCount(VertexInstanceID: VertexInstanceID): number;

        GetVertexInstanceConnectedPolygons(VertexInstanceID: VertexInstanceID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;

        GetVertexInstanceCount(): number;

        GetVertexInstanceVertex(VertexInstanceID: VertexInstanceID): VertexID;

        GetVertexPairEdge(VertexID: VertexID, NextVertexID: VertexID, bOutEdgeWindingIsReversed: $Ref<boolean>): EdgeID;

        InitializeAdapters(): void;

        InsertEdgeLoop(EdgeID: EdgeID, Splits: TArray<number>, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;

        InsetPolygons(PolygonIDs: TArray<PolygonID>, InsetFixedDistance: number, InsetProgressTowardCenter: number, Mode: EInsetPolygonsMode, OutNewCenterPolygonIDs: $Ref<TArray<PolygonID>>, OutNewSidePolygonIDs: $Ref<TArray<PolygonID>>): void;

        IsBeingModified(): boolean;

        IsCommitted(): boolean;

        IsCommittedAsInstance(): boolean;

        IsCompactAllowed(): boolean;

        IsOrphanedVertex(VertexID: VertexID): boolean;

        IsPreviewingSubdivisions(): boolean;

        IsSpatialDatabaseAllowed(): boolean;

        IsUndoAllowed(): boolean;

        IsValidEdge(EdgeID: EdgeID): boolean;

        IsValidPolygon(PolygonID: PolygonID): boolean;

        IsValidPolygonGroup(PolygonGroupID: PolygonGroupID): boolean;

        IsValidVertex(VertexID: VertexID): boolean;

        MoveVertices(VerticesToMove: TArray<VertexToMove>): void;

        PropagateInstanceChanges(): void;

        QuadrangulateMesh(OutNewPolygonIDs: $Ref<TArray<PolygonID>>): void;

        RebuildRenderMesh(): void;

        Revert(): void;

        RevertInstance(): EditableMesh;

        SearchSpatialDatabaseForPolygonsInVolume(Planes: TArray<Plane>, OutPolygons: $Ref<TArray<PolygonID>>): void;

        SearchSpatialDatabaseForPolygonsPotentiallyIntersectingLineSegment(LineSegmentStart: Vector, LineSegmentEnd: Vector, OutPolygons: $Ref<TArray<PolygonID>>): void;

        SearchSpatialDatabaseForPolygonsPotentiallyIntersectingPlane(InPlane: Plane, OutPolygons: $Ref<TArray<PolygonID>>): void;

        SetAllowCompact(bInAllowCompact: boolean): void;

        SetAllowSpatialDatabase(bInAllowSpatialDatabase: boolean): void;

        SetAllowUndo(bInAllowUndo: boolean): void;

        SetEdgesAttributes(AttributesForEdges: TArray<AttributesForEdge>): void;

        SetEdgesCreaseSharpness(EdgeIDs: TArray<EdgeID>, EdgesNewCreaseSharpness: TArray<number>): void;

        SetEdgesHardness(EdgeIDs: TArray<EdgeID>, EdgesNewIsHard: TArray<boolean>): void;

        SetEdgesHardnessAutomatically(EdgeIDs: TArray<EdgeID>, MaxDotProductForSoftEdge: number): void;

        SetPolygonsVertexAttributes(VertexAttributesForPolygons: TArray<VertexAttributesForPolygon>): void;

        SetSubdivisionCount(NewSubdivisionCount: number): void;

        SetTextureCoordinateCount(NumTexCoords: number): void;

        SetVertexInstancesAttributes(AttributesForVertexInstances: TArray<AttributesForVertexInstance>): void;

        SetVerticesAttributes(AttributesForVertices: TArray<AttributesForVertex>): void;

        SetVerticesCornerSharpness(VertexIDs: TArray<VertexID>, VerticesNewCornerSharpness: TArray<number>): void;

        SplitEdge(EdgeID: EdgeID, Splits: TArray<number>, OutNewVertexIDs: $Ref<TArray<VertexID>>): void;

        SplitPolygonalMesh(InPlane: Plane, PolygonIDs1: $Ref<TArray<PolygonID>>, PolygonIDs2: $Ref<TArray<PolygonID>>, BoundaryIDs: $Ref<TArray<EdgeID>>): void;

        SplitPolygons(PolygonsToSplit: TArray<PolygonToSplit>, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;

        StartModification(MeshModificationType: EMeshModificationType, MeshTopologyChange: EMeshTopologyChange): void;

        TessellatePolygons(PolygonIDs: TArray<PolygonID>, TriangleTessellationMode: ETriangleTessellationMode, OutNewPolygonIDs: $Ref<TArray<PolygonID>>): void;

        TriangulatePolygons(PolygonIDs: TArray<PolygonID>, OutNewTrianglePolygons: $Ref<TArray<PolygonID>>): void;

        TryToRemovePolygonEdge(EdgeID: EdgeID, bOutWasEdgeRemoved: $Ref<boolean>, OutNewPolygonID: $Ref<PolygonID>): void;

        TryToRemoveVertex(VertexID: VertexID, bOutWasVertexRemoved: $Ref<boolean>, OutNewEdgeID: $Ref<EdgeID>): void;

        WeldVertices(VertexIDs: TArray<VertexID>, OutNewVertexID: $Ref<VertexID>): void;

        static InvalidEdgeID(): EdgeID;

        static InvalidPolygonGroupID(): PolygonGroupID;

        static InvalidPolygonID(): PolygonID;

        static InvalidVertexID(): VertexID;

        static MakeEdgeID(EdgeIndex: number): EdgeID;

        static MakePolygonGroupID(PolygonGroupIndex: number): PolygonGroupID;

        static MakePolygonID(PolygonIndex: number): PolygonID;

        static MakeVertexID(VertexIndex: number): VertexID;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableMesh;

        static Load(InName: string): EditableMesh;
    }

    export class EditableMeshFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static MakeEditableMesh(PrimitiveComponent: $Nullable<PrimitiveComponent>, LODIndex: number): EditableMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableMeshFactory;

        static Load(InName: string): EditableMeshFactory;
    }

    export class EditableStaticMeshAdapter extends EditableMeshAdapter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StaticMesh: StaticMesh;
        OriginalStaticMesh: StaticMesh;
        StaticMeshLODIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableStaticMeshAdapter;

        static Load(InName: string): EditableStaticMeshAdapter;
    }

    export class EditableTextStyle extends SlateWidgetStyle {
        constructor();
        constructor(Font: SlateFontInfo, ColorAndOpacity: SlateColor, BackgroundImageSelected: SlateBrush, BackgroundImageComposing: SlateBrush, CaretImage: SlateBrush);

        Font: SlateFontInfo;
        ColorAndOpacity: SlateColor;
        BackgroundImageSelected: SlateBrush;
        BackgroundImageComposing: SlateBrush;
        CaretImage: SlateBrush;

        static StaticClass(): Class;
    }

    export enum EVirtualKeyboardType { Default, Number, Web, Email, Password, AlphaNumeric, EVirtualKeyboardType_MAX }

    export class VirtualKeyboardOptions {
        constructor();
        constructor(bEnableAutocorrect: boolean);

        bEnableAutocorrect: boolean;

        static StaticClass(): Class;
    }

    export enum EVirtualKeyboardTrigger { OnFocusByPointer, OnAllFocusEvents, EVirtualKeyboardTrigger_MAX }

    export enum EVirtualKeyboardDismissAction {
        TextChangeOnDismiss,
        TextCommitOnAccept,
        TextCommitOnDismiss,
        EVirtualKeyboardDismissAction_MAX
    }

    export enum ETextJustify { Left, Center, Right, ETextJustify_MAX }

    export enum ETextShapingMethod { Auto, KerningOnly, FullShaping, ETextShapingMethod_MAX }

    export enum ETextFlowDirection { Auto, LeftToRight, RightToLeft, ETextFlowDirection_MAX }

    export class ShapedTextOptions {
        constructor();
        constructor(bOverride_TextShapingMethod: boolean, bOverride_TextFlowDirection: boolean, TextShapingMethod: ETextShapingMethod, TextFlowDirection: ETextFlowDirection);

        bOverride_TextShapingMethod: boolean;
        bOverride_TextFlowDirection: boolean;
        TextShapingMethod: ETextShapingMethod;
        TextFlowDirection: ETextFlowDirection;

        static StaticClass(): Class;
    }

    export enum ETextCommit { Default, OnEnter, OnUserMovedFocus, OnCleared, ETextCommit_MAX }

    export class EditableText extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Text: string;
        TextDelegate: $Delegate<() => string>;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: EditableTextStyle;
        Style: SlateWidgetStyleAsset;
        BackgroundImageSelected: SlateBrushAsset;
        BackgroundImageComposing: SlateBrushAsset;
        CaretImage: SlateBrushAsset;
        Font: SlateFontInfo;
        ColorAndOpacity: SlateColor;
        IsReadOnly: boolean;
        IsPassword: boolean;
        MinimumDesiredWidth: number;
        IsCaretMovedWhenGainFocus: boolean;
        SelectAllTextWhenFocused: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        AllowContextMenu: boolean;
        KeyboardType: EVirtualKeyboardType;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        Justification: ETextJustify;
        ShapedTextOptions: ShapedTextOptions;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;

        GetText(): string;

        OnEditableTextChangedEvent__DelegateSignature(Text: string): void;

        OnEditableTextCommittedEvent__DelegateSignature(Text: string, CommitMethod: ETextCommit): void;

        SetHintText(InHintText: string): void;

        SetIsPassword(InbIsPassword: boolean): void;

        SetIsReadOnly(InbIsReadyOnly: boolean): void;

        SetJustification(InJustification: ETextJustify): void;

        SetText(InText: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableText;

        static Load(InName: string): EditableText;
    }

    export class ScrollBarStyle extends SlateWidgetStyle {
        constructor();
        constructor(HorizontalBackgroundImage: SlateBrush, VerticalBackgroundImage: SlateBrush, VerticalTopSlotImage: SlateBrush, HorizontalTopSlotImage: SlateBrush, VerticalBottomSlotImage: SlateBrush, HorizontalBottomSlotImage: SlateBrush, NormalThumbImage: SlateBrush, HoveredThumbImage: SlateBrush, DraggedThumbImage: SlateBrush);

        HorizontalBackgroundImage: SlateBrush;
        VerticalBackgroundImage: SlateBrush;
        VerticalTopSlotImage: SlateBrush;
        HorizontalTopSlotImage: SlateBrush;
        VerticalBottomSlotImage: SlateBrush;
        HorizontalBottomSlotImage: SlateBrush;
        NormalThumbImage: SlateBrush;
        HoveredThumbImage: SlateBrush;
        DraggedThumbImage: SlateBrush;

        static StaticClass(): Class;
    }

    export class EditableTextBoxStyle extends SlateWidgetStyle {
        constructor();
        constructor(BackgroundImageNormal: SlateBrush, BackgroundImageHovered: SlateBrush, BackgroundImageFocused: SlateBrush, BackgroundImageReadOnly: SlateBrush, Padding: Margin, Font: SlateFontInfo, ForegroundColor: SlateColor, BackgroundColor: SlateColor, ReadOnlyForegroundColor: SlateColor, HScrollBarPadding: Margin, VScrollBarPadding: Margin, ScrollBarStyle: ScrollBarStyle);

        BackgroundImageNormal: SlateBrush;
        BackgroundImageHovered: SlateBrush;
        BackgroundImageFocused: SlateBrush;
        BackgroundImageReadOnly: SlateBrush;
        Padding: Margin;
        Font: SlateFontInfo;
        ForegroundColor: SlateColor;
        BackgroundColor: SlateColor;
        ReadOnlyForegroundColor: SlateColor;
        HScrollBarPadding: Margin;
        VScrollBarPadding: Margin;
        ScrollBarStyle: ScrollBarStyle;

        static StaticClass(): Class;
    }

    export class EditableTextBox extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Text: string;
        TextDelegate: $Delegate<() => string>;
        WidgetStyle: EditableTextBoxStyle;
        Style: SlateWidgetStyleAsset;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        Font: SlateFontInfo;
        ForegroundColor: LinearColor;
        BackgroundColor: LinearColor;
        ReadOnlyForegroundColor: LinearColor;
        IsReadOnly: boolean;
        IsPassword: boolean;
        MinimumDesiredWidth: number;
        Padding: Margin;
        IsCaretMovedWhenGainFocus: boolean;
        SelectAllTextWhenFocused: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        AllowContextMenu: boolean;
        KeyboardType: EVirtualKeyboardType;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        Justification: ETextJustify;
        ShapedTextOptions: ShapedTextOptions;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;

        ClearError(): void;

        GetText(): string;

        HasError(): boolean;

        OnEditableTextBoxChangedEvent__DelegateSignature(Text: string): void;

        OnEditableTextBoxCommittedEvent__DelegateSignature(Text: string, CommitMethod: ETextCommit): void;

        SetError(InError: string): void;

        SetHintText(InText: string): void;

        SetIsPassword(bIsPassword: boolean): void;

        SetIsReadOnly(bReadOnly: boolean): void;

        SetJustification(InJustification: ETextJustify): void;

        SetText(InText: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableTextBox;

        static Load(InName: string): EditableTextBox;
    }

    export class EditableTextBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EditableTextBoxStyle: EditableTextBoxStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableTextBoxWidgetStyle;

        static Load(InName: string): EditableTextBoxWidgetStyle;
    }

    export class EditableTextWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EditableTextStyle: EditableTextStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditableTextWidgetStyle;

        static Load(InName: string): EditableTextWidgetStyle;
    }

    export enum EditConditionTestEnum { First, Second, EditConditionTestEnum_MAX }

    export enum EditConditionByteEnum { First, Second, EditConditionByteEnum_MAX }

    export class EditConditionTestObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoolProperty: boolean;
        enumProperty: EditConditionTestEnum;
        ByteEnumProperty: EditConditionByteEnum;
        DoubleProperty: number;
        IntegerProperty: number;
        UintBitfieldProperty: boolean;
        UObjectPtr: Object;
        SoftClassPtr: TSoftClassPtr<Object>;
        WeakObjectPtr: TWeakObjectPtr<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditConditionTestObject;

        static Load(InName: string): EditConditionTestObject;
    }

    export class EditorActorFolders extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorActorFolders;

        static Load(InName: string): EditorActorFolders;
    }

    export class EditorAnimBaseObj extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorAnimBaseObj;

        static Load(InName: string): EditorAnimBaseObj;
    }

    export class EditorAnimCompositeSegment extends EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimSegment: AnimSegment;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorAnimCompositeSegment;

        static Load(InName: string): EditorAnimCompositeSegment;
    }

    export class EditorAnimCurveBoneLinks extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurveName: SmartName;
        ConnectedBones: TArray<BoneReference>;
        MaxLOD: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorAnimCurveBoneLinks;

        static Load(InName: string): EditorAnimCurveBoneLinks;
    }

    export class EditorAnimSegment extends EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimSegment: AnimSegment;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorAnimSegment;

        static Load(InName: string): EditorAnimSegment;
    }

    export class EditorCompositeSection extends EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CompositeSection: CompositeSection;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorCompositeSection;

        static Load(InName: string): EditorCompositeSection;
    }

    export enum EWindowMode { Fullscreen, WindowedFullscreen, Windowed, EWindowMode_MAX }

    export class GameUserSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseVSync: boolean;
        bUseDynamicResolution: boolean;
        ResolutionSizeX: number;
        ResolutionSizeY: number;
        LastUserConfirmedResolutionSizeX: number;
        LastUserConfirmedResolutionSizeY: number;
        WindowPosX: number;
        WindowPosY: number;
        FullscreenMode: number;
        LastConfirmedFullscreenMode: number;
        PreferredFullscreenMode: number;
        Version: number;
        AudioQualityLevel: number;
        LastConfirmedAudioQualityLevel: number;
        FrameRateLimit: number;
        DesiredScreenWidth: number;
        bUseDesiredScreenHeight: boolean;
        DesiredScreenHeight: number;
        LastUserConfirmedDesiredScreenWidth: number;
        LastUserConfirmedDesiredScreenHeight: number;
        LastRecommendedScreenWidth: number;
        LastRecommendedScreenHeight: number;
        LastCPUBenchmarkResult: number;
        LastGPUBenchmarkResult: number;
        LastCPUBenchmarkSteps: TArray<number>;
        LastGPUBenchmarkSteps: TArray<number>;
        LastGPUBenchmarkMultiplier: number;
        bUseHDRDisplayOutput: boolean;
        HDRDisplayOutputNits: number;
        OnGameUserSettingsUINeedsUpdate: $MulticastDelegate<() => void>;

        ApplyHardwareBenchmarkResults(): void;

        ApplyNonResolutionSettings(): void;

        ApplyResolutionSettings(bCheckForCommandLineOverrides: boolean): void;

        ApplySettings(bCheckForCommandLineOverrides: boolean): void;

        ConfirmVideoMode(): void;

        EnableHDRDisplayOutput(bEnable: boolean, DisplayNits?: number /* = 1000 */): void;

        GetAntiAliasingQuality(): number;

        GetAudioQualityLevel(): number;

        GetCurrentHDRDisplayNits(): number;

        GetDefaultResolutionScale(): number;

        GetDesktopResolution(): IntPoint;

        GetFoliageQuality(): number;

        GetFrameRateLimit(): number;

        GetFullscreenMode(): EWindowMode;

        GetLastConfirmedFullscreenMode(): EWindowMode;

        GetLastConfirmedScreenResolution(): IntPoint;

        GetOverallScalabilityLevel(): number;

        GetPostProcessingQuality(): number;

        GetPreferredFullscreenMode(): EWindowMode;

        GetRecommendedResolutionScale(): number;

        GetResolutionScaleInformation(CurrentScaleNormalized: $Ref<number>, CurrentScaleValue: $Ref<number>, MinScaleValue: $Ref<number>, MaxScaleValue: $Ref<number>): void;

        GetResolutionScaleInformationEx(CurrentScaleNormalized: $Ref<number>, CurrentScaleValue: $Ref<number>, MinScaleValue: $Ref<number>, MaxScaleValue: $Ref<number>): void;

        GetResolutionScaleNormalized(): number;

        GetScreenResolution(): IntPoint;

        GetShadingQuality(): number;

        GetShadowQuality(): number;

        GetTextureQuality(): number;

        GetViewDistanceQuality(): number;

        GetVisualEffectQuality(): number;

        IsDirty(): boolean;

        IsDynamicResolutionDirty(): boolean;

        IsDynamicResolutionEnabled(): boolean;

        IsFullscreenModeDirty(): boolean;

        IsHDREnabled(): boolean;

        IsScreenResolutionDirty(): boolean;

        IsVSyncDirty(): boolean;

        IsVSyncEnabled(): boolean;

        LoadSettings(bForceReload?: boolean /* = false */): void;

        ResetToCurrentSettings(): void;

        RevertVideoMode(): void;

        RunHardwareBenchmark(WorkScale?: number /* = 10 */, CPUMultiplier?: number /* = 1.000000 */, GPUMultiplier?: number /* = 1.000000 */): void;

        SaveSettings(): void;

        SetAntiAliasingQuality(Value: number): void;

        SetAudioQualityLevel(QualityLevel: number): void;

        SetBenchmarkFallbackValues(): void;

        SetDynamicResolutionEnabled(bEnable: boolean): void;

        SetFoliageQuality(Value: number): void;

        SetFrameRateLimit(NewLimit: number): void;

        SetFullscreenMode(InFullscreenMode: EWindowMode): void;

        SetOverallScalabilityLevel(Value: number): void;

        SetPostProcessingQuality(Value: number): void;

        SetResolutionScaleNormalized(NewScaleNormalized: number): void;

        SetResolutionScaleValue(NewScaleValue: number): void;

        SetResolutionScaleValueEx(NewScaleValue: number): void;

        SetScreenResolution(Resolution: IntPoint): void;

        SetShadingQuality(Value: number): void;

        SetShadowQuality(Value: number): void;

        SetTextureQuality(Value: number): void;

        SetToDefaults(): void;

        SetViewDistanceQuality(Value: number): void;

        SetVisualEffectQuality(Value: number): void;

        SetVSyncEnabled(bEnable: boolean): void;

        SupportsHDRDisplayOutput(): boolean;

        ValidateSettings(): void;

        static GetDefaultResolution(): IntPoint;

        static GetDefaultWindowMode(): EWindowMode;

        static GetDefaultWindowPosition(): IntPoint;

        static GetFramePace(): number;

        static GetGameUserSettings(): GameUserSettings;

        static GetSyncInterval(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameUserSettings;

        static Load(InName: string): GameUserSettings;
    }

    export class StatColorMapEntry {
        constructor();
        constructor(In: number, Out: Color);

        In: number;
        Out: Color;

        static StaticClass(): Class;
    }

    export class StatColorMapping {
        constructor();
        constructor(StatName: string, ColorMap: TArray<StatColorMapEntry>, DisableBlend: boolean);

        StatName: string;
        ColorMap: TArray<StatColorMapEntry>;
        DisableBlend: boolean;

        static StaticClass(): Class;
    }

    export class GameNameRedirect {
        constructor();
        constructor(OldGameName: string, NewGameName: string);

        OldGameName: string;
        NewGameName: string;

        static StaticClass(): Class;
    }

    export class ClassRedirect {
        constructor();
        constructor(ObjectName: string, OldClassName: string, NewClassName: string, OldSubobjName: string, NewSubobjName: string, NewClassClass: string, NewClassPackage: string, InstanceOnly: boolean);

        ObjectName: string;
        OldClassName: string;
        NewClassName: string;
        OldSubobjName: string;
        NewSubobjName: string;
        NewClassClass: string;
        NewClassPackage: string;
        InstanceOnly: boolean;

        static StaticClass(): Class;
    }

    export class PluginRedirect {
        constructor();
        constructor(OldPluginName: string, NewPluginName: string);

        OldPluginName: string;
        NewPluginName: string;

        static StaticClass(): Class;
    }

    export class StructRedirect {
        constructor();
        constructor(OldStructName: string, NewStructName: string);

        OldStructName: string;
        NewStructName: string;

        static StaticClass(): Class;
    }

    export class EngineCustomTimeStep extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EngineCustomTimeStep;

        static Load(InName: string): EngineCustomTimeStep;
    }

    export enum ETimecodeProviderSynchronizationState {
        Closed,
        Error,
        Synchronized,
        Synchronizing,
        ETimecodeProviderSynchronizationState_MAX
    }

    export class TimecodeProvider extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FrameDelay: number;

        FetchAndUpdate(): void;

        FetchTimecode(OutFrameTime: $Ref<QualifiedFrameTime>): boolean;

        GetDelayedQualifiedFrameTime(): QualifiedFrameTime;

        GetDelayedTimecode(): Timecode;

        GetFrameRate(): FrameRate;

        GetQualifiedFrameTime(): QualifiedFrameTime;

        GetSynchronizationState(): ETimecodeProviderSynchronizationState;

        GetTimecode(): Timecode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TimecodeProvider;

        static Load(InName: string): TimecodeProvider;
    }

    export enum ETransitionType { None, Paused, Loading, Saving, Connecting, Precaching, WaitingToConnect, MAX }

    export class DropNoteInfo {
        constructor();
        constructor(Location: Vector, Rotation: Rotator, Comment: string);

        Location: Vector;
        Rotation: Rotator;
        Comment: string;

        static StaticClass(): Class;
    }

    export class NetDriverDefinition {
        constructor();
        constructor(DefName: string, DriverClassName: string, DriverClassNameFallback: string);

        DefName: string;
        DriverClassName: string;
        DriverClassNameFallback: string;

        static StaticClass(): Class;
    }

    export class Engine extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TinyFont: Font;
        TinyFontName: SoftObjectPath;
        SmallFont: Font;
        SmallFontName: SoftObjectPath;
        MediumFont: Font;
        MediumFontName: SoftObjectPath;
        LargeFont: Font;
        LargeFontName: SoftObjectPath;
        SubtitleFont: Font;
        SubtitleFontName: SoftObjectPath;
        AdditionalFonts: TArray<Font>;
        AdditionalFontNames: TArray<string>;
        ConsoleClass: Class;
        ConsoleClassName: SoftClassPath;
        GameViewportClientClass: Class;
        GameViewportClientClassName: SoftClassPath;
        LocalPlayerClass: Class;
        LocalPlayerClassName: SoftClassPath;
        WorldSettingsClass: Class;
        WorldSettingsClassName: SoftClassPath;
        NavigationSystemClassName: SoftClassPath;
        NavigationSystemClass: Class;
        NavigationSystemConfigClassName: SoftClassPath;
        NavigationSystemConfigClass: Class;
        AvoidanceManagerClassName: SoftClassPath;
        AvoidanceManagerClass: Class;
        AIControllerClassName: SoftClassPath;
        PhysicsCollisionHandlerClass: Class;
        PhysicsCollisionHandlerClassName: SoftClassPath;
        GameUserSettingsClassName: SoftClassPath;
        GameUserSettingsClass: Class;
        GameUserSettings: GameUserSettings;
        LevelScriptActorClass: Class;
        LevelScriptActorClassName: SoftClassPath;
        DefaultBlueprintBaseClassName: SoftClassPath;
        GameSingletonClassName: SoftClassPath;
        GameSingleton: Object;
        AssetManagerClassName: SoftClassPath;
        AssetManager: AssetManager;
        DefaultTexture: Texture2D;
        DefaultTextureName: SoftObjectPath;
        DefaultDiffuseTexture: Texture;
        DefaultDiffuseTextureName: SoftObjectPath;
        DefaultBSPVertexTexture: Texture2D;
        DefaultBSPVertexTextureName: SoftObjectPath;
        HighFrequencyNoiseTexture: Texture2D;
        HighFrequencyNoiseTextureName: SoftObjectPath;
        DefaultBokehTexture: Texture2D;
        DefaultBokehTextureName: SoftObjectPath;
        DefaultBloomKernelTexture: Texture2D;
        DefaultBloomKernelTextureName: SoftObjectPath;
        WireframeMaterial: Material;
        WireframeMaterialName: string;
        GeomMaterial: Material;
        GeomMaterialName: SoftObjectPath;
        DebugMeshMaterial: Material;
        DebugMeshMaterialName: SoftObjectPath;
        EmissiveMeshMaterial: Material;
        EmissiveMeshMaterialName: SoftObjectPath;
        LevelColorationLitMaterial: Material;
        LevelColorationLitMaterialName: string;
        LevelColorationUnlitMaterial: Material;
        LevelColorationUnlitMaterialName: string;
        LightingTexelDensityMaterial: Material;
        LightingTexelDensityName: string;
        ShadedLevelColorationLitMaterial: Material;
        ShadedLevelColorationLitMaterialName: string;
        ShadedLevelColorationUnlitMaterial: Material;
        ShadedLevelColorationUnlitMaterialName: string;
        RemoveSurfaceMaterial: Material;
        RemoveSurfaceMaterialName: SoftObjectPath;
        VertexColorMaterial: Material;
        VertexColorMaterialName: string;
        VertexColorViewModeMaterial_ColorOnly: Material;
        VertexColorViewModeMaterialName_ColorOnly: string;
        VertexColorViewModeMaterial_AlphaAsColor: Material;
        VertexColorViewModeMaterialName_AlphaAsColor: string;
        VertexColorViewModeMaterial_RedOnly: Material;
        VertexColorViewModeMaterialName_RedOnly: string;
        VertexColorViewModeMaterial_GreenOnly: Material;
        VertexColorViewModeMaterialName_GreenOnly: string;
        VertexColorViewModeMaterial_BlueOnly: Material;
        VertexColorViewModeMaterialName_BlueOnly: string;
        BoneWeightMaterial: Material;
        BoneWeightMaterialName: SoftObjectPath;
        ClothPaintMaterial: Material;
        ClothPaintMaterialWireframe: Material;
        ClothPaintMaterialInstance: MaterialInstanceDynamic;
        ClothPaintMaterialWireframeInstance: MaterialInstanceDynamic;
        ClothPaintMaterialName: SoftObjectPath;
        ClothPaintMaterialWireframeName: SoftObjectPath;
        PhysicalMaterialMaskMaterial: Material;
        PhysicalMaterialMaskMaterialName: SoftObjectPath;
        DebugEditorMaterial: Material;
        DebugEditorMaterialName: SoftObjectPath;
        ConstraintLimitMaterial: Material;
        ConstraintLimitMaterialX: MaterialInstanceDynamic;
        ConstraintLimitMaterialXAxis: MaterialInstanceDynamic;
        ConstraintLimitMaterialY: MaterialInstanceDynamic;
        ConstraintLimitMaterialYAxis: MaterialInstanceDynamic;
        ConstraintLimitMaterialZ: MaterialInstanceDynamic;
        ConstraintLimitMaterialZAxis: MaterialInstanceDynamic;
        ConstraintLimitMaterialPrismatic: MaterialInstanceDynamic;
        InvalidLightmapSettingsMaterial: Material;
        InvalidLightmapSettingsMaterialName: SoftObjectPath;
        PreviewShadowsIndicatorMaterial: Material;
        PreviewShadowsIndicatorMaterialName: SoftObjectPath;
        ArrowMaterial: Material;
        ArrowMaterialYellow: MaterialInstanceDynamic;
        ArrowMaterialName: SoftObjectPath;
        LightingOnlyBrightness: LinearColor;
        ShaderComplexityColors: TArray<LinearColor>;
        QuadComplexityColors: TArray<LinearColor>;
        LightComplexityColors: TArray<LinearColor>;
        StationaryLightOverlapColors: TArray<LinearColor>;
        LODColorationColors: TArray<LinearColor>;
        HLODColorationColors: TArray<LinearColor>;
        StreamingAccuracyColors: TArray<LinearColor>;
        MaxPixelShaderAdditiveComplexityCount: number;
        MaxES3PixelShaderAdditiveComplexityCount: number;
        MinLightMapDensity: number;
        IdealLightMapDensity: number;
        MaxLightMapDensity: number;
        bRenderLightMapDensityGrayscale: boolean;
        RenderLightMapDensityGrayscaleScale: number;
        RenderLightMapDensityColorScale: number;
        LightMapDensityVertexMappedColor: LinearColor;
        LightMapDensitySelectedColor: LinearColor;
        StatColorMappings: TArray<StatColorMapping>;
        EditorBrushMaterial: Material;
        EditorBrushMaterialName: SoftObjectPath;
        DefaultPhysMaterial: PhysicalMaterial;
        DefaultPhysMaterialName: SoftObjectPath;
        ActiveGameNameRedirects: TArray<GameNameRedirect>;
        ActiveClassRedirects: TArray<ClassRedirect>;
        ActivePluginRedirects: TArray<PluginRedirect>;
        ActiveStructRedirects: TArray<StructRedirect>;
        PreIntegratedSkinBRDFTexture: Texture2D;
        PreIntegratedSkinBRDFTextureName: SoftObjectPath;
        BlueNoiseTexture: Texture2D;
        BlueNoiseTextureName: SoftObjectPath;
        MiniFontTexture: Texture2D;
        MiniFontTextureName: SoftObjectPath;
        WeightMapPlaceholderTexture: Texture;
        WeightMapPlaceholderTextureName: SoftObjectPath;
        LightMapDensityTexture: Texture2D;
        LightMapDensityTextureName: SoftObjectPath;
        GameViewport: GameViewportClient;
        DeferredCommands: TArray<string>;
        NearClipPlane: number;
        bSubtitlesEnabled: boolean;
        bSubtitlesForcedOff: boolean;
        MaximumLoopIterationCount: number;
        bCanBlueprintsTickByDefault: boolean;
        bOptimizeAnimBlueprintMemberVariableAccess: boolean;
        bAllowMultiThreadedAnimationUpdate: boolean;
        bEnableEditorPSysRealtimeLOD: boolean;
        bSmoothFrameRate: boolean;
        bUseFixedFrameRate: boolean;
        FixedFrameRate: number;
        SmoothedFrameRateRange: FloatRange;
        CustomTimeStep: EngineCustomTimeStep;
        CustomTimeStepClassName: SoftClassPath;
        TimecodeProvider: TimecodeProvider;
        TimecodeProviderClassName: SoftClassPath;
        bGenerateDefaultTimecode: boolean;
        GenerateDefaultTimecodeFrameRate: FrameRate;
        GenerateDefaultTimecodeFrameDelay: number;
        bCheckForMultiplePawnsSpawnedInAFrame: boolean;
        NumPawnsAllowedToBeSpawnedInAFrame: number;
        bShouldGenerateLowQualityLightmaps: boolean;
        C_WorldBox: Color;
        C_BrushWire: Color;
        C_AddWire: Color;
        C_SubtractWire: Color;
        C_SemiSolidWire: Color;
        C_NonSolidWire: Color;
        C_WireBackground: Color;
        C_ScaleBoxHi: Color;
        C_VolumeCollision: Color;
        C_BSPCollision: Color;
        C_OrthoBackground: Color;
        C_Volume: Color;
        C_BrushShape: Color;
        StreamingDistanceFactor: number;
        GameScreenshotSaveDirectory: DirectoryPath;
        TransitionType: ETransitionType;
        TransitionDescription: string;
        TransitionGameMode: string;
        bAllowMatureLanguage: boolean;
        CameraRotationThreshold: number;
        CameraTranslationThreshold: number;
        PrimitiveProbablyVisibleTime: number;
        MaxOcclusionPixelsFraction: number;
        bPauseOnLossOfFocus: boolean;
        MaxParticleResize: number;
        MaxParticleResizeWarn: number;
        PendingDroppedNotes: TArray<DropNoteInfo>;
        NetClientTicksPerSecond: number;
        DisplayGamma: number;
        MinDesiredFrameRate: number;
        DefaultSelectedMaterialColor: LinearColor;
        SelectedMaterialColor: LinearColor;
        SelectionOutlineColor: LinearColor;
        SubduedSelectionOutlineColor: LinearColor;
        SelectedMaterialColorOverride: LinearColor;
        bIsOverridingSelectedColor: boolean;
        bEnableOnScreenDebugMessages: boolean;
        bEnableOnScreenDebugMessagesDisplay: boolean;
        bSuppressMapWarnings: boolean;
        bDisableAILogging: boolean;
        bEnableVisualLogRecordingOnStart: number;
        ScreenSaverInhibitorSemaphore: number;
        bLockReadOnlyLevels: boolean;
        ParticleEventManagerClassPath: string;
        SelectionHighlightIntensity: number;
        BSPSelectionHighlightIntensity: number;
        SelectionHighlightIntensityBillboards: number;
        NetDriverDefinitions: TArray<NetDriverDefinition>;
        ServerActors: TArray<string>;
        RuntimeServerActors: TArray<string>;
        NetErrorLogInterval: number;
        bStartedLoadMapMovie: boolean;
        NextWorldContextHandle: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Engine;

        static Load(InName: string): Engine;
    }

    export class Transactor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Transactor;

        static Load(InName: string): Transactor;
    }

    export class EditorWorldExtensionCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorWorldExtensionCollection;

        static Load(InName: string): EditorWorldExtensionCollection;
    }

    export class EditorWorldExtensionManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EditorWorldExtensionCollection: TArray<EditorWorldExtensionCollection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorWorldExtensionManager;

        static Load(InName: string): EditorWorldExtensionManager;
    }

    export class EditorEngine extends Engine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TempModel: Model;
        ConversionTempModel: Model;
        Trans: Transactor;
        Bad: Texture2D;
        EditorFont: Font;
        PreviewSoundCue: SoundCue;
        PreviewAudioComponent: AudioComponent;
        EditorCube: StaticMesh;
        EditorSphere: StaticMesh;
        EditorPlane: StaticMesh;
        EditorCylinder: StaticMesh;
        bFastRebuild: boolean;
        IsImportingT3D: boolean;
        ClickFlags: number;
        ParentContext: Package;
        UnsnappedClickLocation: Vector;
        ClickLocation: Vector;
        ClickPlane: Plane;
        MouseMovement: Vector;
        DetailMode: EDetailMode;
        UseSizingBox: boolean;
        UseAxisIndicator: boolean;
        GodMode: boolean;
        GameCommandLine: string;
        bShowBrushMarkerPolys: boolean;
        bEnableSocketSnapping: boolean;
        bEnableLODLocking: boolean;
        HeightMapExportClassName: string;
        ActorFactories: TArray<ActorFactory>;
        UserOpenedFile: string;
        InEditorGameURLOptions: string;
        PlayWorld: World;
        bIsToggleBetweenPIEandSIEQueued: boolean;
        bAllowMultiplePIEWorlds: boolean;
        bRequestEndPlayMapQueued: boolean;
        bSquelchTransactionNotification: boolean;
        bNotifyUndoRedoSelectionChange: boolean;
        PlayFromHerePlayerStartClass: Class;
        EditorWorld: World;
        ActorsThatWereSelected: TArray<TWeakObjectPtr<Actor>>;
        PlayWorldDestination: number;
        CurrentPlayWorldDestination: number;
        bMobilePreviewPortrait: boolean;
        BuildPlayDevice: number;
        UserEditedPlayWorldURL: string;
        ScratchRenderTarget2048: TextureRenderTarget2D;
        ScratchRenderTarget1024: TextureRenderTarget2D;
        ScratchRenderTarget512: TextureRenderTarget2D;
        ScratchRenderTarget256: TextureRenderTarget2D;
        PreviewMeshComp: StaticMeshComponent;
        PreviewMeshIndex: number;
        bShowPreviewMesh: boolean;
        bCustomCameraAlignEmitter: boolean;
        CustomCameraAlignEmitterDistance: number;
        bDrawSocketsInGMode: boolean;
        bDrawParticleHelpers: boolean;
        BrushBuilders: TArray<BrushBuilder>;
        EditorWorldExtensionsManager: EditorWorldExtensionManager;
        ActorGroupingUtilsClassName: SoftClassPath;
        ActorGroupingUtils: ActorGroupingUtils;
        PlayWorldLocation: Vector;
        PlayWorldRotation: Rotator;
        bIsPlayWorldQueued: boolean;
        bIsSimulateInEditorQueued: boolean;
        bHasPlayWorldPlacement: boolean;
        bUseMobilePreviewForPlayWorld: boolean;
        bUseVRPreviewForPlayWorld: boolean;
        bIsSimulatingInEditor: boolean;
        PlayInEditorViewportIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorEngine;

        static Load(InName: string): EditorEngine;
    }

    export enum EConsoleForGamepadLabels { None, XBoxOne, PS4, EConsoleForGamepadLabels_MAX }

    export class EditorExperimentalSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bHDREditor: boolean;
        HDREditorNITLevel: number;
        bProceduralFoliage: boolean;
        bEnableLocalizationDashboard: boolean;
        bEnableTranslationPicker: boolean;
        bEnableFavoriteSystem: boolean;
        ConsoleForGamepadLabels: EConsoleForGamepadLabels;
        bToolbarCustomization: boolean;
        bBreakOnExceptions: boolean;
        BaseClassesToAllowRecompilingDuringPlayInEditor: TArray<TSoftClassPtr<Object>>;
        ResolvedBaseClassesToAllowRecompilingDuringPlayInEditor: TArray<Class>;
        bDrawMidpointArrowsInBlueprints: boolean;
        bContextMenuChunkAssignments: boolean;
        bDisableCookInEditor: boolean;
        bSharedCookedBuilds: boolean;
        MultiProcessCooking: number;
        bAllowLateJoinInPIE: boolean;
        bAllowVulkanPreview: boolean;
        bEnableMultithreadedLightmapEncoding: boolean;
        bEnableMultithreadedShadowmapEncoding: boolean;
        bUseOpenCLForConvexHullDecomp: boolean;
        bAllowPotentiallyUnsafePropertyEditing: boolean;
        bFacialAnimationImporter: boolean;
        bMobilePIEPreviewDeviceLaunch: boolean;
        bTextAssetFormatSupport: boolean;
        bExampleLayersAndBlends: boolean;
        bEnableLongPathsSupport: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorExperimentalSettings;

        static Load(InName: string): EditorExperimentalSettings;
    }

    export enum ELevelVisibilityDirtyMode { ModifyOnChange, DontModify, ELevelVisibilityDirtyMode_MAX }

    export class EditorLevelUtils extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateNewStreamingLevel(LevelStreamingClass: $Nullable<Class>, NewLevelPath?: string /* = "" */, bMoveSelectedActorsIntoNewLevel?: boolean /* = false */): LevelStreaming;

        static K2_AddLevelToWorld(World: $Nullable<World>, LevelPackageName: string, LevelStreamingClass: $Nullable<Class>): LevelStreaming;

        static K2_AddLevelToWorldWithTransform(World: $Nullable<World>, LevelPackageName: string, LevelStreamingClass: $Nullable<Class>, LevelTransform: Transform): LevelStreaming;

        static MakeLevelCurrent(InStreamingLevel: $Nullable<LevelStreaming>): void;

        static MoveActorsToLevel(ActorsToMove: TArray<Actor>, DestStreamingLevel: $Nullable<LevelStreaming>, bWarnAboutReferences?: boolean /* = true */, bWarnAboutRenaming?: boolean /* = true */): number;

        static MoveSelectedActorsToLevel(DestLevel: $Nullable<LevelStreaming>, bWarnAboutReferences?: boolean /* = true */): number;

        static SetLevelsVisibility(Levels: TArray<Level>, bShouldBeVisible: TArray<boolean>, bForceLayersVisible: boolean, ModifyMode?: ELevelVisibilityDirtyMode /* = ModifyOnChange */): void;

        static SetLevelVisibility(Level: $Nullable<Level>, bShouldBeVisible: boolean, bForceLayersVisible: boolean, ModifyMode?: ELevelVisibilityDirtyMode /* = ModifyOnChange */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorLevelUtils;

        static Load(InName: string): EditorLevelUtils;
    }

    export enum EReloadPackagesInteractionMode {
        Interactive,
        AssumePositive,
        AssumeNegative,
        EReloadPackagesInteractionMode_MAX
    }

    export class EditorLoadingAndSavingUtils extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ExportScene(bExportSelectedActorsOnly: boolean): void;

        static GetDirtyContentPackages(OutDirtyPackages: $Ref<TArray<Package>>): void;

        static GetDirtyMapPackages(OutDirtyPackages: $Ref<TArray<Package>>): void;

        static ImportScene(Filename: string): void;

        static LoadMap(Filename: string): World;

        static LoadMapWithDialog(): World;

        static NewBlankMap(bSaveExistingMap: boolean): World;

        static NewMapFromTemplate(PathToTemplateLevel: string, bSaveExistingMap: boolean): World;

        static ReloadPackages(PackagesToReload: TArray<Package>, bOutAnyPackagesReloaded: $Ref<boolean>, OutErrorMessage: $Ref<string>, InteractionMode?: EReloadPackagesInteractionMode /* = Interactive */): void;

        static SaveCurrentLevel(): boolean;

        static SaveDirtyPackages(bSaveMapPackages: boolean, bSaveContentPackages: boolean): boolean;

        static SaveDirtyPackagesWithDialog(bSaveMapPackages: boolean, bSaveContentPackages: boolean): boolean;

        static SaveMap(World: $Nullable<World>, AssetPath: string): boolean;

        static SavePackages(PackagesToSave: TArray<Package>, bOnlyDirty: boolean): boolean;

        static SavePackagesWithDialog(PackagesToSave: TArray<Package>, bOnlyDirty: boolean): boolean;

        static UnloadPackages(PackagesToUnload: TArray<Package>, bOutAnyPackagesUnloaded: $Ref<boolean>, OutErrorMessage: $Ref<string>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorLoadingAndSavingUtils;

        static Load(InName: string): EditorLoadingAndSavingUtils;
    }

    export enum ELoadLevelAtStartup { None, ProjectDefault, LastOpened, ELoadLevelAtStartup_MAX }

    export class AutoReimportWildcard {
        constructor();
        constructor(Wildcard: string, bInclude: boolean);

        Wildcard: string;
        bInclude: boolean;

        static StaticClass(): Class;
    }

    export class AutoReimportDirectoryConfig {
        constructor();
        constructor(SourceDirectory: string, MountPoint: string, Wildcards: TArray<AutoReimportWildcard>);

        SourceDirectory: string;
        MountPoint: string;
        Wildcards: TArray<AutoReimportWildcard>;

        static StaticClass(): Class;
    }

    export class EditorLoadingSavingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LoadLevelAtStartup: ELoadLevelAtStartup;
        bForceCompilationAtStartup: boolean;
        bRestoreOpenAssetTabsOnRestart: boolean;
        bEnableSourceControlCompatabilityCheck: boolean;
        bMonitorContentDirectories: boolean;
        AutoReimportDirectories: TArray<string>;
        AutoReimportDirectorySettings: TArray<AutoReimportDirectoryConfig>;
        AutoReimportThreshold: number;
        bAutoCreateAssets: boolean;
        bAutoDeleteAssets: boolean;
        bDetectChangesOnStartup: boolean;
        bPromptBeforeAutoImporting: boolean;
        bDeleteSourceFilesWithAssets: boolean;
        bAutoReimportTextures: boolean;
        bAutoReimportCSV: boolean;
        bDirtyMigratedBlueprints: boolean;
        bAutoSaveEnable: boolean;
        bAutoSaveMaps: boolean;
        bAutoSaveContent: boolean;
        AutoSaveTimeMinutes: number;
        AutoSaveInteractionDelayInSeconds: number;
        AutoSaveWarningInSeconds: number;
        bAutomaticallyCheckoutOnAssetModification: boolean;
        bPromptForCheckoutOnAssetModification: boolean;
        bSCCAutoAddNewFiles: boolean;
        bSCCUseGlobalSettings: boolean;
        TextDiffToolPath: FilePath;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorLoadingSavingSettings;

        static Load(InName: string): EditorLoadingSavingSettings;
    }

    export class EditorMiscSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorMiscSettings;

        static Load(InName: string): EditorMiscSettings;
    }

    export class EditorNotifyObject extends EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Event: AnimNotifyEvent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorNotifyObject;

        static Load(InName: string): EditorNotifyObject;
    }

    export class EditorParentPlayerListObj extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Overrides: TArray<AnimParentNodeAssetOverride>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorParentPlayerListObj;

        static Load(InName: string): EditorParentPlayerListObj;
    }

    export class EditorPerformanceSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bShowFrameRateAndMemory: boolean;
        bThrottleCPUWhenNotForeground: boolean;
        bDisableRealtimeViewportsInRemoteSessions: boolean;
        bMonitorEditorPerformance: boolean;
        bOverrideDPIBasedEditorViewportScaling: boolean;
        bEnableSharedDDCPerformanceNotifications: boolean;
        bEnableScalabilityWarningIndicator: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorPerformanceSettings;

        static Load(InName: string): EditorPerformanceSettings;
    }

    export class EditorPerProjectUserSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDisplayUIExtensionPoints: boolean;
        bDisplayDocumentationLink: boolean;
        bDisplayActionListItemRefIds: boolean;
        bAlwaysGatherBehaviorTreeDebuggerData: boolean;
        bDisplayBlackboardKeysInAlphabeticalOrder: boolean;
        bDisplayEngineVersionInBadge: boolean;
        bUseSimplygonSwarm: boolean;
        SimplygonServerIP: string;
        bEnableSwarmDebugging: boolean;
        SimplygonSwarmDelay: number;
        SwarmNumOfConcurrentJobs: number;
        SwarmMaxUploadChunkSizeInMB: number;
        SwarmIntermediateFolder: string;
        bAutomaticallyHotReloadNewClasses: boolean;
        bShowCompilerLogOnCompileError: boolean;
        bKeepFbxNamespace: boolean;
        bShowImportDialogAtReimport: boolean;
        DataSourceFolder: DirectoryPath;
        bKeepAttachHierarchy: boolean;
        bAnimationReimportWarnings: boolean;
        bUseCurvesForDistributions: boolean;
        PropertyMatrix_NumberOfPasteOperationsBeforeWarning: number;
        bSCSEditorShowGrid: boolean;
        bSCSEditorShowFloor: boolean;
        bGetAttentionOnUATCompletion: boolean;
        SCSViewportCameraSpeed: number;
        bAutoloadCheckedOutPackages: boolean;
        bSuppressFullyLoadPrompt: boolean;
        bAllowSelectTranslucent: boolean;
        BlueprintFavorites: BlueprintPaletteFavorites;
        AssetViewerProfileIndex: number;
        AssetViewerProfileName: string;
        MaterialQualityLevel: number;
        PreviewFeatureLevel: number;
        PreviewPlatformName: string;
        PreviewShaderFormatName: string;
        bPreviewFeatureLevelActive: boolean;
        PreviewDeviceProfileName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorPerProjectUserSettings;

        static Load(InName: string): EditorPerProjectUserSettings;
    }

    export enum EUnit {
        Micrometers,
        Millimeters,
        Centimeters,
        Meters,
        Kilometers,
        Inches,
        Feet,
        Yards,
        Miles,
        Lightyears,
        Degrees,
        Radians,
        MetersPerSecond,
        KilometersPerHour,
        MilesPerHour,
        Celsius,
        Farenheit,
        Kelvin,
        Micrograms,
        Milligrams,
        Grams,
        Kilograms,
        MetricTons,
        Ounces,
        Pounds,
        Stones,
        Newtons,
        PoundsForce,
        KilogramsForce,
        Hertz,
        Kilohertz,
        Megahertz,
        Gigahertz,
        RevolutionsPerMinute,
        Bytes,
        Kilobytes,
        Megabytes,
        Gigabytes,
        Terabytes,
        Lumens,
        Milliseconds,
        Seconds,
        Minutes,
        Hours,
        Days,
        Months,
        Years,
        Multiplier,
        Percentage,
        Unspecified,
        EUnit_MAX
    }

    export enum EUnitDisplay { None, Metric, Imperial, Invalid, EUnitDisplay_MAX }

    export enum EDefaultLocationUnit {
        Micrometers,
        Millimeters,
        Centimeters,
        Meters,
        Kilometers,
        Inches,
        Feet,
        Yards,
        Miles,
        Invalid,
        EDefaultLocationUnit_MAX
    }

    export class EditorProjectAppearanceSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDisplayUnits: boolean;
        bDisplayUnitsOnComponentTransforms: boolean;
        DistanceUnits: TArray<EUnit>;
        MassUnits: TArray<EUnit>;
        TimeUnits: TArray<EUnit>;
        AngleUnits: EUnit;
        SpeedUnits: EUnit;
        TemperatureUnits: EUnit;
        ForceUnits: EUnit;
        UnitDisplay: EUnitDisplay;
        DefaultInputUnits: EDefaultLocationUnit;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorProjectAppearanceSettings;

        static Load(InName: string): EditorProjectAppearanceSettings;
    }

    export class EditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bLoadTheMostRecentlyLoadedProjectAtStartup: boolean;
        bEditorAnalyticsEnabled: boolean;
        LocalDerivedDataCache: DirectoryPath;
        SharedDerivedDataCache: DirectoryPath;
        bEnableS3DDC: boolean;
        RecentlyOpenedProjectFiles: TArray<string>;
        CreatedProjectPaths: TArray<string>;
        bCopyStarterContentPreference: boolean;
        CompletedSurveys: TArray<Guid>;
        InProgressSurveys: TArray<Guid>;
        AutoScalabilityWorkScaleAmount: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorSettings;

        static Load(InName: string): EditorSettings;
    }

    export class EditorSkeletonNotifyObj extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Name: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorSkeletonNotifyObj;

        static Load(InName: string): EditorSkeletonNotifyObj;
    }

    export enum EColorVisionDeficiency { NormalVision, Deuteranope, Protanope, Tritanope, EColorVisionDeficiency_MAX }

    export enum ELogTimes { None, UTC, SinceGStartTime, Local, ELogTimes_MAX }

    export enum EAssetEditorOpenLocation {
        Default,
        NewWindow,
        MainWindow,
        ContentBrowser,
        LastDockedWindowOrNewWindow,
        LastDockedWindowOrMainWindow,
        LastDockedWindowOrContentBrowser,
        EAssetEditorOpenLocation_MAX
    }

    export class EditorStyleSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bEnableHighDPIAwareness: boolean;
        bEnableUserEditorLayoutManagement: boolean;
        ColorVisionDeficiencyPreviewType: EColorVisionDeficiency;
        ColorVisionDeficiencySeverity: number;
        bColorVisionDeficiencyCorrection: boolean;
        bColorVisionDeficiencyCorrectionPreviewWithDeficiency: boolean;
        SelectionColor: LinearColor;
        PressedSelectionColor: LinearColor;
        InactiveSelectionColor: LinearColor;
        KeyboardFocusColor: LinearColor;
        EditorWindowBackgroundColor: LinearColor;
        EditorMainWindowBackgroundOverride: SlateBrush;
        EditorChildWindowBackgroundOverride: SlateBrush;
        bResetEditorWindowBackgroundSettings: boolean;
        bUseSmallToolBarIcons: boolean;
        bUseGrid: boolean;
        RegularColor: LinearColor;
        RuleColor: LinearColor;
        CenterColor: LinearColor;
        GridSnapSize: number;
        GraphBackgroundBrush: SlateBrush;
        bEnableWindowAnimations: boolean;
        bShowFriendlyNames: boolean;
        bShowNativeComponentNames: boolean;
        bExpandConfigurationMenus: boolean;
        bShowProjectMenus: boolean;
        bShowLaunchMenus: boolean;
        LogBackgroundColor: LinearColor;
        LogSelectionBackgroundColor: LinearColor;
        LogNormalColor: LinearColor;
        LogCommandColor: LinearColor;
        LogWarningColor: LinearColor;
        LogErrorColor: LinearColor;
        bShowAllAdvancedDetails: boolean;
        bShowHiddenPropertiesWhilePlaying: boolean;
        LogFontSize: number;
        LogTimestampMode: ELogTimes;
        bPromoteOutputLogWarningsDuringPIE: boolean;
        AssetEditorOpenLocation: EAssetEditorOpenLocation;
        bEnableColorizedEditorTabs: boolean;
        bEnableLegacyEditorModeUI: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorStyleSettings;

        static Load(InName: string): EditorStyleSettings;
    }

    export class EditorSubsystemBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetEditorSubsystem(Class: $Nullable<Class>): EditorSubsystem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorSubsystemBlueprintLibrary;

        static Load(InName: string): EditorSubsystemBlueprintLibrary;
    }

    export enum ETutorialContent { None, Text, UDNExcerpt, RichText, ETutorialContent_MAX }

    export class TutorialContent {
        constructor();
        constructor(Type: ETutorialContent, Content: string, ExcerptName: string, Text: string);

        Type: ETutorialContent;
        Content: string;
        ExcerptName: string;
        Text: string;

        static StaticClass(): Class;
    }

    export enum ETutorialAnchorIdentifier { None, NamedWidget, Asset, ETutorialAnchorIdentifier_MAX }

    export class TutorialContentAnchor {
        constructor();
        constructor(Type: ETutorialAnchorIdentifier, WrapperIdentifier: string, Asset: SoftObjectPath, bDrawHighlight: boolean, TabToFocusOrOpen: string, FriendlyName: string, GUIDString: string, OuterName: string);

        Type: ETutorialAnchorIdentifier;
        WrapperIdentifier: string;
        Asset: SoftObjectPath;
        bDrawHighlight: boolean;
        TabToFocusOrOpen: string;
        FriendlyName: string;
        GUIDString: string;
        OuterName: string;

        static StaticClass(): Class;
    }

    export class TutorialWidgetContent {
        constructor();
        constructor(Content: TutorialContent, WidgetAnchor: TutorialContentAnchor, HorizontalAlignment: EHorizontalAlignment, VerticalAlignment: EVerticalAlignment, Offset: Vector2D, ContentWidth: number, bAutoFocus: boolean);

        Content: TutorialContent;
        WidgetAnchor: TutorialContentAnchor;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;
        Offset: Vector2D;
        ContentWidth: number;
        bAutoFocus: boolean;

        static StaticClass(): Class;
    }

    export class TutorialStage {
        constructor();
        constructor(Name: string, Content: TutorialContent, WidgetContent: TArray<TutorialWidgetContent>, NextButtonText: string, BackButtonText: string, PlatformsToTest: TArray<string>, bInvertPlatformTest: boolean);

        Name: string;
        Content: TutorialContent;
        WidgetContent: TArray<TutorialWidgetContent>;
        NextButtonText: string;
        BackButtonText: string;
        PlatformsToTest: TArray<string>;
        bInvertPlatformTest: boolean;

        static StaticClass(): Class;
    }

    export class EditorTutorial extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Title: string;
        SortOrder: number;
        Icon: string;
        Texture: Texture2D;
        Category: string;
        SummaryContent: TutorialContent;
        Stages: TArray<TutorialStage>;
        PreviousTutorial: SoftClassPath;
        NextTutorial: SoftClassPath;
        bIsStandalone: boolean;
        AssetToUse: SoftObjectPath;
        ImportPath: string;
        bHideInBrowser: boolean;
        SearchTags: string;

        GetActorReference(PathToActor: string): Actor;

        OnTutorialClosed(): void;

        OnTutorialLaunched(): void;

        OnTutorialStageEnded(StageName: string): void;

        OnTutorialStageStarted(StageName: string): void;

        static BeginTutorial(TutorialToStart: $Nullable<EditorTutorial>, bRestart: boolean): void;

        static GetEngineFolderVisibilty(): boolean;

        static GoToNextTutorialStage(): void;

        static GoToPreviousTutorialStage(): void;

        static OpenAsset(Asset: $Nullable<Object>): void;

        static SetEngineFolderVisibilty(bNewVisibility: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorTutorial;

        static Load(InName: string): EditorTutorial;
    }

    export class EditorTutorialFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorTutorialFactory;

        static Load(InName: string): EditorTutorialFactory;
    }

    export class EditorTutorialImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorTutorialImportFactory;

        static Load(InName: string): EditorTutorialImportFactory;
    }

    export class TutorialCategory {
        constructor();
        constructor(Identifier: string, Title: string, SortOrder: number, Description: string, Icon: string, Texture: SoftObjectPath);

        Identifier: string;
        Title: string;
        SortOrder: number;
        Description: string;
        Icon: string;
        Texture: SoftObjectPath;

        static StaticClass(): Class;
    }

    export class TutorialContext {
        constructor();
        constructor(Context: string, BrowserFilter: string, AttractTutorial: SoftClassPath, LaunchTutorial: SoftClassPath);

        Context: string;
        BrowserFilter: string;
        AttractTutorial: SoftClassPath;
        LaunchTutorial: SoftClassPath;

        static StaticClass(): Class;
    }

    export class EditorTutorialSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDisableAllTutorialAlerts: boolean;
        Categories: TArray<TutorialCategory>;
        StartupTutorial: SoftClassPath;
        TutorialContexts: TArray<TutorialContext>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorTutorialSettings;

        static Load(InName: string): EditorTutorialSettings;
    }

    export class EditorUtilityActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Run(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityActor;

        static Load(InName: string): EditorUtilityActor;
    }

    export class EditorUtilityActorComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityActorComponent;

        static Load(InName: string): EditorUtilityActorComponent;
    }

    export class EditorUtilityBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityBlueprint;

        static Load(InName: string): EditorUtilityBlueprint;
    }

    export class EditorUtilityBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParentClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityBlueprintFactory;

        static Load(InName: string): EditorUtilityBlueprintFactory;
    }

    export class EditorUtilityCamera extends CameraActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityCamera;

        static Load(InName: string): EditorUtilityCamera;
    }

    export class EditorUtilityExtension extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityExtension;

        static Load(InName: string): EditorUtilityExtension;
    }

    export class EditorUtilityLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetActorReference(PathToActor: string): Actor;

        static GetSelectedAssetData(): TArray<AssetData>;

        static GetSelectedAssets(): TArray<Object>;

        static GetSelectedBlueprintClasses(): TArray<Class>;

        static GetSelectionBounds(Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>, SphereRadius: $Ref<number>): void;

        static GetSelectionSet(): TArray<Actor>;

        static RenameAsset(Asset: $Nullable<Object>, NewName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityLibrary;

        static Load(InName: string): EditorUtilityLibrary;
    }

    export class EditorUtilityTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MyTaskManager: EditorUtilitySubsystem;

        FinishExecutingTask(): void;

        ReceiveBeginExecution(): void;

        Run(): void;

        SetTaskNotificationText(Text: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityTask;

        static Load(InName: string): EditorUtilityTask;
    }

    export class EditorPropertyPathSegment {
        constructor();
        constructor(Struct: Struct, MemberName: string, MemberGuid: Guid, IsProperty: boolean);

        Struct: Struct;
        MemberName: string;
        MemberGuid: Guid;
        IsProperty: boolean;

        static StaticClass(): Class;
    }

    export class EditorPropertyPath {
        constructor();
        constructor(Segments: TArray<EditorPropertyPathSegment>);

        Segments: TArray<EditorPropertyPathSegment>;

        static StaticClass(): Class;
    }

    export enum EBindingKind { Function, Property, EBindingKind_MAX }

    export class DelegateEditorBinding {
        constructor();
        constructor(ObjectName: string, PropertyName: string, FunctionName: string, SourceProperty: string, SourcePath: EditorPropertyPath, MemberGuid: Guid, Kind: EBindingKind);

        ObjectName: string;
        PropertyName: string;
        FunctionName: string;
        SourceProperty: string;
        SourcePath: EditorPropertyPath;
        MemberGuid: Guid;
        Kind: EBindingKind;

        static StaticClass(): Class;
    }

    export class WidgetAnimation_DEPRECATED {
        constructor();
        constructor(MovieScene: MovieScene, AnimationBindings: TArray<WidgetAnimationBinding>);

        MovieScene: MovieScene;
        AnimationBindings: TArray<WidgetAnimationBinding>;

        static StaticClass(): Class;
    }

    export enum EWidgetCompileTimeTickPrediction { WontTick, OnDemand, WillTick, EWidgetCompileTimeTickPrediction_MAX }

    export class WidgetBlueprint extends BaseWidgetBlueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Bindings: TArray<DelegateEditorBinding>;
        AnimationData: TArray<WidgetAnimation_DEPRECATED>;
        Animations: TArray<WidgetAnimation>;
        PaletteCategory: string;
        TickFrequency: EWidgetTickFrequency;
        TickPrediction: EWidgetCompileTimeTickPrediction;
        TickPredictionReason: string;
        PropertyBindings: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetBlueprint;

        static Load(InName: string): WidgetBlueprint;
    }

    export class EditorUtilityWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HelpText: string;
        bAlwaysReregisterWithWindowsMenu: boolean;
        bAutoRunDefaultAction: boolean;

        Run(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidget;

        static Load(InName: string): EditorUtilityWidget;
    }

    export class EditorUtilityWidgetBlueprint extends WidgetBlueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CreatedUMGWidget: EditorUtilityWidget;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidgetBlueprint;

        static Load(InName: string): EditorUtilityWidgetBlueprint;
    }

    export class EditorUtilitySubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LoadedUIs: TArray<SoftObjectPath>;
        StartupObjects: TArray<SoftObjectPath>;
        ObjectInstances: TMap<Object, Object>;
        PendingTasks: TArray<EditorUtilityTask>;
        ActiveTask: EditorUtilityTask;

        CloseTabByID(NewTabID: string): boolean;

        DoesTabExist(NewTabID: string): boolean;

        FindUtilityWidgetFromBlueprint(InBlueprint: $Nullable<EditorUtilityWidgetBlueprint>): EditorUtilityWidget;

        RegisterAndExecuteTask(NewTask: $Nullable<EditorUtilityTask>): void;

        RegisterTabAndGetID(InBlueprint: $Nullable<EditorUtilityWidgetBlueprint>, NewTabID: $Ref<string>): void;

        ReleaseInstanceOfAsset(Asset: $Nullable<Object>): void;

        SpawnAndRegisterTab(InBlueprint: $Nullable<EditorUtilityWidgetBlueprint>): EditorUtilityWidget;

        SpawnAndRegisterTabAndGetID(InBlueprint: $Nullable<EditorUtilityWidgetBlueprint>, NewTabID: $Ref<string>): EditorUtilityWidget;

        SpawnRegisteredTabByID(NewTabID: string): boolean;

        TryRun(Asset: $Nullable<Object>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilitySubsystem;

        static Load(InName: string): EditorUtilitySubsystem;
    }

    export class ScriptSlateIcon {
        constructor();
        constructor(StyleSetName: string, StyleName: string, SmallStyleName: string);

        StyleSetName: string;
        StyleName: string;
        SmallStyleName: string;

        static StaticClass(): Class;
    }

    export enum EToolMenuInsertType { Default, Before, After, First, EToolMenuInsertType_MAX }

    export class ToolMenuInsert {
        constructor();
        constructor(Name: string, Position: EToolMenuInsertType);

        Name: string;
        Position: EToolMenuInsertType;

        static StaticClass(): Class;
    }

    export enum EMultiBlockType {
        None,
        ButtonRow,
        EditableText,
        Heading,
        MenuEntry,
        Separator,
        ToolBarButton,
        ToolBarComboButton,
        Widget,
        EMultiBlockType_MAX
    }

    export enum EUserInterfaceActionType {
        None,
        Button,
        ToggleButton,
        RadioButton,
        Check,
        CollapsedButton,
        EUserInterfaceActionType_MAX
    }

    export class ToolMenuEntryScriptDataAdvanced {
        constructor();
        constructor(TutorialHighlight: string, EntryType: EMultiBlockType, UserInterfaceActionType: EUserInterfaceActionType, bIsSubMenu: boolean, bOpenSubMenuOnClick: boolean, bShouldCloseWindowAfterMenuSelection: boolean, bSimpleComboBox: boolean);

        TutorialHighlight: string;
        EntryType: EMultiBlockType;
        UserInterfaceActionType: EUserInterfaceActionType;
        bIsSubMenu: boolean;
        bOpenSubMenuOnClick: boolean;
        bShouldCloseWindowAfterMenuSelection: boolean;
        bSimpleComboBox: boolean;

        static StaticClass(): Class;
    }

    export class ToolMenuEntryScriptData {
        constructor();
        constructor(Menu: string, Section: string, Name: string, Label: string, ToolTip: string, Icon: ScriptSlateIcon, OwnerName: string, InsertPosition: ToolMenuInsert, Advanced: ToolMenuEntryScriptDataAdvanced);

        Menu: string;
        Section: string;
        Name: string;
        Label: string;
        ToolTip: string;
        Icon: ScriptSlateIcon;
        OwnerName: string;
        InsertPosition: ToolMenuInsert;
        Advanced: ToolMenuEntryScriptDataAdvanced;

        static StaticClass(): Class;
    }

    export class ToolMenuContext {
        constructor();
        constructor(ContextObjects: TArray<Object>);

        ContextObjects: TArray<Object>;

        static StaticClass(): Class;
    }

    export class ToolMenuBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenuBase;

        static Load(InName: string): ToolMenuBase;
    }

    export enum EMultiBoxType { MenuBar, ToolBar, VerticalToolBar, UniformToolBar, Menu, ButtonRow, EMultiBoxType_MAX }

    export class ToolMenuOwner {
        constructor();

        static StaticClass(): Class;
    }

    export class ToolMenuEntry {
        constructor();
        constructor(Name: string, Owner: ToolMenuOwner, Type: EMultiBlockType, UserInterfaceActionType: EUserInterfaceActionType, TutorialHighlightName: string, InsertPosition: ToolMenuInsert, bShouldCloseWindowAfterMenuSelection: boolean, ScriptObject: ToolMenuEntryScript);

        Name: string;
        Owner: ToolMenuOwner;
        Type: EMultiBlockType;
        UserInterfaceActionType: EUserInterfaceActionType;
        TutorialHighlightName: string;
        InsertPosition: ToolMenuInsert;
        bShouldCloseWindowAfterMenuSelection: boolean;
        ScriptObject: ToolMenuEntryScript;

        static StaticClass(): Class;
    }

    export class ToolMenuSectionDynamic extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstructSections(Menu: $Nullable<ToolMenu>, Context: ToolMenuContext): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenuSectionDynamic;

        static Load(InName: string): ToolMenuSectionDynamic;
    }

    export class ToolMenuSection {
        constructor();
        constructor(Name: string, Owner: ToolMenuOwner, Blocks: TArray<ToolMenuEntry>, InsertPosition: ToolMenuInsert, Context: ToolMenuContext, ToolMenuSectionDynamic: ToolMenuSectionDynamic);

        Name: string;
        Owner: ToolMenuOwner;
        Blocks: TArray<ToolMenuEntry>;
        InsertPosition: ToolMenuInsert;
        Context: ToolMenuContext;
        ToolMenuSectionDynamic: ToolMenuSectionDynamic;

        static StaticClass(): Class;
    }

    export class ToolMenu extends ToolMenuBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MenuName: string;
        MenuParent: string;
        StyleName: string;
        TutorialHighlightName: string;
        MenuType: EMultiBoxType;
        bShouldCloseWindowAfterMenuSelection: boolean;
        bCloseSelfOnly: boolean;
        bSearchable: boolean;
        bToolBarIsFocusable: boolean;
        bToolBarForceSmallIcons: boolean;
        bPreventCustomization: boolean;
        MenuOwner: ToolMenuOwner;
        Context: ToolMenuContext;
        Sections: TArray<ToolMenuSection>;
        SubMenuParent: ToolMenu;
        SubMenuSourceEntryName: string;

        AddDynamicSectionScript(SectionName: string, Object: $Nullable<ToolMenuSectionDynamic>): void;

        AddMenuEntry(SectionName: string, Args: ToolMenuEntry): void;

        AddMenuEntryObject(InObject: $Nullable<ToolMenuEntryScript>): void;

        AddSectionScript(SectionName: string, Label?: string /* = "" */, InsertName?: string /* = "None" */, InsertType?: EToolMenuInsertType /* = Default */): void;

        AddSubMenuScript(Owner: string, SectionName: string, Name: string, Label: string, ToolTip?: string /* = "" */): ToolMenu;

        InitMenu(Owner: ToolMenuOwner, Name: string, Parent?: string /* = "None" */, Type?: EMultiBoxType /* = Menu */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenu;

        static Load(InName: string): ToolMenu;
    }

    export class ToolMenuEntryScript extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Data: ToolMenuEntryScriptData;

        CanExecute(Context: ToolMenuContext): boolean;

        ConstructMenuEntry(Menu: $Nullable<ToolMenu>, SectionName: string, Context: ToolMenuContext): void;

        Execute(Context: ToolMenuContext): void;

        GetCheckState(Context: ToolMenuContext): ECheckBoxState;

        GetIcon(Context: ToolMenuContext): ScriptSlateIcon;

        GetLabel(Context: ToolMenuContext): string;

        GetToolTip(Context: ToolMenuContext): string;

        InitEntry(OwnerName: string, Menu: string, Section: string, Name: string, Label?: string /* = "" */, ToolTip?: string /* = "" */): void;

        IsVisible(Context: ToolMenuContext): boolean;

        RegisterMenuEntry(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenuEntryScript;

        static Load(InName: string): ToolMenuEntryScript;
    }

    export class EditorUtilityToolMenuEntry extends ToolMenuEntryScript {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityToolMenuEntry;

        static Load(InName: string): EditorUtilityToolMenuEntry;
    }

    export class EditorUtilityToolMenuSection extends ToolMenuSectionDynamic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityToolMenuSection;

        static Load(InName: string): EditorUtilityToolMenuSection;
    }

    export class EditorUtilityWidgetBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlueprintType: EBlueprintType;
        ParentClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidgetBlueprintFactory;

        static Load(InName: string): EditorUtilityWidgetBlueprintFactory;
    }

    export class EditorViewportViewMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EditorViewportViewMenuContext;

        static Load(InName: string): EditorViewportViewMenuContext;
    }

    export class InputRouter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoInvalidateOnHover: boolean;
        bAutoInvalidateOnCapture: boolean;
        ActiveInputBehaviors: InputBehaviorSet;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputRouter;

        static Load(InName: string): InputRouter;
    }

    export class InteractiveToolManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActiveLeftTool: InteractiveTool;
        ActiveRightTool: InteractiveTool;
        ToolBuilders: TMap<string, InteractiveToolBuilder>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveToolManager;

        static Load(InName: string): InteractiveToolManager;
    }

    export class ActiveGizmo {
        constructor();

        static StaticClass(): Class;
    }

    export class InteractiveGizmoManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActiveGizmos: TArray<ActiveGizmo>;
        GizmoBuilders: TMap<string, InteractiveGizmoBuilder>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveGizmoManager;

        static Load(InName: string): InteractiveGizmoManager;
    }

    export class InteractiveToolsContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputRouter: InputRouter;
        ToolManager: InteractiveToolManager;
        GizmoManager: InteractiveGizmoManager;
        ToolManagerClass: TSoftClassPtr<InteractiveToolManager>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveToolsContext;

        static Load(InName: string): InteractiveToolsContext;
    }

    export class EdModeInteractiveToolsContext extends InteractiveToolsContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StandardVertexColorMaterial: MaterialInterface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdModeInteractiveToolsContext;

        static Load(InName: string): EdModeInteractiveToolsContext;
    }

    export class EdMode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ToolsContext: EdModeInteractiveToolsContext;
        SettingsClass: TSoftClassPtr<Object>;
        SettingsObject: Object;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EdMode;

        static Load(InName: string): EdMode;
    }

    export class EllipseSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumberOfPoints: number;
        Length: number;
        Width: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EllipseSplineGenerator;

        static Load(InName: string): EllipseSplineGenerator;
    }

    export class TurnBasedMatchInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnMatchEnded(Match: string): void;

        OnMatchReceivedTurn(Match: string, bDidBecomeActive: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TurnBasedMatchInterface;

        static Load(InName: string): TurnBasedMatchInterface;
    }

    export enum EMPMatchOutcome {
        None,
        Quit,
        Won,
        Lost,
        Tied,
        TimeExpired,
        First,
        Second,
        Third,
        Fourth,
        EMPMatchOutcome_MAX
    }

    export class EndMatchCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;

        static EndMatch(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, MatchActor: TurnBasedMatchInterface, MatchID: string, LocalPlayerOutcome: EMPMatchOutcome, OtherPlayersOutcome: EMPMatchOutcome): EndMatchCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EndMatchCallbackProxy;

        static Load(InName: string): EndMatchCallbackProxy;
    }

    export class EndpointSubmix extends SoundSubmixBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EndpointType: string;
        EndpointSettingsClass: Class;
        EndpointSettings: AudioEndpointSettingsBase;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EndpointSubmix;

        static Load(InName: string): EndpointSubmix;
    }

    export class EndpointSubmixFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EndpointSubmixFactory;

        static Load(InName: string): EndpointSubmixFactory;
    }

    export class EndTurnCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;

        static EndTurn(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, MatchID: string, TurnBasedMatchInterface: TurnBasedMatchInterface): EndTurnCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EndTurnCallbackProxy;

        static Load(InName: string): EndTurnCallbackProxy;
    }

    export class EngineBaseTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EngineBaseTypes;

        static Load(InName: string): EngineBaseTypes;
    }

    export class HandlerComponentFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HandlerComponentFactory;

        static Load(InName: string): HandlerComponentFactory;
    }

    export class EngineHandlerComponentFactory extends HandlerComponentFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EngineHandlerComponentFactory;

        static Load(InName: string): EngineHandlerComponentFactory;
    }

    export class LocalMessage extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalMessage;

        static Load(InName: string): LocalMessage;
    }

    export class EngineMessage extends LocalMessage {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FailedPlaceMessage: string;
        MaxedOutMessage: string;
        EnteredMessage: string;
        LeftMessage: string;
        GlobalNameChange: string;
        SpecEnteredMessage: string;
        NewPlayerMessage: string;
        NewSpecMessage: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EngineMessage;

        static Load(InName: string): EngineMessage;
    }

    export class EngineTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EngineTypes;

        static Load(InName: string): EngineTypes;
    }

    export class EnumFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnumFactory;

        static Load(InName: string): EnumFactory;
    }

    export class EnumProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnumProperty;

        static Load(InName: string): EnumProperty;
    }

    export class EnvQueryContext_BlueprintBase extends EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProvideActorsSet(QuerierObject: $Nullable<Object>, QuerierActor: $Nullable<Actor>, ResultingActorsSet: $Ref<TArray<Actor>>): void;

        ProvideLocationsSet(QuerierObject: $Nullable<Object>, QuerierActor: $Nullable<Actor>, ResultingLocationSet: $Ref<TArray<Vector>>): void;

        ProvideSingleActor(QuerierObject: $Nullable<Object>, QuerierActor: $Nullable<Actor>, ResultingActor: $Ref<Actor>): void;

        ProvideSingleLocation(QuerierObject: $Nullable<Object>, QuerierActor: $Nullable<Actor>, ResultingLocation: $Ref<Vector>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_BlueprintBase;

        static Load(InName: string): EnvQueryContext_BlueprintBase;
    }

    export class EnvQueryContext_Item extends EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_Item;

        static Load(InName: string): EnvQueryContext_Item;
    }

    export class EnvQueryContext_Querier extends EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_Querier;

        static Load(InName: string): EnvQueryContext_Querier;
    }

    export class EnvQueryDebugHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryDebugHelpers;

        static Load(InName: string): EnvQueryDebugHelpers;
    }

    export class EnvQueryGenerator_ActorsOfClass extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SearchedActorClass: Class;
        GenerateOnlyActorsInRadius: AIDataProviderBoolValue;
        SearchRadius: AIDataProviderFloatValue;
        SearchCenter: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_ActorsOfClass;

        static Load(InName: string): EnvQueryGenerator_ActorsOfClass;
    }

    export class EnvQueryGenerator_BlueprintBase extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GeneratorsActionDescription: string;
        Context: Class;
        GeneratedItemType: Class;

        AddGeneratedActor(GeneratedActor: $Nullable<Actor>): void;

        AddGeneratedVector(GeneratedVector: Vector): void;

        DoItemGeneration(ContextLocations: TArray<Vector>): void;

        GetQuerier(): Object;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_BlueprintBase;

        static Load(InName: string): EnvQueryGenerator_BlueprintBase;
    }

    export class EnvQueryGenerator_Composite extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Generators: TArray<EnvQueryGenerator>;
        bAllowDifferentItemTypes: boolean;
        bHasMatchingItemType: boolean;
        ForcedItemType: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Composite;

        static Load(InName: string): EnvQueryGenerator_Composite;
    }

    export enum EEnvTraceShape { Line, Box, Sphere, Capsule, EEnvTraceShape_MAX }

    export enum EEnvQueryTrace { None, Navigation, Geometry, NavigationOverLedges, EEnvQueryTrace_MAX }

    export class EnvTraceData {
        constructor();
        constructor(VersionNum: number, NavigationFilter: Class, ProjectDown: number, ProjectUp: number, ExtentX: number, ExtentY: number, ExtentZ: number, PostProjectionVerticalOffset: number, TraceChannel: ETraceTypeQuery, SerializedChannel: ECollisionChannel, TraceShape: EEnvTraceShape, TraceMode: EEnvQueryTrace, bTraceComplex: boolean, bOnlyBlockingHits: boolean, bCanTraceOnNavMesh: boolean, bCanTraceOnGeometry: boolean, bCanDisableTrace: boolean, bCanProjectDown: boolean);

        VersionNum: number;
        NavigationFilter: Class;
        ProjectDown: number;
        ProjectUp: number;
        ExtentX: number;
        ExtentY: number;
        ExtentZ: number;
        PostProjectionVerticalOffset: number;
        TraceChannel: ETraceTypeQuery;
        SerializedChannel: ECollisionChannel;
        TraceShape: EEnvTraceShape;
        TraceMode: EEnvQueryTrace;
        bTraceComplex: boolean;
        bOnlyBlockingHits: boolean;
        bCanTraceOnNavMesh: boolean;
        bCanTraceOnGeometry: boolean;
        bCanDisableTrace: boolean;
        bCanProjectDown: boolean;

        static StaticClass(): Class;
    }

    export class EnvQueryGenerator_ProjectedPoints extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProjectionData: EnvTraceData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_ProjectedPoints;

        static Load(InName: string): EnvQueryGenerator_ProjectedPoints;
    }

    export class EnvQueryGenerator_Cone extends EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AlignedPointsDistance: AIDataProviderFloatValue;
        ConeDegrees: AIDataProviderFloatValue;
        AngleStep: AIDataProviderFloatValue;
        Range: AIDataProviderFloatValue;
        CenterActor: Class;
        bIncludeContextLocation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Cone;

        static Load(InName: string): EnvQueryGenerator_Cone;
    }

    export class EnvQueryGenerator_CurrentLocation extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QueryContext: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_CurrentLocation;

        static Load(InName: string): EnvQueryGenerator_CurrentLocation;
    }

    export class AIDataProviderIntValue extends AIDataProviderTypedValue {
        constructor();
        constructor(DefaultValue: number);

        DefaultValue: number;

        static StaticClass(): Class;
    }

    export enum EEnvDirection { TwoPoints, Rotation, EEnvDirection_MAX }

    export class EnvDirection {
        constructor();
        constructor(LineFrom: Class, LineTo: Class, Rotation: Class, DirMode: EEnvDirection);

        LineFrom: Class;
        LineTo: Class;
        Rotation: Class;
        DirMode: EEnvDirection;

        static StaticClass(): Class;
    }

    export class EnvQueryGenerator_Donut extends EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InnerRadius: AIDataProviderFloatValue;
        OuterRadius: AIDataProviderFloatValue;
        NumberOfRings: AIDataProviderIntValue;
        PointsPerRing: AIDataProviderIntValue;
        ArcDirection: EnvDirection;
        ArcAngle: AIDataProviderFloatValue;
        bUseSpiralPattern: boolean;
        Center: Class;
        bDefineArc: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Donut;

        static Load(InName: string): EnvQueryGenerator_Donut;
    }

    export enum EPointOnCircleSpacingMethod { BySpaceBetween, ByNumberOfPoints, EPointOnCircleSpacingMethod_MAX }

    export class EnvQueryGenerator_OnCircle extends EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CircleRadius: AIDataProviderFloatValue;
        SpaceBetween: AIDataProviderFloatValue;
        NumberOfPoints: AIDataProviderIntValue;
        PointOnCircleSpacingMethod: EPointOnCircleSpacingMethod;
        ArcDirection: EnvDirection;
        ArcAngle: AIDataProviderFloatValue;
        AngleRadians: number;
        CircleCenter: Class;
        bIgnoreAnyContextActorsWhenGeneratingCircle: boolean;
        CircleCenterZOffset: AIDataProviderFloatValue;
        TraceData: EnvTraceData;
        bDefineArc: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_OnCircle;

        static Load(InName: string): EnvQueryGenerator_OnCircle;
    }

    export class EnvQueryGenerator_SimpleGrid extends EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GridSize: AIDataProviderFloatValue;
        SpaceBetween: AIDataProviderFloatValue;
        GenerateAround: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_SimpleGrid;

        static Load(InName: string): EnvQueryGenerator_SimpleGrid;
    }

    export class EnvQueryGenerator_PathingGrid extends EnvQueryGenerator_SimpleGrid {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PathToItem: AIDataProviderBoolValue;
        NavigationFilter: Class;
        ScanRangeMultiplier: AIDataProviderFloatValue;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_PathingGrid;

        static Load(InName: string): EnvQueryGenerator_PathingGrid;
    }

    export class EnvQueryItemType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType;

        static Load(InName: string): EnvQueryItemType;
    }

    export class EnvQueryItemType_VectorBase extends EnvQueryItemType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_VectorBase;

        static Load(InName: string): EnvQueryItemType_VectorBase;
    }

    export class EnvQueryItemType_ActorBase extends EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_ActorBase;

        static Load(InName: string): EnvQueryItemType_ActorBase;
    }

    export class EnvQueryItemType_Actor extends EnvQueryItemType_ActorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Actor;

        static Load(InName: string): EnvQueryItemType_Actor;
    }

    export class EnvQueryItemType_Direction extends EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Direction;

        static Load(InName: string): EnvQueryItemType_Direction;
    }

    export class EnvQueryItemType_Point extends EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Point;

        static Load(InName: string): EnvQueryItemType_Point;
    }

    export enum EEnvTestDistance { Distance3D, Distance2D, DistanceZ, DistanceAbsoluteZ, EEnvTestDistance_MAX }

    export class EnvQueryTest_Distance extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestMode: EEnvTestDistance;
        DistanceTo: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Distance;

        static Load(InName: string): EnvQueryTest_Distance;
    }

    export enum EEnvTestDot { Dot3D, Dot2D, EEnvTestDot_MAX }

    export class EnvQueryTest_Dot extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LineA: EnvDirection;
        LineB: EnvDirection;
        TestMode: EEnvTestDot;
        bAbsoluteValue: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Dot;

        static Load(InName: string): EnvQueryTest_Dot;
    }

    export class EnvQueryTest_GameplayTags extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TagQueryToMatch: GameplayTagQuery;
        bUpdatedToUseQuery: boolean;
        TagsToMatch: EGameplayContainerMatchType;
        GameplayTags: GameplayTagContainer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_GameplayTags;

        static Load(InName: string): EnvQueryTest_GameplayTags;
    }

    export enum EEnvOverlapShape { Box, Sphere, Capsule, EEnvOverlapShape_MAX }

    export class EnvOverlapData {
        constructor();
        constructor(ExtentX: number, ExtentY: number, ExtentZ: number, ShapeOffset: Vector, OverlapChannel: ECollisionChannel, OverlapShape: EEnvOverlapShape, bOnlyBlockingHits: boolean, bOverlapComplex: boolean, bSkipOverlapQuerier: boolean);

        ExtentX: number;
        ExtentY: number;
        ExtentZ: number;
        ShapeOffset: Vector;
        OverlapChannel: ECollisionChannel;
        OverlapShape: EEnvOverlapShape;
        bOnlyBlockingHits: boolean;
        bOverlapComplex: boolean;
        bSkipOverlapQuerier: boolean;

        static StaticClass(): Class;
    }

    export class EnvQueryTest_Overlap extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OverlapData: EnvOverlapData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Overlap;

        static Load(InName: string): EnvQueryTest_Overlap;
    }

    export enum EEnvTestPathfinding { PathExist, PathCost, PathLength, EEnvTestPathfinding_MAX }

    export class EnvQueryTest_Pathfinding extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestMode: EEnvTestPathfinding;
        Context: Class;
        PathFromContext: AIDataProviderBoolValue;
        SkipUnreachable: AIDataProviderBoolValue;
        FilterClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Pathfinding;

        static Load(InName: string): EnvQueryTest_Pathfinding;
    }

    export class EnvQueryTest_PathfindingBatch extends EnvQueryTest_Pathfinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScanRangeMultiplier: AIDataProviderFloatValue;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_PathfindingBatch;

        static Load(InName: string): EnvQueryTest_PathfindingBatch;
    }

    export class EnvQueryTest_Project extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProjectionData: EnvTraceData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Project;

        static Load(InName: string): EnvQueryTest_Project;
    }

    export class EnvQueryTest_Random extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Random;

        static Load(InName: string): EnvQueryTest_Random;
    }

    export class EnvQueryTest_Trace extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TraceData: EnvTraceData;
        TraceFromContext: AIDataProviderBoolValue;
        ItemHeightOffset: AIDataProviderFloatValue;
        ContextHeightOffset: AIDataProviderFloatValue;
        Context: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Trace;

        static Load(InName: string): EnvQueryTest_Trace;
    }

    export class EnvQueryTest_Volume extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VolumeContext: Class;
        VolumeClass: Class;
        bDoComplexVolumeTest: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Volume;

        static Load(InName: string): EnvQueryTest_Volume;
    }

    export class EnvQueryTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EnvQueryTypes;

        static Load(InName: string): EnvQueryTypes;
    }

    export class EQSQueryResultSourceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EQSQueryResultSourceInterface;

        static Load(InName: string): EQSQueryResultSourceInterface;
    }

    export class EQSRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EQSRenderingComponent;

        static Load(InName: string): EQSRenderingComponent;
    }

    export enum EEnvQueryHightlightMode { All, Best5Pct, Best25Pct, EEnvQueryHightlightMode_MAX }

    export class EQSTestingPawn extends Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QueryTemplate: EnvQuery;
        QueryParams: TArray<EnvNamedValue>;
        QueryConfig: TArray<AIDynamicParam>;
        TimeLimitPerStep: number;
        StepToDebugDraw: number;
        HighlightMode: EEnvQueryHightlightMode;
        bDrawLabels: boolean;
        bDrawFailedItems: boolean;
        bReRunQueryOnlyOnFinishedMove: boolean;
        bShouldBeVisibleInGame: boolean;
        bTickDuringGame: boolean;
        QueryingMode: EEnvQueryRunMode;
        NavAgentProperties: NavAgentProperties;
        EdRenderComp: EQSRenderingComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): EQSTestingPawn;

        static Load(InName: string): EQSTestingPawn;
    }

    export class ExpandableAreaStyle extends SlateWidgetStyle {
        constructor();
        constructor(CollapsedImage: SlateBrush, ExpandedImage: SlateBrush, RolloutAnimationSeconds: number);

        CollapsedImage: SlateBrush;
        ExpandedImage: SlateBrush;
        RolloutAnimationSeconds: number;

        static StaticClass(): Class;
    }

    export class ExpandableArea extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Style: ExpandableAreaStyle;
        BorderBrush: SlateBrush;
        BorderColor: SlateColor;
        bIsExpanded: boolean;
        MaxHeight: number;
        HeaderPadding: Margin;
        AreaPadding: Margin;
        OnExpansionChanged: $MulticastDelegate<(Area: $Nullable<ExpandableArea>, bIsExpanded: boolean) => void>;
        HeaderContent: Widget;
        BodyContent: Widget;

        GetIsExpanded(): boolean;

        SetIsExpanded(IsExpanded: boolean): void;

        SetIsExpanded_Animated(IsExpanded: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ExpandableArea;

        static Load(InName: string): ExpandableArea;
    }

    export class ExponentialHeightFogData {
        constructor();
        constructor(FogDensity: number, FogHeightFalloff: number, FogHeightOffset: number);

        FogDensity: number;
        FogHeightFalloff: number;
        FogHeightOffset: number;

        static StaticClass(): Class;
    }

    export class ExponentialHeightFogComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FogDensity: number;
        FogHeightFalloff: number;
        SecondFogData: ExponentialHeightFogData;
        FogInscatteringColor: LinearColor;
        InscatteringColorCubemap: TextureCube;
        InscatteringColorCubemapAngle: number;
        InscatteringTextureTint: LinearColor;
        FullyDirectionalInscatteringColorDistance: number;
        NonDirectionalInscatteringColorDistance: number;
        DirectionalInscatteringExponent: number;
        DirectionalInscatteringStartDistance: number;
        DirectionalInscatteringColor: LinearColor;
        FogMaxOpacity: number;
        StartDistance: number;
        FogCutoffDistance: number;
        bEnableVolumetricFog: boolean;
        VolumetricFogScatteringDistribution: number;
        VolumetricFogAlbedo: Color;
        VolumetricFogEmissive: LinearColor;
        VolumetricFogExtinctionScale: number;
        VolumetricFogDistance: number;
        VolumetricFogStaticLightingScatteringIntensity: number;
        bOverrideLightColorsWithFogInscatteringColors: boolean;

        SetDirectionalInscatteringColor(Value: LinearColor): void;

        SetDirectionalInscatteringExponent(Value: number): void;

        SetDirectionalInscatteringStartDistance(Value: number): void;

        SetFogCutoffDistance(Value: number): void;

        SetFogDensity(Value: number): void;

        SetFogHeightFalloff(Value: number): void;

        SetFogInscatteringColor(Value: LinearColor): void;

        SetFogMaxOpacity(Value: number): void;

        SetFullyDirectionalInscatteringColorDistance(Value: number): void;

        SetInscatteringColorCubemap(Value: $Nullable<TextureCube>): void;

        SetInscatteringColorCubemapAngle(Value: number): void;

        SetInscatteringTextureTint(Value: LinearColor): void;

        SetNonDirectionalInscatteringColorDistance(Value: number): void;

        SetStartDistance(Value: number): void;

        SetVolumetricFog(bNewValue: boolean): void;

        SetVolumetricFogAlbedo(NewValue: Color): void;

        SetVolumetricFogDistance(NewValue: number): void;

        SetVolumetricFogEmissive(NewValue: LinearColor): void;

        SetVolumetricFogExtinctionScale(NewValue: number): void;

        SetVolumetricFogScatteringDistribution(NewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ExponentialHeightFogComponent;

        static Load(InName: string): ExponentialHeightFogComponent;
    }

    export class ExponentialHeightFog extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Component: ExponentialHeightFogComponent;
        bEnabled: boolean;

        OnRep_bEnabled(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ExponentialHeightFog;

        static Load(InName: string): ExponentialHeightFog;
    }

    export class GatherTextCommandletBase extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GatherTextCommandletBase;

        static Load(InName: string): GatherTextCommandletBase;
    }

    export class ExportDialogueScriptCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ExportDialogueScriptCommandlet;

        static Load(InName: string): ExportDialogueScriptCommandlet;
    }

    export class ExportPakDependenciesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ExportPakDependenciesCommandlet;

        static Load(InName: string): ExportPakDependenciesCommandlet;
    }

    export class ExportTextContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ExportText: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ExportTextContainer;

        static Load(InName: string): ExportTextContainer;
    }

    export class ExtensionMethods extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ExtensionMethods;

        static Load(InName: string): ExtensionMethods;
    }

    export class FbxSceneImportData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceFbxFile: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxSceneImportData;

        static Load(InName: string): FbxSceneImportData;
    }

    export class FbxAssetImportData extends AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImportTranslation: Vector;
        ImportRotation: Rotator;
        ImportUniformScale: number;
        bConvertScene: boolean;
        bForceFrontXAxis: boolean;
        bConvertSceneUnit: boolean;
        bImportAsScene: boolean;
        FbxSceneImportDataReference: FbxSceneImportData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxAssetImportData;

        static Load(InName: string): FbxAssetImportData;
    }

    export enum EFBXAnimationLengthImportType {
        FBXALIT_ExportedTime,
        FBXALIT_AnimatedKey,
        FBXALIT_SetRange,
        FBXALIT_MAX
    }

    export class Int32Interval {
        constructor();
        constructor(Min: number, Max: number);

        Min: number;
        Max: number;

        static StaticClass(): Class;
    }

    export class FbxAnimSequenceImportData extends FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bImportMeshesInBoneHierarchy: boolean;
        AnimationLength: EFBXAnimationLengthImportType;
        StartFrame: number;
        EndFrame: number;
        FrameImportRange: Int32Interval;
        bUseDefaultSampleRate: boolean;
        CustomSampleRate: number;
        SourceAnimationName: string;
        bImportCustomAttribute: boolean;
        bDeleteExistingCustomAttributeCurves: boolean;
        bDeleteExistingNonCurveCustomAttributes: boolean;
        bImportBoneTracks: boolean;
        bSetMaterialDriveParameterOnCustomAttribute: boolean;
        MaterialCurveSuffixes: TArray<string>;
        bRemoveRedundantKeys: boolean;
        bDeleteExistingMorphTargetCurves: boolean;
        bDoNotImportCurveWithZero: boolean;
        bPreserveLocalTransform: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxAnimSequenceImportData;

        static Load(InName: string): FbxAnimSequenceImportData;
    }

    export enum EFbxExportCompatibility {
        FBX_2011,
        FBX_2012,
        FBX_2013,
        FBX_2014,
        FBX_2016,
        FBX_2018,
        FBX_2019,
        FBX_2020,
        FBX_MAX
    }

    export class FbxExportOption extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FbxExportCompatibility: EFbxExportCompatibility;
        bASCII: boolean;
        bForceFrontXAxis: boolean;
        VertexColor: boolean;
        LevelOfDetail: boolean;
        Collision: boolean;
        bExportMorphTargets: boolean;
        bExportPreviewMesh: boolean;
        MapSkeletalMotionToRoot: boolean;
        bExportLocalTime: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxExportOption;

        static Load(InName: string): FbxExportOption;
    }

    export enum EFBXImportType { FBXIT_StaticMesh, FBXIT_SkeletalMesh, FBXIT_Animation, FBXIT_MAX }

    export enum EFBXNormalImportMethod {
        FBXNIM_ComputeNormals,
        FBXNIM_ImportNormals,
        FBXNIM_ImportNormalsAndTangents,
        FBXNIM_MAX
    }

    export enum EFBXNormalGenerationMethod { BuiltIn, MikkTSpace, EFBXNormalGenerationMethod_MAX }

    export class ImportMeshLodSectionsData {
        constructor();
        constructor(SectionOriginalMaterialName: TArray<string>);

        SectionOriginalMaterialName: TArray<string>;

        static StaticClass(): Class;
    }

    export class FbxMeshImportData extends FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bTransformVertexToAbsolute: boolean;
        bBakePivotInVertex: boolean;
        bImportMeshLODs: boolean;
        NormalImportMethod: EFBXNormalImportMethod;
        NormalGenerationMethod: EFBXNormalGenerationMethod;
        bComputeWeightedNormals: boolean;
        bReorderMaterialToFbxOrder: boolean;
        ImportMaterialOriginalNameData: TArray<string>;
        ImportMeshLodData: TArray<ImportMeshLodSectionsData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxMeshImportData;

        static Load(InName: string): FbxMeshImportData;
    }

    export enum EVertexColorImportOption { Replace, Ignore, Override, EVertexColorImportOption_MAX }

    export class FbxStaticMeshImportData extends FbxMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StaticMeshLODGroup: string;
        VertexColorImportOption: EVertexColorImportOption;
        VertexOverrideColor: Color;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bGenerateLightmapUVs: boolean;
        bOneConvexHullPerUCX: boolean;
        bAutoGenerateCollision: boolean;
        bCombineMeshes: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxStaticMeshImportData;

        static Load(InName: string): FbxStaticMeshImportData;
    }

    export enum EFBXImportContentType { FBXICT_All, FBXICT_Geometry, FBXICT_SkinningWeights, FBXICT_MAX }

    export class FbxSkeletalMeshImportData extends FbxMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImportContentType: EFBXImportContentType;
        LastImportContentType: EFBXImportContentType;
        VertexColorImportOption: EVertexColorImportOption;
        VertexOverrideColor: Color;
        bUpdateSkeletonReferencePose: boolean;
        bUseT0AsRefPose: boolean;
        bPreserveSmoothingGroups: boolean;
        bImportMeshesInBoneHierarchy: boolean;
        bImportMorphTargets: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
        MorphThresholdPosition: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxSkeletalMeshImportData;

        static Load(InName: string): FbxSkeletalMeshImportData;
    }

    export enum EMaterialSearchLocation {
        Local,
        UnderParent,
        UnderRoot,
        AllAssets,
        DoNotSearch,
        EMaterialSearchLocation_MAX
    }

    export class FbxTextureImportData extends FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bInvertNormalMaps: boolean;
        MaterialSearchLocation: EMaterialSearchLocation;
        BaseMaterialName: SoftObjectPath;
        BaseColorName: string;
        BaseDiffuseTextureName: string;
        BaseNormalTextureName: string;
        BaseEmissiveColorName: string;
        BaseEmmisiveTextureName: string;
        BaseSpecularTextureName: string;
        BaseOpacityTextureName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxTextureImportData;

        static Load(InName: string): FbxTextureImportData;
    }

    export class FbxImportUI extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsObjImport: boolean;
        OriginalImportType: EFBXImportType;
        MeshTypeToImport: EFBXImportType;
        bOverrideFullName: boolean;
        bImportAsSkeletal: boolean;
        bImportMesh: boolean;
        Skeleton: Skeleton;
        bCreatePhysicsAsset: boolean;
        PhysicsAsset: PhysicsAsset;
        bAutoComputeLodDistances: boolean;
        LodDistance0: number;
        LodDistance1: number;
        LodDistance2: number;
        LodDistance3: number;
        LodDistance4: number;
        LodDistance5: number;
        LodDistance6: number;
        LodDistance7: number;
        MinimumLodNumber: number;
        LodNumber: number;
        bImportAnimations: boolean;
        OverrideAnimationName: string;
        bImportRigidMesh: boolean;
        bImportMaterials: boolean;
        bImportTextures: boolean;
        bResetToFbxOnMaterialConflict: boolean;
        StaticMeshImportData: FbxStaticMeshImportData;
        SkeletalMeshImportData: FbxSkeletalMeshImportData;
        AnimSequenceImportData: FbxAnimSequenceImportData;
        TextureImportData: FbxTextureImportData;
        bAutomatedImportShouldDetectType: boolean;
        FileVersion: string;
        FileCreator: string;
        FileCreatorApplication: string;
        FileUnits: string;
        FileAxisDirection: string;
        FileSampleRate: string;
        AnimStartFrame: string;
        AnimEndFrame: string;

        ResetToDefault(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxImportUI;

        static Load(InName: string): FbxImportUI;
    }

    export class FbxFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImportUI: FbxImportUI;
        OriginalImportUI: FbxImportUI;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxFactory;

        static Load(InName: string): FbxFactory;
    }

    export class SceneImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneImportFactory;

        static Load(InName: string): SceneImportFactory;
    }

    export enum EFBXSceneOptionsCreateHierarchyType {
        FBXSOCHT_CreateLevelActors,
        FBXSOCHT_CreateActorComponents,
        FBXSOCHT_CreateBlueprint,
        FBXSOCHT_MAX
    }

    export class FbxSceneImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCreateContentFolderHierarchy: boolean;
        bImportAsDynamic: boolean;
        HierarchyType: EFBXSceneOptionsCreateHierarchyType;
        bForceFrontXAxis: boolean;
        ImportTranslation: Vector;
        ImportRotation: Rotator;
        ImportUniformScale: number;
        bTransformVertexToAbsolute: boolean;
        bBakePivotInVertex: boolean;
        bImportStaticMeshLODs: boolean;
        bImportSkeletalMeshLODs: boolean;
        bInvertNormalMaps: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptions;

        static Load(InName: string): FbxSceneImportOptions;
    }

    export enum EFbxSceneVertexColorImportOption { Replace, Ignore, Override, EFbxSceneVertexColorImportOption_MAX }

    export enum EFBXSceneNormalImportMethod {
        FBXSceneNIM_ComputeNormals,
        FBXSceneNIM_ImportNormals,
        FBXSceneNIM_ImportNormalsAndTangents,
        FBXSceneNIM_MAX
    }

    export enum EFBXSceneNormalGenerationMethod { BuiltIn, MikkTSpace, EFBXSceneNormalGenerationMethod_MAX }

    export class FbxSceneImportOptionsStaticMesh extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StaticMeshLODGroup: string;
        bAutoGenerateCollision: boolean;
        VertexColorImportOption: EFbxSceneVertexColorImportOption;
        VertexOverrideColor: Color;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bGenerateLightmapUVs: boolean;
        bOneConvexHullPerUCX: boolean;
        NormalImportMethod: EFBXSceneNormalImportMethod;
        NormalGenerationMethod: EFBXSceneNormalGenerationMethod;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptionsStaticMesh;

        static Load(InName: string): FbxSceneImportOptionsStaticMesh;
    }

    export class FbxSceneImportOptionsSkeletalMesh extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUpdateSkeletonReferencePose: boolean;
        bCreatePhysicsAsset: boolean;
        bUseT0AsRefPose: boolean;
        bPreserveSmoothingGroups: boolean;
        bImportMeshesInBoneHierarchy: boolean;
        bImportMorphTargets: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
        MorphThresholdPosition: number;
        bImportAnimations: boolean;
        AnimationLength: EFBXAnimationLengthImportType;
        FrameImportRange: Int32Interval;
        bUseDefaultSampleRate: boolean;
        CustomSampleRate: number;
        bImportCustomAttribute: boolean;
        bDeleteExistingCustomAttributeCurves: boolean;
        bDeleteExistingNonCurveCustomAttributes: boolean;
        bPreserveLocalTransform: boolean;
        bDeleteExistingMorphTargetCurves: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptionsSkeletalMesh;

        static Load(InName: string): FbxSceneImportOptionsSkeletalMesh;
    }

    export class FbxSceneImportFactory extends SceneImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SceneImportOptions: FbxSceneImportOptions;
        SceneImportOptionsStaticMesh: FbxSceneImportOptionsStaticMesh;
        SceneImportOptionsSkeletalMesh: FbxSceneImportOptionsSkeletalMesh;
        StaticMeshImportData: FbxStaticMeshImportData;
        SkeletalMeshImportData: FbxSkeletalMeshImportData;
        AnimSequenceImportData: FbxAnimSequenceImportData;
        TextureImportData: FbxTextureImportData;
        ReimportData: FbxSceneImportData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxSceneImportFactory;

        static Load(InName: string): FbxSceneImportFactory;
    }

    export enum EFBXTestPlanActionType {
        Import,
        Reimport,
        AddLOD,
        ReimportLOD,
        ImportReload,
        EFBXTestPlanActionType_MAX
    }

    export enum EFBXExpectedResultPreset {
        Error_Number,
        Warning_Number,
        Created_Staticmesh_Number,
        Created_Skeletalmesh_Number,
        Materials_Created_Number,
        Material_Slot_Imported_Name,
        Vertex_Number,
        Lod_Number,
        Vertex_Number_Lod,
        Mesh_Materials_Number,
        Mesh_LOD_Section_Number,
        Mesh_LOD_Section_Vertex_Number,
        Mesh_LOD_Section_Triangle_Number,
        Mesh_LOD_Section_Material_Name,
        Mesh_LOD_Section_Material_Index,
        Mesh_LOD_Section_Material_Imported_Name,
        Mesh_LOD_Vertex_Position,
        Mesh_LOD_Vertex_Normal,
        LOD_UV_Channel_Number,
        Bone_Number,
        Bone_Position,
        Animation_Frame_Number,
        Animation_Length,
        EFBXExpectedResultPreset_MAX
    }

    export class FbxTestPlanExpectedResult {
        constructor();
        constructor(ExpectedPresetsType: EFBXExpectedResultPreset, ExpectedPresetsDataInteger: TArray<number>, ExpectedPresetsDataFloat: TArray<number>, ExpectedPresetsDataDouble: TArray<number>, ExpectedPresetsDataString: TArray<string>);

        ExpectedPresetsType: EFBXExpectedResultPreset;
        ExpectedPresetsDataInteger: TArray<number>;
        ExpectedPresetsDataFloat: TArray<number>;
        ExpectedPresetsDataDouble: TArray<number>;
        ExpectedPresetsDataString: TArray<string>;

        static StaticClass(): Class;
    }

    export class FbxTestPlan extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestPlanName: string;
        Action: EFBXTestPlanActionType;
        LodIndex: number;
        bDeleteFolderAssets: boolean;
        ExpectedResult: TArray<FbxTestPlanExpectedResult>;
        ImportUI: FbxImportUI;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FbxTestPlan;

        static Load(InName: string): FbxTestPlan;
    }

    export class FieldNodeInt extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldNodeInt;

        static Load(InName: string): FieldNodeInt;
    }

    export class FieldNodeVector extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldNodeVector;

        static Load(InName: string): FieldNodeVector;
    }

    export class FieldSystemMetaDataIteration extends FieldSystemMetaData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Iterations: number;

        SetMetaDataIteration(Iterations: number): FieldSystemMetaDataIteration;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaDataIteration;

        static Load(InName: string): FieldSystemMetaDataIteration;
    }

    export enum EFieldResolutionType {
        Field_Resolution_Minimal,
        Field_Resolution_DisabledParents,
        Field_Resolution_Maximum,
        Field_Resolution_Max,
        Field_Resolution_MAX
    }

    export class FieldSystemMetaDataProcessingResolution extends FieldSystemMetaData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ResolutionType: EFieldResolutionType;

        SetMetaDataaProcessingResolutionType(ResolutionType: EFieldResolutionType): FieldSystemMetaDataProcessingResolution;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaDataProcessingResolution;

        static Load(InName: string): FieldSystemMetaDataProcessingResolution;
    }

    export class FileMediaSource extends BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FilePath: string;
        PrecacheFile: boolean;

        SetFilePath(Path: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FileMediaSource;

        static Load(InName: string): FileMediaSource;
    }

    export class FileServerCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FileServerCommandlet;

        static Load(InName: string): FileServerCommandlet;
    }

    export class FileSystemOperation extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateDirectory(Path: string): void;

        static DirectoryExists(Path: string): boolean;

        static FileExists(Path: string): boolean;

        static FileMD5Hash(Path: string): string;

        static GetCurrentDirectory(): string;

        static GetDirectories(Path: string): TArray<string>;

        static GetFiles(Path: string): TArray<string>;

        static PuertsNotifyChange(Path: string, Source: string): void;

        static ReadFile(Path: string, Data: $Ref<string>): boolean;

        static ResolvePath(Path: string): string;

        static WriteFile(Path: string, Data: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FileSystemOperation;

        static Load(InName: string): FileSystemOperation;
    }

    export class BlueprintSessionResult {
        constructor();

        static StaticClass(): Class;
    }

    export class FindSessionsCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(Results: TArray<BlueprintSessionResult>) => void>;
        OnFailure: $MulticastDelegate<(Results: TArray<BlueprintSessionResult>) => void>;

        static FindSessions(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, MaxResults: number, bUseLAN: boolean): FindSessionsCallbackProxy;

        static GetCurrentPlayers(Result: BlueprintSessionResult): number;

        static GetMaxPlayers(Result: BlueprintSessionResult): number;

        static GetPingInMs(Result: BlueprintSessionResult): number;

        static GetServerName(Result: BlueprintSessionResult): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FindSessionsCallbackProxy;

        static Load(InName: string): FindSessionsCallbackProxy;
    }

    export class FindTurnBasedMatchCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(MatchID: string) => void>;
        OnFailure: $MulticastDelegate<(MatchID: string) => void>;

        static FindTurnBasedMatch(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, MatchActor: TurnBasedMatchInterface, MinPlayers: number, MaxPlayers: number, PlayerGroup: number, ShowExistingMatches: boolean): FindTurnBasedMatchCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FindTurnBasedMatchCallbackProxy;

        static Load(InName: string): FindTurnBasedMatchCallbackProxy;
    }

    export class FixConflictingLocalizationKeysCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FixConflictingLocalizationKeysCommandlet;

        static Load(InName: string): FixConflictingLocalizationKeysCommandlet;
    }

    export class FixedFrameRateCustomTimeStep extends EngineCustomTimeStep {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FixedFrameRate: FrameRate;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FixedFrameRateCustomTimeStep;

        static Load(InName: string): FixedFrameRateCustomTimeStep;
    }

    export class ResavePackagesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ResavePackagesCommandlet;

        static Load(InName: string): ResavePackagesCommandlet;
    }

    export class FixupNeedsLoadForEditorGameCommandlet extends ResavePackagesCommandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FixupNeedsLoadForEditorGameCommandlet;

        static Load(InName: string): FixupNeedsLoadForEditorGameCommandlet;
    }

    export class FloatBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetValue(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FloatBinding;

        static Load(InName: string): FloatBinding;
    }

    export class MovieSceneEntitySystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Linker: MovieSceneEntitySystemLinker;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEntitySystem;

        static Load(InName: string): MovieSceneEntitySystem;
    }

    export class FloatChannelEvaluatorSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FloatChannelEvaluatorSystem;

        static Load(InName: string): FloatChannelEvaluatorSystem;
    }

    export class MovieSceneTangentData {
        constructor();
        constructor(ArriveTangent: number, LeaveTangent: number, ArriveTangentWeight: number, LeaveTangentWeight: number, TangentWeightMode: ERichCurveTangentWeightMode);

        ArriveTangent: number;
        LeaveTangent: number;
        ArriveTangentWeight: number;
        LeaveTangentWeight: number;
        TangentWeightMode: ERichCurveTangentWeightMode;

        static StaticClass(): Class;
    }

    export class MovieSceneFloatValue {
        constructor();
        constructor(Value: number, Tangent: MovieSceneTangentData, InterpMode: ERichCurveInterpMode, TangentMode: ERichCurveTangentMode, PaddingByte: number);

        Value: number;
        Tangent: MovieSceneTangentData;
        InterpMode: ERichCurveInterpMode;
        TangentMode: ERichCurveTangentMode;
        PaddingByte: number;

        static StaticClass(): Class;
    }

    export class FloatChannelKeyProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Time: FrameNumber;
        Value: MovieSceneFloatValue;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FloatChannelKeyProxy;

        static Load(InName: string): FloatChannelKeyProxy;
    }

    export class FloatingPawnMovement extends PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxSpeed: number;
        Acceleration: number;
        Deceleration: number;
        TurningBoost: number;
        bPositionCorrected: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FloatingPawnMovement;

        static Load(InName: string): FloatingPawnMovement;
    }

    export enum EHorizTextAligment { EHTA_Left, EHTA_Center, EHTA_Right, EHTA_MAX }

    export enum EVerticalTextAligment { EVRTA_TextTop, EVRTA_TextCenter, EVRTA_TextBottom, EVRTA_QuadTop, EVRTA_MAX }

    export class TextRenderComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Text: string;
        TextMaterial: MaterialInterface;
        Font: Font;
        HorizontalAlignment: EHorizTextAligment;
        VerticalAlignment: EVerticalTextAligment;
        TextRenderColor: Color;
        XScale: number;
        YScale: number;
        WorldSize: number;
        InvDefaultSize: number;
        HorizSpacingAdjust: number;
        VertSpacingAdjust: number;
        bAlwaysRenderAsText: boolean;

        GetTextLocalSize(): Vector;

        GetTextWorldSize(): Vector;

        K2_SetText(Value: string): void;

        SetFont(Value: $Nullable<Font>): void;

        SetHorizontalAlignment(Value: EHorizTextAligment): void;

        SetHorizSpacingAdjust(Value: number): void;

        SetText(Value: string): void;

        SetTextMaterial(Material: $Nullable<MaterialInterface>): void;

        SetTextRenderColor(Value: Color): void;

        SetVerticalAlignment(Value: EVerticalTextAligment): void;

        SetVertSpacingAdjust(Value: number): void;

        SetWorldSize(Value: number): void;

        SetXScale(Value: number): void;

        SetYScale(Value: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextRenderComponent;

        static Load(InName: string): TextRenderComponent;
    }

    export class FloatingText extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SceneComponent: SceneComponent;
        FirstLineComponent: StaticMeshComponent;
        JointSphereComponent: StaticMeshComponent;
        SecondLineComponent: StaticMeshComponent;
        TextComponent: TextRenderComponent;
        MaskedTextMaterial: MaterialInterface;
        TranslucentTextMaterial: MaterialInterface;
        LineMaterial: MaterialInterface;
        LineMaterialMID: MaterialInstanceDynamic;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FloatingText;

        static Load(InName: string): FloatingText;
    }

    export class FloatProperty extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FloatProperty;

        static Load(InName: string): FloatProperty;
    }

    export class InstancedStaticMeshInstanceData {
        constructor();
        constructor(Transform: Matrix);

        Transform: Matrix;

        static StaticClass(): Class;
    }

    export class InstancedStaticMeshOverrideMaterial {
        constructor();
        constructor(OverrideMaterials: TArray<MaterialInterface>);

        OverrideMaterials: TArray<MaterialInterface>;

        static StaticClass(): Class;
    }

    export class InstancedStaticMeshMappingInfo {
        constructor();

        static StaticClass(): Class;
    }

    export class InstancedStaticMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PerInstanceSMData: TArray<InstancedStaticMeshInstanceData>;
        NumCustomDataFloats: number;
        PerInstanceSMCustomData: TArray<number>;
        InstancingRandomSeed: number;
        InstanceStartCullDistance: number;
        InstanceEndCullDistance: number;
        InstanceOverrideMaterials: TMap<number, InstancedStaticMeshOverrideMaterial>;
        InstanceReorderTable: TArray<number>;
        NumPendingLightmaps: number;
        CachedMappings: TArray<InstancedStaticMeshMappingInfo>;

        AddInstance(InstanceTransform: Transform): number;

        AddInstances(InstanceTransforms: TArray<Transform>, bShouldReturnIndices: boolean): TArray<number>;

        AddInstanceWorldSpace(WorldTransform: Transform): number;

        BatchUpdateInstancesTransform(StartInstanceIndex: number, NumInstances: number, NewInstancesTransform: Transform, bWorldSpace?: boolean /* = false */, bMarkRenderStateDirty?: boolean /* = false */, bTeleport?: boolean /* = false */): boolean;

        BatchUpdateInstancesTransforms(StartInstanceIndex: number, NewInstancesTransforms: TArray<Transform>, bWorldSpace?: boolean /* = false */, bMarkRenderStateDirty?: boolean /* = false */, bTeleport?: boolean /* = false */): boolean;

        ClearInstances(): void;

        ClearPerInstanceOverrideMaterials(): void;

        GetInstanceCount(): number;

        GetInstancesOverlappingBox(Box: Box, bBoxInWorldSpace?: boolean /* = true */): TArray<number>;

        GetInstancesOverlappingSphere(Center: Vector, Radius: number, bSphereInWorldSpace?: boolean /* = true */): TArray<number>;

        GetInstanceTransform(InstanceIndex: number, OutInstanceTransform: $Ref<Transform>, bWorldSpace?: boolean /* = false */): boolean;

        RemoveInstance(InstanceIndex: number): boolean;

        RemovePerInstanceOverrideMaterials(InstanceIndex: number): void;

        SetCullDistances(StartCullDistance: number, EndCullDistance: number): void;

        SetCustomDataValue(InstanceIndex: number, CustomDataIndex: number, CustomDataValue: number, bMarkRenderStateDirty?: boolean /* = false */): boolean;

        SetPerInstanceOverrideMaterials(InstanceIndex: number, InOverrideMaterials: InstancedStaticMeshOverrideMaterial): void;

        UpdateInstanceTransform(InstanceIndex: number, NewInstanceTransform: Transform, bWorldSpace?: boolean /* = false */, bMarkRenderStateDirty?: boolean /* = false */, bTeleport?: boolean /* = false */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InstancedStaticMeshComponent;

        static Load(InName: string): InstancedStaticMeshComponent;
    }

    export class HierarchicalInstancedStaticMeshComponent extends InstancedStaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SortedInstances: TArray<number>;
        NumBuiltInstances: number;
        BuiltInstanceBounds: Box;
        UnbuiltInstanceBounds: Box;
        UnbuiltInstanceBoundsList: TArray<Box>;
        bEnableDensityScaling: boolean;
        OcclusionLayerNumNodes: number;
        CacheMeshExtendedBounds: BoxSphereBounds;
        bDisableCollision: boolean;
        InstanceCountToRender: number;

        RemoveInstances(InstancesToRemove: TArray<number>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HierarchicalInstancedStaticMeshComponent;

        static Load(InName: string): HierarchicalInstancedStaticMeshComponent;
    }

    export class FoliageInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnInstanceTakePointDamage: $MulticastDelegate<(InstanceIndex: number, Damage: number, InstigatedBy: $Nullable<Controller>, HitLocation: Vector, ShotFromDirection: Vector, DamageType: $Nullable<DamageType>, DamageCauser: $Nullable<Actor>) => void>;
        OnInstanceTakeRadialDamage: $MulticastDelegate<(Instances: TArray<number>, Damages: TArray<number>, InstigatedBy: $Nullable<Controller>, Origin: Vector, MaxRadius: number, DamageType: $Nullable<DamageType>, DamageCauser: $Nullable<Actor>) => void>;
        FoliageHiddenEditorViews: bigint;
        GenerationGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageInstancedStaticMeshComponent;

        static Load(InName: string): FoliageInstancedStaticMeshComponent;
    }

    export class FoliageStatistics extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static FoliageOverlappingBoxCount(WorldContextObject: $Nullable<Object>, StaticMesh: $Nullable<StaticMesh>, Box: Box): number;

        static FoliageOverlappingSphereCount(WorldContextObject: $Nullable<Object>, StaticMesh: $Nullable<StaticMesh>, CenterPosition: Vector, Radius: number): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageStatistics;

        static Load(InName: string): FoliageStatistics;
    }

    export enum EFoliageScaling { Uniform, Free, LockXY, LockXZ, LockYZ, EFoliageScaling_MAX }

    export class FoliageVertexColorChannelMask {
        constructor();
        constructor(UseMask: boolean, MaskThreshold: number, InvertMask: boolean);

        UseMask: boolean;
        MaskThreshold: number;
        InvertMask: boolean;

        static StaticClass(): Class;
    }

    export enum FoliageVertexColorMask {
        FOLIAGEVERTEXCOLORMASK_Disabled,
        FOLIAGEVERTEXCOLORMASK_Red,
        FOLIAGEVERTEXCOLORMASK_Green,
        FOLIAGEVERTEXCOLORMASK_Blue,
        FOLIAGEVERTEXCOLORMASK_Alpha,
        FOLIAGEVERTEXCOLORMASK_MAX
    }

    export class FoliageType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UpdateGuid: Guid;
        Density: number;
        DensityAdjustmentFactor: number;
        Radius: number;
        bSingleInstanceModeOverrideRadius: boolean;
        SingleInstanceModeRadius: number;
        Scaling: EFoliageScaling;
        ScaleX: FloatInterval;
        ScaleY: FloatInterval;
        ScaleZ: FloatInterval;
        VertexColorMaskByChannel: FixSizeArray<FoliageVertexColorChannelMask>;
        VertexColorMask: FoliageVertexColorMask;
        VertexColorMaskThreshold: number;
        VertexColorMaskInvert: boolean;
        ZOffset: FloatInterval;
        AlignToNormal: boolean;
        AlignMaxAngle: number;
        RandomYaw: boolean;
        RandomPitchAngle: number;
        GroundSlopeAngle: FloatInterval;
        Height: FloatInterval;
        LandscapeLayers: TArray<string>;
        MinimumLayerWeight: number;
        ExclusionLandscapeLayers: TArray<string>;
        MinimumExclusionLayerWeight: number;
        LandscapeLayer: string;
        CollisionWithWorld: boolean;
        CollisionScale: Vector;
        MeshBounds: BoxSphereBounds;
        LowBoundOriginRadius: Vector;
        Mobility: EComponentMobility;
        CullDistance: Int32Interval;
        bEnableStaticLighting: boolean;
        CastShadow: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bAffectDistanceFieldLighting: boolean;
        bCastDynamicShadow: boolean;
        bCastStaticShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bReceivesDecals: boolean;
        bOverrideLightMapRes: boolean;
        OverriddenLightMapRes: number;
        LightmapType: ELightmapType;
        bUseAsOccluder: boolean;
        BodyInstance: BodyInstance;
        CustomNavigableGeometry: EHasCustomNavigableGeometry;
        LightingChannels: LightingChannels;
        bRenderCustomDepth: boolean;
        CustomDepthStencilWriteMask: ERendererStencilMask;
        CustomDepthStencilValue: number;
        TranslucencySortPriority: number;
        HiddenEditorViews: bigint;
        IsSelected: boolean;
        CollisionRadius: number;
        ShadeRadius: number;
        NumSteps: number;
        InitialSeedDensity: number;
        AverageSpreadDistance: number;
        SpreadVariance: number;
        SeedsPerStep: number;
        DistributionSeed: number;
        MaxInitialSeedOffset: number;
        bCanGrowInShade: boolean;
        bSpawnsInShade: boolean;
        MaxInitialAge: number;
        MaxAge: number;
        OverlapPriority: number;
        ProceduralScale: FloatInterval;
        ScaleCurve: RuntimeFloatCurve;
        ChangeCount: number;
        ReapplyDensity: boolean;
        ReapplyRadius: boolean;
        ReapplyAlignToNormal: boolean;
        ReapplyRandomYaw: boolean;
        ReapplyScaling: boolean;
        ReapplyScaleX: boolean;
        ReapplyScaleY: boolean;
        ReapplyScaleZ: boolean;
        ReapplyRandomPitchAngle: boolean;
        ReapplyGroundSlope: boolean;
        ReapplyHeight: boolean;
        ReapplyLandscapeLayers: boolean;
        ReapplyZOffset: boolean;
        ReapplyCollisionWithWorld: boolean;
        ReapplyVertexColorMask: boolean;
        bEnableDensityScaling: boolean;
        bEnableDiscardOnLoad: boolean;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureCullMips: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        ScaleMinX: number;
        ScaleMinY: number;
        ScaleMinZ: number;
        ScaleMaxX: number;
        ScaleMaxY: number;
        ScaleMaxZ: number;
        HeightMin: number;
        HeightMax: number;
        ZOffsetMin: number;
        ZOffsetMax: number;
        StartCullDistance: number;
        EndCullDistance: number;
        UniformScale: boolean;
        LockScaleX: boolean;
        LockScaleY: boolean;
        LockScaleZ: boolean;
        GroundSlope: number;
        MinGroundSlope: number;
        MinScale: number;
        MaxScale: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageType;

        static Load(InName: string): FoliageType;
    }

    export class FoliageType_Actor extends FoliageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActorClass: Class;
        bShouldAttachToBaseComponent: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageType_Actor;

        static Load(InName: string): FoliageType_Actor;
    }

    export class FoliageType_ActorFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageType_ActorFactory;

        static Load(InName: string): FoliageType_ActorFactory;
    }

    export class FoliageType_ActorThumbnailRenderer extends BlueprintThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageType_ActorThumbnailRenderer;

        static Load(InName: string): FoliageType_ActorThumbnailRenderer;
    }

    export class FoliageType_InstancedStaticMesh extends FoliageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Mesh: StaticMesh;
        OverrideMaterials: TArray<MaterialInterface>;
        ComponentClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageType_InstancedStaticMesh;

        static Load(InName: string): FoliageType_InstancedStaticMesh;
    }

    export class FoliageType_InstancedStaticMeshFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageType_InstancedStaticMeshFactory;

        static Load(InName: string): FoliageType_InstancedStaticMeshFactory;
    }

    export class FoliageType_ISMThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FoliageType_ISMThumbnailRenderer;

        static Load(InName: string): FoliageType_ISMThumbnailRenderer;
    }

    export enum ETextWrappingPolicy { DefaultWrapping, AllowPerCharacterWrapping, ETextWrappingPolicy_MAX }

    export class TextLayoutWidget extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShapedTextOptions: ShapedTextOptions;
        Justification: ETextJustify;
        WrappingPolicy: ETextWrappingPolicy;
        AutoWrapText: boolean;
        WrapTextAt: number;
        Margin: Margin;
        LineHeightPercentage: number;

        SetJustification(InJustification: ETextJustify): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextLayoutWidget;

        static Load(InName: string): TextLayoutWidget;
    }

    export enum ETextTransformPolicy { None, ToLower, ToUpper, ETextTransformPolicy_MAX }

    export class TextBlock extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Text: string;
        TextDelegate: $Delegate<() => string>;
        ColorAndOpacity: SlateColor;
        ColorAndOpacityDelegate: $Delegate<() => SlateColor>;
        Font: SlateFontInfo;
        StrikeBrush: SlateBrush;
        ShadowOffset: Vector2D;
        ShadowColorAndOpacity: LinearColor;
        ShadowColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        MinDesiredWidth: number;
        bWrapWithInvalidationPanel: boolean;
        bAutoWrapText: boolean;
        TextTransformPolicy: ETextTransformPolicy;
        bSimpleTextMode: boolean;

        GetDynamicFontMaterial(): MaterialInstanceDynamic;

        GetDynamicOutlineMaterial(): MaterialInstanceDynamic;

        GetText(): string;

        SetAutoWrapText(InAutoTextWrap: boolean): void;

        SetColorAndOpacity(InColorAndOpacity: SlateColor): void;

        SetFont(InFontInfo: SlateFontInfo): void;

        SetMinDesiredWidth(InMinDesiredWidth: number): void;

        SetOpacity(InOpacity: number): void;

        SetShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;

        SetShadowOffset(InShadowOffset: Vector2D): void;

        SetStrikeBrush(InStrikeBrush: SlateBrush): void;

        SetText(InText: string): void;

        SetTextTransformPolicy(InTransformPolicy: ETextTransformPolicy): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextBlock;

        static Load(InName: string): TextBlock;
    }

    export class FollowCharacterObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OverHeadUIWidget: UserWidget;
        ChatContent: TextBlock;
        Nickname: TextBlock;
        ChatBoxCanvas: CanvasPanel;
        NameCanvas: CanvasPanel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FollowCharacterObject;

        static Load(InName: string): FollowCharacterObject;
    }

    export enum EFontLayoutMethod { Metrics, BoundingBox, EFontLayoutMethod_MAX }

    export class FontFace extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceFilename: string;
        Hinting: EFontHinting;
        LoadingPolicy: EFontLoadingPolicy;
        LayoutMethod: EFontLayoutMethod;
        FontFaceData: TArray<number>;
        SubFaces: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FontFace;

        static Load(InName: string): FontFace;
    }

    export class FontFaceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FontFaceInterface;

        static Load(InName: string): FontFaceInterface;
    }

    export class FontFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FontFactory;

        static Load(InName: string): FontFactory;
    }

    export class FontFileImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FontFileImportFactory;

        static Load(InName: string): FontFileImportFactory;
    }

    export class FontImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Data: FontImportOptionsData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FontImportOptions;

        static Load(InName: string): FontImportOptions;
    }

    export class FontProviderInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FontProviderInterface;

        static Load(InName: string): FontProviderInterface;
    }

    export class TextureThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureThumbnailRenderer;

        static Load(InName: string): TextureThumbnailRenderer;
    }

    export class FontThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FontThumbnailRenderer;

        static Load(InName: string): FontThumbnailRenderer;
    }

    export class ForceFeedbackAttenuationSettings extends BaseAttenuationSettings {
        constructor();

        static StaticClass(): Class;
    }

    export class ForceFeedbackAttenuation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Attenuation: ForceFeedbackAttenuationSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ForceFeedbackAttenuation;

        static Load(InName: string): ForceFeedbackAttenuation;
    }

    export class ForceFeedbackAttenuationFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ForceFeedbackAttenuationFactory;

        static Load(InName: string): ForceFeedbackAttenuationFactory;
    }

    export class ForceFeedbackComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ForceFeedbackEffect: ForceFeedbackEffect;
        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bLooping: boolean;
        bIgnoreTimeDilation: boolean;
        bOverrideAttenuation: boolean;
        IntensityMultiplier: number;
        AttenuationSettings: ForceFeedbackAttenuation;
        AttenuationOverrides: ForceFeedbackAttenuationSettings;
        OnForceFeedbackFinished: $MulticastDelegate<(ForceFeedbackComponent: $Nullable<ForceFeedbackComponent>) => void>;

        AdjustAttenuation(InAttenuationSettings: ForceFeedbackAttenuationSettings): void;

        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<ForceFeedbackAttenuationSettings>): boolean;

        Play(StartTime?: number /* = 0.000000 */): void;

        SetForceFeedbackEffect(NewForceFeedbackEffect: $Nullable<ForceFeedbackEffect>): void;

        SetIntensityMultiplier(NewIntensityMultiplier: number): void;

        Stop(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ForceFeedbackComponent;

        static Load(InName: string): ForceFeedbackComponent;
    }

    export class ForceFeedbackEffectFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ForceFeedbackEffectFactory;

        static Load(InName: string): ForceFeedbackEffectFactory;
    }

    export class FuncTestRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FuncTestRenderingComponent;

        static Load(InName: string): FuncTestRenderingComponent;
    }

    export enum EFunctionalTestLogHandling {
        ProjectDefault,
        OutputIsError,
        OutputIgnored,
        EFunctionalTestLogHandling_MAX
    }

    export class RandomStream {
        constructor();
        constructor(InitialSeed: number, Seed: number);

        InitialSeed: number;
        Seed: number;

        static StaticClass(): Class;
    }

    export enum EFunctionalTestResult { Default, Invalid, Error, Running, Failed, Succeeded, EFunctionalTestResult_MAX }

    export enum EComparisonMethod {
        Equal_To,
        Not_Equal_To,
        Greater_Than_Or_Equal_To,
        Less_Than_Or_Equal_To,
        Greater_Than,
        Less_Than,
        EComparisonMethod_MAX
    }

    export class TraceQueryTestNames {
        constructor();
        constructor(ComponentName: string, PhysicalMaterialName: string, ActorName: string);

        ComponentName: string;
        PhysicalMaterialName: string;
        ActorName: string;

        static StaticClass(): Class;
    }

    export class TraceQueryTestResultsInnerMost {
        constructor();
        constructor(SingleHit: HitResult, SingleNames: TraceQueryTestNames, bSingleResult: boolean, MultiHits: TArray<HitResult>, MultiNames: TArray<TraceQueryTestNames>, bMultiResult: boolean);

        SingleHit: HitResult;
        SingleNames: TraceQueryTestNames;
        bSingleResult: boolean;
        MultiHits: TArray<HitResult>;
        MultiNames: TArray<TraceQueryTestNames>;
        bMultiResult: boolean;

        static StaticClass(): Class;
    }

    export class TraceQueryTestResultsInner {
        constructor();
        constructor(LineResults: TraceQueryTestResultsInnerMost, SphereResults: TraceQueryTestResultsInnerMost, CapsuleResults: TraceQueryTestResultsInnerMost, BoxResults: TraceQueryTestResultsInnerMost);

        LineResults: TraceQueryTestResultsInnerMost;
        SphereResults: TraceQueryTestResultsInnerMost;
        CapsuleResults: TraceQueryTestResultsInnerMost;
        BoxResults: TraceQueryTestResultsInnerMost;

        static StaticClass(): Class;
    }

    export class TraceChannelTestBatchOptions {
        constructor();
        constructor(bLineTrace: boolean, bSphereTrace: boolean, bCapsuleTrace: boolean, bBoxTrace: boolean, bChannelTrace: boolean, bObjectsTrace: boolean, bProfileTrace: boolean);

        bLineTrace: boolean;
        bSphereTrace: boolean;
        bCapsuleTrace: boolean;
        bBoxTrace: boolean;
        bChannelTrace: boolean;
        bObjectsTrace: boolean;
        bProfileTrace: boolean;

        static StaticClass(): Class;
    }

    export class TraceQueryTestResults extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChannelResults: TraceQueryTestResultsInner;
        ObjectResults: TraceQueryTestResultsInner;
        ProfileResults: TraceQueryTestResultsInner;
        BatchOptions: TraceChannelTestBatchOptions;

        ToString(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TraceQueryTestResults;

        static Load(InName: string): TraceQueryTestResults;
    }

    export class FunctionalTest extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpriteComponent: BillboardComponent;
        bIsEnabled: boolean;
        LogErrorHandling: EFunctionalTestLogHandling;
        LogWarningHandling: EFunctionalTestLogHandling;
        Author: string;
        Description: string;
        ObservationPoint: Actor;
        RandomNumbersStream: RandomStream;
        Result: EFunctionalTestResult;
        PreparationTimeLimit: number;
        TimeLimit: number;
        TimesUpMessage: string;
        TimesUpResult: EFunctionalTestResult;
        OnTestPrepare: $MulticastDelegate<() => void>;
        OnTestStart: $MulticastDelegate<() => void>;
        OnTestFinished: $MulticastDelegate<() => void>;
        AutoDestroyActors: TArray<Actor>;
        RenderComp: FuncTestRenderingComponent;
        TestName: TextRenderComponent;
        bIsRunning: boolean;
        TotalTime: number;

        AddError(Message: string): void;

        AddRerun(Reason: string): void;

        AddWarning(Message: string): void;

        AssertEqual_Bool(Actual: boolean, Expected: boolean, What: string, ContextObject?: Object /* = None */): boolean;

        AssertEqual_Float(Actual: number, Expected: number, What: string, Tolerance?: number /* = 0.000100 */, ContextObject?: Object /* = None */): boolean;

        AssertEqual_Int(Actual: number, Expected: number, What: string, ContextObject?: Object /* = None */): boolean;

        AssertEqual_Name(Actual: string, Expected: string, What: string, ContextObject?: Object /* = None */): boolean;

        AssertEqual_Object(Actual: $Nullable<Object>, Expected: $Nullable<Object>, What: string, ContextObject?: Object /* = None */): boolean;

        AssertEqual_Rotator(Actual: Rotator, Expected: Rotator, What: string, Tolerance?: number /* = 0.000100 */, ContextObject?: Object /* = None */): boolean;

        AssertEqual_String(Actual: string, Expected: string, What: string, ContextObject?: Object /* = None */): boolean;

        AssertEqual_TraceQueryResults(Actual: $Nullable<TraceQueryTestResults>, Expected: $Nullable<TraceQueryTestResults>, What: string, ContextObject?: Object /* = None */): boolean;

        AssertEqual_Transform(Actual: Transform, Expected: Transform, What: string, Tolerance?: number /* = 0.000100 */, ContextObject?: Object /* = None */): boolean;

        AssertEqual_Vector(Actual: Vector, Expected: Vector, What: string, Tolerance?: number /* = 0.000100 */, ContextObject?: Object /* = None */): boolean;

        AssertFalse(Condition: boolean, Message: string, ContextObject?: Object /* = None */): boolean;

        AssertIsValid(Object: $Nullable<Object>, Message: string, ContextObject?: Object /* = None */): boolean;

        AssertNotEqual_Rotator(Actual: Rotator, NotExpected: Rotator, What: string, ContextObject?: Object /* = None */): boolean;

        AssertNotEqual_String(Actual: string, NotExpected: string, What: string, ContextObject?: Object /* = None */): boolean;

        AssertNotEqual_Transform(Actual: Transform, NotExpected: Transform, What: string, ContextObject?: Object /* = None */): boolean;

        AssertNotEqual_Vector(Actual: Vector, NotExpected: Vector, What: string, ContextObject?: Object /* = None */): boolean;

        AssertTrue(Condition: boolean, Message: string, ContextObject?: Object /* = None */): boolean;

        AssertValue_DateTime(Actual: DateTime, ShouldBe: EComparisonMethod, Expected: DateTime, What: string, ContextObject?: Object /* = None */): boolean;

        AssertValue_Float(Actual: number, ShouldBe: EComparisonMethod, Expected: number, What: string, ContextObject?: Object /* = None */): boolean;

        AssertValue_Int(Actual: number, ShouldBe: EComparisonMethod, Expected: number, What: string, ContextObject?: Object /* = None */): boolean;

        DebugGatherRelevantActors(): TArray<Actor>;

        FinishTest(TestResult: EFunctionalTestResult, Message: string): void;

        GetCurrentRerunReason(): string;

        IsEnabled(): boolean;

        IsReady(): boolean;

        IsRunning(): boolean;

        LogMessage(Message: string): void;

        OnAdditionalTestFinishedMessageRequest(TestResult: EFunctionalTestResult): string;

        OnWantsReRunCheck(): boolean;

        ReceivePrepareTest(): void;

        ReceiveStartTest(): void;

        RegisterAutoDestroyActor(ActorToAutoDestroy: $Nullable<Actor>): void;

        SetTimeLimit(NewTimeLimit: number, ResultWhenTimeRunsOut: EFunctionalTestResult): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FunctionalTest;

        static Load(InName: string): FunctionalTest;
    }

    export class GenericTeamId {
        constructor();
        constructor(TeamID: number);

        TeamID: number;

        static StaticClass(): Class;
    }

    export class AITestSpawnInfo {
        constructor();
        constructor(PawnClass: Class, ControllerClass: Class, TeamID: GenericTeamId, BehaviorTree: BehaviorTree, SpawnLocation: Actor, NumberToSpawn: number, SpawnDelay: number, PreSpawnDelay: number);

        PawnClass: Class;
        ControllerClass: Class;
        TeamID: GenericTeamId;
        BehaviorTree: BehaviorTree;
        SpawnLocation: Actor;
        NumberToSpawn: number;
        SpawnDelay: number;
        PreSpawnDelay: number;

        static StaticClass(): Class;
    }

    export class AITestSpawnSet {
        constructor();
        constructor(SpawnInfoContainer: TArray<AITestSpawnInfo>, Name: string, bEnabled: boolean, FallbackSpawnLocation: Actor);

        SpawnInfoContainer: TArray<AITestSpawnInfo>;
        Name: string;
        bEnabled: boolean;
        FallbackSpawnLocation: Actor;

        static StaticClass(): Class;
    }

    export class PendingDelayedSpawn extends AITestSpawnInfo {
        constructor();

        static StaticClass(): Class;
    }

    export class FunctionalAITest extends FunctionalTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpawnSets: TArray<AITestSpawnSet>;
        SpawnLocationRandomizationRange: number;
        SpawnedPawns: TArray<Pawn>;
        PendingDelayedSpawns: TArray<PendingDelayedSpawn>;
        CurrentSpawnSetIndex: number;
        CurrentSpawnSetName: string;
        OnAISpawned: $MulticastDelegate<(Controller: $Nullable<AIController>, Pawn: $Nullable<Pawn>) => void>;
        OnAllAISPawned: $MulticastDelegate<() => void>;
        NavMeshDebugOrigin: Vector;
        NavMeshDebugExtent: Vector;
        bWaitForNavMesh: boolean;
        bDebugNavMeshOnTimeout: boolean;

        IsOneOfSpawnedPawns(Actor: $Nullable<Actor>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FunctionalAITest;

        static Load(InName: string): FunctionalAITest;
    }

    export class FunctionalTestGameMode extends GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FunctionalTestGameMode;

        static Load(InName: string): FunctionalTestGameMode;
    }

    export class FunctionalTestingManager extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestsLeft: TArray<FunctionalTest>;
        AllTests: TArray<FunctionalTest>;
        OnSetupTests: $MulticastDelegate<() => void>;
        OnTestsComplete: $MulticastDelegate<() => void>;
        OnTestsBegin: $MulticastDelegate<() => void>;

        static RunAllFunctionalTests(WorldContextObject: $Nullable<Object>, bNewLog?: boolean /* = true */, bRunLooped?: boolean /* = false */, FailedTestsReproString?: string /* = "" */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FunctionalTestingManager;

        static Load(InName: string): FunctionalTestingManager;
    }

    export class FunctionalTestLevelScript extends LevelScriptActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FunctionalTestLevelScript;

        static Load(InName: string): FunctionalTestLevelScript;
    }

    export enum EDrawDebugTrace { None, ForOneFrame, ForDuration, Persistent, EDrawDebugTrace_MAX }

    export class FunctionalTestUtilityLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static TraceChannelTestUtil(WorldContextObject: $Nullable<Object>, BatchOptions: TraceChannelTestBatchOptions, Start: Vector, End: Vector, SphereCapsuleRadius: number, CapsuleHalfHeight: number, BoxHalfSize: Vector, Orientation: Rotator, TraceChannel: ETraceTypeQuery, ObjectTypes: TArray<EObjectTypeQuery>, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, bIgnoreSelf: boolean, DrawDebugType: EDrawDebugTrace, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): TraceQueryTestResults;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FunctionalTestUtilityLibrary;

        static Load(InName: string): FunctionalTestUtilityLibrary;
    }

    export class ScreenshotFunctionalTestBase extends FunctionalTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Notes: string;
        ScreenshotCamera: CameraComponent;
        ScreenshotOptions: AutomationScreenshotOptions;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScreenshotFunctionalTestBase;

        static Load(InName: string): ScreenshotFunctionalTestBase;
    }

    export enum EWidgetTestAppearLocation { Viewport, PlayerScreen, EWidgetTestAppearLocation_MAX }

    export class FunctionalUIScreenshotTest extends ScreenshotFunctionalTestBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetClass: Class;
        SpawnedWidget: UserWidget;
        WidgetLocation: EWidgetTestAppearLocation;
        ScreenshotRT: TextureRenderTarget2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): FunctionalUIScreenshotTest;

        static Load(InName: string): FunctionalUIScreenshotTest;
    }

    export class GameEngine extends Engine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxDeltaTime: number;
        ServerFlushLogInterval: number;
        GameInstance: GameInstance;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameEngine;

        static Load(InName: string): GameEngine;
    }

    export class GameInstanceSubsystem extends Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameInstanceSubsystem;

        static Load(InName: string): GameInstanceSubsystem;
    }

    export class ScrollerData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Row: number;
        Col: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScrollerData;

        static Load(InName: string): ScrollerData;
    }

    export class GameData {
        constructor();
        constructor(GameName: string, ThumbnailUrl: string, GameDataUrl: string, GameId: string, GameVersion: string);

        GameName: string;
        ThumbnailUrl: string;
        GameDataUrl: string;
        GameId: string;
        GameVersion: string;

        static StaticClass(): Class;
    }

    export class GameListData extends ScrollerData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GameData: GameData;
        DyTexture2D: Texture2DDynamic;
        OnImageRefresh: $MulticastDelegate<() => void>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameListData;

        static Load(InName: string): GameListData;
    }

    export enum ETwoPlayerSplitScreenType { Horizontal, Vertical, ETwoPlayerSplitScreenType_MAX }

    export enum EThreePlayerSplitScreenType {
        FavorTop,
        FavorBottom,
        Vertical,
        Horizontal,
        EThreePlayerSplitScreenType_MAX
    }

    export enum EFourPlayerSplitScreenType { Grid, Vertical, Horizontal, EFourPlayerSplitScreenType_MAX }

    export class GameModeName {
        constructor();
        constructor(Name: string, GameMode: SoftClassPath);

        Name: string;
        GameMode: SoftClassPath;

        static StaticClass(): Class;
    }

    export class GameMapsSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EditorStartupMap: SoftObjectPath;
        LocalMapOptions: string;
        TransitionMap: SoftObjectPath;
        bUseSplitscreen: boolean;
        TwoPlayerSplitscreenLayout: ETwoPlayerSplitScreenType;
        ThreePlayerSplitscreenLayout: EThreePlayerSplitScreenType;
        FourPlayerSplitscreenLayout: EFourPlayerSplitScreenType;
        bOffsetPlayerGamepadIds: boolean;
        GameInstanceClass: SoftClassPath;
        GameDefaultMap: SoftObjectPath;
        ServerDefaultMap: SoftObjectPath;
        GlobalDefaultGameMode: SoftClassPath;
        GlobalDefaultServerGameMode: SoftClassPath;
        GameModeMapPrefixes: TArray<GameModeName>;
        GameModeClassAliases: TArray<GameModeName>;

        GetSkipAssigningGamepadToPlayer1(): boolean;

        SetSkipAssigningGamepadToPlayer1(bSkipFirstPlayer?: boolean /* = true */): void;

        static GetGameMapsSettings(): GameMapsSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameMapsSettings;

        static Load(InName: string): GameMapsSettings;
    }

    export class GameNetworkManagerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MinDynamicBandwidth: number;
        MaxDynamicBandwidth: number;
        TotalNetBandwidth: number;
        BadPingThreshold: number;
        bIsStandbyCheckingEnabled: boolean;
        StandbyRxCheatTime: number;
        StandbyTxCheatTime: number;
        PercentMissingForRxStandby: number;
        PercentMissingForTxStandby: number;
        PercentForBadPing: number;
        JoinInProgressStandbyWaitTime: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameNetworkManagerSettings;

        static Load(InName: string): GameNetworkManagerSettings;
    }

    export class GameplayAbilitiesBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlueprintType: EBlueprintType;
        ParentClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilitiesBlueprintFactory;

        static Load(InName: string): GameplayAbilitiesBlueprintFactory;
    }

    export class GameplayAbility_CharacterJump extends GameplayAbility {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbility_CharacterJump;

        static Load(InName: string): GameplayAbility_CharacterJump;
    }

    export class GameplayAbility_Montage extends GameplayAbility {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MontageToPlay: AnimMontage;
        PlayRate: number;
        SectionName: string;
        GameplayEffectClassesWhileAnimating: TArray<Class>;
        GameplayEffectsWhileAnimating: TArray<GameplayEffect>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbility_Montage;

        static Load(InName: string): GameplayAbility_Montage;
    }

    export class GameplayAbilityBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityBlueprint;

        static Load(InName: string): GameplayAbilityBlueprint;
    }

    export class GameplayAbilityGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityGraph;

        static Load(InName: string): GameplayAbilityGraph;
    }

    export class GameplayAbilityGraphSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityGraphSchema;

        static Load(InName: string): GameplayAbilityGraphSchema;
    }

    export enum EGameplayAbilityInputBinds {
        Ability1,
        Ability2,
        Ability3,
        Ability4,
        Ability5,
        Ability6,
        Ability7,
        Ability8,
        Ability9,
        EGameplayAbilityInputBinds_MAX
    }

    export class GameplayAbilityBindInfo {
        constructor();
        constructor(Command: EGameplayAbilityInputBinds, GameplayAbilityClass: Class);

        Command: EGameplayAbilityInputBinds;
        GameplayAbilityClass: Class;

        static StaticClass(): Class;
    }

    export class GameplayAbilitySet extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Abilities: TArray<GameplayAbilityBindInfo>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilitySet;

        static Load(InName: string): GameplayAbilitySet;
    }

    export class CollisionProfileName {
        constructor();
        constructor(Name: string);

        Name: string;

        static StaticClass(): Class;
    }

    export class GameplayAbilityTargetActor_Trace extends GameplayAbilityTargetActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxRange: number;
        TraceProfile: CollisionProfileName;
        bTraceAffectsAimPitch: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityTargetActor_Trace;

        static Load(InName: string): GameplayAbilityTargetActor_Trace;
    }

    export class GameplayAbilityTargetActor_GroundTrace extends GameplayAbilityTargetActor_Trace {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CollisionRadius: number;
        CollisionHeight: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityTargetActor_GroundTrace;

        static Load(InName: string): GameplayAbilityTargetActor_GroundTrace;
    }

    export class GameplayAbilityTargetActor_ActorPlacement extends GameplayAbilityTargetActor_GroundTrace {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlacedActorClass: Class;
        PlacedActorMaterial: MaterialInterface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityTargetActor_ActorPlacement;

        static Load(InName: string): GameplayAbilityTargetActor_ActorPlacement;
    }

    export class GameplayAbilityTargetActor_Radius extends GameplayAbilityTargetActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Radius: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityTargetActor_Radius;

        static Load(InName: string): GameplayAbilityTargetActor_Radius;
    }

    export class GameplayAbilityTargetActor_SingleLineTrace extends GameplayAbilityTargetActor_Trace {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityTargetActor_SingleLineTrace;

        static Load(InName: string): GameplayAbilityTargetActor_SingleLineTrace;
    }

    export class GameplayAbilityWorldReticle extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Parameters: WorldReticleParameters;
        bFaceOwnerFlat: boolean;
        bSnapToTargetedActor: boolean;
        bIsTargetValid: boolean;
        bIsTargetAnActor: boolean;
        MasterPC: PlayerController;
        TargetingActor: Actor;

        FaceTowardSource(bFaceIn2D: boolean): void;

        OnParametersInitialized(): void;

        OnTargetingAnActor(bNewValue: boolean): void;

        OnValidTargetChanged(bNewValue: boolean): void;

        SetReticleMaterialParamFloat(ParamName: string, value: number): void;

        SetReticleMaterialParamVector(ParamName: string, value: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityWorldReticle;

        static Load(InName: string): GameplayAbilityWorldReticle;
    }

    export class GameplayAbilityWorldReticle_ActorVisualization extends GameplayAbilityWorldReticle {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CollisionComponent: CapsuleComponent;
        VisualizationComponents: TArray<ActorComponent>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayAbilityWorldReticle_ActorVisualization;

        static Load(InName: string): GameplayAbilityWorldReticle_ActorVisualization;
    }

    export class GameplayCueNotify_Actor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoDestroyOnRemove: boolean;
        AutoDestroyDelay: number;
        WarnIfTimelineIsStillRunning: boolean;
        WarnIfLatentActionIsStillRunning: boolean;
        GameplayCueTag: GameplayTag;
        GameplayCueName: string;
        bAutoAttachToOwner: boolean;
        IsOverride: boolean;
        bUniqueInstancePerInstigator: boolean;
        bUniqueInstancePerSourceObject: boolean;
        bAllowMultipleOnActiveEvents: boolean;
        bAllowMultipleWhileActiveEvents: boolean;
        NumPreallocatedInstances: number;

        K2_EndGameplayCue(): void;

        K2_HandleGameplayCue(MyTarget: $Nullable<Actor>, EventType: EGameplayCueEvent, Parameters: GameplayCueParameters): void;

        OnActive(MyTarget: $Nullable<Actor>, Parameters: GameplayCueParameters): boolean;

        OnExecute(MyTarget: $Nullable<Actor>, Parameters: GameplayCueParameters): boolean;

        OnOwnerDestroyed(DestroyedActor: $Nullable<Actor>): void;

        OnRemove(MyTarget: $Nullable<Actor>, Parameters: GameplayCueParameters): boolean;

        WhileActive(MyTarget: $Nullable<Actor>, Parameters: GameplayCueParameters): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayCueNotify_Actor;

        static Load(InName: string): GameplayCueNotify_Actor;
    }

    export class GameplayCueNotify_Static extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GameplayCueTag: GameplayTag;
        GameplayCueName: string;
        IsOverride: boolean;

        K2_HandleGameplayCue(MyTarget: $Nullable<Actor>, EventType: EGameplayCueEvent, Parameters: GameplayCueParameters): void;

        OnActive(MyTarget: $Nullable<Actor>, Parameters: GameplayCueParameters): boolean;

        OnExecute(MyTarget: $Nullable<Actor>, Parameters: GameplayCueParameters): boolean;

        OnRemove(MyTarget: $Nullable<Actor>, Parameters: GameplayCueParameters): boolean;

        WhileActive(MyTarget: $Nullable<Actor>, Parameters: GameplayCueParameters): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayCueNotify_Static;

        static Load(InName: string): GameplayCueNotify_Static;
    }

    export class GameplayCueNotify_HitImpact extends GameplayCueNotify_Static {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sound: SoundBase;
        ParticleSystem: ParticleSystem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayCueNotify_HitImpact;

        static Load(InName: string): GameplayCueNotify_HitImpact;
    }

    export class GameplayCueTranslator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayCueTranslator;

        static Load(InName: string): GameplayCueTranslator;
    }

    export class GameplayCueTranslator_Test extends GameplayCueTranslator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayCueTranslator_Test;

        static Load(InName: string): GameplayCueTranslator_Test;
    }

    export class GameplayDebuggerNetPack {
        constructor();

        static StaticClass(): Class;
    }

    export class GameplayDebuggerDebugActor {
        constructor();
        constructor(Actor: Actor, ActorName: string, SyncCounter: number);

        Actor: Actor;
        ActorName: string;
        SyncCounter: number;

        static StaticClass(): Class;
    }

    export class GameplayDebuggerVisLogSync {
        constructor();
        constructor(DeviceIDs: string);

        DeviceIDs: string;

        static StaticClass(): Class;
    }

    export class GameplayDebuggerRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerRenderingComponent;

        static Load(InName: string): GameplayDebuggerRenderingComponent;
    }

    export class GameplayDebuggerCategoryReplicator extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwnerPC: PlayerController;
        bIsEnabled: boolean;
        ReplicatedData: GameplayDebuggerNetPack;
        DebugActor: GameplayDebuggerDebugActor;
        VisLogSync: GameplayDebuggerVisLogSync;
        RenderingComp: GameplayDebuggerRenderingComponent;

        ServerSendCategoryInputEvent(CategoryId: number, HandlerId: number): void;

        ServerSendExtensionInputEvent(ExtensionId: number, HandlerId: number): void;

        ServerSetCategoryEnabled(CategoryId: number, bEnable: boolean): void;

        ServerSetDebugActor(Actor: $Nullable<Actor>, bSelectInEditor: boolean): void;

        ServerSetEnabled(bEnable: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerCategoryReplicator;

        static Load(InName: string): GameplayDebuggerCategoryReplicator;
    }

    export enum EGameplayDebuggerOverrideMode { Enable, Disable, UseDefault, EGameplayDebuggerOverrideMode_MAX }

    export class GameplayDebuggerInputConfig {
        constructor();
        constructor(ConfigName: string, Key: Key, bModShift: boolean, bModCtrl: boolean, bModAlt: boolean, bModCmd: boolean);

        ConfigName: string;
        Key: Key;
        bModShift: boolean;
        bModCtrl: boolean;
        bModAlt: boolean;
        bModCmd: boolean;

        static StaticClass(): Class;
    }

    export class GameplayDebuggerCategoryConfig {
        constructor();
        constructor(CategoryName: string, SlotIdx: number, ActiveInGame: EGameplayDebuggerOverrideMode, ActiveInSimulate: EGameplayDebuggerOverrideMode, Hidden: EGameplayDebuggerOverrideMode, bOverrideSlotIdx: boolean, InputHandlers: TArray<GameplayDebuggerInputConfig>);

        CategoryName: string;
        SlotIdx: number;
        ActiveInGame: EGameplayDebuggerOverrideMode;
        ActiveInSimulate: EGameplayDebuggerOverrideMode;
        Hidden: EGameplayDebuggerOverrideMode;
        bOverrideSlotIdx: boolean;
        InputHandlers: TArray<GameplayDebuggerInputConfig>;

        static StaticClass(): Class;
    }

    export class GameplayDebuggerExtensionConfig {
        constructor();
        constructor(ExtensionName: string, UseExtension: EGameplayDebuggerOverrideMode, InputHandlers: TArray<GameplayDebuggerInputConfig>);

        ExtensionName: string;
        UseExtension: EGameplayDebuggerOverrideMode;
        InputHandlers: TArray<GameplayDebuggerInputConfig>;

        static StaticClass(): Class;
    }

    export class GameplayDebuggerConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActivationKey: Key;
        CategoryRowNextKey: Key;
        CategoryRowPrevKey: Key;
        CategorySlot0: Key;
        CategorySlot1: Key;
        CategorySlot2: Key;
        CategorySlot3: Key;
        CategorySlot4: Key;
        CategorySlot5: Key;
        CategorySlot6: Key;
        CategorySlot7: Key;
        CategorySlot8: Key;
        CategorySlot9: Key;
        DebugCanvasPaddingLeft: number;
        DebugCanvasPaddingRight: number;
        DebugCanvasPaddingTop: number;
        DebugCanvasPaddingBottom: number;
        bDebugCanvasEnableTextShadow: boolean;
        Categories: TArray<GameplayDebuggerCategoryConfig>;
        Extensions: TArray<GameplayDebuggerExtensionConfig>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerConfig;

        static Load(InName: string): GameplayDebuggerConfig;
    }

    export class GameplayDebuggerPlayerData {
        constructor();
        constructor(Controller: GameplayDebuggerLocalController, InputComponent: InputComponent, Replicator: GameplayDebuggerCategoryReplicator);

        Controller: GameplayDebuggerLocalController;
        InputComponent: InputComponent;
        Replicator: GameplayDebuggerCategoryReplicator;

        static StaticClass(): Class;
    }

    export class GameplayDebuggerPlayerManager extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerData: TArray<GameplayDebuggerPlayerData>;
        PendingRegistrations: TArray<GameplayDebuggerCategoryReplicator>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerPlayerManager;

        static Load(InName: string): GameplayDebuggerPlayerManager;
    }

    export class GameplayDebuggerLocalController extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CachedReplicator: GameplayDebuggerCategoryReplicator;
        CachedPlayerManager: GameplayDebuggerPlayerManager;
        DebugActorCandidate: Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerLocalController;

        static Load(InName: string): GameplayDebuggerLocalController;
    }

    export class GameplayEffectCalculation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RelevantAttributesToCapture: TArray<GameplayEffectAttributeCaptureDefinition>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayEffectCalculation;

        static Load(InName: string): GameplayEffectCalculation;
    }

    export class GameplayEffectCreationData {
        constructor();
        constructor(MenuPath: string, BaseName: string, ParentGameplayEffect: Class);

        MenuPath: string;
        BaseName: string;
        ParentGameplayEffect: Class;

        static StaticClass(): Class;
    }

    export class GameplayEffectCreationMenu extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Definitions: TArray<GameplayEffectCreationData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayEffectCreationMenu;

        static Load(InName: string): GameplayEffectCreationMenu;
    }

    export class GameplayEffectCustomApplicationRequirement extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CanApplyGameplayEffect(GameplayEffect: $Nullable<GameplayEffect>, Spec: GameplayEffectSpec, ASC: $Nullable<AbilitySystemComponent>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayEffectCustomApplicationRequirement;

        static Load(InName: string): GameplayEffectCustomApplicationRequirement;
    }

    export class GameplayEffectCustomExecutionParameters {
        constructor();

        static StaticClass(): Class;
    }

    export class GameplayModifierEvaluatedData {
        constructor();
        constructor(Attribute: GameplayAttribute, ModifierOp: EGameplayModOp, Magnitude: number, Handle: ActiveGameplayEffectHandle, IsValid: boolean);

        Attribute: GameplayAttribute;
        ModifierOp: EGameplayModOp;
        Magnitude: number;
        Handle: ActiveGameplayEffectHandle;
        IsValid: boolean;

        static StaticClass(): Class;
    }

    export class GameplayEffectCustomExecutionOutput {
        constructor();
        constructor(OutputModifiers: TArray<GameplayModifierEvaluatedData>, bTriggerConditionalGameplayEffects: boolean, bHandledStackCountManually: boolean, bHandledGameplayCuesManually: boolean);

        OutputModifiers: TArray<GameplayModifierEvaluatedData>;
        bTriggerConditionalGameplayEffects: boolean;
        bHandledStackCountManually: boolean;
        bHandledGameplayCuesManually: boolean;

        static StaticClass(): Class;
    }

    export class GameplayEffectExecutionCalculation extends GameplayEffectCalculation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bRequiresPassedInTags: boolean;
        InvalidScopedModifierAttributes: TArray<GameplayEffectAttributeCaptureDefinition>;
        ValidTransientAggregatorIdentifiers: GameplayTagContainer;

        Execute(ExecutionParams: GameplayEffectCustomExecutionParameters, OutExecutionOutput: $Ref<GameplayEffectCustomExecutionOutput>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayEffectExecutionCalculation;

        static Load(InName: string): GameplayEffectExecutionCalculation;
    }

    export class GameplayEffectUIData_TextOnly extends GameplayEffectUIData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Description: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayEffectUIData_TextOnly;

        static Load(InName: string): GameplayEffectUIData_TextOnly;
    }

    export class GameplayModMagnitudeCalculation extends GameplayEffectCalculation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAllowNonNetAuthorityDependencyRegistration: boolean;

        CalculateBaseMagnitude(Spec: GameplayEffectSpec): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayModMagnitudeCalculation;

        static Load(InName: string): GameplayModMagnitudeCalculation;
    }

    export enum EPSCPoolMethod {
        None,
        AutoRelease,
        ManualRelease,
        ManualRelease_OnComplete,
        FreeInPool,
        EPSCPoolMethod_MAX
    }

    export enum EMouseCaptureMode {
        NoCapture,
        CapturePermanently,
        CapturePermanently_IncludingInitialMouseDown,
        CaptureDuringMouseDown,
        CaptureDuringRightMouseDown,
        EMouseCaptureMode_MAX
    }

    export enum ESuggestProjVelocityTraceOption {
        DoNotTrace,
        TraceFullPath,
        OnlyTraceWhileAscending,
        ESuggestProjVelocityTraceOption_MAX
    }

    export class PredictProjectilePathParams {
        constructor();
        constructor(StartLocation: Vector, LaunchVelocity: Vector, bTraceWithCollision: boolean, ProjectileRadius: number, MaxSimTime: number, bTraceWithChannel: boolean, TraceChannel: ECollisionChannel, ObjectTypes: TArray<EObjectTypeQuery>, ActorsToIgnore: TArray<Actor>, SimFrequency: number, OverrideGravityZ: number, DrawDebugType: EDrawDebugTrace, DrawDebugTime: number, bTraceComplex: boolean);

        StartLocation: Vector;
        LaunchVelocity: Vector;
        bTraceWithCollision: boolean;
        ProjectileRadius: number;
        MaxSimTime: number;
        bTraceWithChannel: boolean;
        TraceChannel: ECollisionChannel;
        ObjectTypes: TArray<EObjectTypeQuery>;
        ActorsToIgnore: TArray<Actor>;
        SimFrequency: number;
        OverrideGravityZ: number;
        DrawDebugType: EDrawDebugTrace;
        DrawDebugTime: number;
        bTraceComplex: boolean;

        static StaticClass(): Class;
    }

    export class PredictProjectilePathPointData {
        constructor();
        constructor(Location: Vector, Velocity: Vector, Time: number);

        Location: Vector;
        Velocity: Vector;
        Time: number;

        static StaticClass(): Class;
    }

    export class PredictProjectilePathResult {
        constructor();
        constructor(PathData: TArray<PredictProjectilePathPointData>, LastTraceDestination: PredictProjectilePathPointData, HitResult: HitResult);

        PathData: TArray<PredictProjectilePathPointData>;
        LastTraceDestination: PredictProjectilePathPointData;
        HitResult: HitResult;

        static StaticClass(): Class;
    }

    export class GameplayStatics extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ActivateReverbEffect(WorldContextObject: $Nullable<Object>, ReverbEffect: $Nullable<ReverbEffect>, TagName: string, Priority?: number /* = 0.000000 */, Volume?: number /* = 0.500000 */, FadeTime?: number /* = 2.000000 */): void;

        static AnnounceAccessibleString(AnnouncementString: string): void;

        static ApplyDamage(DamagedActor: $Nullable<Actor>, BaseDamage: number, EventInstigator: $Nullable<Controller>, DamageCauser: $Nullable<Actor>, DamageTypeClass: $Nullable<Class>): number;

        static ApplyPointDamage(DamagedActor: $Nullable<Actor>, BaseDamage: number, HitFromDirection: Vector, HitInfo: HitResult, EventInstigator: $Nullable<Controller>, DamageCauser: $Nullable<Actor>, DamageTypeClass: $Nullable<Class>): number;

        static ApplyRadialDamage(WorldContextObject: $Nullable<Object>, BaseDamage: number, Origin: Vector, DamageRadius: number, DamageTypeClass: $Nullable<Class>, IgnoreActors: TArray<Actor>, DamageCauser?: Actor /* = None */, InstigatedByController?: Controller /* = None */, bDoFullDamage?: boolean /* = false */, DamagePreventionChannel?: ECollisionChannel /* = ECC_Visibility */): boolean;

        static ApplyRadialDamageWithFalloff(WorldContextObject: $Nullable<Object>, BaseDamage: number, MinimumDamage: number, Origin: Vector, DamageInnerRadius: number, DamageOuterRadius: number, DamageFalloff: number, DamageTypeClass: $Nullable<Class>, IgnoreActors: TArray<Actor>, DamageCauser?: Actor /* = None */, InstigatedByController?: Controller /* = None */, DamagePreventionChannel?: ECollisionChannel /* = ECC_Visibility */): boolean;

        static AreAnyListenersWithinRange(WorldContextObject: $Nullable<Object>, Location: Vector, MaximumRange: number): boolean;

        static AreSubtitlesEnabled(): boolean;

        static BeginDeferredActorSpawnFromClass(WorldContextObject: $Nullable<Object>, ActorClass: $Nullable<Class>, SpawnTransform: Transform, CollisionHandlingOverride?: ESpawnActorCollisionHandlingMethod /* = Undefined */, Owner?: Actor /* = None */): Actor;

        static BeginSpawningActorFromBlueprint(WorldContextObject: $Nullable<Object>, Blueprint: $Nullable<Blueprint>, SpawnTransform: Transform, bNoCollisionFail: boolean): Actor;

        static BeginSpawningActorFromClass(WorldContextObject: $Nullable<Object>, ActorClass: $Nullable<Class>, SpawnTransform: Transform, bNoCollisionFail?: boolean /* = false */, Owner?: Actor /* = None */): Actor;

        static Blueprint_PredictProjectilePath_Advanced(WorldContextObject: $Nullable<Object>, PredictParams: PredictProjectilePathParams, PredictResult: $Ref<PredictProjectilePathResult>): boolean;

        static Blueprint_PredictProjectilePath_ByObjectType(WorldContextObject: $Nullable<Object>, OutHit: $Ref<HitResult>, OutPathPositions: $Ref<TArray<Vector>>, OutLastTraceDestination: $Ref<Vector>, StartPos: Vector, LaunchVelocity: Vector, bTracePath: boolean, ProjectileRadius: number, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, DrawDebugTime: number, SimFrequency?: number /* = 15.000000 */, MaxSimTime?: number /* = 2.000000 */, OverrideGravityZ?: number /* = 0.000000 */): boolean;

        static Blueprint_PredictProjectilePath_ByTraceChannel(WorldContextObject: $Nullable<Object>, OutHit: $Ref<HitResult>, OutPathPositions: $Ref<TArray<Vector>>, OutLastTraceDestination: $Ref<Vector>, StartPos: Vector, LaunchVelocity: Vector, bTracePath: boolean, ProjectileRadius: number, TraceChannel: ECollisionChannel, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, DrawDebugTime: number, SimFrequency?: number /* = 15.000000 */, MaxSimTime?: number /* = 2.000000 */, OverrideGravityZ?: number /* = 0.000000 */): boolean;

        static BlueprintSuggestProjectileVelocity(WorldContextObject: $Nullable<Object>, TossVelocity: $Ref<Vector>, StartLocation: Vector, EndLocation: Vector, LaunchSpeed: number, OverrideGravityZ: number, TraceOption: ESuggestProjVelocityTraceOption, CollisionRadius: number, bFavorHighArc: boolean, bDrawDebug: boolean): boolean;

        static BreakHitResult(Hit: HitResult, bBlockingHit: $Ref<boolean>, bInitialOverlap: $Ref<boolean>, Time: $Ref<number>, Distance: $Ref<number>, Location: $Ref<Vector>, ImpactPoint: $Ref<Vector>, Normal: $Ref<Vector>, ImpactNormal: $Ref<Vector>, PhysMat: $Ref<PhysicalMaterial>, HitActor: $Ref<Actor>, HitComponent: $Ref<PrimitiveComponent>, HitBoneName: $Ref<string>, HitItem: $Ref<number>, FaceIndex: $Ref<number>, TraceStart: $Ref<Vector>, TraceEnd: $Ref<Vector>): void;

        static CancelAsyncLoading(): void;

        static ClearSoundMixClassOverride(WorldContextObject: $Nullable<Object>, InSoundMixModifier: $Nullable<SoundMix>, InSoundClass: $Nullable<SoundClass>, FadeOutTime?: number /* = 1.000000 */): void;

        static ClearSoundMixModifiers(WorldContextObject: $Nullable<Object>): void;

        static CreatePlayer(WorldContextObject: $Nullable<Object>, ControllerId?: number /* = -1 */, bSpawnPlayerController?: boolean /* = true */): PlayerController;

        static CreateSaveGameObject(SaveGameClass: $Nullable<Class>): SaveGame;

        static CreateSound2D(WorldContextObject: $Nullable<Object>, Sound: $Nullable<SoundBase>, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, ConcurrencySettings?: SoundConcurrency /* = None */, bPersistAcrossLevelTransition?: boolean /* = false */, bAutoDestroy?: boolean /* = true */): AudioComponent;

        static DeactivateReverbEffect(WorldContextObject: $Nullable<Object>, TagName: string): void;

        static DeleteGameInSlot(SlotName: string, UserIndex: number): boolean;

        static DeprojectScreenToWorld(Player: $Nullable<PlayerController>, ScreenPosition: Vector2D, WorldPosition: $Ref<Vector>, WorldDirection: $Ref<Vector>): boolean;

        static DoesSaveGameExist(SlotName: string, UserIndex: number): boolean;

        static EnableLiveStreaming(Enable: boolean): void;

        static FindCollisionUV(Hit: HitResult, UVChannel: number, UV: $Ref<Vector2D>): boolean;

        static FinishSpawningActor(Actor: $Nullable<Actor>, SpawnTransform: Transform): Actor;

        static FlushLevelStreaming(WorldContextObject: $Nullable<Object>): void;

        static GetAccurateRealTime(WorldContextObject: $Nullable<Object>, Seconds: $Ref<number>, PartialSeconds: $Ref<number>): void;

        static GetActorArrayAverageLocation(Actors: TArray<Actor>): Vector;

        static GetActorArrayBounds(Actors: TArray<Actor>, bOnlyCollidingComponents: boolean, Center: $Ref<Vector>, BoxExtent: $Ref<Vector>): void;

        static GetActorOfClass(WorldContextObject: $Nullable<Object>, ActorClass: $Nullable<Class>): Actor;

        static GetAllActorsOfClass(WorldContextObject: $Nullable<Object>, ActorClass: $Nullable<Class>, OutActors: $Ref<TArray<Actor>>): void;

        static GetAllActorsOfClassWithTag(WorldContextObject: $Nullable<Object>, ActorClass: $Nullable<Class>, Tag: string, OutActors: $Ref<TArray<Actor>>): void;

        static GetAllActorsWithInterface(WorldContextObject: $Nullable<Object>, Interface: $Nullable<Class>, OutActors: $Ref<TArray<Actor>>): void;

        static GetAllActorsWithTag(WorldContextObject: $Nullable<Object>, Tag: string, OutActors: $Ref<TArray<Actor>>): void;

        static GetAudioTimeSeconds(WorldContextObject: $Nullable<Object>): number;

        static GetClosestListenerLocation(WorldContextObject: $Nullable<Object>, Location: Vector, MaximumRange: number, bAllowAttenuationOverride: boolean, ListenerPosition: $Ref<Vector>): boolean;

        static GetCurrentLevelName(WorldContextObject: $Nullable<Object>, bRemovePrefixString?: boolean /* = true */): string;

        static GetCurrentReverbEffect(WorldContextObject: $Nullable<Object>): ReverbEffect;

        static GetEnableWorldRendering(WorldContextObject: $Nullable<Object>): boolean;

        static GetGameInstance(WorldContextObject: $Nullable<Object>): GameInstance;

        static GetGameMode(WorldContextObject: $Nullable<Object>): GameModeBase;

        static GetGameState(WorldContextObject: $Nullable<Object>): GameStateBase;

        static GetGlobalTimeDilation(WorldContextObject: $Nullable<Object>): number;

        static GetIntOption(Options: string, Key: string, DefaultValue: number): number;

        static GetKeyValue(Pair: string, Key: $Ref<string>, Value: $Ref<string>): void;

        static GetMaxAudioChannelCount(WorldContextObject: $Nullable<Object>): number;

        static GetObjectClass(Object: $Nullable<Object>): Class;

        static GetPlatformName(): string;

        static GetPlayerCameraManager(WorldContextObject: $Nullable<Object>, PlayerIndex: number): PlayerCameraManager;

        static GetPlayerCharacter(WorldContextObject: $Nullable<Object>, PlayerIndex: number): Character;

        static GetPlayerController(WorldContextObject: $Nullable<Object>, PlayerIndex: number): PlayerController;

        static GetPlayerControllerFromID(WorldContextObject: $Nullable<Object>, ControllerID: number): PlayerController;

        static GetPlayerControllerID(Player: $Nullable<PlayerController>): number;

        static GetPlayerPawn(WorldContextObject: $Nullable<Object>, PlayerIndex: number): Pawn;

        static GetRealTimeSeconds(WorldContextObject: $Nullable<Object>): number;

        static GetStreamingLevel(WorldContextObject: $Nullable<Object>, PackageName: string): LevelStreaming;

        static GetSurfaceType(Hit: HitResult): EPhysicalSurface;

        static GetTimeSeconds(WorldContextObject: $Nullable<Object>): number;

        static GetUnpausedTimeSeconds(WorldContextObject: $Nullable<Object>): number;

        static GetViewportMouseCaptureMode(WorldContextObject: $Nullable<Object>): EMouseCaptureMode;

        static GetViewProjectionMatrix(DesiredView: MinimalViewInfo, ViewMatrix: $Ref<Matrix>, ProjectionMatrix: $Ref<Matrix>, ViewProjectionMatrix: $Ref<Matrix>): void;

        static GetWorldDeltaSeconds(WorldContextObject: $Nullable<Object>): number;

        static GetWorldOriginLocation(WorldContextObject: $Nullable<Object>): IntVector;

        static GrassOverlappingSphereCount(WorldContextObject: $Nullable<Object>, StaticMesh: $Nullable<StaticMesh>, CenterPosition: Vector, Radius: number): number;

        static HasLaunchOption(OptionToCheck: string): boolean;

        static HasOption(Options: string, InKey: string): boolean;

        static IsGamePaused(WorldContextObject: $Nullable<Object>): boolean;

        static IsSplitscreenForceDisabled(WorldContextObject: $Nullable<Object>): boolean;

        static LoadGameFromSlot(SlotName: string, UserIndex: number): SaveGame;

        static LoadStreamLevel(WorldContextObject: $Nullable<Object>, LevelName: string, bMakeVisibleAfterLoad: boolean, bShouldBlockOnLoad: boolean, LatentInfo: LatentActionInfo): void;

        static LoadStreamLevelBySoftObjectPtr(WorldContextObject: $Nullable<Object>, Level: TSoftObjectPtr<World>, bMakeVisibleAfterLoad: boolean, bShouldBlockOnLoad: boolean, LatentInfo: LatentActionInfo): void;

        static MakeHitResult(bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Distance: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: $Nullable<PhysicalMaterial>, HitActor: $Nullable<Actor>, HitComponent: $Nullable<PrimitiveComponent>, HitBoneName: string, HitItem: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector): HitResult;

        static OpenLevel(WorldContextObject: $Nullable<Object>, LevelName: string, bAbsolute?: boolean /* = true */, Options?: string /* = "" */): void;

        static OpenLevelBySoftObjectPtr(WorldContextObject: $Nullable<Object>, Level: TSoftObjectPtr<World>, bAbsolute?: boolean /* = true */, Options?: string /* = "" */): void;

        static ParseOption(Options: string, Key: string): string;

        static PlayDialogue2D(WorldContextObject: $Nullable<Object>, Dialogue: $Nullable<DialogueWave>, Context: DialogueContext, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */): void;

        static PlayDialogueAtLocation(WorldContextObject: $Nullable<Object>, Dialogue: $Nullable<DialogueWave>, Context: DialogueContext, Location: Vector, Rotation: Rotator, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: SoundAttenuation /* = None */): void;

        static PlaySound2D(WorldContextObject: $Nullable<Object>, Sound: $Nullable<SoundBase>, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, ConcurrencySettings?: SoundConcurrency /* = None */, OwningActor?: Actor /* = None */, bIsUISound?: boolean /* = true */): void;

        static PlaySoundAtLocation(WorldContextObject: $Nullable<Object>, Sound: $Nullable<SoundBase>, Location: Vector, Rotation: Rotator, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: SoundAttenuation /* = None */, ConcurrencySettings?: SoundConcurrency /* = None */, OwningActor?: Actor /* = None */): void;

        static PlayWorldCameraShake(WorldContextObject: $Nullable<Object>, Shake: $Nullable<Class>, Epicenter: Vector, InnerRadius: number, OuterRadius: number, Falloff?: number /* = 1.000000 */, bOrientShakeTowardsEpicenter?: boolean /* = false */): void;

        static PopSoundMixModifier(WorldContextObject: $Nullable<Object>, InSoundMixModifier: $Nullable<SoundMix>): void;

        static PrimeSound(InSound: $Nullable<SoundBase>): void;

        static ProjectWorldToScreen(Player: $Nullable<PlayerController>, WorldPosition: Vector, ScreenPosition: $Ref<Vector2D>, bPlayerViewportRelative?: boolean /* = false */): boolean;

        static PushSoundMixModifier(WorldContextObject: $Nullable<Object>, InSoundMixModifier: $Nullable<SoundMix>): void;

        static RebaseLocalOriginOntoZero(WorldContextObject: $Nullable<Object>, WorldLocation: Vector): Vector;

        static RebaseZeroOriginOntoLocal(WorldContextObject: $Nullable<Object>, WorldLocation: Vector): Vector;

        static RemovePlayer(Player: $Nullable<PlayerController>, bDestroyPawn: boolean): void;

        static SaveGameToSlot(SaveGameObject: $Nullable<SaveGame>, SlotName: string, UserIndex: number): boolean;

        static SetBaseSoundMix(WorldContextObject: $Nullable<Object>, InSoundMix: $Nullable<SoundMix>): void;

        static SetEnableWorldRendering(WorldContextObject: $Nullable<Object>, bEnable: boolean): void;

        static SetForceDisableSplitscreen(WorldContextObject: $Nullable<Object>, bDisable: boolean): void;

        static SetGamePaused(WorldContextObject: $Nullable<Object>, bPaused: boolean): boolean;

        static SetGlobalListenerFocusParameters(WorldContextObject: $Nullable<Object>, FocusAzimuthScale?: number /* = 1.000000 */, NonFocusAzimuthScale?: number /* = 1.000000 */, FocusDistanceScale?: number /* = 1.000000 */, NonFocusDistanceScale?: number /* = 1.000000 */, FocusVolumeScale?: number /* = 1.000000 */, NonFocusVolumeScale?: number /* = 1.000000 */, FocusPriorityScale?: number /* = 1.000000 */, NonFocusPriorityScale?: number /* = 1.000000 */): void;

        static SetGlobalPitchModulation(WorldContextObject: $Nullable<Object>, PitchModulation: number, TimeSec: number): void;

        static SetGlobalTimeDilation(WorldContextObject: $Nullable<Object>, TimeDilation: number): void;

        static SetMaxAudioChannelsScaled(WorldContextObject: $Nullable<Object>, MaxChannelCountScale: number): void;

        static SetPlayerControllerID(Player: $Nullable<PlayerController>, ControllerId: number): void;

        static SetSoundClassDistanceScale(WorldContextObject: $Nullable<Object>, SoundClass: $Nullable<SoundClass>, DistanceAttenuationScale: number, TimeSec?: number /* = 0.000000 */): void;

        static SetSoundMixClassOverride(WorldContextObject: $Nullable<Object>, InSoundMixModifier: $Nullable<SoundMix>, InSoundClass: $Nullable<SoundClass>, Volume?: number /* = 1.000000 */, Pitch?: number /* = 1.000000 */, FadeInTime?: number /* = 1.000000 */, bApplyToChildren?: boolean /* = true */): void;

        static SetSubtitlesEnabled(bEnabled: boolean): void;

        static SetViewportMouseCaptureMode(WorldContextObject: $Nullable<Object>, MouseCaptureMode: EMouseCaptureMode): void;

        static SetWorldOriginLocation(WorldContextObject: $Nullable<Object>, NewLocation: IntVector): void;

        static SpawnDecalAtLocation(WorldContextObject: $Nullable<Object>, DecalMaterial: $Nullable<MaterialInterface>, DecalSize: Vector, Location: Vector, Rotation?: Rotator /* = -90.000000,0.000000,0.000000 */, LifeSpan?: number /* = 0.000000 */): DecalComponent;

        static SpawnDecalAttached(DecalMaterial: $Nullable<MaterialInterface>, DecalSize: Vector, AttachToComponent: $Nullable<SceneComponent>, AttachPointName?: string /* = "None" */, Location?: Vector /* =  */, Rotation?: Rotator /* =  */, LocationType?: EAttachLocation /* = KeepRelativeOffset */, LifeSpan?: number /* = 0.000000 */): DecalComponent;

        static SpawnDialogue2D(WorldContextObject: $Nullable<Object>, Dialogue: $Nullable<DialogueWave>, Context: DialogueContext, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, bAutoDestroy?: boolean /* = true */): AudioComponent;

        static SpawnDialogueAtLocation(WorldContextObject: $Nullable<Object>, Dialogue: $Nullable<DialogueWave>, Context: DialogueContext, Location: Vector, Rotation?: Rotator /* =  */, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: SoundAttenuation /* = None */, bAutoDestroy?: boolean /* = true */): AudioComponent;

        static SpawnDialogueAttached(Dialogue: $Nullable<DialogueWave>, Context: DialogueContext, AttachToComponent: $Nullable<SceneComponent>, AttachPointName?: string /* = "None" */, Location?: Vector /* =  */, Rotation?: Rotator /* =  */, LocationType?: EAttachLocation /* = KeepRelativeOffset */, bStopWhenAttachedToDestroyed?: boolean /* = false */, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: SoundAttenuation /* = None */, bAutoDestroy?: boolean /* = true */): AudioComponent;

        static SpawnEmitterAtLocation(WorldContextObject: $Nullable<Object>, EmitterTemplate: $Nullable<ParticleSystem>, Location: Vector, Rotation?: Rotator /* =  */, Scale?: Vector /* = 1.000000,1.000000,1.000000 */, bAutoDestroy?: boolean /* = true */, PoolingMethod?: EPSCPoolMethod /* = None */, bAutoActivateSystem?: boolean /* = true */): ParticleSystemComponent;

        static SpawnEmitterAttached(EmitterTemplate: $Nullable<ParticleSystem>, AttachToComponent: $Nullable<SceneComponent>, AttachPointName?: string /* = "None" */, Location?: Vector /* =  */, Rotation?: Rotator /* =  */, Scale?: Vector /* = 1.000000,1.000000,1.000000 */, LocationType?: EAttachLocation /* = KeepRelativeOffset */, bAutoDestroy?: boolean /* = true */, PoolingMethod?: EPSCPoolMethod /* = None */, bAutoActivate?: boolean /* = true */): ParticleSystemComponent;

        static SpawnForceFeedbackAtLocation(WorldContextObject: $Nullable<Object>, ForceFeedbackEffect: $Nullable<ForceFeedbackEffect>, Location: Vector, Rotation?: Rotator /* =  */, bLooping?: boolean /* = false */, IntensityMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: ForceFeedbackAttenuation /* = None */, bAutoDestroy?: boolean /* = true */): ForceFeedbackComponent;

        static SpawnForceFeedbackAttached(ForceFeedbackEffect: $Nullable<ForceFeedbackEffect>, AttachToComponent: $Nullable<SceneComponent>, AttachPointName?: string /* = "None" */, Location?: Vector /* =  */, Rotation?: Rotator /* =  */, LocationType?: EAttachLocation /* = KeepRelativeOffset */, bStopWhenAttachedToDestroyed?: boolean /* = false */, bLooping?: boolean /* = false */, IntensityMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: ForceFeedbackAttenuation /* = None */, bAutoDestroy?: boolean /* = true */): ForceFeedbackComponent;

        static SpawnObject(ObjectClass: $Nullable<Class>, Outer: $Nullable<Object>): Object;

        static SpawnSound2D(WorldContextObject: $Nullable<Object>, Sound: $Nullable<SoundBase>, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, ConcurrencySettings?: SoundConcurrency /* = None */, bPersistAcrossLevelTransition?: boolean /* = false */, bAutoDestroy?: boolean /* = true */): AudioComponent;

        static SpawnSoundAtLocation(WorldContextObject: $Nullable<Object>, Sound: $Nullable<SoundBase>, Location: Vector, Rotation?: Rotator /* =  */, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: SoundAttenuation /* = None */, ConcurrencySettings?: SoundConcurrency /* = None */, bAutoDestroy?: boolean /* = true */): AudioComponent;

        static SpawnSoundAttached(Sound: $Nullable<SoundBase>, AttachToComponent: $Nullable<SceneComponent>, AttachPointName?: string /* = "None" */, Location?: Vector /* =  */, Rotation?: Rotator /* =  */, LocationType?: EAttachLocation /* = KeepRelativeOffset */, bStopWhenAttachedToDestroyed?: boolean /* = false */, VolumeMultiplier?: number /* = 1.000000 */, PitchMultiplier?: number /* = 1.000000 */, StartTime?: number /* = 0.000000 */, AttenuationSettings?: SoundAttenuation /* = None */, ConcurrencySettings?: SoundConcurrency /* = None */, bAutoDestroy?: boolean /* = true */): AudioComponent;

        static SuggestProjectileVelocity_CustomArc(WorldContextObject: $Nullable<Object>, OutLaunchVelocity: $Ref<Vector>, StartPos: Vector, EndPos: Vector, OverrideGravityZ?: number /* = 0.000000 */, ArcParam?: number /* = 0.500000 */): boolean;

        static UnloadStreamLevel(WorldContextObject: $Nullable<Object>, LevelName: string, LatentInfo: LatentActionInfo, bShouldBlockOnUnload: boolean): void;

        static UnloadStreamLevelBySoftObjectPtr(WorldContextObject: $Nullable<Object>, Level: TSoftObjectPtr<World>, LatentInfo: LatentActionInfo, bShouldBlockOnUnload: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayStatics;

        static Load(InName: string): GameplayStatics;
    }

    export class GameplayTagsDeveloperSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DeveloperConfigName: string;
        FavoriteTagSource: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsDeveloperSettings;

        static Load(InName: string): GameplayTagsDeveloperSettings;
    }

    export class GameplayTagSearchFilter extends ContentBrowserFrontEndFilterExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagSearchFilter;

        static Load(InName: string): GameplayTagSearchFilter;
    }

    export class GameplayTagsK2Node_LiteralGameplayTag extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_LiteralGameplayTag;

        static Load(InName: string): GameplayTagsK2Node_LiteralGameplayTag;
    }

    export class GameplayTagsK2Node_MultiCompareBase extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumberOfPins: number;
        PinNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareBase;

        static Load(InName: string): GameplayTagsK2Node_MultiCompareBase;
    }

    export class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface extends GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;

        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
    }

    export class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags extends GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;

        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
    }

    export class GameplayTagsK2Node_MultiCompareGameplayTagContainer extends GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagContainer;

        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
    }

    export class GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags extends GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;

        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
    }

    export class K2Node_Switch extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bHasDefaultPin: boolean;
        FunctionName: string;
        FunctionClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Switch;

        static Load(InName: string): K2Node_Switch;
    }

    export class GameplayTagsK2Node_SwitchGameplayTag extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PinTags: TArray<GameplayTag>;
        PinNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_SwitchGameplayTag;

        static Load(InName: string): GameplayTagsK2Node_SwitchGameplayTag;
    }

    export class GameplayTagsK2Node_SwitchGameplayTagContainer extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PinContainers: TArray<GameplayTagContainer>;
        PinNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_SwitchGameplayTagContainer;

        static Load(InName: string): GameplayTagsK2Node_SwitchGameplayTagContainer;
    }

    export class GameplayTagTableRow extends TableRowBase {
        constructor();
        constructor(Tag: string, DevComment: string);

        Tag: string;
        DevComment: string;

        static StaticClass(): Class;
    }

    export class GameplayTagsList extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConfigFileName: string;
        GameplayTagList: TArray<GameplayTagTableRow>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsList;

        static Load(InName: string): GameplayTagsList;
    }

    export enum EGameplayTagSourceType {
        Native,
        DefaultTagList,
        TagList,
        RestrictedTagList,
        DataTable,
        Invalid,
        EGameplayTagSourceType_MAX
    }

    export class RestrictedGameplayTagTableRow extends GameplayTagTableRow {
        constructor();
        constructor(bAllowNonRestrictedChildren: boolean);

        bAllowNonRestrictedChildren: boolean;

        static StaticClass(): Class;
    }

    export class RestrictedGameplayTagsList extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConfigFileName: string;
        RestrictedGameplayTagList: TArray<RestrictedGameplayTagTableRow>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RestrictedGameplayTagsList;

        static Load(InName: string): RestrictedGameplayTagsList;
    }

    export class GameplayTagSource {
        constructor();
        constructor(SourceName: string, SourceType: EGameplayTagSourceType, SourceTagList: GameplayTagsList, SourceRestrictedTagList: RestrictedGameplayTagsList);

        SourceName: string;
        SourceType: EGameplayTagSourceType;
        SourceTagList: GameplayTagsList;
        SourceRestrictedTagList: RestrictedGameplayTagsList;

        static StaticClass(): Class;
    }

    export class GameplayTagsManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TagSources: TArray<GameplayTagSource>;
        GameplayTagTables: TArray<DataTable>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsManager;

        static Load(InName: string): GameplayTagsManager;
    }

    export class GameplayTagCategoryRemap {
        constructor();
        constructor(BaseCategory: string, RemapCategories: TArray<string>);

        BaseCategory: string;
        RemapCategories: TArray<string>;

        static StaticClass(): Class;
    }

    export class GameplayTagRedirect {
        constructor();
        constructor(OldTagName: string, NewTagName: string);

        OldTagName: string;
        NewTagName: string;

        static StaticClass(): Class;
    }

    export class RestrictedConfigInfo {
        constructor();
        constructor(RestrictedConfigName: string, Owners: TArray<string>);

        RestrictedConfigName: string;
        Owners: TArray<string>;

        static StaticClass(): Class;
    }

    export class GameplayTagsSettings extends GameplayTagsList {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImportTagsFromConfig: boolean;
        WarnOnInvalidTags: boolean;
        FastReplication: boolean;
        InvalidTagCharacters: string;
        CategoryRemapping: TArray<GameplayTagCategoryRemap>;
        GameplayTagTableList: TArray<SoftObjectPath>;
        GameplayTagRedirects: TArray<GameplayTagRedirect>;
        CommonlyReplicatedTags: TArray<string>;
        NumBitsForContainerSize: number;
        NetIndexFirstBitSegment: number;
        RestrictedConfigFiles: TArray<RestrictedConfigInfo>;
        RestrictedTagList: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTagsSettings;

        static Load(InName: string): GameplayTagsSettings;
    }

    export class GameplayTask_ClaimResource extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ClaimResource(InTaskOwner: GameplayTaskOwnerInterface, ResourceClass: $Nullable<Class>, Priority?: number /* = 192 */, TaskInstanceName?: string /* = "None" */): GameplayTask_ClaimResource;

        static ClaimResources(InTaskOwner: GameplayTaskOwnerInterface, ResourceClasses: TArray<Class>, Priority?: number /* = 192 */, TaskInstanceName?: string /* = "None" */): GameplayTask_ClaimResource;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTask_ClaimResource;

        static Load(InName: string): GameplayTask_ClaimResource;
    }

    export class GameplayTask_SpawnActor extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Success: $MulticastDelegate<(SpawnedActor: $Nullable<Actor>) => void>;
        DidNotSpawn: $MulticastDelegate<(SpawnedActor: $Nullable<Actor>) => void>;
        ClassToSpawn: Class;

        BeginSpawningActor(WorldContextObject: $Nullable<Object>, SpawnedActor: $Ref<Actor>): boolean;

        FinishSpawningActor(WorldContextObject: $Nullable<Object>, SpawnedActor: $Nullable<Actor>): void;

        static SpawnActor(TaskOwner: GameplayTaskOwnerInterface, SpawnLocation: Vector, SpawnRotation: Rotator, Class: $Nullable<Class>, bSpawnOnlyOnAuthority?: boolean /* = false */): GameplayTask_SpawnActor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTask_SpawnActor;

        static Load(InName: string): GameplayTask_SpawnActor;
    }

    export class GameplayTask_TimeLimitedExecution extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnFinished: $MulticastDelegate<() => void>;
        OnTimeExpired: $MulticastDelegate<() => void>;

        TaskFinishDelegate__DelegateSignature(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTask_TimeLimitedExecution;

        static Load(InName: string): GameplayTask_TimeLimitedExecution;
    }

    export class GameplayTask_WaitDelay extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnFinish: $MulticastDelegate<() => void>;

        TaskDelayDelegate__DelegateSignature(): void;

        static TaskWaitDelay(TaskOwner: GameplayTaskOwnerInterface, Time: number, Priority?: number /* = 192 */): GameplayTask_WaitDelay;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameplayTask_WaitDelay;

        static Load(InName: string): GameplayTask_WaitDelay;
    }

    export class GameSessionSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxSpectators: number;
        MaxPlayers: number;
        bRequiresPushToTalk: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GameSessionSettings;

        static Load(InName: string): GameSessionSettings;
    }

    export class GarbageCollectionSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TimeBetweenPurgingPendingKillObjects: number;
        FlushStreamingOnGC: boolean;
        AllowParallelGC: boolean;
        IncrementalBeginDestroyEnabled: boolean;
        MultithreadedDestructionEnabled: boolean;
        CreateGCClusters: boolean;
        AssetClusteringEnabled: boolean;
        ActorClusteringEnabled: boolean;
        BlueprintClusteringEnabled: boolean;
        UseDisregardForGCOnDedicatedServers: boolean;
        MinGCClusterSize: number;
        NumRetriesBeforeForcingGC: number;
        MaxObjectsNotConsideredByGC: number;
        SizeOfPermanentObjectPool: number;
        MaxObjectsInGame: number;
        MaxObjectsInEditor: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GarbageCollectionSettings;

        static Load(InName: string): GarbageCollectionSettings;
    }

    export class GatherTextCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GatherTextCommandlet;

        static Load(InName: string): GatherTextCommandlet;
    }

    export class GatherTextFromAssetsCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GatherTextFromAssetsCommandlet;

        static Load(InName: string): GatherTextFromAssetsCommandlet;
    }

    export class GatherTextFromMetaDataCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GatherTextFromMetaDataCommandlet;

        static Load(InName: string): GatherTextFromMetaDataCommandlet;
    }

    export class GatherTextFromSourceCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GatherTextFromSourceCommandlet;

        static Load(InName: string): GatherTextFromSourceCommandlet;
    }

    export class GCObjectReferencer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GCObjectReferencer;

        static Load(InName: string): GCObjectReferencer;
    }

    export class GeneralEngineSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeneralEngineSettings;

        static Load(InName: string): GeneralEngineSettings;
    }

    export class GeneralProjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CompanyName: string;
        CompanyDistinguishedName: string;
        CopyrightNotice: string;
        Description: string;
        Homepage: string;
        LicensingTerms: string;
        PrivacyPolicy: string;
        ProjectID: Guid;
        ProjectName: string;
        ProjectVersion: string;
        SupportContact: string;
        ProjectDisplayedTitle: string;
        ProjectDebugTitleInfo: string;
        bShouldWindowPreserveAspectRatio: boolean;
        bUseBorderlessWindow: boolean;
        bStartInVR: boolean;
        bAllowWindowResize: boolean;
        bAllowClose: boolean;
        bAllowMaximize: boolean;
        bAllowMinimize: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeneralProjectSettings;

        static Load(InName: string): GeneralProjectSettings;
    }

    export class GenerateAssetManifestCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenerateAssetManifestCommandlet;

        static Load(InName: string): GenerateAssetManifestCommandlet;
    }

    export class GenerateBlueprintAPICommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenerateBlueprintAPICommandlet;

        static Load(InName: string): GenerateBlueprintAPICommandlet;
    }

    export class GenerateDistillFileSetsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenerateDistillFileSetsCommandlet;

        static Load(InName: string): GenerateDistillFileSetsCommandlet;
    }

    export enum ELightUnits { Unitless, Candelas, Lumens, ELightUnits_MAX }

    export class LightmassPointLightSettings extends LightmassLightSettings {
        constructor();

        static StaticClass(): Class;
    }

    export class LocalLightComponent extends LightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IntensityUnits: ELightUnits;
        Radius: number;
        AttenuationRadius: number;
        LightmassSettings: LightmassPointLightSettings;

        SetAttenuationRadius(NewRadius: number): void;

        SetIntensityUnits(NewIntensityUnits: ELightUnits): void;

        static GetUnitsConversionFactor(SrcUnits: ELightUnits, TargetUnits: ELightUnits, CosHalfConeAngle?: number /* = -1.000000 */): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalLightComponent;

        static Load(InName: string): LocalLightComponent;
    }

    export class PointLightComponent extends LocalLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseInverseSquaredFalloff: boolean;
        LightFalloffExponent: number;
        SourceRadius: number;
        SoftSourceRadius: number;
        SourceLength: number;

        SetLightFalloffExponent(NewLightFalloffExponent: number): void;

        SetSoftSourceRadius(bNewValue: number): void;

        SetSourceLength(NewValue: number): void;

        SetSourceRadius(bNewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PointLightComponent;

        static Load(InName: string): PointLightComponent;
    }

    export class SpotLightComponent extends PointLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InnerConeAngle: number;
        OuterConeAngle: number;

        SetInnerConeAngle(NewInnerConeAngle: number): void;

        SetOuterConeAngle(NewOuterConeAngle: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpotLightComponent;

        static Load(InName: string): SpotLightComponent;
    }

    export class SpotLight extends Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpotLightComponent: SpotLightComponent;
        ArrowComponent: ArrowComponent;

        SetInnerConeAngle(NewInnerConeAngle: number): void;

        SetOuterConeAngle(NewOuterConeAngle: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpotLight;

        static Load(InName: string): SpotLight;
    }

    export class GeneratedMeshAreaLight extends SpotLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeneratedMeshAreaLight;

        static Load(InName: string): GeneratedMeshAreaLight;
    }

    export class GenerateGatherArchiveCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenerateGatherArchiveCommandlet;

        static Load(InName: string): GenerateGatherArchiveCommandlet;
    }

    export class GenerateGatherManifestCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenerateGatherManifestCommandlet;

        static Load(InName: string): GenerateGatherManifestCommandlet;
    }

    export class GenerateTextLocalizationReportCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenerateTextLocalizationReportCommandlet;

        static Load(InName: string): GenerateTextLocalizationReportCommandlet;
    }

    export class GenerateTextLocalizationResourceCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenerateTextLocalizationResourceCommandlet;

        static Load(InName: string): GenerateTextLocalizationResourceCommandlet;
    }

    export class GenericTeamAgentInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenericTeamAgentInterface;

        static Load(InName: string): GenericTeamAgentInterface;
    }

    export class GenlockedCustomTimeStep extends FixedFrameRateCustomTimeStep {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenlockedCustomTimeStep;

        static Load(InName: string): GenlockedCustomTimeStep;
    }

    export class GenlockedTimecodeProvider extends TimecodeProvider {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseGenlockToCount: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenlockedTimecodeProvider;

        static Load(InName: string): GenlockedTimecodeProvider;
    }

    export class GenUeDTsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GenUeDTsCommandlet;

        static Load(InName: string): GenUeDTsCommandlet;
    }

    export class Polys extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Polys;

        static Load(InName: string): Polys;
    }

    export class GeomModifier extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Description: string;
        Tooltip: string;
        ToolbarIconName: string;
        bPushButton: boolean;
        bInitialized: boolean;
        bPendingPivotOffsetUpdate: boolean;
        bAppearsInToolbar: boolean;
        CachedPolys: Polys;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier;

        static Load(InName: string): GeomModifier;
    }

    export class GeomModifier_Edit extends GeomModifier {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Edit;

        static Load(InName: string): GeomModifier_Edit;
    }

    export class GeomModifier_Clip extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bFlipNormal: boolean;
        bSplit: boolean;
        ClipMarkers: TArray<Vector>;
        SnappedMouseWorldSpacePos: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Clip;

        static Load(InName: string): GeomModifier_Clip;
    }

    export class GeomModifier_Create extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Create;

        static Load(InName: string): GeomModifier_Create;
    }

    export class GeomModifier_Delete extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Delete;

        static Load(InName: string): GeomModifier_Delete;
    }

    export class GeomModifier_Extrude extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Length: number;
        Segments: number;
        SaveCoordSystem: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Extrude;

        static Load(InName: string): GeomModifier_Extrude;
    }

    export class GeomModifier_Flip extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Flip;

        static Load(InName: string): GeomModifier_Flip;
    }

    export class GeomModifier_Lathe extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TotalSegments: number;
        Segments: number;
        AlignToSide: boolean;
        Axis: EAxis;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Lathe;

        static Load(InName: string): GeomModifier_Lathe;
    }

    export class GeomModifier_Triangulate extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Triangulate;

        static Load(InName: string): GeomModifier_Triangulate;
    }

    export class GeomModifier_Optimize extends GeomModifier_Triangulate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Optimize;

        static Load(InName: string): GeomModifier_Optimize;
    }

    export class GeomModifier_Pen extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoExtrude: boolean;
        bCreateConvexPolygons: boolean;
        bCreateBrushShape: boolean;
        ExtrudeDepth: number;
        ShapeVertices: TArray<Vector>;
        MouseWorldSpacePos: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Pen;

        static Load(InName: string): GeomModifier_Pen;
    }

    export class GeomModifier_Split extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Split;

        static Load(InName: string): GeomModifier_Split;
    }

    export class GeomModifier_Turn extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Turn;

        static Load(InName: string): GeomModifier_Turn;
    }

    export class GeomModifier_Weld extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GeomModifier_Weld;

        static Load(InName: string): GeomModifier_Weld;
    }

    export class GetGeoLocationAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(Longitude: number, Latitude: number, Altitude: number, Error: string) => void>;
        OnFailed: $MulticastDelegate<(Longitude: number, Latitude: number, Altitude: number, Error: string) => void>;

        GetGeoLocationDelegate__DelegateSignature(Longitude: number, Latitude: number, Altitude: number, Error: string): void;

        static GetGeoLocationAtWorldPosition(WorldContextObject: $Nullable<Object>, WorldPosition: Vector): GetGeoLocationAsyncTaskBlueprintProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GetGeoLocationAsyncTaskBlueprintProxy;

        static Load(InName: string): GetGeoLocationAsyncTaskBlueprintProxy;
    }

    export class InternalToolFrameworkActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InternalToolFrameworkActor;

        static Load(InName: string): InternalToolFrameworkActor;
    }

    export class GizmoActor extends InternalToolFrameworkActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoActor;

        static Load(InName: string): GizmoActor;
    }

    export class GizmoBaseComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Color: LinearColor;
        HoverSizeMultiplier: number;
        PixelHitDistanceThreshold: number;

        UpdateHoverState(bHoveringIn: boolean): void;

        UpdateWorldLocalState(bWorldIn: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoBaseComponent;

        static Load(InName: string): GizmoBaseComponent;
    }

    export class GizmoArrowComponent extends GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Direction: Vector;
        Gap: number;
        Length: number;
        Thickness: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoArrowComponent;

        static Load(InName: string): GizmoArrowComponent;
    }

    export class GizmoBaseFloatParameterSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoBaseFloatParameterSource;

        static Load(InName: string): GizmoBaseFloatParameterSource;
    }

    export class GizmoAxisIntervalParameterSource extends GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatParameterSource: GizmoFloatParameterSource;
        MinParameter: number;
        MaxParameter: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoAxisIntervalParameterSource;

        static Load(InName: string): GizmoAxisIntervalParameterSource;
    }

    export class GizmoTransformSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetTransform(): Transform;

        SetTransform(NewTransform: Transform): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoTransformSource;

        static Load(InName: string): GizmoTransformSource;
    }

    export class GizmoFloatParameterChange {
        constructor();
        constructor(InitialValue: number, CurrentValue: number);

        InitialValue: number;
        CurrentValue: number;

        static StaticClass(): Class;
    }

    export class GizmoAxisRotationParameterSource extends GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Angle: number;
        LastChange: GizmoFloatParameterChange;
        CurRotationAxis: Vector;
        CurRotationOrigin: Vector;
        InitialTransform: Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoAxisRotationParameterSource;

        static Load(InName: string): GizmoAxisRotationParameterSource;
    }

    export class GizmoAxisScaleParameterSource extends GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        ScaleMultiplier: number;
        Parameter: number;
        LastChange: GizmoFloatParameterChange;
        CurScaleAxis: Vector;
        CurScaleOrigin: Vector;
        InitialTransform: Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoAxisScaleParameterSource;

        static Load(InName: string): GizmoAxisScaleParameterSource;
    }

    export class GizmoAxisTranslationParameterSource extends GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Parameter: number;
        LastChange: GizmoFloatParameterChange;
        CurTranslationAxis: Vector;
        CurTranslationOrigin: Vector;
        InitialTransform: Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoAxisTranslationParameterSource;

        static Load(InName: string): GizmoAxisTranslationParameterSource;
    }

    export class GizmoBaseTransformSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoBaseTransformSource;

        static Load(InName: string): GizmoBaseTransformSource;
    }

    export class GizmoBaseVec2ParameterSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoBaseVec2ParameterSource;

        static Load(InName: string): GizmoBaseVec2ParameterSource;
    }

    export class GizmoBoxComponent extends GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Origin: Vector;
        Rotation: Quat;
        Dimensions: Vector;
        LineThickness: number;
        bRemoveHiddenLines: boolean;
        bEnableAxisFlip: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoBoxComponent;

        static Load(InName: string): GizmoBoxComponent;
    }

    export class GizmoCircleComponent extends GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Normal: Vector;
        Radius: number;
        Thickness: number;
        NumSides: number;
        bViewAligned: boolean;
        bOnlyAllowFrontFacingHits: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoCircleComponent;

        static Load(InName: string): GizmoCircleComponent;
    }

    export class GizmoComponentAxisSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Component: SceneComponent;
        AxisIndex: number;
        bLocalAxes: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoComponentAxisSource;

        static Load(InName: string): GizmoComponentAxisSource;
    }

    export class GizmoComponentHitTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Component: PrimitiveComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoComponentHitTarget;

        static Load(InName: string): GizmoComponentHitTarget;
    }

    export class GizmoComponentWorldTransformSource extends GizmoBaseTransformSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Component: SceneComponent;
        bModifyComponentOnTransform: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoComponentWorldTransformSource;

        static Load(InName: string): GizmoComponentWorldTransformSource;
    }

    export class GizmoConstantAxisSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Origin: Vector;
        Direction: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoConstantAxisSource;

        static Load(InName: string): GizmoConstantAxisSource;
    }

    export class GizmoConstantFrameAxisSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Origin: Vector;
        Direction: Vector;
        TangentX: Vector;
        TangentY: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoConstantFrameAxisSource;

        static Load(InName: string): GizmoConstantFrameAxisSource;
    }

    export class GizmoHandleMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoHandleMeshComponent;

        static Load(InName: string): GizmoHandleMeshComponent;
    }

    export class GizmoLambdaHitTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoLambdaHitTarget;

        static Load(InName: string): GizmoLambdaHitTarget;
    }

    export class GizmoLambdaStateTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoLambdaStateTarget;

        static Load(InName: string): GizmoLambdaStateTarget;
    }

    export class GizmoLineHandleComponent extends GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Normal: Vector;
        HandleSize: number;
        Thickness: number;
        Direction: Vector;
        Length: number;
        bImageScale: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoLineHandleComponent;

        static Load(InName: string): GizmoLineHandleComponent;
    }

    export class GizmoLocalFloatParameterSource extends GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Value: number;
        LastChange: GizmoFloatParameterChange;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoLocalFloatParameterSource;

        static Load(InName: string): GizmoLocalFloatParameterSource;
    }

    export class GizmoVec2ParameterChange {
        constructor();
        constructor(InitialValue: Vector2D, CurrentValue: Vector2D);

        InitialValue: Vector2D;
        CurrentValue: Vector2D;

        static StaticClass(): Class;
    }

    export class GizmoLocalVec2ParameterSource extends GizmoBaseVec2ParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Value: Vector2D;
        LastChange: GizmoVec2ParameterChange;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoLocalVec2ParameterSource;

        static Load(InName: string): GizmoLocalVec2ParameterSource;
    }

    export class GizmoNilStateTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoNilStateTarget;

        static Load(InName: string): GizmoNilStateTarget;
    }

    export class GizmoObjectModifyStateTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoObjectModifyStateTarget;

        static Load(InName: string): GizmoObjectModifyStateTarget;
    }

    export class GizmoPlaneScaleParameterSource extends GizmoBaseVec2ParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        ScaleMultiplier: number;
        Parameter: Vector2D;
        LastChange: GizmoVec2ParameterChange;
        CurScaleOrigin: Vector;
        CurScaleNormal: Vector;
        CurScaleAxisX: Vector;
        CurScaleAxisY: Vector;
        InitialTransform: Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoPlaneScaleParameterSource;

        static Load(InName: string): GizmoPlaneScaleParameterSource;
    }

    export class GizmoPlaneTranslationParameterSource extends GizmoBaseVec2ParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Parameter: Vector2D;
        LastChange: GizmoVec2ParameterChange;
        CurTranslationOrigin: Vector;
        CurTranslationNormal: Vector;
        CurTranslationAxisX: Vector;
        CurTranslationAxisY: Vector;
        InitialTransform: Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoPlaneTranslationParameterSource;

        static Load(InName: string): GizmoPlaneTranslationParameterSource;
    }

    export class GizmoRectangleComponent extends GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DirectionX: Vector;
        DirectionY: Vector;
        OffsetX: number;
        OffsetY: number;
        LengthX: number;
        LengthY: number;
        Thickness: number;
        SegmentFlags: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoRectangleComponent;

        static Load(InName: string): GizmoRectangleComponent;
    }

    export class GizmoScaledTransformSource extends GizmoBaseTransformSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChildTransformSource: GizmoTransformSource;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoScaledTransformSource;

        static Load(InName: string): GizmoScaledTransformSource;
    }

    export class ToolContextTransactionProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolContextTransactionProvider;

        static Load(InName: string): ToolContextTransactionProvider;
    }

    export class GizmoTransformChangeStateTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TransactionManager: ToolContextTransactionProvider;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoTransformChangeStateTarget;

        static Load(InName: string): GizmoTransformChangeStateTarget;
    }

    export class TransformProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bRotatePerObject: boolean;
        bSetPivotMode: boolean;
        SharedTransform: Transform;
        InitialSharedTransform: Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TransformProxy;

        static Load(InName: string): TransformProxy;
    }

    export class GizmoTransformProxyTransformSource extends GizmoBaseTransformSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Proxy: TransformProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoTransformProxyTransformSource;

        static Load(InName: string): GizmoTransformProxyTransformSource;
    }

    export class GizmoUniformScaleParameterSource extends GizmoBaseVec2ParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        ScaleMultiplier: number;
        Parameter: Vector2D;
        LastChange: GizmoVec2ParameterChange;
        CurScaleOrigin: Vector;
        CurScaleNormal: Vector;
        CurScaleAxisX: Vector;
        CurScaleAxisY: Vector;
        InitialTransform: Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoUniformScaleParameterSource;

        static Load(InName: string): GizmoUniformScaleParameterSource;
    }

    export class GizmoVec2ParameterSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BeginModify(): void;

        EndModify(): void;

        GetParameter(): Vector2D;

        SetParameter(NewValue: Vector2D): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoVec2ParameterSource;

        static Load(InName: string): GizmoVec2ParameterSource;
    }

    export class GizmoWorldAxisSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Origin: Vector;
        AxisIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GizmoWorldAxisSource;

        static Load(InName: string): GizmoWorldAxisSource;
    }

    export class GlobalEditorUtilityBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HelpText: string;
        bDirtiedSelectionSet: boolean;
        bAutoRunDefaultAction: boolean;
        OnEachSelectedActor: $MulticastDelegate<(Actor: $Nullable<Actor>, Index: number) => void>;
        OnEachSelectedAsset: $MulticastDelegate<(Asset: $Nullable<Object>, Index: number) => void>;

        ClearActorSelectionSet(): void;

        ForEachSelectedActor(): void;

        ForEachSelectedAsset(): void;

        GetActorReference(PathToActor: string): Actor;

        GetEditorUserSettings(): EditorPerProjectUserSettings;

        GetSelectedAssets(): TArray<Object>;

        GetSelectionBounds(Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>, SphereRadius: $Ref<number>): void;

        GetSelectionSet(): TArray<Actor>;

        OnDefaultActionClicked(): void;

        RenameAsset(Asset: $Nullable<Object>, NewName: string): void;

        SelectNothing(): void;

        SetActorSelectionState(Actor: $Nullable<Actor>, bShouldBeSelected: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GlobalEditorUtilityBase;

        static Load(InName: string): GlobalEditorUtilityBase;
    }

    export enum EBlueprintPinStyleType { BPST_Original, BPST_VariantA, BPST_MAX }

    export enum EGraphPanningMouseButton { Right, Middle, Both, EGraphPanningMouseButton_MAX }

    export class GraphEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DataPinStyle: EBlueprintPinStyleType;
        PanningMouseButton: EGraphPanningMouseButton;
        PaddingAbovePin: number;
        PaddingBelowPin: number;
        PaddingRightOfInput: number;
        PaddingLeftOfOutput: number;
        PaddingTowardsNodeEdge: number;
        bTreatSplinesLikePins: boolean;
        SplineHoverTolerance: number;
        ForwardSplineHorizontalDeltaRange: number;
        ForwardSplineVerticalDeltaRange: number;
        ForwardSplineTangentFromHorizontalDelta: Vector2D;
        ForwardSplineTangentFromVerticalDelta: Vector2D;
        BackwardSplineHorizontalDeltaRange: number;
        BackwardSplineVerticalDeltaRange: number;
        BackwardSplineTangentFromHorizontalDelta: Vector2D;
        BackwardSplineTangentFromVerticalDelta: Vector2D;
        DefaultPinTypeColor: LinearColor;
        ExecutionPinTypeColor: LinearColor;
        BooleanPinTypeColor: LinearColor;
        BytePinTypeColor: LinearColor;
        ClassPinTypeColor: LinearColor;
        IntPinTypeColor: LinearColor;
        Int64PinTypeColor: LinearColor;
        FloatPinTypeColor: LinearColor;
        NamePinTypeColor: LinearColor;
        SoftObjectPinTypeColor: LinearColor;
        SoftClassPinTypeColor: LinearColor;
        DelegatePinTypeColor: LinearColor;
        ObjectPinTypeColor: LinearColor;
        InterfacePinTypeColor: LinearColor;
        StringPinTypeColor: LinearColor;
        TextPinTypeColor: LinearColor;
        StructPinTypeColor: LinearColor;
        WildcardPinTypeColor: LinearColor;
        VectorPinTypeColor: LinearColor;
        RotatorPinTypeColor: LinearColor;
        TransformPinTypeColor: LinearColor;
        IndexPinTypeColor: LinearColor;
        EventNodeTitleColor: LinearColor;
        FunctionCallNodeTitleColor: LinearColor;
        PureFunctionCallNodeTitleColor: LinearColor;
        ParentFunctionCallNodeTitleColor: LinearColor;
        FunctionTerminatorNodeTitleColor: LinearColor;
        ExecBranchNodeTitleColor: LinearColor;
        ExecSequenceNodeTitleColor: LinearColor;
        ResultNodeTitleColor: LinearColor;
        DefaultCommentNodeTitleColor: LinearColor;
        PreviewNodeTitleColor: LinearColor;
        DefaultDataWireThickness: number;
        DefaultExecutionWireThickness: number;
        TraceAttackColor: LinearColor;
        TraceAttackWireThickness: number;
        TraceAttackHoldPeriod: number;
        TraceDecayPeriod: number;
        TraceDecayExponent: number;
        TraceSustainColor: LinearColor;
        TraceSustainWireThickness: number;
        TraceSustainHoldPeriod: number;
        TraceReleaseColor: LinearColor;
        TraceReleaseWireThickness: number;
        TraceReleasePeriod: number;
        TraceReleaseExponent: number;
        TracePositionBonusPeriod: number;
        TracePositionExponent: number;
        PaddingAutoCollateIncrement: number;
        bOpenCreateMenuOnBlankGraphAreas: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GraphEditorSettings;

        static Load(InName: string): GraphEditorSettings;
    }

    export class GraphNodeContextMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Blueprint: Blueprint;
        Graph: EdGraph;
        Node: EdGraphNode;
        bIsDebugging: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GraphNodeContextMenuContext;

        static Load(InName: string): GraphNodeContextMenuContext;
    }

    export class GridSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;
        Row: number;
        RowSpan: number;
        Column: number;
        ColumnSpan: number;
        Layer: number;
        Nudge: Vector2D;

        SetColumn(InColumn: number): void;

        SetColumnSpan(InColumnSpan: number): void;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetLayer(InLayer: number): void;

        SetNudge(InNudge: Vector2D): void;

        SetPadding(InPadding: Margin): void;

        SetRow(InRow: number): void;

        SetRowSpan(InRowSpan: number): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GridSlot;

        static Load(InName: string): GridSlot;
    }

    export class GridPanel extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ColumnFill: TArray<number>;
        RowFill: TArray<number>;

        AddChildToGrid(Content: $Nullable<Widget>, InRow?: number /* = 0 */, InColumn?: number /* = 0 */): GridSlot;

        SetColumnFill(ColumnIndex: number, Coefficient: number): void;

        SetRowFill(ColumnIndex: number, Coefficient: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GridPanel;

        static Load(InName: string): GridPanel;
    }

    export class GridPathAIController extends AIController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GridPathAIController;

        static Load(InName: string): GridPathAIController;
    }

    export class GridPathFollowingComponent extends PathFollowingComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GridManager: NavLocalGridManager;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GridPathFollowingComponent;

        static Load(InName: string): GridPathFollowingComponent;
    }

    export class GroundTruthData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bResetGroundTruth: boolean;
        ObjectData: Object;

        CanModify(): boolean;

        LoadObject(): Object;

        SaveObject(GroundTruth: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GroundTruthData;

        static Load(InName: string): GroundTruthData;
    }

    export class GroupActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bLocked: boolean;
        GroupActors: TArray<Actor>;
        SubGroups: TArray<GroupActor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): GroupActor;

        static Load(InName: string): GroupActor;
    }

    export class HapticFeedbackEffect_Buffer extends HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Amplitudes: TArray<number>;
        SampleRate: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Buffer;

        static Load(InName: string): HapticFeedbackEffect_Buffer;
    }

    export class HapticFeedbackDetails_Curve {
        constructor();
        constructor(Frequency: RuntimeFloatCurve, Amplitude: RuntimeFloatCurve);

        Frequency: RuntimeFloatCurve;
        Amplitude: RuntimeFloatCurve;

        static StaticClass(): Class;
    }

    export class HapticFeedbackEffect_Curve extends HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HapticDetails: HapticFeedbackDetails_Curve;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Curve;

        static Load(InName: string): HapticFeedbackEffect_Curve;
    }

    export class HapticFeedbackEffect_SoundWave extends HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundWave: SoundWave;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_SoundWave;

        static Load(InName: string): HapticFeedbackEffect_SoundWave;
    }

    export class HapticFeedbackEffectBufferFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectBufferFactory;

        static Load(InName: string): HapticFeedbackEffectBufferFactory;
    }

    export class HapticFeedbackEffectCurveFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectCurveFactory;

        static Load(InName: string): HapticFeedbackEffectCurveFactory;
    }

    export class HapticFeedbackEffectSoundWaveFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectSoundWaveFactory;

        static Load(InName: string): HapticFeedbackEffectSoundWaveFactory;
    }

    export enum EHardwareClass { Unspecified, Desktop, Mobile, EHardwareClass_MAX }

    export enum EGraphicsPreset { Unspecified, Maximum, Scalable, EGraphicsPreset_MAX }

    export class HardwareTargetingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetedHardwareClass: EHardwareClass;
        AppliedTargetedHardwareClass: EHardwareClass;
        DefaultGraphicsPerformance: EGraphicsPreset;
        AppliedDefaultGraphicsPerformance: EGraphicsPreset;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HardwareTargetingSettings;

        static Load(InName: string): HardwareTargetingSettings;
    }

    export enum EHMDTrackingOrigin { Floor, Eye, Stage, Unbounded, EHMDTrackingOrigin_MAX }

    export enum ESpectatorScreenMode {
        Disabled,
        SingleEyeLetterboxed,
        Undistorted,
        Distorted,
        SingleEye,
        SingleEyeCroppedToFill,
        Texture,
        TexturePlusEye,
        ESpectatorScreenMode_MAX
    }

    export enum EOrientPositionSelector { Orientation, Position, OrientationAndPosition, EOrientPositionSelector_MAX }

    export enum EXRVisualType { Controller, Hand, EXRVisualType_MAX }

    export enum ETrackingStatus { NotTracked, InertialOnly, Tracked, ETrackingStatus_MAX }

    export class XRMotionControllerData {
        constructor();
        constructor(bValid: boolean, DeviceName: string, ApplicationInstanceID: Guid, DeviceVisualType: EXRVisualType, HandIndex: EControllerHand, TrackingStatus: ETrackingStatus, GripPosition: Vector, GripRotation: Quat, AimPosition: Vector, AimRotation: Quat, HandKeyPositions: TArray<Vector>, HandKeyRotations: TArray<Quat>, HandKeyRadii: TArray<number>, bIsGrasped: boolean);

        bValid: boolean;
        DeviceName: string;
        ApplicationInstanceID: Guid;
        DeviceVisualType: EXRVisualType;
        HandIndex: EControllerHand;
        TrackingStatus: ETrackingStatus;
        GripPosition: Vector;
        GripRotation: Quat;
        AimPosition: Vector;
        AimRotation: Quat;
        HandKeyPositions: TArray<Vector>;
        HandKeyRotations: TArray<Quat>;
        HandKeyRadii: TArray<number>;
        bIsGrasped: boolean;

        static StaticClass(): Class;
    }

    export enum EHMDWornState { Unknown, Worn, NotWorn, EHMDWornState_MAX }

    export class XRHMDData {
        constructor();
        constructor(bValid: boolean, DeviceName: string, ApplicationInstanceID: Guid, TrackingStatus: ETrackingStatus, Position: Vector, Rotation: Quat);

        bValid: boolean;
        DeviceName: string;
        ApplicationInstanceID: Guid;
        TrackingStatus: ETrackingStatus;
        Position: Vector;
        Rotation: Quat;

        static StaticClass(): Class;
    }

    export enum EXRTrackedDeviceType {
        HeadMountedDisplay,
        Controller,
        TrackingReference,
        Other,
        Invalid,
        Any,
        EXRTrackedDeviceType_MAX
    }

    export enum EXRDeviceConnectionResult {
        NoTrackingSystem,
        FeatureNotSupported,
        NoValidViewport,
        MiscFailure,
        Success,
        EXRDeviceConnectionResult_MAX
    }

    export enum ESpatialInputGestureAxis {
        None,
        Manipulation,
        Navigation,
        NavigationRails,
        ESpatialInputGestureAxis_MAX
    }

    export class XRGestureConfig {
        constructor();
        constructor(bTap: boolean, bHold: boolean, AxisGesture: ESpatialInputGestureAxis, bNavigationAxisX: boolean, bNavigationAxisY: boolean, bNavigationAxisZ: boolean);

        bTap: boolean;
        bHold: boolean;
        AxisGesture: ESpatialInputGestureAxis;
        bNavigationAxisX: boolean;
        bNavigationAxisY: boolean;
        bNavigationAxisZ: boolean;

        static StaticClass(): Class;
    }

    export class HeadMountedDisplayFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: Transform): void;

        static ClearXRTimedInputActionDelegate(ActionPath: string): void;

        static ConfigureGestures(GestureConfig: XRGestureConfig): boolean;

        static ConnectRemoteXRDevice(IpAddress: string, BitRate: number): EXRDeviceConnectionResult;

        static DisconnectRemoteXRDevice(): void;

        static EnableHMD(bEnable: boolean): boolean;

        static EnableLowPersistenceMode(bEnable: boolean): void;

        static EnumerateTrackedDevices(SystemId?: string /* = "None" */, DeviceType?: EXRTrackedDeviceType /* = Any */): TArray<XRDeviceId>;

        static GetControllerTransformForTime(WorldContext: $Nullable<Object>, ControllerIndex: number, MotionSource: string, Time: Timespan, bTimeWasUsed: $Ref<boolean>, Orientation: $Ref<Rotator>, Position: $Ref<Vector>, bProvidedLinearVelocity: $Ref<boolean>, LinearVelocity: $Ref<Vector>, bProvidedAngularVelocity: $Ref<boolean>, AngularVelocityRadPerSec: $Ref<Vector>): boolean;

        static GetDevicePose(XRDeviceId: XRDeviceId, bIsTracked: $Ref<boolean>, Orientation: $Ref<Rotator>, bHasPositionalTracking: $Ref<boolean>, Position: $Ref<Vector>): void;

        static GetDeviceWorldPose(WorldContext: $Nullable<Object>, XRDeviceId: XRDeviceId, bIsTracked: $Ref<boolean>, Orientation: $Ref<Rotator>, bHasPositionalTracking: $Ref<boolean>, Position: $Ref<Vector>): void;

        static GetHMDData(WorldContext: $Nullable<Object>, HMDData: $Ref<XRHMDData>): void;

        static GetHMDDeviceName(): string;

        static GetHMDWornState(): EHMDWornState;

        static GetMotionControllerData(WorldContext: $Nullable<Object>, Hand: EControllerHand, MotionControllerData: $Ref<XRMotionControllerData>): void;

        static GetNumOfTrackingSensors(): number;

        static GetOrientationAndPosition(DeviceRotation: $Ref<Rotator>, DevicePosition: $Ref<Vector>): void;

        static GetPixelDensity(): number;

        static GetPositionalTrackingCameraParameters(CameraOrigin: $Ref<Vector>, CameraRotation: $Ref<Rotator>, HFOV: $Ref<number>, VFOV: $Ref<number>, CameraDistance: $Ref<number>, NearPlane: $Ref<number>, FarPlane: $Ref<number>): void;

        static GetScreenPercentage(): number;

        static GetTrackingOrigin(): EHMDTrackingOrigin;

        static GetTrackingSensorParameters(Origin: $Ref<Vector>, Rotation: $Ref<Rotator>, LeftFOV: $Ref<number>, RightFOV: $Ref<number>, TopFOV: $Ref<number>, BottomFOV: $Ref<number>, Distance: $Ref<number>, NearPlane: $Ref<number>, FarPlane: $Ref<number>, IsActive: $Ref<boolean>, Index?: number /* = 0 */): void;

        static GetTrackingToWorldTransform(WorldContext: $Nullable<Object>): Transform;

        static GetVersionString(): string;

        static GetVRFocusState(bUseFocus: $Ref<boolean>, bHasFocus: $Ref<boolean>): void;

        static GetWorldToMetersScale(WorldContext: $Nullable<Object>): number;

        static GetXRSystemFlags(): number;

        static HasValidTrackingPosition(): boolean;

        static IsDeviceTracking(XRDeviceId: XRDeviceId): boolean;

        static IsHeadMountedDisplayConnected(): boolean;

        static IsHeadMountedDisplayEnabled(): boolean;

        static IsInLowPersistenceMode(): boolean;

        static IsSpectatorScreenModeControllable(): boolean;

        static ResetOrientationAndPosition(Yaw?: number /* = 0.000000 */, Options?: EOrientPositionSelector /* = OrientationAndPosition */): void;

        static SetClippingPlanes(Near: number, Far: number): void;

        static SetSpectatorScreenMode(Mode: ESpectatorScreenMode): void;

        static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D, EyeRectMax: Vector2D, TextureRectMin: Vector2D, TextureRectMax: Vector2D, bDrawEyeFirst?: boolean /* = true */, bClearBlack?: boolean /* = false */, bUseAlpha?: boolean /* = false */): void;

        static SetSpectatorScreenTexture(InTexture: $Nullable<Texture>): void;

        static SetTrackingOrigin(Origin: EHMDTrackingOrigin): void;

        static SetWorldToMetersScale(WorldContext: $Nullable<Object>, NewScale?: number /* = 100.000000 */): void;

        static SetXRDisconnectDelegate(InDisconnectedDelegate: $Delegate<(OutReason: string) => void>): void;

        static SetXRTimedInputActionDelegate(ActionName: string, InDelegate: $Delegate<(Value: number, Time: Timespan) => void>): void;

        static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: Transform): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HeadMountedDisplayFunctionLibrary;

        static Load(InName: string): HeadMountedDisplayFunctionLibrary;
    }

    export class HealthSnapshotBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static LogPerformanceSnapshot(SnapshotTitle: string, bResetStats?: boolean /* = true */): void;

        static StartPerformanceSnapshots(): void;

        static StopPerformanceSnapshots(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HealthSnapshotBlueprintLibrary;

        static Load(InName: string): HealthSnapshotBlueprintLibrary;
    }

    export class HierarchicalLODSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bForceSettingsInAllMaps: boolean;
        bSaveLODActorsToHLODPackages: boolean;
        DefaultSetup: TSoftClassPtr<HierarchicalLODSetup>;
        DirectoriesForHLODCommandlet: TArray<DirectoryPath>;
        MapsToBuild: TArray<FilePath>;
        bInvalidateHLODClusters: boolean;
        bDeleteHLODAssets: boolean;
        BaseMaterial: TSoftObjectPtr<MaterialInterface>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HierarchicalLODSettings;

        static Load(InName: string): HierarchicalLODSettings;
    }

    export class HierarchicalLODSetup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HierarchicalLODSetup: TArray<HierarchicalSimplification>;
        OverrideBaseMaterial: TSoftObjectPtr<MaterialInterface>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HierarchicalLODSetup;

        static Load(InName: string): HierarchicalLODSetup;
    }

    export class HierarchicalLODVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIncludeOverlappingActors: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HierarchicalLODVolume;

        static Load(InName: string): HierarchicalLODVolume;
    }

    export class HLODEngineSubsystem extends EngineSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HLODEngineSubsystem;

        static Load(InName: string): HLODEngineSubsystem;
    }

    export class HLODISMComponentDesc {
        constructor();
        constructor(StaticMesh: StaticMesh, Material: MaterialInterface, Instances: TArray<Transform>);

        StaticMesh: StaticMesh;
        Material: MaterialInterface;
        Instances: TArray<Transform>;

        static StaticClass(): Class;
    }

    export class HLODProxyDesc extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SubActors: TArray<string>;
        StaticMesh: StaticMesh;
        ISMComponentsDesc: TArray<HLODISMComponentDesc>;
        LODDrawDistance: number;
        bOverrideMaterialMergeSettings: boolean;
        MaterialSettings: MaterialProxySettings;
        bOverrideTransitionScreenSize: boolean;
        TransitionScreenSize: number;
        bOverrideScreenSize: boolean;
        ScreenSize: number;
        Key: string;
        LODLevel: number;
        LODActorTag: string;
        Location: Vector;
        SubHLODDescs: TArray<TSoftObjectPtr<HLODProxyDesc>>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HLODProxyDesc;

        static Load(InName: string): HLODProxyDesc;
    }

    export class LODActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StaticMeshComponent: StaticMeshComponent;
        ImpostersStaticMeshComponents: TMap<MaterialInterface, InstancedStaticMeshComponent>;
        Proxy: HLODProxy;
        Key: string;
        LODDrawDistance: number;
        LODLevel: number;
        SubActors: TArray<Actor>;
        CachedNumHLODLevels: number;
        NumTrianglesInSubActors: number;
        NumTrianglesInMergedMesh: number;
        bOverrideMaterialMergeSettings: boolean;
        MaterialSettings: MaterialProxySettings;
        bOverrideTransitionScreenSize: boolean;
        TransitionScreenSize: number;
        bOverrideScreenSize: boolean;
        ScreenSize: number;
        LODActorTag: string;
        bBuiltFromHLODDesc: boolean;
        ProxyDesc: HLODProxyDesc;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LODActor;

        static Load(InName: string): LODActor;
    }

    export class HLODProxyMesh {
        constructor();
        constructor(LODActor: TLazyObjectPtr<LODActor>, StaticMesh: StaticMesh, Key: string);

        LODActor: TLazyObjectPtr<LODActor>;
        StaticMesh: StaticMesh;
        Key: string;

        static StaticClass(): Class;
    }

    export class HLODProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwningMap: TSoftObjectPtr<World>;
        ProxyMeshes: TArray<HLODProxyMesh>;
        HLODActors: TMap<HLODProxyDesc, HLODProxyMesh>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HLODProxy;

        static Load(InName: string): HLODProxy;
    }

    export class HorizontalBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        Size: SlateChildSize;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetSize(InSize: SlateChildSize): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HorizontalBoxSlot;

        static Load(InName: string): HorizontalBoxSlot;
    }

    export class HorizontalBox extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddChildToHorizontalBox(Content: $Nullable<Widget>): HorizontalBoxSlot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HorizontalBox;

        static Load(InName: string): HorizontalBox;
    }

    export class HudSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bShowHUD: boolean;
        DebugDisplay: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): HudSettings;

        static Load(InName: string): HudSettings;
    }

    export class SlateTextureAtlasInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateTextureAtlasInterface;

        static Load(InName: string): SlateTextureAtlasInterface;
    }

    export class Image extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Image: SlateBrushAsset;
        Brush: SlateBrush;
        BrushDelegate: $Delegate<() => SlateBrush>;
        ColorAndOpacity: LinearColor;
        ColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        bFlipForRightToLeftFlowDirection: boolean;
        OnMouseButtonDownEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;

        GetDynamicMaterial(): MaterialInstanceDynamic;

        SetBrush(InBrush: SlateBrush): void;

        SetBrushFromAsset(Asset: $Nullable<SlateBrushAsset>): void;

        SetBrushFromAtlasInterface(AtlasRegion: SlateTextureAtlasInterface, bMatchSize?: boolean /* = false */): void;

        SetBrushFromMaterial(Material: $Nullable<MaterialInterface>): void;

        SetBrushFromSoftMaterial(SoftMaterial: TSoftObjectPtr<MaterialInterface>): void;

        SetBrushFromSoftTexture(SoftTexture: TSoftObjectPtr<Texture2D>, bMatchSize?: boolean /* = false */): void;

        SetBrushFromTexture(Texture: $Nullable<Texture2D>, bMatchSize?: boolean /* = false */): void;

        SetBrushFromTextureDynamic(Texture: $Nullable<Texture2DDynamic>, bMatchSize?: boolean /* = false */): void;

        SetBrushResourceObject(ResourceObject: $Nullable<Object>): void;

        SetBrushSize(DesiredSize: Vector2D): void;

        SetBrushTintColor(TintColor: SlateColor): void;

        SetColorAndOpacity(InColorAndOpacity: LinearColor): void;

        SetOpacity(InOpacity: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Image;

        static Load(InName: string): Image;
    }

    export class ImageSequenceProtocol_BMP extends ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_BMP;

        static Load(InName: string): ImageSequenceProtocol_BMP;
    }

    export class ImageSequenceProtocol_EXR extends ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCompressed: boolean;
        CaptureGamut: EHDRCaptureGamut;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_EXR;

        static Load(InName: string): ImageSequenceProtocol_EXR;
    }

    export class ImageSequenceProtocol_JPG extends CompressedImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_JPG;

        static Load(InName: string): ImageSequenceProtocol_JPG;
    }

    export class ImageSequenceProtocol_PNG extends CompressedImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_PNG;

        static Load(InName: string): ImageSequenceProtocol_PNG;
    }

    export enum EDesiredImageFormat { PNG, JPG, BMP, EXR, EDesiredImageFormat_MAX }

    export class ImageWriteOptions {
        constructor();
        constructor(Format: EDesiredImageFormat, OnComplete: $Delegate<(bSuccess: boolean) => void>, CompressionQuality: number, bOverwriteFile: boolean, bAsync: boolean);

        Format: EDesiredImageFormat;
        OnComplete: $Delegate<(bSuccess: boolean) => void>;
        CompressionQuality: number;
        bOverwriteFile: boolean;
        bAsync: boolean;

        static StaticClass(): Class;
    }

    export class ImageWriteBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ExportToDisk(Texture: $Nullable<Texture>, Filename: string, Options: ImageWriteOptions): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImageWriteBlueprintLibrary;

        static Load(InName: string): ImageWriteBlueprintLibrary;
    }

    export enum EImportanceWeight { Luminance, Red, Green, Blue, Alpha, EImportanceWeight_MAX }

    export class ImportanceTexture {
        constructor();
        constructor(Size: IntPoint, NumMips: number, MarginalCDF: TArray<number>, ConditionalCDF: TArray<number>, TextureData: TArray<Color>, Texture: TWeakObjectPtr<Texture2D>, Weighting: EImportanceWeight);

        Size: IntPoint;
        NumMips: number;
        MarginalCDF: TArray<number>;
        ConditionalCDF: TArray<number>;
        TextureData: TArray<Color>;
        Texture: TWeakObjectPtr<Texture2D>;
        Weighting: EImportanceWeight;

        static StaticClass(): Class;
    }

    export class ImportanceSamplingLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static BreakImportanceTexture(ImportanceTexture: ImportanceTexture, Texture: $Ref<Texture2D>, WeightingFunc: $Ref<EImportanceWeight>): void;

        static ImportanceSample(Texture: ImportanceTexture, Rand: Vector2D, Samples: number, Intensity: number, SamplePosition: $Ref<Vector2D>, SampleColor: $Ref<LinearColor>, SampleIntensity: $Ref<number>, SampleSize: $Ref<number>): void;

        static MakeImportanceTexture(Texture: $Nullable<Texture2D>, WeightingFunc: EImportanceWeight): ImportanceTexture;

        static NextSobolCell2D(Index: number, NumCells?: number /* = 1 */, PreviousValue?: Vector2D /* = (X=0.000,Y=0.000) */): Vector2D;

        static NextSobolCell3D(Index: number, NumCells?: number /* = 1 */, PreviousValue?: Vector /* = 0.000000,0.000000,0.000000 */): Vector;

        static NextSobolFloat(Index: number, Dimension: number, PreviousValue: number): number;

        static RandomSobolCell2D(Index: number, NumCells?: number /* = 1 */, Cell?: Vector2D /* = (X=0.000,Y=0.000) */, Seed?: Vector2D /* = (X=0.000,Y=0.000) */): Vector2D;

        static RandomSobolCell3D(Index: number, NumCells?: number /* = 1 */, Cell?: Vector /* = 0.000000,0.000000,0.000000 */, Seed?: Vector /* = 0.000000,0.000000,0.000000 */): Vector;

        static RandomSobolFloat(Index: number, Dimension: number, Seed: number): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImportanceSamplingLibrary;

        static Load(InName: string): ImportanceSamplingLibrary;
    }

    export class ImportantToggleSettingInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImportantToggleSettingInterface;

        static Load(InName: string): ImportantToggleSettingInterface;
    }

    export class ImportAssetsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GlobalImportData: AutomatedAssetImportData;
        ImportDataList: TArray<AutomatedAssetImportData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImportAssetsCommandlet;

        static Load(InName: string): ImportAssetsCommandlet;
    }

    export class ImportDialogueScriptCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImportDialogueScriptCommandlet;

        static Load(InName: string): ImportDialogueScriptCommandlet;
    }

    export class ImportLocalizedDialogueCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImportLocalizedDialogueCommandlet;

        static Load(InName: string): ImportLocalizedDialogueCommandlet;
    }

    export class ImportSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnAssetPreImport_BP: $MulticastDelegate<(InFactory: $Nullable<Factory>, InClass: $Nullable<Class>, InParent: $Nullable<Object>, Name: string, Type: string) => void>;
        OnAssetPostImport_BP: $MulticastDelegate<(InFactory: $Nullable<Factory>, InCreatedObject: $Nullable<Object>) => void>;
        OnAssetReimport_BP: $MulticastDelegate<(InCreatedObject: $Nullable<Object>) => void>;
        OnAssetPostLODImport_BP: $MulticastDelegate<(InObject: $Nullable<Object>, InLODIndex: number) => void>;

        OnAssetPostImport_Dyn__DelegateSignature(InFactory: $Nullable<Factory>, InCreatedObject: $Nullable<Object>): void;

        OnAssetPostLODImport_Dyn__DelegateSignature(InObject: $Nullable<Object>, InLODIndex: number): void;

        OnAssetPreImport_Dyn__DelegateSignature(InFactory: $Nullable<Factory>, InClass: $Nullable<Class>, InParent: $Nullable<Object>, Name: string, Type: string): void;

        OnAssetReimport_Dyn__DelegateSignature(InCreatedObject: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ImportSubsystem;

        static Load(InName: string): ImportSubsystem;
    }

    export enum EInAppPurchaseState {
        Unknown,
        Success,
        Failed,
        Cancelled,
        Invalid,
        NotAllowed,
        Restored,
        AlreadyOwned,
        EInAppPurchaseState_MAX
    }

    export class InAppPurchaseProductInfo {
        constructor();
        constructor(Identifier: string, TransactionIdentifier: string, DisplayName: string, DisplayDescription: string, DisplayPrice: string, RawPrice: number, CurrencyCode: string, CurrencySymbol: string, DecimalSeparator: string, GroupingSeparator: string, ReceiptData: string);

        Identifier: string;
        TransactionIdentifier: string;
        DisplayName: string;
        DisplayDescription: string;
        DisplayPrice: string;
        RawPrice: number;
        CurrencyCode: string;
        CurrencySymbol: string;
        DecimalSeparator: string;
        GroupingSeparator: string;
        ReceiptData: string;

        static StaticClass(): Class;
    }

    export class InAppPurchaseProductRequest {
        constructor();
        constructor(ProductIdentifier: string, bIsConsumable: boolean);

        ProductIdentifier: string;
        bIsConsumable: boolean;

        static StaticClass(): Class;
    }

    export class InAppPurchaseCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(PurchaseStatus: EInAppPurchaseState, InAppPurchaseReceipts: InAppPurchaseProductInfo) => void>;
        OnFailure: $MulticastDelegate<(PurchaseStatus: EInAppPurchaseState, InAppPurchaseReceipts: InAppPurchaseProductInfo) => void>;

        static CreateProxyObjectForInAppPurchase(PlayerController: $Nullable<PlayerController>, ProductRequest: InAppPurchaseProductRequest): InAppPurchaseCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InAppPurchaseCallbackProxy;

        static Load(InName: string): InAppPurchaseCallbackProxy;
    }

    export enum EInAppPurchaseStatus {
        Invalid,
        Failed,
        Deferred,
        Canceled,
        Purchased,
        Restored,
        EInAppPurchaseStatus_MAX
    }

    export class InAppPurchaseReceiptInfo2 {
        constructor();
        constructor(ItemName: string, ItemId: string, ValidationInfo: string);

        ItemName: string;
        ItemId: string;
        ValidationInfo: string;

        static StaticClass(): Class;
    }

    export class InAppPurchaseProductRequest2 {
        constructor();
        constructor(ProductIdentifier: string, bIsConsumable: boolean);

        ProductIdentifier: string;
        bIsConsumable: boolean;

        static StaticClass(): Class;
    }

    export class InAppPurchaseCallbackProxy2 extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseReceipts: TArray<InAppPurchaseReceiptInfo2>) => void>;
        OnFailure: $MulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseReceipts: TArray<InAppPurchaseReceiptInfo2>) => void>;

        static CreateProxyObjectForInAppPurchase(PlayerController: $Nullable<PlayerController>, ProductRequest: InAppPurchaseProductRequest2): InAppPurchaseCallbackProxy2;

        static CreateProxyObjectForInAppPurchaseQueryOwned(PlayerController: $Nullable<PlayerController>): InAppPurchaseCallbackProxy2;

        static CreateProxyObjectForInAppPurchaseUnprocessedPurchases(PlayerController: $Nullable<PlayerController>): InAppPurchaseCallbackProxy2;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InAppPurchaseCallbackProxy2;

        static Load(InName: string): InAppPurchaseCallbackProxy2;
    }

    export class InAppPurchaseQueryCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(InAppPurchaseInformation: TArray<InAppPurchaseProductInfo>) => void>;
        OnFailure: $MulticastDelegate<(InAppPurchaseInformation: TArray<InAppPurchaseProductInfo>) => void>;

        static CreateProxyObjectForInAppPurchaseQuery(PlayerController: $Nullable<PlayerController>, ProductIdentifiers: TArray<string>): InAppPurchaseQueryCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InAppPurchaseQueryCallbackProxy;

        static Load(InName: string): InAppPurchaseQueryCallbackProxy;
    }

    export enum EOnlineProxyStoreOfferDiscountType {
        NotOnSale,
        Percentage,
        DiscountAmount,
        PayAmount,
        EOnlineProxyStoreOfferDiscountType_MAX
    }

    export class OnlineProxyStoreOffer {
        constructor();
        constructor(OfferId: string, Title: string, Description: string, LongDescription: string, RegularPriceText: string, RegularPrice: number, PriceText: string, NumericPrice: number, CurrencyCode: string, ReleaseDate: DateTime, ExpirationDate: DateTime, DiscountType: EOnlineProxyStoreOfferDiscountType, DynamicFields: TMap<string, string>);

        OfferId: string;
        Title: string;
        Description: string;
        LongDescription: string;
        RegularPriceText: string;
        RegularPrice: number;
        PriceText: string;
        NumericPrice: number;
        CurrencyCode: string;
        ReleaseDate: DateTime;
        ExpirationDate: DateTime;
        DiscountType: EOnlineProxyStoreOfferDiscountType;
        DynamicFields: TMap<string, string>;

        static StaticClass(): Class;
    }

    export class InAppPurchaseQueryCallbackProxy2 extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(InAppOfferInformation: TArray<OnlineProxyStoreOffer>) => void>;
        OnFailure: $MulticastDelegate<(InAppOfferInformation: TArray<OnlineProxyStoreOffer>) => void>;

        static CreateProxyObjectForInAppPurchaseQuery(PlayerController: $Nullable<PlayerController>, ProductIdentifiers: TArray<string>): InAppPurchaseQueryCallbackProxy2;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InAppPurchaseQueryCallbackProxy2;

        static Load(InName: string): InAppPurchaseQueryCallbackProxy2;
    }

    export class InAppPurchaseRestoreInfo {
        constructor();
        constructor(Identifier: string, ReceiptData: string, TransactionIdentifier: string);

        Identifier: string;
        ReceiptData: string;
        TransactionIdentifier: string;

        static StaticClass(): Class;
    }

    export class InAppPurchaseRestoreCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(CompletionStatus: EInAppPurchaseState, InAppRestorePurchaseInformation: TArray<InAppPurchaseRestoreInfo>) => void>;
        OnFailure: $MulticastDelegate<(CompletionStatus: EInAppPurchaseState, InAppRestorePurchaseInformation: TArray<InAppPurchaseRestoreInfo>) => void>;

        static CreateProxyObjectForInAppPurchaseRestore(ConsumableProductFlags: TArray<InAppPurchaseProductRequest>, PlayerController: $Nullable<PlayerController>): InAppPurchaseRestoreCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InAppPurchaseRestoreCallbackProxy;

        static Load(InName: string): InAppPurchaseRestoreCallbackProxy;
    }

    export class InAppPurchaseRestoreInfo2 {
        constructor();
        constructor(ItemName: string, ItemId: string, ValidationInfo: string);

        ItemName: string;
        ItemId: string;
        ValidationInfo: string;

        static StaticClass(): Class;
    }

    export class InAppPurchaseRestoreCallbackProxy2 extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseRestoreInfo: TArray<InAppPurchaseRestoreInfo2>) => void>;
        OnFailure: $MulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseRestoreInfo: TArray<InAppPurchaseRestoreInfo2>) => void>;

        static CreateProxyObjectForInAppPurchaseRestore(ConsumableProductFlags: TArray<InAppPurchaseProductRequest2>, PlayerController: $Nullable<PlayerController>): InAppPurchaseRestoreCallbackProxy2;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InAppPurchaseRestoreCallbackProxy2;

        static Load(InName: string): InAppPurchaseRestoreCallbackProxy2;
    }

    export class InGameAdManager extends PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bShouldPauseWhileAdOpen: boolean;
        ClickedBannerDelegates: TArray<$Delegate<() => void>>;
        ClosedAdDelegates: TArray<$Delegate<() => void>>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InGameAdManager;

        static Load(InName: string): InGameAdManager;
    }

    export class InputDelegateBinding extends DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputDelegateBinding;

        static Load(InName: string): InputDelegateBinding;
    }

    export class BlueprintInputDelegateBinding {
        constructor();
        constructor(bConsumeInput: boolean, bExecuteWhenPaused: boolean, bOverrideParentBinding: boolean);

        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;

        static StaticClass(): Class;
    }

    export class BlueprintInputActionDelegateBinding extends BlueprintInputDelegateBinding {
        constructor();
        constructor(InputActionName: string, InputKeyEvent: EInputEvent, FunctionNameToBind: string);

        InputActionName: string;
        InputKeyEvent: EInputEvent;
        FunctionNameToBind: string;

        static StaticClass(): Class;
    }

    export class InputActionDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputActionDelegateBindings: TArray<BlueprintInputActionDelegateBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputActionDelegateBinding;

        static Load(InName: string): InputActionDelegateBinding;
    }

    export class BlueprintInputAxisDelegateBinding extends BlueprintInputDelegateBinding {
        constructor();
        constructor(InputAxisName: string, FunctionNameToBind: string);

        InputAxisName: string;
        FunctionNameToBind: string;

        static StaticClass(): Class;
    }

    export class InputAxisDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputAxisDelegateBindings: TArray<BlueprintInputAxisDelegateBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputAxisDelegateBinding;

        static Load(InName: string): InputAxisDelegateBinding;
    }

    export class BlueprintInputAxisKeyDelegateBinding extends BlueprintInputDelegateBinding {
        constructor();
        constructor(AxisKey: Key, FunctionNameToBind: string);

        AxisKey: Key;
        FunctionNameToBind: string;

        static StaticClass(): Class;
    }

    export class InputAxisKeyDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputAxisKeyDelegateBindings: TArray<BlueprintInputAxisKeyDelegateBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputAxisKeyDelegateBinding;

        static Load(InName: string): InputAxisKeyDelegateBinding;
    }

    export class InputBehaviorSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputBehaviorSource;

        static Load(InName: string): InputBehaviorSource;
    }

    export class InputCoreTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputCoreTypes;

        static Load(InName: string): InputCoreTypes;
    }

    export class SlateBrushWithGuid extends SlateBrush {
        constructor();
        constructor(Guid: string);

        Guid: string;

        static StaticClass(): Class;
    }

    export class InputEditorSettings extends MWEdToolBarSettingsBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssertStr: SlateBrushWithGuid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputEditorSettings;

        static Load(InName: string): InputEditorSettings;
    }

    export class InputChord {
        constructor();
        constructor(Key: Key, bShift: boolean, bCtrl: boolean, bAlt: boolean, bCmd: boolean);

        Key: Key;
        bShift: boolean;
        bCtrl: boolean;
        bAlt: boolean;
        bCmd: boolean;

        static StaticClass(): Class;
    }

    export class BlueprintInputKeyDelegateBinding extends BlueprintInputDelegateBinding {
        constructor();
        constructor(InputChord: InputChord, InputKeyEvent: EInputEvent, FunctionNameToBind: string);

        InputChord: InputChord;
        InputKeyEvent: EInputEvent;
        FunctionNameToBind: string;

        static StaticClass(): Class;
    }

    export class InputKeyDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputKeyDelegateBindings: TArray<BlueprintInputKeyDelegateBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputKeyDelegateBinding;

        static Load(InName: string): InputKeyDelegateBinding;
    }

    export class TextBlockStyle extends SlateWidgetStyle {
        constructor();
        constructor(Font: SlateFontInfo, ColorAndOpacity: SlateColor, ShadowOffset: Vector2D, ShadowColorAndOpacity: LinearColor, SelectedBackgroundColor: SlateColor, HighlightColor: LinearColor, HighlightShape: SlateBrush, StrikeBrush: SlateBrush, UnderlineBrush: SlateBrush);

        Font: SlateFontInfo;
        ColorAndOpacity: SlateColor;
        ShadowOffset: Vector2D;
        ShadowColorAndOpacity: LinearColor;
        SelectedBackgroundColor: SlateColor;
        HighlightColor: LinearColor;
        HighlightShape: SlateBrush;
        StrikeBrush: SlateBrush;
        UnderlineBrush: SlateBrush;

        static StaticClass(): Class;
    }

    export class InputKeySelector extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetStyle: ButtonStyle;
        TextStyle: TextBlockStyle;
        SelectedKey: InputChord;
        Font: SlateFontInfo;
        Margin: Margin;
        ColorAndOpacity: LinearColor;
        KeySelectionText: string;
        NoKeySpecifiedText: string;
        bAllowModifierKeys: boolean;
        bAllowGamepadKeys: boolean;
        EscapeKeys: TArray<Key>;
        OnKeySelected: $MulticastDelegate<(SelectedKey: InputChord) => void>;
        OnIsSelectingKeyChanged: $MulticastDelegate<() => void>;

        GetIsSelectingKey(): boolean;

        OnIsSelectingKeyChanged__DelegateSignature(): void;

        OnKeySelected__DelegateSignature(SelectedKey: InputChord): void;

        SetAllowGamepadKeys(bInAllowGamepadKeys: boolean): void;

        SetAllowModifierKeys(bInAllowModifierKeys: boolean): void;

        SetEscapeKeys(InKeys: TArray<Key>): void;

        SetKeySelectionText(InKeySelectionText: string): void;

        SetNoKeySpecifiedText(InNoKeySpecifiedText: string): void;

        SetSelectedKey(InSelectedKey: InputChord): void;

        SetTextBlockVisibility(InVisibility: ESlateVisibility): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputKeySelector;

        static Load(InName: string): InputKeySelector;
    }

    export class InputAxisProperties {
        constructor();
        constructor(DeadZone: number, Sensitivity: number, Exponent: number, bInvert: boolean);

        DeadZone: number;
        Sensitivity: number;
        Exponent: number;
        bInvert: boolean;

        static StaticClass(): Class;
    }

    export class InputAxisConfigEntry {
        constructor();
        constructor(AxisKeyName: string, AxisProperties: InputAxisProperties);

        AxisKeyName: string;
        AxisProperties: InputAxisProperties;

        static StaticClass(): Class;
    }

    export enum EMouseLockMode { DoNotLock, LockOnCapture, LockAlways, LockInFullscreen, EMouseLockMode_MAX }

    export class InputActionKeyMapping {
        constructor();
        constructor(ActionName: string, bShift: boolean, bCtrl: boolean, bAlt: boolean, bCmd: boolean, Key: Key);

        ActionName: string;
        bShift: boolean;
        bCtrl: boolean;
        bAlt: boolean;
        bCmd: boolean;
        Key: Key;

        static StaticClass(): Class;
    }

    export class InputAxisKeyMapping {
        constructor();
        constructor(AxisName: string, Scale: number, Key: Key);

        AxisName: string;
        Scale: number;
        Key: Key;

        static StaticClass(): Class;
    }

    export class InputActionSpeechMapping {
        constructor();
        constructor(ActionName: string, SpeechKeyword: string);

        ActionName: string;
        SpeechKeyword: string;

        static StaticClass(): Class;
    }

    export class InputSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisConfig: TArray<InputAxisConfigEntry>;
        bAltEnterTogglesFullscreen: boolean;
        bF11TogglesFullscreen: boolean;
        bUseMouseForTouch: boolean;
        bEnableMouseSmoothing: boolean;
        bEnableFOVScaling: boolean;
        bCaptureMouseOnLaunch: boolean;
        bDefaultViewportMouseLock: boolean;
        bAlwaysShowTouchInterface: boolean;
        bShowConsoleOnFourFingerTap: boolean;
        bEnableGestureRecognizer: boolean;
        bUseAutocorrect: boolean;
        ExcludedAutocorrectOS: TArray<string>;
        ExcludedAutocorrectCultures: TArray<string>;
        ExcludedAutocorrectDeviceModels: TArray<string>;
        DefaultViewportMouseCaptureMode: EMouseCaptureMode;
        DefaultViewportMouseLockMode: EMouseLockMode;
        FOVScale: number;
        DoubleClickTime: number;
        ActionMappings: TArray<InputActionKeyMapping>;
        AxisMappings: TArray<InputAxisKeyMapping>;
        SpeechMappings: TArray<InputActionSpeechMapping>;
        DefaultPlayerInputClass: TSoftClassPtr<PlayerInput>;
        DefaultInputComponentClass: TSoftClassPtr<InputComponent>;
        DefaultTouchInterface: SoftObjectPath;
        ConsoleKey: Key;
        ConsoleKeys: TArray<Key>;

        AddActionMapping(KeyMapping: InputActionKeyMapping, bForceRebuildKeymaps?: boolean /* = true */): void;

        AddAxisMapping(KeyMapping: InputAxisKeyMapping, bForceRebuildKeymaps?: boolean /* = true */): void;

        ForceRebuildKeymaps(): void;

        GetActionMappingByName(InActionName: string, OutMappings: $Ref<TArray<InputActionKeyMapping>>): void;

        GetActionNames(ActionNames: $Ref<TArray<string>>): void;

        GetAxisMappingByName(InAxisName: string, OutMappings: $Ref<TArray<InputAxisKeyMapping>>): void;

        GetAxisNames(AxisNames: $Ref<TArray<string>>): void;

        RemoveActionMapping(KeyMapping: InputActionKeyMapping, bForceRebuildKeymaps?: boolean /* = true */): void;

        RemoveAxisMapping(KeyMapping: InputAxisKeyMapping, bForceRebuildKeymaps?: boolean /* = true */): void;

        SaveKeyMappings(): void;

        static GetInputSettings(): InputSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputSettings;

        static Load(InName: string): InputSettings;
    }

    export class BlueprintInputTouchDelegateBinding extends BlueprintInputDelegateBinding {
        constructor();
        constructor(InputKeyEvent: EInputEvent, FunctionNameToBind: string);

        InputKeyEvent: EInputEvent;
        FunctionNameToBind: string;

        static StaticClass(): Class;
    }

    export class InputTouchDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputTouchDelegateBindings: TArray<BlueprintInputTouchDelegateBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputTouchDelegateBinding;

        static Load(InName: string): InputTouchDelegateBinding;
    }

    export class InputVectorAxisDelegateBinding extends InputAxisKeyDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InputVectorAxisDelegateBinding;

        static Load(InName: string): InputVectorAxisDelegateBinding;
    }

    export class InstancedFoliageActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InstancedFoliageActor;

        static Load(InName: string): InstancedFoliageActor;
    }

    export class Int16Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Int16Property;

        static Load(InName: string): Int16Property;
    }

    export class Int32Binding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetValue(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Int32Binding;

        static Load(InName: string): Int32Binding;
    }

    export class Int64Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Int64Property;

        static Load(InName: string): Int64Property;
    }

    export class Int8Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Int8Property;

        static Load(InName: string): Int8Property;
    }

    export class IntegerChannelKeyProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Time: FrameNumber;
        Value: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IntegerChannelKeyProxy;

        static Load(InName: string): IntegerChannelKeyProxy;
    }

    export class InteractionMechanic extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractionMechanic;

        static Load(InName: string): InteractionMechanic;
    }

    export enum ENavDataGatheringMode { Default, Instant, Lazy, ENavDataGatheringMode_MAX }

    export class StaticMeshActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StaticMeshComponent: StaticMeshComponent;
        bStaticMeshReplicateMovement: boolean;
        NavigationGeometryGatheringMode: ENavDataGatheringMode;

        OutlineEffectAdd(): void;

        OutlineEffectRemove(): void;

        SetMobility(InMobility: EComponentMobility): void;

        UnifySpecifyPassWithOutlineMaterialType(): void;

        UnifySpecifyPassWithPassMaterialParams(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshActor;

        static Load(InName: string): StaticMeshActor;
    }

    export class InteractiveFoliageActor extends StaticMeshActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CapsuleComponent: CapsuleComponent;
        TouchingActorEntryPosition: Vector;
        FoliageVelocity: Vector;
        FoliageForce: Vector;
        FoliagePosition: Vector;
        FoliageDamageImpulseScale: number;
        FoliageTouchImpulseScale: number;
        FoliageStiffness: number;
        FoliageStiffnessQuadratic: number;
        FoliageDamping: number;
        MaxDamageImpulse: number;
        MaxTouchImpulse: number;
        MaxForce: number;
        Mass: number;

        CapsuleTouched(OverlappedComp: $Nullable<PrimitiveComponent>, Other: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, OverlapInfo: HitResult): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveFoliageActor;

        static Load(InName: string): InteractiveFoliageActor;
    }

    export class InteractiveFoliageComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InteractiveFoliageComponent;

        static Load(InName: string): InteractiveFoliageComponent;
    }

    export class Interface_AssetUserData extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Interface_AssetUserData;

        static Load(InName: string): Interface_AssetUserData;
    }

    export class Interface_CollisionDataProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Interface_CollisionDataProvider;

        static Load(InName: string): Interface_CollisionDataProvider;
    }

    export class Interface_PostProcessVolume extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Interface_PostProcessVolume;

        static Load(InName: string): Interface_PostProcessVolume;
    }

    export class Interface_PreviewMeshProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Interface_PreviewMeshProvider;

        static Load(InName: string): Interface_PreviewMeshProvider;
    }

    export class InterfaceProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterfaceProperty;

        static Load(InName: string): InterfaceProperty;
    }

    export class InternationalizationConditioningCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InternationalizationConditioningCommandlet;

        static Load(InName: string): InternationalizationConditioningCommandlet;
    }

    export class InternationalizationExportCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InternationalizationExportCommandlet;

        static Load(InName: string): InternationalizationExportCommandlet;
    }

    export class InternationalizationExportSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CulturesToGenerate: TArray<string>;
        CommandletClass: string;
        SourcePath: string;
        DestinationPath: string;
        PortableObjectName: string;
        ManifestName: string;
        ArchiveName: string;
        bExportLoc: boolean;
        bImportLoc: boolean;
        bUseCultureDirectory: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InternationalizationExportSettings;

        static Load(InName: string): InternationalizationExportSettings;
    }

    export enum ETimezoneSetting {
        InternationalDateLineWest,
        CoordinatedUniversalTimeNeg11,
        Samoa,
        Hawaii,
        Alaska,
        PacificTime_USCAN,
        BajaCalifornia,
        MountainTime_USCAN,
        Chihuahua_LaPaz_Mazatlan,
        Arizona,
        Saskatchewan,
        CentralAmerica,
        CentralTime_USCAN,
        Guadalajara_MexicoCity_Monterrey,
        EasternTime_USCAN,
        Bogota_Lima_Quito,
        Indiana_US,
        Caracas,
        AtlanticTime_Canada,
        Cuiaba,
        Santiago,
        Georgetown_LaPaz_Manaus_SanJuan,
        Asuncion,
        Newfoundland,
        Brasilia,
        Greenland,
        Montevideo,
        Cayenne_Fortaleza,
        BuenosAires,
        MidAtlantic,
        CoordinatedUniversalTimeNeg02,
        Azores,
        CaboVerdeIs,
        Dublin_Edinburgh_Lisbon_London,
        Monrovia_Reykjavik,
        Casablanca,
        UTC,
        Belgrade_Bratislava_Budapest_Ljubljana_Prague,
        Sarajevo_Skopje_Warsaw_Zagreb,
        Brussels_Copenhagen_Madrid_Paris,
        WestCentralAfrica,
        Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna,
        Windhoek,
        Minsk,
        Cairo,
        Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius,
        Athens_Bucharest,
        Jerusalem,
        Amman,
        Beirut,
        Harare_Pretoria,
        Damascus,
        Istanbul,
        Kuwait_Riyadh,
        Baghdad,
        Nairobi,
        Kaliningrad,
        Tehran,
        Moscow_StPetersburg_Volgograd,
        AbuDhabi_Muscat,
        Baku,
        Yerevan,
        Tbilisi,
        PortLouis,
        Kabul,
        Tashkent,
        Islamabad_Karachi,
        Chennai_Kolkata_Mumbai_NewDelhi,
        SriJayawardenepura,
        Kathmandu,
        Ekaterinburg,
        Astana,
        Dhaka,
        Yangon_Rangoon,
        Novosibirsk,
        Bangkok_Hanoi_Jakarta,
        Krasnoyarsk,
        Beijing_Chongqing_HongKong_Urumqi,
        KualaLumpur_Singapore,
        Taipei,
        Perth,
        Ulaanbaatar,
        Irkutsk,
        Seoul,
        Osaka_Sapporo_Tokyo,
        Darwin,
        Adelaide,
        Yakutsk,
        Canberra_Melbourne_Sydney,
        Brisbane,
        Hobart,
        Guam_PortMoresby,
        Vladivostok,
        SolomonIs_NewCaledonia,
        Magadan,
        Fiji,
        Auckland_Wellington,
        CoordinatedUniversalTime12,
        Nukualofa,
        LocalTime,
        ETimezoneSetting_MAX
    }

    export class InternationalizationSettingsModel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DisplayTimezone: ETimezoneSetting;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InternationalizationSettingsModel;

        static Load(InName: string): InternationalizationSettingsModel;
    }

    export class InterpDataFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpDataFactoryNew;

        static Load(InName: string): InterpDataFactoryNew;
    }

    export class InterpFilter_Classes extends InterpFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ClassToFilterBy: Class;
        TrackClasses: TArray<Class>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpFilter_Classes;

        static Load(InName: string): InterpFilter_Classes;
    }

    export class InterpFilter_Custom extends InterpFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GroupsToInclude: TArray<InterpGroup>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpFilter_Custom;

        static Load(InName: string): InterpFilter_Custom;
    }

    export class CameraPreviewInfo {
        constructor();
        constructor(PawnClass: Class, AnimSeq: AnimSequence, Location: Vector, Rotation: Rotator, PawnInst: Pawn);

        PawnClass: Class;
        AnimSeq: AnimSequence;
        Location: Vector;
        Rotation: Rotator;
        PawnInst: Pawn;

        static StaticClass(): Class;
    }

    export class InterpGroupCamera extends InterpGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraAnimInst: CameraAnim;
        Target: CameraPreviewInfo;
        CompressTolerance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpGroupCamera;

        static Load(InName: string): InterpGroupCamera;
    }

    export class InterpGroupInstCamera extends InterpGroupInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpGroupInstCamera;

        static Load(InName: string): InterpGroupInstCamera;
    }

    export class InterpGroupInstDirector extends InterpGroupInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpGroupInstDirector;

        static Load(InName: string): InterpGroupInstDirector;
    }

    export enum EInterpToBehaviourType { OneShot, OneShot_Reverse, Loop_Reset, PingPong, EInterpToBehaviourType_MAX }

    export class InterpControlPoint {
        constructor();
        constructor(PositionControlPoint: Vector, bPositionIsRelative: boolean);

        PositionControlPoint: Vector;
        bPositionIsRelative: boolean;

        static StaticClass(): Class;
    }

    export class InterpToMovementComponent extends MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Duration: number;
        bPauseOnImpact: boolean;
        bSweep: boolean;
        TeleportType: ETeleportType;
        BehaviourType: EInterpToBehaviourType;
        bCheckIfStillInWorld: boolean;
        bForceSubStepping: boolean;
        OnInterpToReverse: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        OnInterpToStop: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        OnWaitBeginDelegate: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        OnWaitEndDelegate: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        OnResetDelegate: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        ControlPoints: TArray<InterpControlPoint>;

        FinaliseControlPoints(): void;

        OnInterpToResetDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;

        OnInterpToReverseDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;

        OnInterpToStopDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;

        OnInterpToWaitBeginDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;

        OnInterpToWaitEndDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;

        RestartMovement(InitialDirection?: number /* = 1.000000 */): void;

        StopSimulating(HitResult: HitResult): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpToMovementComponent;

        static Load(InName: string): InterpToMovementComponent;
    }

    export class InterpTrackFloatBase extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatTrack: InterpCurveFloat;
        CurveTension: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatBase;

        static Load(InName: string): InterpTrackFloatBase;
    }

    export class AnimControlTrackKey {
        constructor();
        constructor(StartTime: number, AnimSeq: AnimSequence, AnimStartOffset: number, AnimEndOffset: number, AnimPlayRate: number, bLooping: boolean, bReverse: boolean);

        StartTime: number;
        AnimSeq: AnimSequence;
        AnimStartOffset: number;
        AnimEndOffset: number;
        AnimPlayRate: number;
        bLooping: boolean;
        bReverse: boolean;

        static StaticClass(): Class;
    }

    export class InterpTrackAnimControl extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SlotName: string;
        AnimSeqs: TArray<AnimControlTrackKey>;
        bSkipAnimNotifiers: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackAnimControl;

        static Load(InName: string): InterpTrackAnimControl;
    }

    export class InterpTrackVectorBase extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VectorTrack: InterpCurveVector;
        CurveTension: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorBase;

        static Load(InName: string): InterpTrackVectorBase;
    }

    export class InterpTrackAudioMaster extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackAudioMaster;

        static Load(InName: string): InterpTrackAudioMaster;
    }

    export class BoolTrackKey {
        constructor();
        constructor(Time: number, Value: boolean);

        Time: number;
        Value: boolean;

        static StaticClass(): Class;
    }

    export class InterpTrackBoolProp extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoolTrack: TArray<BoolTrackKey>;
        PropertyName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackBoolProp;

        static Load(InName: string): InterpTrackBoolProp;
    }

    export class InterpTrackColorProp extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PropertyName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackColorProp;

        static Load(InName: string): InterpTrackColorProp;
    }

    export class InterpTrackColorScale extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackColorScale;

        static Load(InName: string): InterpTrackColorScale;
    }

    export class DirectorTrackCut {
        constructor();
        constructor(Time: number, TransitionTime: number, TargetCamGroup: string, ShotNumber: number);

        Time: number;
        TransitionTime: number;
        TargetCamGroup: string;
        ShotNumber: number;

        static StaticClass(): Class;
    }

    export class InterpTrackDirector extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CutTrack: TArray<DirectorTrackCut>;
        bSimulateCameraCutsOnClients: boolean;
        PreviewCamera: CameraActor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackDirector;

        static Load(InName: string): InterpTrackDirector;
    }

    export class EventTrackKey {
        constructor();
        constructor(Time: number, EventName: string);

        Time: number;
        EventName: string;

        static StaticClass(): Class;
    }

    export class InterpTrackEvent extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventTrack: TArray<EventTrackKey>;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;
        bUseCustomEventName: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackEvent;

        static Load(InName: string): InterpTrackEvent;
    }

    export class InterpTrackFade extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bPersistFade: boolean;
        bFadeAudio: boolean;
        FadeColor: LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackFade;

        static Load(InName: string): InterpTrackFade;
    }

    export class InterpTrackFloatAnimBPParam extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimBlueprintClass: AnimBlueprintGeneratedClass;
        AnimClass: Class;
        ParamName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatAnimBPParam;

        static Load(InName: string): InterpTrackFloatAnimBPParam;
    }

    export class InterpTrackFloatMaterialParam extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetMaterials: TArray<MaterialInterface>;
        ParamName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatMaterialParam;

        static Load(InName: string): InterpTrackFloatMaterialParam;
    }

    export class InterpTrackFloatParticleParam extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParamName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatParticleParam;

        static Load(InName: string): InterpTrackFloatParticleParam;
    }

    export class InterpTrackFloatProp extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PropertyName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatProp;

        static Load(InName: string): InterpTrackFloatProp;
    }

    export class InterpTrackInstAnimControl extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LastUpdatePosition: number;
        InitPosition: Vector;
        InitRotation: Rotator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstAnimControl;

        static Load(InName: string): InterpTrackInstAnimControl;
    }

    export class InterpTrackInstAudioMaster extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstAudioMaster;

        static Load(InName: string): InterpTrackInstAudioMaster;
    }

    export class InterpTrackInstProperty extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PropertyOuterObjectInst: Object;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstProperty;

        static Load(InName: string): InterpTrackInstProperty;
    }

    export class InterpTrackInstBoolProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ResetBool: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstBoolProp;

        static Load(InName: string): InterpTrackInstBoolProp;
    }

    export class InterpTrackInstColorProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ResetColor: Color;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstColorProp;

        static Load(InName: string): InterpTrackInstColorProp;
    }

    export class InterpTrackInstColorScale extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstColorScale;

        static Load(InName: string): InterpTrackInstColorScale;
    }

    export class InterpTrackInstEvent extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LastUpdatePosition: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstEvent;

        static Load(InName: string): InterpTrackInstEvent;
    }

    export class InterpTrackInstFade extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFade;

        static Load(InName: string): InterpTrackInstFade;
    }

    export class InterpTrackInstFloatAnimBPParam extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimScriptInstance: AnimInstance;
        ResetFloat: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatAnimBPParam;

        static Load(InName: string): InterpTrackInstFloatAnimBPParam;
    }

    export class PrimitiveMaterialRef {
        constructor();
        constructor(Primitive: PrimitiveComponent, Decal: DecalComponent, ElementIndex: number);

        Primitive: PrimitiveComponent;
        Decal: DecalComponent;
        ElementIndex: number;

        static StaticClass(): Class;
    }

    export class InterpTrackInstFloatMaterialParam extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialInstances: TArray<MaterialInstanceDynamic>;
        ResetFloats: TArray<number>;
        PrimitiveMaterialRefs: TArray<PrimitiveMaterialRef>;
        InstancedTrack: InterpTrackFloatMaterialParam;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatMaterialParam;

        static Load(InName: string): InterpTrackInstFloatMaterialParam;
    }

    export class InterpTrackInstFloatParticleParam extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ResetFloat: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatParticleParam;

        static Load(InName: string): InterpTrackInstFloatParticleParam;
    }

    export class InterpTrackInstFloatProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ResetFloat: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatProp;

        static Load(InName: string): InterpTrackInstFloatProp;
    }

    export class InterpTrackInstLinearColorProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ResetColor: LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstLinearColorProp;

        static Load(InName: string): InterpTrackInstLinearColorProp;
    }

    export class InterpTrackInstParticleReplay extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LastUpdatePosition: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstParticleReplay;

        static Load(InName: string): InterpTrackInstParticleReplay;
    }

    export class InterpTrackInstSlomo extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OldTimeDilation: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstSlomo;

        static Load(InName: string): InterpTrackInstSlomo;
    }

    export class InterpTrackInstSound extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LastUpdatePosition: number;
        PlayAudioComp: AudioComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstSound;

        static Load(InName: string): InterpTrackInstSound;
    }

    export enum ETrackToggleAction { ETTA_Off, ETTA_On, ETTA_Toggle, ETTA_Trigger, ETTA_MAX }

    export class InterpTrackInstToggle extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Action: ETrackToggleAction;
        LastUpdatePosition: number;
        bSavedActiveState: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstToggle;

        static Load(InName: string): InterpTrackInstToggle;
    }

    export class InterpTrackVectorMaterialParam extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetMaterials: TArray<MaterialInterface>;
        ParamName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorMaterialParam;

        static Load(InName: string): InterpTrackVectorMaterialParam;
    }

    export class InterpTrackInstVectorMaterialParam extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialInstances: TArray<MaterialInstanceDynamic>;
        ResetVectors: TArray<Vector>;
        PrimitiveMaterialRefs: TArray<PrimitiveMaterialRef>;
        InstancedTrack: InterpTrackVectorMaterialParam;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVectorMaterialParam;

        static Load(InName: string): InterpTrackInstVectorMaterialParam;
    }

    export class InterpTrackInstVectorProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ResetVector: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVectorProp;

        static Load(InName: string): InterpTrackInstVectorProp;
    }

    export enum EVisibilityTrackAction { EVTA_Hide, EVTA_Show, EVTA_Toggle, EVTA_MAX }

    export class InterpTrackInstVisibility extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Action: EVisibilityTrackAction;
        LastUpdatePosition: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVisibility;

        static Load(InName: string): InterpTrackInstVisibility;
    }

    export class InterpCurvePointLinearColor {
        constructor();
        constructor(InVal: number, OutVal: LinearColor, ArriveTangent: LinearColor, LeaveTangent: LinearColor, InterpMode: EInterpCurveMode);

        InVal: number;
        OutVal: LinearColor;
        ArriveTangent: LinearColor;
        LeaveTangent: LinearColor;
        InterpMode: EInterpCurveMode;

        static StaticClass(): Class;
    }

    export class InterpCurveLinearColor {
        constructor();
        constructor(Points: TArray<InterpCurvePointLinearColor>, bIsLooped: boolean, LoopKeyOffset: number);

        Points: TArray<InterpCurvePointLinearColor>;
        bIsLooped: boolean;
        LoopKeyOffset: number;

        static StaticClass(): Class;
    }

    export class InterpTrackLinearColorBase extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LinearColorTrack: InterpCurveLinearColor;
        CurveTension: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackLinearColorBase;

        static Load(InName: string): InterpTrackLinearColorBase;
    }

    export class InterpTrackLinearColorProp extends InterpTrackLinearColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PropertyName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackLinearColorProp;

        static Load(InName: string): InterpTrackLinearColorProp;
    }

    export enum EInterpMoveAxis {
        AXIS_TranslationX,
        AXIS_TranslationY,
        AXIS_TranslationZ,
        AXIS_RotationX,
        AXIS_RotationY,
        AXIS_RotationZ,
        AXIS_MAX
    }

    export class InterpTrackMoveAxis extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MoveAxis: EInterpMoveAxis;
        LookupTrack: InterpLookupTrack;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackMoveAxis;

        static Load(InName: string): InterpTrackMoveAxis;
    }

    export class ParticleReplayTrackKey {
        constructor();
        constructor(Time: number, Duration: number, ClipIDNumber: number);

        Time: number;
        Duration: number;
        ClipIDNumber: number;

        static StaticClass(): Class;
    }

    export class InterpTrackParticleReplay extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TrackKeys: TArray<ParticleReplayTrackKey>;
        bIsCapturingReplay: boolean;
        FixedTimeStep: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackParticleReplay;

        static Load(InName: string): InterpTrackParticleReplay;
    }

    export class InterpTrackSlomo extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackSlomo;

        static Load(InName: string): InterpTrackSlomo;
    }

    export class SoundTrackKey {
        constructor();
        constructor(Time: number, Volume: number, Pitch: number, Sound: SoundBase);

        Time: number;
        Volume: number;
        Pitch: number;
        Sound: SoundBase;

        static StaticClass(): Class;
    }

    export class InterpTrackSound extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sounds: TArray<SoundTrackKey>;
        bPlayOnReverse: boolean;
        bContinueSoundOnMatineeEnd: boolean;
        bSuppressSubtitles: boolean;
        bTreatAsDialogue: boolean;
        bAttach: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackSound;

        static Load(InName: string): InterpTrackSound;
    }

    export class ToggleTrackKey {
        constructor();
        constructor(Time: number, ToggleAction: ETrackToggleAction);

        Time: number;
        ToggleAction: ETrackToggleAction;

        static StaticClass(): Class;
    }

    export class InterpTrackToggle extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ToggleTrack: TArray<ToggleTrackKey>;
        bActivateSystemEachUpdate: boolean;
        bActivateWithJustAttachedFlag: boolean;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackToggle;

        static Load(InName: string): InterpTrackToggle;
    }

    export class InterpTrackVectorProp extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PropertyName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorProp;

        static Load(InName: string): InterpTrackVectorProp;
    }

    export enum EVisibilityTrackCondition { EVTC_Always, EVTC_GoreEnabled, EVTC_GoreDisabled, EVTC_MAX }

    export class VisibilityTrackKey {
        constructor();
        constructor(Time: number, Action: EVisibilityTrackAction, ActiveCondition: EVisibilityTrackCondition);

        Time: number;
        Action: EVisibilityTrackAction;
        ActiveCondition: EVisibilityTrackCondition;

        static StaticClass(): Class;
    }

    export class InterpTrackVisibility extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VisibilityTrack: TArray<VisibilityTrackKey>;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InterpTrackVisibility;

        static Load(InName: string): InterpTrackVisibility;
    }

    export class IntervalGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StateTarget: GizmoTransformChangeStateTarget;
        TransformProxy: TransformProxy;
        ActiveComponents: TArray<PrimitiveComponent>;
        ActiveGizmos: TArray<InteractiveGizmo>;
        AxisYSource: GizmoComponentAxisSource;
        AxisZSource: GizmoComponentAxisSource;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IntervalGizmo;

        static Load(InName: string): IntervalGizmo;
    }

    export class IntervalGizmoActor extends GizmoActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UpIntervalComponent: GizmoLineHandleComponent;
        DownIntervalComponent: GizmoLineHandleComponent;
        ForwardIntervalComponent: GizmoLineHandleComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IntervalGizmoActor;

        static Load(InName: string): IntervalGizmoActor;
    }

    export class IntervalGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IntervalGizmoBuilder;

        static Load(InName: string): IntervalGizmoBuilder;
    }

    export class IntProperty extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IntProperty;

        static Load(InName: string): IntProperty;
    }

    export class IntSerialization extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UnsignedInt16Variable: number;
        UnsignedInt32Variable: number;
        UnsignedInt64Variable: bigint;
        SignedInt8Variable: number;
        SignedInt16Variable: number;
        SignedInt64Variable: bigint;
        UnsignedInt8Variable: number;
        SignedInt32Variable: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IntSerialization;

        static Load(InName: string): IntSerialization;
    }

    export class InvalidationBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCanCache: boolean;
        CacheRelativeTransforms: boolean;

        GetCanCache(): boolean;

        InvalidateCache(): void;

        SetCanCache(CanCache: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): InvalidationBox;

        static Load(InName: string): InvalidationBox;
    }

    export class IoStoreCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IoStoreCommandlet;

        static Load(InName: string): IoStoreCommandlet;
    }

    export class IpConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SocketErrorDisconnectDelay: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IpConnection;

        static Load(InName: string): IpConnection;
    }

    export class IpNetDriver extends NetDriver {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LogPortUnreach: boolean;
        AllowPlayerPortUnreach: boolean;
        MaxPortCountToTry: number;
        ServerDesiredSocketReceiveBufferBytes: number;
        ServerDesiredSocketSendBufferBytes: number;
        ClientDesiredSocketReceiveBufferBytes: number;
        ClientDesiredSocketSendBufferBytes: number;
        MaxSecondsInReceive: number;
        NbPacketsBetweenReceiveTimeTest: number;
        ResolutionConnectionTimeout: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): IpNetDriver;

        static Load(InName: string): IpNetDriver;
    }

    export class JoinSessionCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;

        static JoinSession(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, SearchResult: BlueprintSessionResult): JoinSessionCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): JoinSessionCallbackProxy;

        static Load(InName: string): JoinSessionCallbackProxy;
    }

    export class JSAnimGeneratedClass extends AnimBlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): JSAnimGeneratedClass;

        static Load(InName: string): JSAnimGeneratedClass;
    }

    export class JSGeneratedClass extends BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): JSGeneratedClass;

        static Load(InName: string): JSGeneratedClass;
    }

    export class JSGeneratedFunction extends Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): JSGeneratedFunction;

        static Load(InName: string): JSGeneratedFunction;
    }

    export class JsonUtilitiesDummyObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): JsonUtilitiesDummyObject;

        static Load(InName: string): JsonUtilitiesDummyObject;
    }

    export class DelegateRuntimeBinding {
        constructor();
        constructor(ObjectName: string, PropertyName: string, FunctionName: string, SourcePath: DynamicPropertyPath, Kind: EBindingKind);

        ObjectName: string;
        PropertyName: string;
        FunctionName: string;
        SourcePath: DynamicPropertyPath;
        Kind: EBindingKind;

        static StaticClass(): Class;
    }

    export class WidgetBlueprintGeneratedClass extends BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetTree: WidgetTree;
        bCanCallPreConstruct: boolean;
        bClassRequiresNativeTick: boolean;
        Bindings: TArray<DelegateRuntimeBinding>;
        Animations: TArray<WidgetAnimation>;
        NamedSlots: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintGeneratedClass;

        static Load(InName: string): WidgetBlueprintGeneratedClass;
    }

    export class JSWidgetGeneratedClass extends WidgetBlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): JSWidgetGeneratedClass;

        static Load(InName: string): JSWidgetGeneratedClass;
    }

    export class K2Node_EditablePinBase extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsEditable: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_EditablePinBase;

        static Load(InName: string): K2Node_EditablePinBase;
    }

    export class K2Node_Event extends K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventSignatureName: string;
        EventSignatureClass: Class;
        EventReference: MemberReference;
        bOverrideFunction: boolean;
        bInternalEvent: boolean;
        CustomFunctionName: string;
        FunctionFlags: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Event;

        static Load(InName: string): K2Node_Event;
    }

    export class K2Node_ActorBoundEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelegatePropertyName: string;
        DelegateOwnerClass: Class;
        EventOwner: Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_ActorBoundEvent;

        static Load(InName: string): K2Node_ActorBoundEvent;
    }

    export class K2Node_CallFunction extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsPureFunc: boolean;
        bIsConstFunc: boolean;
        bWantsEnumToExecExpansion: boolean;
        bIsInterfaceCall: boolean;
        bIsFinalFunction: boolean;
        bIsBeadFunction: boolean;
        FunctionReference: MemberReference;
        CallFunctionName: string;
        CallFunctionClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CallFunction;

        static Load(InName: string): K2Node_CallFunction;
    }

    export class K2Node_AddComponent extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bHasExposedVariable: boolean;
        TemplateBlueprint: string;
        TemplateType: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AddComponent;

        static Load(InName: string): K2Node_AddComponent;
    }

    export class K2Node_ConstructObjectFromClass extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_ConstructObjectFromClass;

        static Load(InName: string): K2Node_ConstructObjectFromClass;
    }

    export class K2Node_AddComponentByClass extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AddComponentByClass;

        static Load(InName: string): K2Node_AddComponentByClass;
    }

    export class K2Node_BaseMCDelegate extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelegateReference: MemberReference;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_BaseMCDelegate;

        static Load(InName: string): K2Node_BaseMCDelegate;
    }

    export class K2Node_AddDelegate extends K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AddDelegate;

        static Load(InName: string): K2Node_AddDelegate;
    }

    export class K2Node_AddPinInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AddPinInterface;

        static Load(InName: string): K2Node_AddPinInterface;
    }

    export class K2Node_BaseAsyncTask extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProxyFactoryFunctionName: string;
        ProxyFactoryClass: Class;
        ProxyClass: Class;
        ProxyActivateFunctionName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_BaseAsyncTask;

        static Load(InName: string): K2Node_BaseAsyncTask;
    }

    export class K2Node_AIMoveTo extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AIMoveTo;

        static Load(InName: string): K2Node_AIMoveTo;
    }

    export class K2Node_AnimGetter extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceNode: AnimGraphNode_Base;
        SourceStateNode: AnimStateNodeBase;
        GetterClass: Class;
        SourceAnimBlueprint: AnimBlueprint;
        CachedTitle: string;
        Contexts: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AnimGetter;

        static Load(InName: string): K2Node_AnimGetter;
    }

    export class K2Node_AssignDelegate extends K2Node_AddDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AssignDelegate;

        static Load(InName: string): K2Node_AssignDelegate;
    }

    export class K2Node_AssignmentStatement extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AssignmentStatement;

        static Load(InName: string): K2Node_AssignmentStatement;
    }

    export class K2Node_AsyncAction extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_AsyncAction;

        static Load(InName: string): K2Node_AsyncAction;
    }

    export class K2Node_BitmaskLiteral extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BitflagsEnum: Enum;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_BitmaskLiteral;

        static Load(InName: string): K2Node_BitmaskLiteral;
    }

    export enum ESelfContextInfo { Unspecified, NotSelfContext, ESelfContextInfo_MAX }

    export class K2Node_Variable extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VariableReference: MemberReference;
        SelfContextInfo: ESelfContextInfo;
        VariableSourceClass: Class;
        VariableName: string;
        bSelfContext: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Variable;

        static Load(InName: string): K2Node_Variable;
    }

    export class K2Node_StructOperation extends K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StructType: ScriptStruct;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_StructOperation;

        static Load(InName: string): K2Node_StructOperation;
    }

    export class K2Node_StructMemberGet extends K2Node_StructOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShowPinForProperties: TArray<OptionalPinFromProperty>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_StructMemberGet;

        static Load(InName: string): K2Node_StructMemberGet;
    }

    export class K2Node_BreakStruct extends K2Node_StructMemberGet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bMadeAfterOverridePinRemoval: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_BreakStruct;

        static Load(InName: string): K2Node_BreakStruct;
    }

    export class K2Node_CallArrayFunction extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CallArrayFunction;

        static Load(InName: string): K2Node_CallArrayFunction;
    }

    export class K2Node_CallDataTableFunction extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CallDataTableFunction;

        static Load(InName: string): K2Node_CallDataTableFunction;
    }

    export class K2Node_CallDelegate extends K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CallDelegate;

        static Load(InName: string): K2Node_CallDelegate;
    }

    export class K2Node_CallFunctionOnMember extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MemberVariableToCallOn: MemberReference;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CallFunctionOnMember;

        static Load(InName: string): K2Node_CallFunctionOnMember;
    }

    export class K2Node_CallMaterialParameterCollectionFunction extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CallMaterialParameterCollectionFunction;

        static Load(InName: string): K2Node_CallMaterialParameterCollectionFunction;
    }

    export class K2Node_CallParentFunction extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CallParentFunction;

        static Load(InName: string): K2Node_CallParentFunction;
    }

    export class K2Node_CastByteToEnum extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSafe: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CastByteToEnum;

        static Load(InName: string): K2Node_CastByteToEnum;
    }

    export class K2Node_DynamicCast extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetType: Class;
        bIsPureCast: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_DynamicCast;

        static Load(InName: string): K2Node_DynamicCast;
    }

    export class K2Node_ClassDynamicCast extends K2Node_DynamicCast {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_ClassDynamicCast;

        static Load(InName: string): K2Node_ClassDynamicCast;
    }

    export class K2Node_ClearDelegate extends K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_ClearDelegate;

        static Load(InName: string): K2Node_ClearDelegate;
    }

    export class K2Node_CommutativeAssociativeBinaryOperator extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumAdditionalInputs: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CommutativeAssociativeBinaryOperator;

        static Load(InName: string): K2Node_CommutativeAssociativeBinaryOperator;
    }

    export class K2Node_ComponentBoundEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelegatePropertyName: string;
        DelegateOwnerClass: Class;
        ComponentPropertyName: string;
        DelegatePropertyDisplayName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_ComponentBoundEvent;

        static Load(InName: string): K2Node_ComponentBoundEvent;
    }

    export class KismetUserDeclaredFunctionMetadata {
        constructor();
        constructor(ToolTip: string, Category: string, Keywords: string, CompactNodeTitle: string, InstanceTitleColor: LinearColor, DeprecationMessage: string, bIsDeprecated: boolean, bCallInEditor: boolean, HasLatentFunctions: number);

        ToolTip: string;
        Category: string;
        Keywords: string;
        CompactNodeTitle: string;
        InstanceTitleColor: LinearColor;
        DeprecationMessage: string;
        bIsDeprecated: boolean;
        bCallInEditor: boolean;
        HasLatentFunctions: number;

        static StaticClass(): Class;
    }

    export class K2Node_Tunnel extends K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OutputSourceNode: K2Node_Tunnel;
        InputSinkNode: K2Node_Tunnel;
        bCanHaveInputs: boolean;
        bCanHaveOutputs: boolean;
        MetaData: KismetUserDeclaredFunctionMetadata;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Tunnel;

        static Load(InName: string): K2Node_Tunnel;
    }

    export class K2Node_Composite extends K2Node_Tunnel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoundGraph: EdGraph;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Composite;

        static Load(InName: string): K2Node_Composite;
    }

    export class K2Node_ConvertAsset extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertAsset;

        static Load(InName: string): K2Node_ConvertAsset;
    }

    export class K2Node_Copy extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Copy;

        static Load(InName: string): K2Node_Copy;
    }

    export class K2Node_CreateDelegate extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SelectedFunctionName: string;
        SelectedFunctionGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CreateDelegate;

        static Load(InName: string): K2Node_CreateDelegate;
    }

    export class K2Node_CreateDragDropOperation extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CreateDragDropOperation;

        static Load(InName: string): K2Node_CreateDragDropOperation;
    }

    export class K2Node_CreateWidget extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CreateWidget;

        static Load(InName: string): K2Node_CreateWidget;
    }

    export class K2Node_CustomEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DeprecationMessage: string;
        bIsDeprecated: boolean;
        bCallInEditor: boolean;
        MetaData: KismetUserDeclaredFunctionMetadata;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_CustomEvent;

        static Load(InName: string): K2Node_CustomEvent;
    }

    export class K2Node_DeadClass extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_DeadClass;

        static Load(InName: string): K2Node_DeadClass;
    }

    export class K2Node_DelegateSet extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelegatePropertyName: string;
        DelegatePropertyClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_DelegateSet;

        static Load(InName: string): K2Node_DelegateSet;
    }

    export class K2Node_TemporaryVariable extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VariableType: EdGraphPinType;
        bIsPersistent: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_TemporaryVariable;

        static Load(InName: string): K2Node_TemporaryVariable;
    }

    export class K2Node_DoOnceMultiInput extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumAdditionalInputs: number;
        DataNode: K2Node_TemporaryVariable;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_DoOnceMultiInput;

        static Load(InName: string): K2Node_DoOnceMultiInput;
    }

    export class K2Node_EaseFunction extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EaseFunctionName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_EaseFunction;

        static Load(InName: string): K2Node_EaseFunction;
    }

    export class K2Node_EditorPropertyAccessBase extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_EditorPropertyAccessBase;

        static Load(InName: string): K2Node_EditorPropertyAccessBase;
    }

    export class K2Node_EnumEquality extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_EnumEquality;

        static Load(InName: string): K2Node_EnumEquality;
    }

    export class K2Node_EnumInequality extends K2Node_EnumEquality {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_EnumInequality;

        static Load(InName: string): K2Node_EnumInequality;
    }

    export class K2Node_EnumLiteral extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_EnumLiteral;

        static Load(InName: string): K2Node_EnumLiteral;
    }

    export class K2Node_EventNodeInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_EventNodeInterface;

        static Load(InName: string): K2Node_EventNodeInterface;
    }

    export class K2Node_ExecutionSequence extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_ExecutionSequence;

        static Load(InName: string): K2Node_ExecutionSequence;
    }

    export class K2Node_ForEachElementInEnum extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_ForEachElementInEnum;

        static Load(InName: string): K2Node_ForEachElementInEnum;
    }

    export class K2Node_FormatText extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PinNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_FormatText;

        static Load(InName: string): K2Node_FormatText;
    }

    export class K2Node_FunctionTerminator extends K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FunctionReference: MemberReference;
        SignatureClass: Class;
        SignatureName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionTerminator;

        static Load(InName: string): K2Node_FunctionTerminator;
    }

    export class K2Node_FunctionEntry extends K2Node_FunctionTerminator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CustomGeneratedFunctionName: string;
        MetaData: KismetUserDeclaredFunctionMetadata;
        LocalVariables: TArray<BPVariableDescription>;
        bEnforceConstCorrectness: boolean;
        ExtraFlags: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionEntry;

        static Load(InName: string): K2Node_FunctionEntry;
    }

    export class K2Node_FunctionResult extends K2Node_FunctionTerminator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionResult;

        static Load(InName: string): K2Node_FunctionResult;
    }

    export class K2Node_GameplayCueEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GameplayCueEvent;

        static Load(InName: string): K2Node_GameplayCueEvent;
    }

    export class K2Node_GenericCreateObject extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GenericCreateObject;

        static Load(InName: string): K2Node_GenericCreateObject;
    }

    export class K2Node_GetArrayItem extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bReturnByRefDesired: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetArrayItem;

        static Load(InName: string): K2Node_GetArrayItem;
    }

    export class K2Node_GetClassDefaults extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlueprintSubscribedTo: Blueprint;
        ShowPinForProperties: TArray<OptionalPinFromProperty>;
        bExcludeObjectContainers: boolean;
        bExcludeObjectArrays: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetClassDefaults;

        static Load(InName: string): K2Node_GetClassDefaults;
    }

    export class K2Node_GetDataTableRow extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetDataTableRow;

        static Load(InName: string): K2Node_GetDataTableRow;
    }

    export class K2Node_GetEditorProperty extends K2Node_EditorPropertyAccessBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetEditorProperty;

        static Load(InName: string): K2Node_GetEditorProperty;
    }

    export class K2Node_GetSubsystem extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CustomClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetSubsystem;

        static Load(InName: string): K2Node_GetSubsystem;
    }

    export class K2Node_GetEditorSubsystem extends K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetEditorSubsystem;

        static Load(InName: string): K2Node_GetEditorSubsystem;
    }

    export class K2Node_GetEngineSubsystem extends K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetEngineSubsystem;

        static Load(InName: string): K2Node_GetEngineSubsystem;
    }

    export class K2Node_GetEnumeratorName extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetEnumeratorName;

        static Load(InName: string): K2Node_GetEnumeratorName;
    }

    export class K2Node_GetEnumeratorNameAsString extends K2Node_GetEnumeratorName {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetEnumeratorNameAsString;

        static Load(InName: string): K2Node_GetEnumeratorNameAsString;
    }

    export class K2Node_GetInputAxisKeyValue extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputAxisKey: Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputAxisKeyValue;

        static Load(InName: string): K2Node_GetInputAxisKeyValue;
    }

    export class K2Node_GetInputAxisValue extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputAxisName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputAxisValue;

        static Load(InName: string): K2Node_GetInputAxisValue;
    }

    export class K2Node_GetInputVectorAxisValue extends K2Node_GetInputAxisKeyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputVectorAxisValue;

        static Load(InName: string): K2Node_GetInputVectorAxisValue;
    }

    export class K2Node_GetNumEnumEntries extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetNumEnumEntries;

        static Load(InName: string): K2Node_GetNumEnumEntries;
    }

    export class K2Node_GetSequenceBinding extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceSequence: SoftObjectPath;
        Binding: MovieSceneObjectBindingID;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetSequenceBinding;

        static Load(InName: string): K2Node_GetSequenceBinding;
    }

    export class K2Node_GetSubsystemFromPC extends K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_GetSubsystemFromPC;

        static Load(InName: string): K2Node_GetSubsystemFromPC;
    }

    export class K2Node_IfThenElse extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_IfThenElse;

        static Load(InName: string): K2Node_IfThenElse;
    }

    export class K2Node_InAppPurchase extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchase;

        static Load(InName: string): K2Node_InAppPurchase;
    }

    export class K2Node_InAppPurchase2 extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchase2;

        static Load(InName: string): K2Node_InAppPurchase2;
    }

    export class K2Node_InAppPurchaseQuery extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseQuery;

        static Load(InName: string): K2Node_InAppPurchaseQuery;
    }

    export class K2Node_InAppPurchaseQuery2 extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseQuery2;

        static Load(InName: string): K2Node_InAppPurchaseQuery2;
    }

    export class K2Node_InAppPurchaseQueryOwned2 extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseQueryOwned2;

        static Load(InName: string): K2Node_InAppPurchaseQueryOwned2;
    }

    export class K2Node_InAppPurchaseRestore extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseRestore;

        static Load(InName: string): K2Node_InAppPurchaseRestore;
    }

    export class K2Node_InAppPurchaseRestore2 extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseRestore2;

        static Load(InName: string): K2Node_InAppPurchaseRestore2;
    }

    export class K2Node_InAppPurchaseUnprocessed2 extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseUnprocessed2;

        static Load(InName: string): K2Node_InAppPurchaseUnprocessed2;
    }

    export class K2Node_InputAction extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputActionName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputAction;

        static Load(InName: string): K2Node_InputAction;
    }

    export class K2Node_InputActionEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputActionName: string;
        InputKeyEvent: EInputEvent;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputActionEvent;

        static Load(InName: string): K2Node_InputActionEvent;
    }

    export class K2Node_InputAxisEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputAxisName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputAxisEvent;

        static Load(InName: string): K2Node_InputAxisEvent;
    }

    export class K2Node_InputAxisKeyEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisKey: Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputAxisKeyEvent;

        static Load(InName: string): K2Node_InputAxisKeyEvent;
    }

    export class K2Node_InputKey extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputKey: Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        bControl: boolean;
        bAlt: boolean;
        bShift: boolean;
        bCommand: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputKey;

        static Load(InName: string): K2Node_InputKey;
    }

    export class K2Node_InputKeyEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputChord: InputChord;
        InputKeyEvent: EInputEvent;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputKeyEvent;

        static Load(InName: string): K2Node_InputKeyEvent;
    }

    export class K2Node_InputTouch extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputTouch;

        static Load(InName: string): K2Node_InputTouch;
    }

    export class K2Node_InputTouchEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputKeyEvent: EInputEvent;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputTouchEvent;

        static Load(InName: string): K2Node_InputTouchEvent;
    }

    export class K2Node_InputVectorAxisEvent extends K2Node_InputAxisKeyEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_InputVectorAxisEvent;

        static Load(InName: string): K2Node_InputVectorAxisEvent;
    }

    export class K2Node_Knot extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Knot;

        static Load(InName: string): K2Node_Knot;
    }

    export class K2Node_LatentGameplayTaskCall extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpawnParamPins: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_LatentGameplayTaskCall;

        static Load(InName: string): K2Node_LatentGameplayTaskCall;
    }

    export class K2Node_LatentAbilityCall extends K2Node_LatentGameplayTaskCall {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_LatentAbilityCall;

        static Load(InName: string): K2Node_LatentAbilityCall;
    }

    export class K2Node_LeaderboardFlush extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_LeaderboardFlush;

        static Load(InName: string): K2Node_LeaderboardFlush;
    }

    export class K2Node_LeaderboardQuery extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_LeaderboardQuery;

        static Load(InName: string): K2Node_LeaderboardQuery;
    }

    export class K2Node_Literal extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ObjectRef: Object;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Literal;

        static Load(InName: string): K2Node_Literal;
    }

    export class K2Node_LoadAsset extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_LoadAsset;

        static Load(InName: string): K2Node_LoadAsset;
    }

    export class K2Node_LoadAssetClass extends K2Node_LoadAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_LoadAssetClass;

        static Load(InName: string): K2Node_LoadAssetClass;
    }

    export class K2Node_LocalVariable extends K2Node_TemporaryVariable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CustomVariableName: string;
        VariableTooltip: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_LocalVariable;

        static Load(InName: string): K2Node_LocalVariable;
    }

    export class GraphReference {
        constructor();
        constructor(MacroGraph: EdGraph, GraphBlueprint: Blueprint, GraphGuid: Guid);

        MacroGraph: EdGraph;
        GraphBlueprint: Blueprint;
        GraphGuid: Guid;

        static StaticClass(): Class;
    }

    export class K2Node_MacroInstance extends K2Node_Tunnel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MacroGraph: EdGraph;
        MacroGraphReference: GraphReference;
        ResolvedWildcardType: EdGraphPinType;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MacroInstance;

        static Load(InName: string): K2Node_MacroInstance;
    }

    export class K2Node_MakeContainer extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumInputs: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MakeContainer;

        static Load(InName: string): K2Node_MakeContainer;
    }

    export class K2Node_MakeArray extends K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MakeArray;

        static Load(InName: string): K2Node_MakeArray;
    }

    export class K2Node_MakeMap extends K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MakeMap;

        static Load(InName: string): K2Node_MakeMap;
    }

    export class K2Node_MakeSet extends K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MakeSet;

        static Load(InName: string): K2Node_MakeSet;
    }

    export class K2Node_StructMemberSet extends K2Node_StructOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShowPinForProperties: TArray<OptionalPinFromProperty>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_StructMemberSet;

        static Load(InName: string): K2Node_StructMemberSet;
    }

    export class K2Node_MakeStruct extends K2Node_StructMemberSet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bMadeAfterOverridePinRemoval: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MakeStruct;

        static Load(InName: string): K2Node_MakeStruct;
    }

    export class K2Node_MakeVariable extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VariableType: BPVariableDescription;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MakeVariable;

        static Load(InName: string): K2Node_MakeVariable;
    }

    export class K2Node_MathExpression extends K2Node_Composite {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Expression: string;
        bMadeAfterRotChange: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MathExpression;

        static Load(InName: string): K2Node_MathExpression;
    }

    export class K2Node_MatineeController extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MatineeActor: MatineeActor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MatineeController;

        static Load(InName: string): K2Node_MatineeController;
    }

    export class K2Node_Message extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Message;

        static Load(InName: string): K2Node_Message;
    }

    export class K2Node_MultiGate extends K2Node_ExecutionSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DataNode: K2Node_TemporaryVariable;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_MultiGate;

        static Load(InName: string): K2Node_MultiGate;
    }

    export class K2Node_PlayAnimation extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_PlayAnimation;

        static Load(InName: string): K2Node_PlayAnimation;
    }

    export class K2Node_PlayAnimationTimeRange extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_PlayAnimationTimeRange;

        static Load(InName: string): K2Node_PlayAnimationTimeRange;
    }

    export class K2Node_PlayMontage extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_PlayMontage;

        static Load(InName: string): K2Node_PlayMontage;
    }

    export class K2Node_PureAssignmentStatement extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_PureAssignmentStatement;

        static Load(InName: string): K2Node_PureAssignmentStatement;
    }

    export class K2Node_RemoveDelegate extends K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_RemoveDelegate;

        static Load(InName: string): K2Node_RemoveDelegate;
    }

    export class K2Node_Select extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumOptionPins: number;
        IndexPinType: EdGraphPinType;

        bReconstructNode: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Select;

        static Load(InName: string): K2Node_Select;
    }

    export class K2Node_Self extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Self;

        static Load(InName: string): K2Node_Self;
    }

    export class K2Node_SetEditorProperty extends K2Node_EditorPropertyAccessBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SetEditorProperty;

        static Load(InName: string): K2Node_SetEditorProperty;
    }

    export class K2Node_SetFieldsInStruct extends K2Node_MakeStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SetFieldsInStruct;

        static Load(InName: string): K2Node_SetFieldsInStruct;
    }

    export class K2Node_SetVariableOnPersistentFrame extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SetVariableOnPersistentFrame;

        static Load(InName: string): K2Node_SetVariableOnPersistentFrame;
    }

    export class K2Node_SpawnActor extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SpawnActor;

        static Load(InName: string): K2Node_SpawnActor;
    }

    export class K2Node_SpawnActorFromClass extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SpawnActorFromClass;

        static Load(InName: string): K2Node_SpawnActorFromClass;
    }

    export class K2Node_SwitchEnum extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchEnum;

        static Load(InName: string): K2Node_SwitchEnum;
    }

    export class K2Node_SwitchInteger extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchInteger;

        static Load(InName: string): K2Node_SwitchInteger;
    }

    export class K2Node_SwitchName extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PinNames: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchName;

        static Load(InName: string): K2Node_SwitchName;
    }

    export class K2Node_SwitchString extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PinNames: TArray<string>;
        bIsCaseSensitive: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchString;

        static Load(InName: string): K2Node_SwitchString;
    }

    export class K2Node_Timeline extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TimelineName: string;
        bAutoPlay: boolean;
        TimelineGuid: Guid;
        bLoop: boolean;
        bReplicated: boolean;
        bIgnoreTimeDilation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_Timeline;

        static Load(InName: string): K2Node_Timeline;
    }

    export enum ETransitionGetter {
        AnimationAsset_GetCurrentTime,
        AnimationAsset_GetLength,
        AnimationAsset_GetCurrentTimeFraction,
        AnimationAsset_GetTimeFromEnd,
        AnimationAsset_GetTimeFromEndFraction,
        CurrentState_ElapsedTime,
        CurrentState_GetBlendWeight,
        CurrentTransitionDuration,
        ArbitraryState_GetBlendWeight,
        ETransitionGetter_MAX
    }

    export class K2Node_TransitionRuleGetter extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetterType: ETransitionGetter;
        AssociatedAnimAssetPlayerNode: AnimGraphNode_Base;
        AssociatedStateNode: AnimStateNode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_TransitionRuleGetter;

        static Load(InName: string): K2Node_TransitionRuleGetter;
    }

    export enum ETunnelBoundaryType { Unknown, EntrySite, InputSite, OutputSite, ETunnelBoundaryType_MAX }

    export class K2Node_TunnelBoundary extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BaseName: string;
        TunnelBoundaryType: ETunnelBoundaryType;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_TunnelBoundary;

        static Load(InName: string): K2Node_TunnelBoundary;
    }

    export class K2Node_VariableGet extends K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsPureGet: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_VariableGet;

        static Load(InName: string): K2Node_VariableGet;
    }

    export class K2Node_VariableSet extends K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_VariableSet;

        static Load(InName: string): K2Node_VariableSet;
    }

    export class K2Node_VariableSetRef extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_VariableSetRef;

        static Load(InName: string): K2Node_VariableSetRef;
    }

    export class K2Node_WidgetAnimationEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Action: EWidgetAnimationEvent;
        AnimationPropertyName: string;
        UserTag: string;
        SourceWidgetBlueprint: WidgetBlueprint;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): K2Node_WidgetAnimationEvent;

        static Load(InName: string): K2Node_WidgetAnimationEvent;
    }

    export class KeyAsModifierInputBehavior extends InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KeyAsModifierInputBehavior;

        static Load(InName: string): KeyAsModifierInputBehavior;
    }

    export class KillZVolume extends PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KillZVolume;

        static Load(InName: string): KillZVolume;
    }

    export class PositionHistory {
        constructor();
        constructor(Positions: TArray<Vector>, Range: number);

        Positions: TArray<Vector>;
        Range: number;

        static StaticClass(): Class;
    }

    export class KismetAnimationLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static K2_CalculateVelocityFromPositionHistory(DeltaSeconds: number, Position: Vector, History: $Ref<PositionHistory>, NumberOfSamples: number, VelocityMin: number, VelocityMax: number): number;

        static K2_CalculateVelocityFromSockets(DeltaSeconds: number, Component: $Nullable<SkeletalMeshComponent>, SocketOrBoneName: string, ReferenceSocketOrBone: string, SocketSpace: ERelativeTransformSpace, OffsetInBoneSpace: Vector, History: $Ref<PositionHistory>, NumberOfSamples: number, VelocityMin: number, VelocityMax: number, EasingType: EEasingFuncType, CustomCurve: RuntimeFloatCurve): number;

        static K2_DirectionBetweenSockets(Component: $Nullable<SkeletalMeshComponent>, SocketOrBoneNameFrom: string, SocketOrBoneNameTo: string): Vector;

        static K2_DistanceBetweenTwoSocketsAndMapRange(Component: $Nullable<SkeletalMeshComponent>, SocketOrBoneNameA: string, SocketSpaceA: ERelativeTransformSpace, SocketOrBoneNameB: string, SocketSpaceB: ERelativeTransformSpace, bRemapRange: boolean, InRangeMin: number, InRangeMax: number, OutRangeMin: number, OutRangeMax: number): number;

        static K2_EndProfilingTimer(bLog?: boolean /* = true */, LogPrefix?: string /* = "" */): number;

        static K2_LookAt(CurrentTransform: Transform, TargetPosition: Vector, LookAtVector: Vector, bUseUpVector: boolean, UpVector: Vector, ClampConeInDegree: number): Transform;

        static K2_MakePerlinNoiseAndRemap(Value: number, RangeOutMin: number, RangeOutMax: number): number;

        static K2_MakePerlinNoiseVectorAndRemap(X: number, Y: number, Z: number, RangeOutMinX: number, RangeOutMaxX: number, RangeOutMinY: number, RangeOutMaxY: number, RangeOutMinZ: number, RangeOutMaxZ: number): Vector;

        static K2_StartProfilingTimer(): void;

        static K2_TwoBoneIK(RootPos: Vector, JointPos: Vector, EndPos: Vector, JointTarget: Vector, Effector: Vector, OutJointPos: $Ref<Vector>, OutEndPos: $Ref<Vector>, bAllowStretching: boolean, StartStretchRatio: number, MaxStretchScale: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetAnimationLibrary;

        static Load(InName: string): KismetAnimationLibrary;
    }

    export class KismetArrayLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static Array_Add(TargetArray: TArray<number>, NewItem: number): number;

        static Array_AddUnique(TargetArray: TArray<number>, NewItem: number): number;

        static Array_Append(TargetArray: TArray<number>, SourceArray: TArray<number>): void;

        static Array_Clear(TargetArray: TArray<number>): void;

        static Array_Contains(TargetArray: TArray<number>, ItemToFind: number): boolean;

        static Array_Find(TargetArray: TArray<number>, ItemToFind: number): number;

        static Array_Get(TargetArray: TArray<number>, Index: number, Item: $Ref<number>): void;

        static Array_Identical(ArrayA: TArray<number>, ArrayB: TArray<number>): boolean;

        static Array_Insert(TargetArray: TArray<number>, NewItem: number, Index: number): void;

        static Array_IsValidIndex(TargetArray: TArray<number>, IndexToTest: number): boolean;

        static Array_LastIndex(TargetArray: TArray<number>): number;

        static Array_Length(TargetArray: TArray<number>): number;

        static Array_Random(TargetArray: TArray<number>, OutItem: $Ref<number>, OutIndex: $Ref<number>): void;

        static Array_RandomFromStream(TargetArray: TArray<number>, RandomStream: $Ref<RandomStream>, OutItem: $Ref<number>, OutIndex: $Ref<number>): void;

        static Array_Remove(TargetArray: TArray<number>, IndexToRemove: number): void;

        static Array_RemoveItem(TargetArray: TArray<number>, Item: number): boolean;

        static Array_Resize(TargetArray: TArray<number>, Size: number): void;

        static Array_Reverse(TargetArray: TArray<number>): void;

        static Array_Set(TargetArray: TArray<number>, Index: number, Item: number, bSizeToFit: boolean): void;

        static Array_Shuffle(TargetArray: TArray<number>): void;

        static Array_Swap(TargetArray: TArray<number>, FirstIndex: number, SecondIndex: number): void;

        static FilterArray(TargetArray: TArray<Actor>, FilterClass: $Nullable<Class>, FilteredArray: $Ref<TArray<Actor>>): void;

        static SetArrayPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: TArray<number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetArrayLibrary;

        static Load(InName: string): KismetArrayLibrary;
    }

    export class KismetGuidLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static Conv_GuidToString(InGuid: Guid): string;

        static EqualEqual_GuidGuid(A: Guid, B: Guid): boolean;

        static Invalidate_Guid(InGuid: $Ref<Guid>): void;

        static IsValid_Guid(InGuid: Guid): boolean;

        static NewGuid(): Guid;

        static NotEqual_GuidGuid(A: Guid, B: Guid): boolean;

        static Parse_StringToGuid(GuidString: string, OutGuid: $Ref<Guid>, Success: $Ref<boolean>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetGuidLibrary;

        static Load(InName: string): KismetGuidLibrary;
    }

    export enum ESlateGesture { None, Scroll, Magnify, Swipe, Rotate, LongPress, ESlateGesture_MAX }

    export enum EUINavigationAction { Accept, Back, Num, Invalid, EUINavigationAction_MAX }

    export class KismetInputLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CalibrateTilt(): void;

        static EqualEqual_InputChordInputChord(A: InputChord, B: InputChord): boolean;

        static EqualEqual_KeyKey(A: Key, B: Key): boolean;

        static GetAnalogValue(Input: AnalogInputEvent): number;

        static GetKey(Input: KeyEvent): Key;

        static GetUserIndex(Input: KeyEvent): number;

        static InputChord_GetDisplayName(Key: InputChord): string;

        static InputEvent_IsAltDown(Input: InputEvent): boolean;

        static InputEvent_IsCommandDown(Input: InputEvent): boolean;

        static InputEvent_IsControlDown(Input: InputEvent): boolean;

        static InputEvent_IsLeftAltDown(Input: InputEvent): boolean;

        static InputEvent_IsLeftCommandDown(Input: InputEvent): boolean;

        static InputEvent_IsLeftControlDown(Input: InputEvent): boolean;

        static InputEvent_IsLeftShiftDown(Input: InputEvent): boolean;

        static InputEvent_IsRepeat(Input: InputEvent): boolean;

        static InputEvent_IsRightAltDown(Input: InputEvent): boolean;

        static InputEvent_IsRightCommandDown(Input: InputEvent): boolean;

        static InputEvent_IsRightControlDown(Input: InputEvent): boolean;

        static InputEvent_IsRightShiftDown(Input: InputEvent): boolean;

        static InputEvent_IsShiftDown(Input: InputEvent): boolean;

        static Key_GetDisplayName(Key: Key): string;

        static Key_GetNavigationAction(InKey: Key): EUINavigationAction;

        static Key_GetNavigationActionFromKey(InKeyEvent: KeyEvent): EUINavigationAction;

        static Key_GetNavigationDirectionFromAnalog(InAnalogEvent: AnalogInputEvent): EUINavigation;

        static Key_GetNavigationDirectionFromKey(InKeyEvent: KeyEvent): EUINavigation;

        static Key_IsAnalog(Key: Key): boolean;

        static Key_IsAxis1D(Key: Key): boolean;

        static Key_IsAxis2D(Key: Key): boolean;

        static Key_IsAxis3D(Key: Key): boolean;

        static Key_IsButtonAxis(Key: Key): boolean;

        static Key_IsDigital(Key: Key): boolean;

        static Key_IsGamepadKey(Key: Key): boolean;

        static Key_IsKeyboardKey(Key: Key): boolean;

        static Key_IsModifierKey(Key: Key): boolean;

        static Key_IsMouseButton(Key: Key): boolean;

        static Key_IsValid(Key: Key): boolean;

        static Key_IsVectorAxis(Key: Key): boolean;

        static PointerEvent_GetCursorDelta(Input: PointerEvent): Vector2D;

        static PointerEvent_GetEffectingButton(Input: PointerEvent): Key;

        static PointerEvent_GetGestureDelta(Input: PointerEvent): Vector2D;

        static PointerEvent_GetGestureType(Input: PointerEvent): ESlateGesture;

        static PointerEvent_GetLastScreenSpacePosition(Input: PointerEvent): Vector2D;

        static PointerEvent_GetPointerIndex(Input: PointerEvent): number;

        static PointerEvent_GetScreenSpacePosition(Input: PointerEvent): Vector2D;

        static PointerEvent_GetTouchpadIndex(Input: PointerEvent): number;

        static PointerEvent_GetUserIndex(Input: PointerEvent): number;

        static PointerEvent_GetWheelDelta(Input: PointerEvent): number;

        static PointerEvent_IsMouseButtonDown(Input: PointerEvent, MouseButton: Key): boolean;

        static PointerEvent_IsTouchEvent(Input: PointerEvent): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetInputLibrary;

        static Load(InName: string): KismetInputLibrary;
    }

    export enum ELocalizedTextSourceCategory { Game, Engine, Editor, ELocalizedTextSourceCategory_MAX }

    export class KismetInternationalizationLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ClearCurrentAssetGroupCulture(AssetGroup: string, SaveToConfig?: boolean /* = false */): void;

        static GetCultureDisplayName(Culture: string, Localized?: boolean /* = true */): string;

        static GetCurrentAssetGroupCulture(AssetGroup: string): string;

        static GetCurrentCulture(): string;

        static GetCurrentLanguage(): string;

        static GetCurrentLocale(): string;

        static GetLocalizedCultures(IncludeGame?: boolean /* = true */, IncludeEngine?: boolean /* = false */, IncludeEditor?: boolean /* = false */, IncludeAdditional?: boolean /* = false */): TArray<string>;

        static GetNativeCulture(TextCategory: ELocalizedTextSourceCategory): string;

        static GetSuitableCulture(AvailableCultures: TArray<string>, CultureToMatch: string, FallbackCulture?: string /* = "en" */): string;

        static SetCurrentAssetGroupCulture(AssetGroup: string, Culture: string, SaveToConfig?: boolean /* = false */): boolean;

        static SetCurrentCulture(Culture: string, SaveToConfig?: boolean /* = false */): boolean;

        static SetCurrentLanguage(Culture: string, SaveToConfig?: boolean /* = false */): boolean;

        static SetCurrentLanguageAndLocale(Culture: string, SaveToConfig?: boolean /* = false */): boolean;

        static SetCurrentLocale(Culture: string, SaveToConfig?: boolean /* = false */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetInternationalizationLibrary;

        static Load(InName: string): KismetInternationalizationLibrary;
    }

    export enum EMIDCreationFlags { None, Transient, EMIDCreationFlags_MAX }

    export class KismetMaterialLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateDynamicMaterialInstance(WorldContextObject: $Nullable<Object>, Parent: $Nullable<MaterialInterface>, OptionalName?: string /* = "None" */, CreationFlags?: EMIDCreationFlags /* = None */): MaterialInstanceDynamic;

        static GetScalarParameterValue(WorldContextObject: $Nullable<Object>, Collection: $Nullable<MaterialParameterCollection>, ParameterName: string): number;

        static GetVectorParameterValue(WorldContextObject: $Nullable<Object>, Collection: $Nullable<MaterialParameterCollection>, ParameterName: string): LinearColor;

        static SetScalarParameterValue(WorldContextObject: $Nullable<Object>, Collection: $Nullable<MaterialParameterCollection>, ParameterName: string, ParameterValue: number): void;

        static SetVectorParameterValue(WorldContextObject: $Nullable<Object>, Collection: $Nullable<MaterialParameterCollection>, ParameterName: string, ParameterValue: LinearColor): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetMaterialLibrary;

        static Load(InName: string): KismetMaterialLibrary;
    }

    export class VectorSpringState {
        constructor();

        static StaticClass(): Class;
    }

    export enum EEasingFunc {
        Linear,
        Step,
        SinusoidalIn,
        SinusoidalOut,
        SinusoidalInOut,
        EaseIn,
        EaseOut,
        EaseInOut,
        ExpoIn,
        ExpoOut,
        ExpoInOut,
        CircularIn,
        CircularOut,
        CircularInOut,
        EEasingFunc_MAX
    }

    export enum ELerpInterpolationMode { QuatInterp, EulerInterp, DualQuatInterp, ELerpInterpolationMode_MAX }

    export class FloatSpringState {
        constructor();

        static StaticClass(): Class;
    }

    export enum EMatrixColumns { First, Second, Third, Fourth, EMatrixColumns_MAX }

    export class KismetMathLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static Abs(A: number): number;

        static Abs_Int(A: number): number;

        static Abs_Int64(A: bigint): bigint;

        static Acos(A: number): number;

        static Add_ByteByte(A: number, B?: number /* = 1 */): number;

        static Add_DateTimeDateTime(A: DateTime, B: DateTime): DateTime;

        static Add_DateTimeTimespan(A: DateTime, B: Timespan): DateTime;

        static Add_FloatFloat(A: number, B?: number /* = 1.000000 */): number;

        static Add_Int64Int64(A: bigint, B?: bigint /* = 1 */): bigint;

        static Add_IntInt(A: number, B?: number /* = 1 */): number;

        static Add_IntPointInt(A: IntPoint, B: number): IntPoint;

        static Add_IntPointIntPoint(A: IntPoint, B: IntPoint): IntPoint;

        static Add_LinearColorLinearColor(A: LinearColor, B: LinearColor): LinearColor;

        static Add_MatrixMatrix(A: Matrix, B: Matrix): Matrix;

        static Add_QuatQuat(A: Quat, B: Quat): Quat;

        static Add_TimespanTimespan(A: Timespan, B: Timespan): Timespan;

        static Add_Vector2DFloat(A: Vector2D, B: number): Vector2D;

        static Add_Vector2DVector2D(A: Vector2D, B: Vector2D): Vector2D;

        static Add_Vector4Vector4(A: Vector4, B: Vector4): Vector4;

        static Add_VectorFloat(A: Vector, B: number): Vector;

        static Add_VectorInt(A: Vector, B: number): Vector;

        static Add_VectorVector(A: Vector, B: Vector): Vector;

        static And_Int64Int64(A: bigint, B: bigint): bigint;

        static And_IntInt(A: number, B: number): number;

        static Asin(A: number): number;

        static Atan(A: number): number;

        static Atan2(Y: number, X: number): number;

        static BMax(A: number, B: number): number;

        static BMin(A: number, B: number): number;

        static BooleanAND(A: boolean, B: boolean): boolean;

        static BooleanNAND(A: boolean, B: boolean): boolean;

        static BooleanNOR(A: boolean, B: boolean): boolean;

        static BooleanOR(A: boolean, B: boolean): boolean;

        static BooleanXOR(A: boolean, B: boolean): boolean;

        static BreakColor(InColor: LinearColor, R: $Ref<number>, G: $Ref<number>, B: $Ref<number>, A: $Ref<number>): void;

        static BreakDateTime(InDateTime: DateTime, Year: $Ref<number>, Month: $Ref<number>, Day: $Ref<number>, Hour: $Ref<number>, Minute: $Ref<number>, Second: $Ref<number>, Millisecond: $Ref<number>): void;

        static BreakFrameRate(InFrameRate: FrameRate, Numerator: $Ref<number>, Denominator: $Ref<number>): void;

        static BreakQualifiedFrameTime(InFrameTime: QualifiedFrameTime, Frame: $Ref<FrameNumber>, FrameRate: $Ref<FrameRate>, SubFrame: $Ref<number>): void;

        static BreakRandomStream(InRandomStream: RandomStream, InitialSeed: $Ref<number>): void;

        static BreakRotator(InRot: Rotator, Roll: $Ref<number>, Pitch: $Ref<number>, Yaw: $Ref<number>): void;

        static BreakRotIntoAxes(InRot: Rotator, X: $Ref<Vector>, Y: $Ref<Vector>, Z: $Ref<Vector>): void;

        static BreakTimespan(InTimespan: Timespan, Days: $Ref<number>, Hours: $Ref<number>, Minutes: $Ref<number>, Seconds: $Ref<number>, Milliseconds: $Ref<number>): void;

        static BreakTimespan2(InTimespan: Timespan, Days: $Ref<number>, Hours: $Ref<number>, Minutes: $Ref<number>, Seconds: $Ref<number>, FractionNano: $Ref<number>): void;

        static BreakTransform(InTransform: Transform, Location: $Ref<Vector>, Rotation: $Ref<Rotator>, Scale: $Ref<Vector>): void;

        static BreakVector(InVec: Vector, X: $Ref<number>, Y: $Ref<number>, Z: $Ref<number>): void;

        static BreakVector2D(InVec: Vector2D, X: $Ref<number>, Y: $Ref<number>): void;

        static BreakVector4(InVec: Vector4, X: $Ref<number>, Y: $Ref<number>, Z: $Ref<number>, W: $Ref<number>): void;

        static CInterpTo(Current: LinearColor, Target: LinearColor, DeltaTime: number, InterpSpeed: number): LinearColor;

        static Clamp(Value: number, Min: number, Max: number): number;

        static ClampAngle(AngleDegrees: number, MinAngleDegrees: number, MaxAngleDegrees: number): number;

        static ClampAxes2D(A: Vector2D, MinAxisVal: number, MaxAxisVal: number): Vector2D;

        static ClampAxis(Angle: number): number;

        static ClampInt64(Value: bigint, Min: bigint, Max: bigint): bigint;

        static ClampVectorSize(A: Vector, Min: number, Max: number): Vector;

        static ClassIsChildOf(TestClass: $Nullable<Class>, ParentClass: $Nullable<Class>): boolean;

        static ComposeRotators(A: Rotator, B: Rotator): Rotator;

        static ComposeTransforms(A: Transform, B: Transform): Transform;

        static Conv_BoolToByte(InBool: boolean): number;

        static Conv_BoolToFloat(InBool: boolean): number;

        static Conv_BoolToInt(InBool: boolean): number;

        static Conv_ByteToFloat(InByte: number): number;

        static Conv_ByteToInt(InByte: number): number;

        static Conv_ColorToLinearColor(InColor: Color): LinearColor;

        static Conv_FloatToLinearColor(InFloat: number): LinearColor;

        static Conv_FloatToVector(InFloat: number): Vector;

        static Conv_Int64ToByte(InInt: bigint): number;

        static Conv_Int64ToInt(InInt: bigint): number;

        static Conv_IntPointToVector2D(InIntPoint: IntPoint): Vector2D;

        static Conv_IntToBool(InInt: number): boolean;

        static Conv_IntToByte(InInt: number): number;

        static Conv_IntToFloat(InInt: number): number;

        static Conv_IntToInt64(InInt: number): bigint;

        static Conv_IntToIntVector(InInt: number): IntVector;

        static Conv_IntVectorToVector(InIntVector: IntVector): Vector;

        static Conv_LinearColorToColor(InLinearColor: LinearColor, InUseSRGB?: boolean /* = true */): Color;

        static Conv_LinearColorToVector(InLinearColor: LinearColor): Vector;

        static Conv_MatrixToRotator(InMatrix: Matrix): Rotator;

        static Conv_MatrixToTransform(InMatrix: Matrix): Transform;

        static Conv_RotatorToTransform(InRotator: Rotator): Transform;

        static Conv_RotatorToVector(InRot: Rotator): Vector;

        static Conv_TransformToMatrix(Transform: Transform): Matrix;

        static Conv_Vector2DToIntPoint(InVector2D: Vector2D): IntPoint;

        static Conv_Vector2DToVector(InVector2D: Vector2D, Z?: number /* = 0.000000 */): Vector;

        static Conv_Vector4ToQuaternion(InVec: Vector4): Quat;

        static Conv_Vector4ToRotator(InVec: Vector4): Rotator;

        static Conv_Vector4ToVector(InVector4: Vector4): Vector;

        static Conv_VectorToLinearColor(InVec: Vector): LinearColor;

        static Conv_VectorToQuaternion(InVec: Vector): Quat;

        static Conv_VectorToRotator(InVec: Vector): Rotator;

        static Conv_VectorToTransform(InLocation: Vector): Transform;

        static Conv_VectorToVector2D(InVector: Vector): Vector2D;

        static ConvertTransformToRelative(Transform: Transform, ParentTransform: Transform): Transform;

        static Cos(A: number): number;

        static CreateVectorFromYawPitch(Yaw: number, Pitch: number, Length?: number /* = 1.000000 */): Vector;

        static Cross_VectorVector(A: Vector, B: Vector): Vector;

        static CrossProduct2D(A: Vector2D, B: Vector2D): number;

        static DateTimeFromIsoString(IsoString: string, Result: $Ref<DateTime>): boolean;

        static DateTimeFromString(DateTimeString: string, Result: $Ref<DateTime>): boolean;

        static DateTimeMaxValue(): DateTime;

        static DateTimeMinValue(): DateTime;

        static DaysInMonth(Year: number, Month: number): number;

        static DaysInYear(Year: number): number;

        static DegAcos(A: number): number;

        static DegAsin(A: number): number;

        static DegAtan(A: number): number;

        static DegAtan2(Y: number, X: number): number;

        static DegCos(A: number): number;

        static DegreesToRadians(A: number): number;

        static DegSin(A: number): number;

        static DegTan(A: number): number;

        static Distance2D(V1: Vector2D, V2: Vector2D): number;

        static DistanceSquared2D(V1: Vector2D, V2: Vector2D): number;

        static Divide_ByteByte(A: number, B?: number /* = 1 */): number;

        static Divide_FloatFloat(A: number, B?: number /* = 1.000000 */): number;

        static Divide_Int64Int64(A: bigint, B?: bigint /* = 1 */): bigint;

        static Divide_IntInt(A: number, B?: number /* = 1 */): number;

        static Divide_IntPointInt(A: IntPoint, B: number): IntPoint;

        static Divide_IntPointIntPoint(A: IntPoint, B: IntPoint): IntPoint;

        static Divide_LinearColorLinearColor(A: LinearColor, B: LinearColor): LinearColor;

        static Divide_TimespanFloat(A: Timespan, Scalar: number): Timespan;

        static Divide_Vector2DFloat(A: Vector2D, B?: number /* = 1.000000 */): Vector2D;

        static Divide_Vector2DVector2D(A: Vector2D, B: Vector2D): Vector2D;

        static Divide_Vector4Vector4(A: Vector4, B: Vector4): Vector4;

        static Divide_VectorFloat(A: Vector, B?: number /* = 1.000000 */): Vector;

        static Divide_VectorInt(A: Vector, B?: number /* = 1 */): Vector;

        static Divide_VectorVector(A: Vector, B?: Vector /* = 1.000000,1.000000,1.000000 */): Vector;

        static Dot_VectorVector(A: Vector, B: Vector): number;

        static DotProduct2D(A: Vector2D, B: Vector2D): number;

        static DynamicWeightedMovingAverage_Float(CurrentSample: number, PreviousSample: number, MaxDistance: number, MinWeight: number, MaxWeight: number): number;

        static DynamicWeightedMovingAverage_FRotator(CurrentSample: Rotator, PreviousSample: Rotator, MaxDistance: number, MinWeight: number, MaxWeight: number): Rotator;

        static DynamicWeightedMovingAverage_FVector(CurrentSample: Vector, PreviousSample: Vector, MaxDistance: number, MinWeight: number, MaxWeight: number): Vector;

        static Ease(A: number, B: number, Alpha: number, EasingFunc: EEasingFunc, BlendExp?: number /* = 2.000000 */, Steps?: number /* = 2 */): number;

        static Equal_IntPointIntPoint(A: IntPoint, B: IntPoint): boolean;

        static EqualEqual_BoolBool(A: boolean, B: boolean): boolean;

        static EqualEqual_ByteByte(A: number, B: number): boolean;

        static EqualEqual_ClassClass(A: $Nullable<Class>, B: $Nullable<Class>): boolean;

        static EqualEqual_DateTimeDateTime(A: DateTime, B: DateTime): boolean;

        static EqualEqual_FloatFloat(A: number, B: number): boolean;

        static EqualEqual_Int64Int64(A: bigint, B: bigint): boolean;

        static EqualEqual_IntInt(A: number, B: number): boolean;

        static EqualEqual_LinearColorLinearColor(A: LinearColor, B: LinearColor): boolean;

        static EqualEqual_MatrixMatrix(A: Matrix, B: Matrix, Tolerance?: number /* = 0.000100 */): boolean;

        static EqualEqual_NameName(A: string, B: string): boolean;

        static EqualEqual_ObjectObject(A: $Nullable<Object>, B: $Nullable<Object>): boolean;

        static EqualEqual_QuatQuat(A: Quat, B: Quat, Tolerance?: number /* = 0.000100 */): boolean;

        static EqualEqual_RotatorRotator(A: Rotator, B: Rotator, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static EqualEqual_TimespanTimespan(A: Timespan, B: Timespan): boolean;

        static EqualEqual_TransformTransform(A: Transform, B: Transform): boolean;

        static EqualEqual_Vector2DVector2D(A: Vector2D, B: Vector2D, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static EqualEqual_Vector4Vector4(A: Vector4, B: Vector4, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static EqualEqual_VectorVector(A: Vector, B: Vector, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static EqualExactly_Vector2DVector2D(A: Vector2D, B: Vector2D): boolean;

        static EqualExactly_Vector4Vector4(A: Vector4, B: Vector4): boolean;

        static EqualExactly_VectorVector(A: Vector, B: Vector): boolean;

        static Exp(A: number): number;

        static FCeil(A: number): number;

        static FCeil64(A: number): bigint;

        static FClamp(Value: number, Min: number, Max: number): number;

        static FFloor(A: number): number;

        static FFloor64(A: number): bigint;

        static FindClosestPointOnLine(Point: Vector, LineOrigin: Vector, LineDirection: Vector): Vector;

        static FindClosestPointOnSegment(Point: Vector, SegmentStart: Vector, SegmentEnd: Vector): Vector;

        static FindLookAtRotation(Start: Vector, Target: Vector): Rotator;

        static FindNearestPointsOnLineSegments(Segment1Start: Vector, Segment1End: Vector, Segment2Start: Vector, Segment2End: Vector, Segment1Point: $Ref<Vector>, Segment2Point: $Ref<Vector>): void;

        static FInterpEaseInOut(A: number, B: number, Alpha: number, Exponent: number): number;

        static FInterpTo(Current: number, Target: number, DeltaTime: number, InterpSpeed: number): number;

        static FInterpTo_Constant(Current: number, Target: number, DeltaTime: number, InterpSpeed: number): number;

        static FixedTurn(InCurrent: number, InDesired: number, InDeltaRate: number): number;

        static FloatSpringInterp(Current: number, Target: number, SpringState: $Ref<FloatSpringState>, Stiffness: number, CriticalDampingFactor: number, DeltaTime: number, Mass?: number /* = 1.000000 */): number;

        static FMax(A: number, B: number): number;

        static FMin(A: number, B: number): number;

        static FMod(Dividend: number, Divisor: number, Remainder: $Ref<number>): number;

        static Fraction(A: number): number;

        static FromDays(Days: number): Timespan;

        static FromHours(Hours: number): Timespan;

        static FromMilliseconds(Milliseconds: number): Timespan;

        static FromMinutes(Minutes: number): Timespan;

        static FromSeconds(Seconds: number): Timespan;

        static FTrunc(A: number): number;

        static FTrunc64(A: number): bigint;

        static FTruncVector(InVector: Vector): IntVector;

        static FWrap(Value: number, Min: number, Max: number): number;

        static GetAbs2D(A: Vector2D): Vector2D;

        static GetAbsMax2D(A: Vector2D): number;

        static GetAxes(A: Rotator, X: $Ref<Vector>, Y: $Ref<Vector>, Z: $Ref<Vector>): void;

        static GetAzimuthAndElevation(InDirection: Vector, ReferenceFrame: Transform, Azimuth: $Ref<number>, Elevation: $Ref<number>): void;

        static GetDate(A: DateTime): DateTime;

        static GetDay(A: DateTime): number;

        static GetDayOfYear(A: DateTime): number;

        static GetDays(A: Timespan): number;

        static GetDirectionUnitVector(From: Vector, To: Vector): Vector;

        static GetDuration(A: Timespan): Timespan;

        static GetForwardVector(InRot: Rotator): Vector;

        static GetHour(A: DateTime): number;

        static GetHour12(A: DateTime): number;

        static GetHours(A: Timespan): number;

        static GetMax2D(A: Vector2D): number;

        static GetMaxElement(A: Vector): number;

        static GetMillisecond(A: DateTime): number;

        static GetMilliseconds(A: Timespan): number;

        static GetMin2D(A: Vector2D): number;

        static GetMinElement(A: Vector): number;

        static GetMinute(A: DateTime): number;

        static GetMinutes(A: Timespan): number;

        static GetMonth(A: DateTime): number;

        static GetPI(): number;

        static GetPointDistanceToLine(Point: Vector, LineOrigin: Vector, LineDirection: Vector): number;

        static GetPointDistanceToSegment(Point: Vector, SegmentStart: Vector, SegmentEnd: Vector): number;

        static GetReflectionVector(Direction: Vector, SurfaceNormal: Vector): Vector;

        static GetRightVector(InRot: Rotator): Vector;

        static GetRotated2D(A: Vector2D, AngleDeg: number): Vector2D;

        static GetSecond(A: DateTime): number;

        static GetSeconds(A: Timespan): number;

        static GetSlopeDegreeAngles(MyRightYAxis: Vector, FloorNormal: Vector, UpVector: Vector, OutSlopePitchDegreeAngle: $Ref<number>, OutSlopeRollDegreeAngle: $Ref<number>): void;

        static GetTAU(): number;

        static GetTimeOfDay(A: DateTime): Timespan;

        static GetTotalDays(A: Timespan): number;

        static GetTotalHours(A: Timespan): number;

        static GetTotalMilliseconds(A: Timespan): number;

        static GetTotalMinutes(A: Timespan): number;

        static GetTotalSeconds(A: Timespan): number;

        static GetUpVector(InRot: Rotator): Vector;

        static GetVectorArrayAverage(Vectors: TArray<Vector>): Vector;

        static GetYawPitchFromVector(InVec: Vector, Yaw: $Ref<number>, Pitch: $Ref<number>): void;

        static GetYear(A: DateTime): number;

        static Greater_ByteByte(A: number, B: number): boolean;

        static Greater_DateTimeDateTime(A: DateTime, B: DateTime): boolean;

        static Greater_FloatFloat(A: number, B: number): boolean;

        static Greater_Int64Int64(A: bigint, B: bigint): boolean;

        static Greater_IntInt(A: number, B: number): boolean;

        static Greater_TimespanTimespan(A: Timespan, B: Timespan): boolean;

        static GreaterEqual_ByteByte(A: number, B: number): boolean;

        static GreaterEqual_DateTimeDateTime(A: DateTime, B: DateTime): boolean;

        static GreaterEqual_FloatFloat(A: number, B: number): boolean;

        static GreaterEqual_Int64Int64(A: bigint, B: bigint): boolean;

        static GreaterEqual_IntInt(A: number, B: number): boolean;

        static GreaterEqual_TimespanTimespan(A: Timespan, B: Timespan): boolean;

        static GreaterGreater_VectorRotator(A: Vector, B: Rotator): Vector;

        static GridSnap_Float(Location: number, GridSize: number): number;

        static HSVToRGB(H: number, S: number, V: number, A?: number /* = 1.000000 */): LinearColor;

        static HSVToRGB_Vector(HSV: LinearColor, RGB: $Ref<LinearColor>): void;

        static HSVToRGBLinear(HSV: LinearColor): LinearColor;

        static Hypotenuse(Width: number, Height: number): number;

        static InRange_FloatFloat(Value: number, Min: number, Max: number, InclusiveMin?: boolean /* = true */, InclusiveMax?: boolean /* = true */): boolean;

        static InRange_Int64Int64(Value: bigint, Min: bigint, Max: bigint, InclusiveMin?: boolean /* = true */, InclusiveMax?: boolean /* = true */): boolean;

        static InRange_IntInt(Value: number, Min: number, Max: number, InclusiveMin?: boolean /* = true */, InclusiveMax?: boolean /* = true */): boolean;

        static IntPoint_Down(): IntPoint;

        static IntPoint_Left(): IntPoint;

        static IntPoint_One(): IntPoint;

        static IntPoint_Right(): IntPoint;

        static IntPoint_Up(): IntPoint;

        static IntPoint_Zero(): IntPoint;

        static InverseTransformDirection(T: Transform, Direction: Vector): Vector;

        static InverseTransformLocation(T: Transform, Location: Vector): Vector;

        static InverseTransformRotation(T: Transform, Rotation: Rotator): Rotator;

        static InvertTransform(T: Transform): Transform;

        static IsAfternoon(A: DateTime): boolean;

        static IsLeapYear(Year: number): boolean;

        static IsMorning(A: DateTime): boolean;

        static IsNearlyZero2D(A: Vector2D, Tolerance?: number /* = 0.000100 */): boolean;

        static IsPointInBox(Point: Vector, BoxOrigin: Vector, BoxExtent: Vector): boolean;

        static IsPointInBoxWithTransform(Point: Vector, BoxWorldTransform: Transform, BoxExtent: Vector): boolean;

        static IsZero2D(A: Vector2D): boolean;

        static Lerp(A: number, B: number, Alpha: number): number;

        static Less_ByteByte(A: number, B: number): boolean;

        static Less_DateTimeDateTime(A: DateTime, B: DateTime): boolean;

        static Less_FloatFloat(A: number, B: number): boolean;

        static Less_Int64Int64(A: bigint, B: bigint): boolean;

        static Less_IntInt(A: number, B: number): boolean;

        static Less_TimespanTimespan(A: Timespan, B: Timespan): boolean;

        static LessEqual_ByteByte(A: number, B: number): boolean;

        static LessEqual_DateTimeDateTime(A: DateTime, B: DateTime): boolean;

        static LessEqual_FloatFloat(A: number, B: number): boolean;

        static LessEqual_Int64Int64(A: bigint, B: bigint): boolean;

        static LessEqual_IntInt(A: number, B: number): boolean;

        static LessEqual_TimespanTimespan(A: Timespan, B: Timespan): boolean;

        static LessLess_VectorRotator(A: Vector, B: Rotator): Vector;

        static LinearColor_Black(): LinearColor;

        static LinearColor_Blue(): LinearColor;

        static LinearColor_Desaturated(InColor: LinearColor, InDesaturation: number): LinearColor;

        static LinearColor_Distance(C1: LinearColor, C2: LinearColor): number;

        static LinearColor_GetLuminance(InColor: LinearColor): number;

        static LinearColor_GetMax(InColor: LinearColor): number;

        static LinearColor_GetMin(InColor: LinearColor): number;

        static LinearColor_Gray(): LinearColor;

        static LinearColor_Green(): LinearColor;

        static LinearColor_IsNearEqual(A: LinearColor, B: LinearColor, Tolerance?: number /* = 0.000100 */): boolean;

        static LinearColor_Quantize(InColor: LinearColor): Color;

        static LinearColor_QuantizeRound(InColor: LinearColor): Color;

        static LinearColor_Red(): LinearColor;

        static LinearColor_Set(InOutColor: $Ref<LinearColor>, InColor: LinearColor): void;

        static LinearColor_SetFromHSV(InOutColor: $Ref<LinearColor>, H: number, S: number, V: number, A?: number /* = 1.000000 */): void;

        static LinearColor_SetFromPow22(InOutColor: $Ref<LinearColor>, InColor: Color): void;

        static LinearColor_SetFromSRGB(InOutColor: $Ref<LinearColor>, InSRGB: Color): void;

        static LinearColor_SetRandomHue(InOutColor: $Ref<LinearColor>): void;

        static LinearColor_SetRGBA(InOutColor: $Ref<LinearColor>, R: number, G: number, B: number, A?: number /* = 1.000000 */): void;

        static LinearColor_SetTemperature(InOutColor: $Ref<LinearColor>, InTemperature: number): void;

        static LinearColor_ToNewOpacity(InColor: LinearColor, InOpacity: number): LinearColor;

        static LinearColor_ToRGBE(InLinearColor: LinearColor): Color;

        static LinearColor_Transparent(): LinearColor;

        static LinearColor_White(): LinearColor;

        static LinearColor_Yellow(): LinearColor;

        static LinearColorLerp(A: LinearColor, B: LinearColor, Alpha: number): LinearColor;

        static LinearColorLerpUsingHSV(A: LinearColor, B: LinearColor, Alpha: number): LinearColor;

        static LinePlaneIntersection(LineStart: Vector, LineEnd: Vector, APlane: Plane, T: $Ref<number>, Intersection: $Ref<Vector>): boolean;

        static LinePlaneIntersection_OriginNormal(LineStart: Vector, LineEnd: Vector, PlaneOrigin: Vector, PlaneNormal: Vector, T: $Ref<number>, Intersection: $Ref<Vector>): boolean;

        static Log(A: number, Base?: number /* = 1.000000 */): number;

        static Loge(A: number): number;

        static MakeBox(Min: Vector, Max: Vector): Box;

        static MakeBox2D(Min: Vector2D, Max: Vector2D): Box2D;

        static MakeColor(R: number, G: number, B: number, A?: number /* = 1.000000 */): LinearColor;

        static MakeDateTime(Year: number, Month: number, Day: number, Hour?: number /* = 0 */, Minute?: number /* = 0 */, Second?: number /* = 0 */, Millisecond?: number /* = 0 */): DateTime;

        static MakeFrameRate(Numerator: number, Denominator?: number /* = 1 */): FrameRate;

        static MakePlaneFromPointAndNormal(Point: Vector, Normal: Vector): Plane;

        static MakePulsatingValue(InCurrentTime: number, InPulsesPerSecond?: number /* = 1.000000 */, InPhase?: number /* = 0.000000 */): number;

        static MakeQualifiedFrameTime(Frame: FrameNumber, FrameRate: FrameRate, SubFrame?: number /* = 0.000000 */): QualifiedFrameTime;

        static MakeRandomStream(InitialSeed: number): RandomStream;

        static MakeRelativeTransform(A: Transform, RelativeTo: Transform): Transform;

        static MakeRotationFromAxes(Forward: Vector, Right: Vector, Up: Vector): Rotator;

        static MakeRotator(Roll: number, Pitch: number, Yaw: number): Rotator;

        static MakeRotFromX(X: Vector): Rotator;

        static MakeRotFromXY(X: Vector, Y: Vector): Rotator;

        static MakeRotFromXZ(X: Vector, Z: Vector): Rotator;

        static MakeRotFromY(Y: Vector): Rotator;

        static MakeRotFromYX(Y: Vector, X: Vector): Rotator;

        static MakeRotFromYZ(Y: Vector, Z: Vector): Rotator;

        static MakeRotFromZ(Z: Vector): Rotator;

        static MakeRotFromZX(Z: Vector, X: Vector): Rotator;

        static MakeRotFromZY(Z: Vector, Y: Vector): Rotator;

        static MakeTimespan(Days: number, Hours: number, Minutes: number, Seconds: number, Milliseconds: number): Timespan;

        static MakeTimespan2(Days: number, Hours: number, Minutes: number, Seconds: number, FractionNano: number): Timespan;

        static MakeTransform(Location: Vector, Rotation: Rotator, Scale: Vector): Transform;

        static MakeVector(X: number, Y: number, Z: number): Vector;

        static MakeVector2D(X: number, Y: number): Vector2D;

        static MakeVector4(X: number, Y: number, Z: number, W: number): Vector4;

        static MapRangeClamped(Value: number, InRangeA: number, InRangeB: number, OutRangeA: number, OutRangeB: number): number;

        static MapRangeUnclamped(Value: number, InRangeA: number, InRangeB: number, OutRangeA: number, OutRangeB: number): number;

        static Matrix_ApplyScale(M: Matrix, Scale: number): Matrix;

        static Matrix_ConcatenateTranslation(M: Matrix, Translation: Vector): Matrix;

        static Matrix_ContainsNaN(M: Matrix): boolean;

        static Matrix_GetColumn(M: Matrix, Column: EMatrixColumns): Vector;

        static Matrix_GetDeterminant(M: Matrix): number;

        static Matrix_GetFrustumBottomPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;

        static Matrix_GetFrustumFarPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;

        static Matrix_GetFrustumLeftPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;

        static Matrix_GetFrustumNearPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;

        static Matrix_GetFrustumRightPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;

        static Matrix_GetFrustumTopPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;

        static Matrix_GetInverse(M: Matrix): Matrix;

        static Matrix_GetMatrixWithoutScale(M: Matrix, Tolerance?: number /* = 0.000000 */): Matrix;

        static Matrix_GetMaximumAxisScale(M: Matrix): number;

        static Matrix_GetOrigin(InMatrix: Matrix): Vector;

        static Matrix_GetRotator(M: Matrix): Rotator;

        static Matrix_GetRotDeterminant(M: Matrix): number;

        static Matrix_GetScaledAxes(M: Matrix, X: $Ref<Vector>, Y: $Ref<Vector>, Z: $Ref<Vector>): void;

        static Matrix_GetScaledAxis(M: Matrix, Axis: EAxis): Vector;

        static Matrix_GetScaleVector(M: Matrix, Tolerance?: number /* = 0.000000 */): Vector;

        static Matrix_GetTransposeAdjoint(M: Matrix): Matrix;

        static Matrix_GetTransposed(M: Matrix): Matrix;

        static Matrix_GetUnitAxes(M: Matrix, X: $Ref<Vector>, Y: $Ref<Vector>, Z: $Ref<Vector>): void;

        static Matrix_GetUnitAxis(M: Matrix, Axis: EAxis): Vector;

        static Matrix_Identity(): Matrix;

        static Matrix_InverseTransformPosition(M: Matrix, V: Vector): Vector;

        static Matrix_InverseTransformVector(M: Matrix, V: Vector): Vector;

        static Matrix_Mirror(M: Matrix, MirrorAxis: EAxis, FlipAxis: EAxis): Matrix;

        static Matrix_RemoveScaling(M: $Ref<Matrix>, Tolerance?: number /* = 0.000000 */): void;

        static Matrix_RemoveTranslation(M: Matrix): Matrix;

        static Matrix_ScaleTranslation(M: Matrix, Scale3D: Vector): Matrix;

        static Matrix_SetAxis(M: $Ref<Matrix>, Axis: EAxis, AxisVector: Vector): void;

        static Matrix_SetColumn(M: $Ref<Matrix>, Column: EMatrixColumns, Value: Vector): void;

        static Matrix_SetOrigin(M: $Ref<Matrix>, NewOrigin: Vector): void;

        static Matrix_ToQuat(M: Matrix): Quat;

        static Matrix_TransformPosition(M: Matrix, V: Vector): Vector4;

        static Matrix_TransformVector(M: Matrix, V: Vector): Vector4;

        static Matrix_TransformVector4(M: Matrix, V: Vector4): Vector4;

        static Max(A: number, B: number): number;

        static MaxInt64(A: bigint, B: bigint): bigint;

        static MaxOfByteArray(ByteArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>): void;

        static MaxOfFloatArray(FloatArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>): void;

        static MaxOfIntArray(IntArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>): void;

        static Min(A: number, B: number): number;

        static MinimumAreaRectangle(WorldContextObject: $Nullable<Object>, InVerts: TArray<Vector>, SampleSurfaceNormal: Vector, OutRectCenter: $Ref<Vector>, OutRectRotation: $Ref<Rotator>, OutSideLengthX: $Ref<number>, OutSideLengthY: $Ref<number>, bDebugDraw?: boolean /* = false */): void;

        static MinInt64(A: bigint, B: bigint): bigint;

        static MinOfByteArray(ByteArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>): void;

        static MinOfFloatArray(FloatArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>): void;

        static MinOfIntArray(IntArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>): void;

        static MirrorVectorByNormal(InVect: Vector, InNormal: Vector): Vector;

        static Multiply_ByteByte(A: number, B: number): number;

        static Multiply_FloatFloat(A: number, B: number): number;

        static Multiply_Int64Int64(A: bigint, B: bigint): bigint;

        static Multiply_IntFloat(A: number, B: number): number;

        static Multiply_IntInt(A: number, B: number): number;

        static Multiply_IntPointInt(A: IntPoint, B: number): IntPoint;

        static Multiply_IntPointIntPoint(A: IntPoint, B: IntPoint): IntPoint;

        static Multiply_LinearColorFloat(A: LinearColor, B: number): LinearColor;

        static Multiply_LinearColorLinearColor(A: LinearColor, B: LinearColor): LinearColor;

        static Multiply_MatrixFloat(A: Matrix, B: number): Matrix;

        static Multiply_MatrixMatrix(A: Matrix, B: Matrix): Matrix;

        static Multiply_QuatQuat(A: Quat, B: Quat): Quat;

        static Multiply_RotatorFloat(A: Rotator, B: number): Rotator;

        static Multiply_RotatorInt(A: Rotator, B: number): Rotator;

        static Multiply_TimespanFloat(A: Timespan, Scalar: number): Timespan;

        static Multiply_Vector2DFloat(A: Vector2D, B: number): Vector2D;

        static Multiply_Vector2DVector2D(A: Vector2D, B: Vector2D): Vector2D;

        static Multiply_Vector4Vector4(A: Vector4, B: Vector4): Vector4;

        static Multiply_VectorFloat(A: Vector, B: number): Vector;

        static Multiply_VectorInt(A: Vector, B: number): Vector;

        static Multiply_VectorVector(A: Vector, B: Vector): Vector;

        static MultiplyByPi(Value: number): number;

        static MultiplyMultiply_FloatFloat(Base: number, Exp: number): number;

        static NearlyEqual_FloatFloat(A: number, B: number, ErrorTolerance?: number /* = 0.000001 */): boolean;

        static NearlyEqual_TransformTransform(A: Transform, B: Transform, LocationTolerance?: number /* = 0.000100 */, RotationTolerance?: number /* = 0.000100 */, Scale3DTolerance?: number /* = 0.000100 */): boolean;

        static Negated2D(A: Vector2D): Vector2D;

        static NegateRotator(A: Rotator): Rotator;

        static NegateVector(A: Vector): Vector;

        static Normal(A: Vector, Tolerance?: number /* = 0.000100 */): Vector;

        static Normal2D(A: Vector2D): Vector2D;

        static Normalize2D(A: $Ref<Vector2D>, Tolerance?: number /* = 0.000000 */): void;

        static NormalizeAxis(Angle: number): number;

        static NormalizedDeltaRotator(A: Rotator, B: Rotator): Rotator;

        static NormalizeToRange(Value: number, RangeMin: number, RangeMax: number): number;

        static NormalSafe2D(A: Vector2D, Tolerance?: number /* = 0.000000 */): Vector2D;

        static Not_Int(A: number): number;

        static Not_Int64(A: bigint): bigint;

        static Not_PreBool(A: boolean): boolean;

        static NotEqual_BoolBool(A: boolean, B: boolean): boolean;

        static NotEqual_ByteByte(A: number, B: number): boolean;

        static NotEqual_ClassClass(A: $Nullable<Class>, B: $Nullable<Class>): boolean;

        static NotEqual_DateTimeDateTime(A: DateTime, B: DateTime): boolean;

        static NotEqual_FloatFloat(A: number, B: number): boolean;

        static NotEqual_Int64Int64(A: bigint, B: bigint): boolean;

        static NotEqual_IntInt(A: number, B: number): boolean;

        static NotEqual_IntPointIntPoint(A: IntPoint, B: IntPoint): boolean;

        static NotEqual_LinearColorLinearColor(A: LinearColor, B: LinearColor): boolean;

        static NotEqual_MatrixMatrix(A: Matrix, B: Matrix, Tolerance?: number /* = 0.000100 */): boolean;

        static NotEqual_NameName(A: string, B: string): boolean;

        static NotEqual_ObjectObject(A: $Nullable<Object>, B: $Nullable<Object>): boolean;

        static NotEqual_QuatQuat(A: Quat, B: Quat, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static NotEqual_RotatorRotator(A: Rotator, B: Rotator, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static NotEqual_TimespanTimespan(A: Timespan, B: Timespan): boolean;

        static NotEqual_Vector2DVector2D(A: Vector2D, B: Vector2D, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static NotEqual_Vector4Vector4(A: Vector4, B: Vector4, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static NotEqual_VectorVector(A: Vector, B: Vector, ErrorTolerance?: number /* = 0.000100 */): boolean;

        static NotEqualExactly_Vector2DVector2D(A: Vector2D, B: Vector2D): boolean;

        static NotEqualExactly_Vector4Vector4(A: Vector4, B: Vector4): boolean;

        static NotEqualExactly_VectorVector(A: Vector, B: Vector): boolean;

        static Now(): DateTime;

        static Or_Int64Int64(A: bigint, B: bigint): bigint;

        static Or_IntInt(A: number, B: number): number;

        static Percent_ByteByte(A: number, B?: number /* = 1 */): number;

        static Percent_FloatFloat(A: number, B?: number /* = 1.000000 */): number;

        static Percent_IntInt(A: number, B?: number /* = 1 */): number;

        static PerlinNoise1D(Value: number): number;

        static PointsAreCoplanar(Points: TArray<Vector>, Tolerance?: number /* = 0.100000 */): boolean;

        static ProjectPointOnToPlane(Point: Vector, PlaneBase: Vector, PlaneNormal: Vector): Vector;

        static ProjectVectorOnToPlane(V: Vector, PlaneNormal: Vector): Vector;

        static ProjectVectorOnToVector(V: Vector, Target: Vector): Vector;

        static Quat_AngularDistance(A: Quat, B: Quat): number;

        static Quat_EnforceShortestArcWith(A: $Ref<Quat>, B: Quat): void;

        static Quat_Euler(Q: Quat): Vector;

        static Quat_Exp(Q: Quat): Quat;

        static Quat_GetAngle(Q: Quat): number;

        static Quat_GetAxisX(Q: Quat): Vector;

        static Quat_GetAxisY(Q: Quat): Vector;

        static Quat_GetAxisZ(Q: Quat): Vector;

        static Quat_GetRotationAxis(Q: Quat): Vector;

        static Quat_Identity(): Quat;

        static Quat_Inversed(Q: Quat): Quat;

        static Quat_IsFinite(Q: Quat): boolean;

        static Quat_IsIdentity(Q: Quat, Tolerance?: number /* = 0.000100 */): boolean;

        static Quat_IsNonFinite(Q: Quat): boolean;

        static Quat_IsNormalized(Q: Quat): boolean;

        static Quat_Log(Q: Quat): Quat;

        static Quat_MakeFromEuler(Euler: Vector): Quat;

        static Quat_Normalize(Q: $Ref<Quat>, Tolerance?: number /* = 0.000100 */): void;

        static Quat_Normalized(Q: Quat, Tolerance?: number /* = 0.000100 */): Quat;

        static Quat_RotateVector(Q: Quat, V: Vector): Vector;

        static Quat_Rotator(Q: Quat): Rotator;

        static Quat_SetComponents(Q: $Ref<Quat>, X: number, Y: number, Z: number, W: number): void;

        static Quat_SetFromEuler(Q: $Ref<Quat>, Euler: Vector): void;

        static Quat_Size(Q: Quat): number;

        static Quat_SizeSquared(Q: Quat): number;

        static Quat_UnrotateVector(Q: Quat, V: Vector): Vector;

        static Quat_VectorForward(Q: Quat): Vector;

        static Quat_VectorRight(Q: Quat): Vector;

        static Quat_VectorUp(Q: Quat): Vector;

        static RadiansToDegrees(A: number): number;

        static RandomBool(): boolean;

        static RandomBoolFromStream(Stream: RandomStream): boolean;

        static RandomBoolWithWeight(Weight: number): boolean;

        static RandomBoolWithWeightFromStream(Weight: number, RandomStream: RandomStream): boolean;

        static RandomFloat(): number;

        static RandomFloatFromStream(Stream: RandomStream): number;

        static RandomFloatInRange(Min: number, Max: number): number;

        static RandomFloatInRangeFromStream(Min: number, Max: number, Stream: RandomStream): number;

        static RandomInteger(Max: number): number;

        static RandomInteger64(Max: bigint): bigint;

        static RandomInteger64InRange(Min: bigint, Max: bigint): bigint;

        static RandomIntegerFromStream(Max: number, Stream: RandomStream): number;

        static RandomIntegerInRange(Min: number, Max: number): number;

        static RandomIntegerInRangeFromStream(Min: number, Max: number, Stream: RandomStream): number;

        static RandomPointInBoundingBox(Origin: Vector, BoxExtent: Vector): Vector;

        static RandomRotator(bRoll?: boolean /* = false */): Rotator;

        static RandomRotatorFromStream(bRoll: boolean, Stream: RandomStream): Rotator;

        static RandomUnitVector(): Vector;

        static RandomUnitVectorFromStream(Stream: RandomStream): Vector;

        static RandomUnitVectorInConeInDegrees(ConeDir: Vector, ConeHalfAngleInDegrees: number): Vector;

        static RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector, ConeHalfAngleInDegrees: number, Stream: RandomStream): Vector;

        static RandomUnitVectorInConeInRadians(ConeDir: Vector, ConeHalfAngleInRadians: number): Vector;

        static RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector, ConeHalfAngleInRadians: number, Stream: RandomStream): Vector;

        static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector, MaxYawInDegrees: number, MaxPitchInDegrees: number): Vector;

        static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector, MaxYawInDegrees: number, MaxPitchInDegrees: number, Stream: RandomStream): Vector;

        static RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector, MaxYawInRadians: number, MaxPitchInRadians: number): Vector;

        static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector, MaxYawInRadians: number, MaxPitchInRadians: number, Stream: RandomStream): Vector;

        static REase(A: Rotator, B: Rotator, Alpha: number, bShortestPath: boolean, EasingFunc: EEasingFunc, BlendExp?: number /* = 2.000000 */, Steps?: number /* = 2 */): Rotator;

        static ResetFloatSpringState(SpringState: $Ref<FloatSpringState>): void;

        static ResetRandomStream(Stream: RandomStream): void;

        static ResetVectorSpringState(SpringState: $Ref<VectorSpringState>): void;

        static RGBLinearToHSV(RGB: LinearColor): LinearColor;

        static RGBToHSV(InColor: LinearColor, H: $Ref<number>, S: $Ref<number>, V: $Ref<number>, A: $Ref<number>): void;

        static RGBToHSV_Vector(RGB: LinearColor, HSV: $Ref<LinearColor>): void;

        static RInterpTo(Current: Rotator, Target: Rotator, DeltaTime: number, InterpSpeed: number): Rotator;

        static RInterpTo_Constant(Current: Rotator, Target: Rotator, DeltaTime: number, InterpSpeed: number): Rotator;

        static RLerp(A: Rotator, B: Rotator, Alpha: number, bShortestPath: boolean): Rotator;

        static RotateAngleAxis(InVect: Vector, AngleDeg: number, Axis: Vector): Vector;

        static RotatorFromAxisAndAngle(Axis: Vector, Angle: number): Rotator;

        static Round(A: number): number;

        static Round64(A: number): bigint;

        static SafeDivide(A: number, B: number): number;

        static SeedRandomStream(Stream: $Ref<RandomStream>): void;

        static SelectClass(A: $Nullable<Class>, B: $Nullable<Class>, bSelectA: boolean): Class;

        static SelectColor(A: LinearColor, B: LinearColor, bPickA: boolean): LinearColor;

        static SelectFloat(A: number, B: number, bPickA: boolean): number;

        static SelectInt(A: number, B: number, bPickA: boolean): number;

        static SelectObject(A: $Nullable<Object>, B: $Nullable<Object>, bSelectA: boolean): Object;

        static SelectRotator(A: Rotator, B: Rotator, bPickA: boolean): Rotator;

        static SelectString(A: string, B: string, bPickA: boolean): string;

        static SelectTransform(A: Transform, B: Transform, bPickA: boolean): Transform;

        static SelectVector(A: Vector, B: Vector, bPickA: boolean): Vector;

        static Set2D(A: $Ref<Vector2D>, X: number, Y: number): void;

        static SetRandomStreamSeed(Stream: $Ref<RandomStream>, NewSeed: number): void;

        static SignOfFloat(A: number): number;

        static SignOfInteger(A: number): number;

        static SignOfInteger64(A: bigint): bigint;

        static Sin(A: number): number;

        static Spherical2DToUnitCartesian(A: Vector2D): Vector;

        static Sqrt(A: number): number;

        static Square(A: number): number;

        static Subtract_ByteByte(A: number, B?: number /* = 1 */): number;

        static Subtract_DateTimeDateTime(A: DateTime, B: DateTime): Timespan;

        static Subtract_DateTimeTimespan(A: DateTime, B: Timespan): DateTime;

        static Subtract_FloatFloat(A: number, B?: number /* = 1.000000 */): number;

        static Subtract_Int64Int64(A: bigint, B?: bigint /* = 1 */): bigint;

        static Subtract_IntInt(A: number, B?: number /* = 1 */): number;

        static Subtract_IntPointInt(A: IntPoint, B: number): IntPoint;

        static Subtract_IntPointIntPoint(A: IntPoint, B: IntPoint): IntPoint;

        static Subtract_LinearColorLinearColor(A: LinearColor, B: LinearColor): LinearColor;

        static Subtract_QuatQuat(A: Quat, B: Quat): Quat;

        static Subtract_TimespanTimespan(A: Timespan, B: Timespan): Timespan;

        static Subtract_Vector2DFloat(A: Vector2D, B: number): Vector2D;

        static Subtract_Vector2DVector2D(A: Vector2D, B: Vector2D): Vector2D;

        static Subtract_Vector4Vector4(A: Vector4, B: Vector4): Vector4;

        static Subtract_VectorFloat(A: Vector, B: number): Vector;

        static Subtract_VectorInt(A: Vector, B: number): Vector;

        static Subtract_VectorVector(A: Vector, B: Vector): Vector;

        static Tan(A: number): number;

        static TEase(A: Transform, B: Transform, Alpha: number, EasingFunc: EEasingFunc, BlendExp?: number /* = 2.000000 */, Steps?: number /* = 2 */): Transform;

        static TimespanFromString(TimespanString: string, Result: $Ref<Timespan>): boolean;

        static TimespanMaxValue(): Timespan;

        static TimespanMinValue(): Timespan;

        static TimespanRatio(A: Timespan, B: Timespan): number;

        static TimespanZeroValue(): Timespan;

        static TInterpTo(Current: Transform, Target: Transform, DeltaTime: number, InterpSpeed: number): Transform;

        static TLerp(A: Transform, B: Transform, Alpha: number, InterpMode?: ELerpInterpolationMode /* = QuatInterp */): Transform;

        static Today(): DateTime;

        static ToDirectionAndLength2D(A: Vector2D, OutDir: $Ref<Vector2D>, OutLength: $Ref<number>): void;

        static ToRounded2D(A: Vector2D): Vector2D;

        static ToSign2D(A: Vector2D): Vector2D;

        static Transform_Determinant(Transform: Transform): number;

        static TransformDirection(T: Transform, Direction: Vector): Vector;

        static TransformLocation(T: Transform, Location: Vector): Vector;

        static TransformRotation(T: Transform, Rotation: Rotator): Rotator;

        static TransformVector4(Matrix: Matrix, Vec4: Vector4): Vector4;

        static UtcNow(): DateTime;

        static VEase(A: Vector, B: Vector, Alpha: number, EasingFunc: EEasingFunc, BlendExp?: number /* = 2.000000 */, Steps?: number /* = 2 */): Vector;

        static Vector2D_One(): Vector2D;

        static Vector2D_Unit45Deg(): Vector2D;

        static Vector2D_Zero(): Vector2D;

        static Vector2DInterpTo(Current: Vector2D, Target: Vector2D, DeltaTime: number, InterpSpeed: number): Vector2D;

        static Vector2DInterpTo_Constant(Current: Vector2D, Target: Vector2D, DeltaTime: number, InterpSpeed: number): Vector2D;

        static Vector4_Assign(A: $Ref<Vector4>, InVector: Vector4): void;

        static Vector4_CrossProduct3(A: Vector4, B: Vector4): Vector4;

        static Vector4_DotProduct(A: Vector4, B: Vector4): number;

        static Vector4_DotProduct3(A: Vector4, B: Vector4): number;

        static Vector4_IsNAN(A: Vector4): boolean;

        static Vector4_IsNearlyZero3(A: Vector4, Tolerance?: number /* = 0.000100 */): boolean;

        static Vector4_IsNormal3(A: Vector4): boolean;

        static Vector4_IsUnit3(A: Vector4, SquaredLenthTolerance?: number /* = 0.000100 */): boolean;

        static Vector4_IsZero(A: Vector4): boolean;

        static Vector4_MirrorByVector3(Direction: Vector4, SurfaceNormal: Vector4): Vector4;

        static Vector4_Negated(A: Vector4): Vector4;

        static Vector4_Normal3(A: Vector4, Tolerance?: number /* = 0.000100 */): Vector4;

        static Vector4_Normalize3(A: $Ref<Vector4>, Tolerance?: number /* = 0.000000 */): void;

        static Vector4_NormalUnsafe3(A: Vector4): Vector4;

        static Vector4_Set(A: $Ref<Vector4>, X: number, Y: number, Z: number, W: number): void;

        static Vector4_Size(A: Vector4): number;

        static Vector4_Size3(A: Vector4): number;

        static Vector4_SizeSquared(A: Vector4): number;

        static Vector4_SizeSquared3(A: Vector4): number;

        static Vector4_Zero(): Vector4;

        static Vector_AddBounded(A: $Ref<Vector>, InAddVect: Vector, InRadius: number): void;

        static Vector_Assign(A: $Ref<Vector>, InVector: Vector): void;

        static Vector_Backward(): Vector;

        static Vector_BoundedToBox(InVect: Vector, InBoxMin: Vector, InBoxMax: Vector): Vector;

        static Vector_BoundedToCube(InVect: Vector, InRadius: number): Vector;

        static Vector_ClampSize2D(A: Vector, Min: number, Max: number): Vector;

        static Vector_ClampSizeMax(A: Vector, Max: number): Vector;

        static Vector_ClampSizeMax2D(A: Vector, Max: number): Vector;

        static Vector_ComponentMax(A: Vector, B: Vector): Vector;

        static Vector_ComponentMin(A: Vector, B: Vector): Vector;

        static Vector_CosineAngle2D(A: Vector, B: Vector): number;

        static Vector_Distance(V1: Vector, V2: Vector): number;

        static Vector_Distance2D(V1: Vector, V2: Vector): number;

        static Vector_Distance2DSquared(V1: Vector, V2: Vector): number;

        static Vector_DistanceSquared(V1: Vector, V2: Vector): number;

        static Vector_Down(): Vector;

        static Vector_Forward(): Vector;

        static Vector_GetAbs(A: Vector): Vector;

        static Vector_GetAbsMax(A: Vector): number;

        static Vector_GetAbsMin(A: Vector): number;

        static Vector_GetProjection(A: Vector): Vector;

        static Vector_GetSignVector(A: Vector): Vector;

        static Vector_HeadingAngle(A: Vector): number;

        static Vector_IsNAN(A: Vector): boolean;

        static Vector_IsNearlyZero(A: Vector, Tolerance?: number /* = 0.000100 */): boolean;

        static Vector_IsNormal(A: Vector): boolean;

        static Vector_IsUniform(A: Vector, Tolerance?: number /* = 0.000100 */): boolean;

        static Vector_IsUnit(A: Vector, SquaredLenthTolerance?: number /* = 0.000100 */): boolean;

        static Vector_IsZero(A: Vector): boolean;

        static Vector_Left(): Vector;

        static Vector_MirrorByPlane(A: Vector, InPlane: Plane): Vector;

        static Vector_Normal2D(A: Vector, Tolerance?: number /* = 0.000100 */): Vector;

        static Vector_Normalize(A: $Ref<Vector>, Tolerance?: number /* = 0.000000 */): void;

        static Vector_NormalUnsafe(A: Vector): Vector;

        static Vector_One(): Vector;

        static Vector_ProjectOnToNormal(V: Vector, InNormal: Vector): Vector;

        static Vector_Reciprocal(A: Vector): Vector;

        static Vector_Right(): Vector;

        static Vector_Set(A: $Ref<Vector>, X: number, Y: number, Z: number): void;

        static Vector_SnappedToGrid(InVect: Vector, InGridSize: number): Vector;

        static Vector_ToDegrees(A: Vector): Vector;

        static Vector_ToRadians(A: Vector): Vector;

        static Vector_UnitCartesianToSpherical(A: Vector): Vector2D;

        static Vector_UnwindEuler(A: $Ref<Vector>): void;

        static Vector_Up(): Vector;

        static Vector_Zero(): Vector;

        static VectorSpringInterp(Current: Vector, Target: Vector, SpringState: $Ref<VectorSpringState>, Stiffness: number, CriticalDampingFactor: number, DeltaTime: number, Mass?: number /* = 1.000000 */): Vector;

        static VInterpTo(Current: Vector, Target: Vector, DeltaTime: number, InterpSpeed: number): Vector;

        static VInterpTo_Constant(Current: Vector, Target: Vector, DeltaTime: number, InterpSpeed: number): Vector;

        static VLerp(A: Vector, B: Vector, Alpha: number): Vector;

        static VSize(A: Vector): number;

        static VSize2D(A: Vector2D): number;

        static VSize2DSquared(A: Vector2D): number;

        static VSizeSquared(A: Vector): number;

        static VSizeXY(A: Vector): number;

        static VSizeXYSquared(A: Vector): number;

        static WeightedMovingAverage_Float(CurrentSample: number, PreviousSample: number, Weight: number): number;

        static WeightedMovingAverage_FRotator(CurrentSample: Rotator, PreviousSample: Rotator, Weight: number): Rotator;

        static WeightedMovingAverage_FVector(CurrentSample: Vector, PreviousSample: Vector, Weight: number): Vector;

        static Wrap(Value: number, Min: number, Max: number): number;

        static Xor_Int64Int64(A: bigint, B: bigint): bigint;

        static Xor_IntInt(A: number, B: number): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetMathLibrary;

        static Load(InName: string): KismetMathLibrary;
    }

    export class KismetNodeHelperLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static BitIsMarked(Data: number, Index: number): boolean;

        static ClearAllBits(Data: $Ref<number>): void;

        static ClearBit(Data: $Ref<number>, Index: number): void;

        static GetEnumeratorName(Enum: $Nullable<Enum>, EnumeratorValue: number): string;

        static GetEnumeratorUserFriendlyName(Enum: $Nullable<Enum>, EnumeratorValue: number): string;

        static GetEnumeratorValueFromIndex(Enum: $Nullable<Enum>, EnumeratorIndex: number): number;

        static GetFirstUnmarkedBit(Data: number, StartIdx: number, NumBits: number): number;

        static GetRandomUnmarkedBit(Data: number, StartIdx: number, NumBits: number): number;

        static GetUnmarkedBit(Data: number, StartIdx: number, NumBits: number, bRandom: boolean): number;

        static GetValidValue(Enum: $Nullable<Enum>, EnumeratorValue: number): number;

        static HasMarkedBit(Data: number, NumBits: number): boolean;

        static HasUnmarkedBit(Data: number, NumBits: number): boolean;

        static MarkBit(Data: $Ref<number>, Index: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetNodeHelperLibrary;

        static Load(InName: string): KismetNodeHelperLibrary;
    }

    export class ProcMeshTangent {
        constructor();
        constructor(TangentX: Vector, bFlipTangentY: boolean);

        TangentX: Vector;
        bFlipTangentY: boolean;

        static StaticClass(): Class;
    }

    export class ProcMeshVertex {
        constructor();
        constructor(Position: Vector, Normal: Vector, Tangent: ProcMeshTangent, Color: Color, UV0: Vector2D, UV1: Vector2D, UV2: Vector2D, UV3: Vector2D);

        Position: Vector;
        Normal: Vector;
        Tangent: ProcMeshTangent;
        Color: Color;
        UV0: Vector2D;
        UV1: Vector2D;
        UV2: Vector2D;
        UV3: Vector2D;

        static StaticClass(): Class;
    }

    export class ProcMeshSection {
        constructor();
        constructor(ProcVertexBuffer: TArray<ProcMeshVertex>, ProcIndexBuffer: TArray<number>, SectionLocalBox: Box, bEnableCollision: boolean, bSectionVisible: boolean);

        ProcVertexBuffer: TArray<ProcMeshVertex>;
        ProcIndexBuffer: TArray<number>;
        SectionLocalBox: Box;
        bEnableCollision: boolean;
        bSectionVisible: boolean;

        static StaticClass(): Class;
    }

    export class ProceduralMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseComplexAsSimpleCollision: boolean;
        bUseAsyncCooking: boolean;
        ProcMeshBodySetup: BodySetup;
        ProcMeshSections: TArray<ProcMeshSection>;
        CollisionConvexElems: TArray<KConvexElem>;
        LocalBounds: BoxSphereBounds;
        AsyncBodySetupQueue: TArray<BodySetup>;

        AddCollisionConvexMesh(ConvexVerts: TArray<Vector>): void;

        ClearAllMeshSections(): void;

        ClearCollisionConvexMeshes(): void;

        ClearMeshSection(SectionIndex: number): void;

        CreateMeshSection(SectionIndex: number, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, UV0: TArray<Vector2D>, VertexColors: TArray<Color>, Tangents: TArray<ProcMeshTangent>, bCreateCollision: boolean): void;

        CreateMeshSection_LinearColor(SectionIndex: number, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, UV0: TArray<Vector2D>, UV1: TArray<Vector2D>, UV2: TArray<Vector2D>, UV3: TArray<Vector2D>, VertexColors: TArray<LinearColor>, Tangents: TArray<ProcMeshTangent>, bCreateCollision: boolean): void;

        GetNumSections(): number;

        IsMeshSectionVisible(SectionIndex: number): boolean;

        SetMeshSectionVisible(SectionIndex: number, bNewVisibility: boolean): void;

        UpdateMeshSection(SectionIndex: number, Vertices: TArray<Vector>, Normals: TArray<Vector>, UV0: TArray<Vector2D>, VertexColors: TArray<Color>, Tangents: TArray<ProcMeshTangent>): void;

        UpdateMeshSection_LinearColor(SectionIndex: number, Vertices: TArray<Vector>, Normals: TArray<Vector>, UV0: TArray<Vector2D>, UV1: TArray<Vector2D>, UV2: TArray<Vector2D>, UV3: TArray<Vector2D>, VertexColors: TArray<LinearColor>, Tangents: TArray<ProcMeshTangent>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProceduralMeshComponent;

        static Load(InName: string): ProceduralMeshComponent;
    }

    export enum EProcMeshSliceCapOption {
        NoCap,
        CreateNewSectionForCap,
        UseLastSectionForCap,
        EProcMeshSliceCapOption_MAX
    }

    export class KismetProceduralMeshLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CalculateTangentsForMesh(Vertices: TArray<Vector>, Triangles: TArray<number>, UVs: TArray<Vector2D>, Normals: $Ref<TArray<Vector>>, Tangents: $Ref<TArray<ProcMeshTangent>>): void;

        static ConvertQuadToTriangles(Triangles: $Ref<TArray<number>>, Vert0: number, Vert1: number, Vert2: number, Vert3: number): void;

        static CopyProceduralMeshFromStaticMeshComponent(StaticMeshComponent: $Nullable<StaticMeshComponent>, LODIndex: number, ProcMeshComponent: $Nullable<ProceduralMeshComponent>, bCreateCollision: boolean): void;

        static CreateGridMeshSplit(NumX: number, NumY: number, Triangles: $Ref<TArray<number>>, Vertices: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, UV1s: $Ref<TArray<Vector2D>>, GridSpacing?: number /* = 16.000000 */): void;

        static CreateGridMeshTriangles(NumX: number, NumY: number, bWinding: boolean, Triangles: $Ref<TArray<number>>): void;

        static CreateGridMeshWelded(NumX: number, NumY: number, Triangles: $Ref<TArray<number>>, Vertices: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, GridSpacing?: number /* = 16.000000 */): void;

        static GenerateBoxMesh(BoxRadius: Vector, Vertices: $Ref<TArray<Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, Tangents: $Ref<TArray<ProcMeshTangent>>): void;

        static GetSectionFromProceduralMesh(InProcMesh: $Nullable<ProceduralMeshComponent>, SectionIndex: number, Vertices: $Ref<TArray<Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, Tangents: $Ref<TArray<ProcMeshTangent>>): void;

        static GetSectionFromStaticMesh(InMesh: $Nullable<StaticMesh>, LODIndex: number, SectionIndex: number, Vertices: $Ref<TArray<Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, Tangents: $Ref<TArray<ProcMeshTangent>>): void;

        static SliceProceduralMesh(InProcMesh: $Nullable<ProceduralMeshComponent>, PlanePosition: Vector, PlaneNormal: Vector, bCreateOtherHalf: boolean, OutOtherHalfProcMesh: $Ref<ProceduralMeshComponent>, CapOption: EProcMeshSliceCapOption, CapMaterial: $Nullable<MaterialInterface>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetProceduralMeshLibrary;

        static Load(InName: string): KismetProceduralMeshLibrary;
    }

    export class DrawToRenderTargetContext {
        constructor();
        constructor(RenderTarget: TextureRenderTarget2D);

        RenderTarget: TextureRenderTarget2D;

        static StaticClass(): Class;
    }

    export class TextureRenderTargetVolume extends TextureRenderTarget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SizeX: number;
        SizeY: number;
        SizeZ: number;
        ClearColor: LinearColor;
        OverrideFormat: EPixelFormat;
        bHDR: boolean;
        bForceLinearGamma: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetVolume;

        static Load(InName: string): TextureRenderTargetVolume;
    }

    export class TextureRenderTarget2DArray extends TextureRenderTarget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SizeX: number;
        SizeY: number;
        Slices: number;
        ClearColor: LinearColor;
        OverrideFormat: EPixelFormat;
        bHDR: boolean;
        bForceLinearGamma: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTarget2DArray;

        static Load(InName: string): TextureRenderTarget2DArray;
    }

    export class KismetRenderingLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static BeginDrawCanvasToRenderTarget(WorldContextObject: $Nullable<Object>, TextureRenderTarget: $Nullable<TextureRenderTarget2D>, Canvas: $Ref<Canvas>, Size: $Ref<Vector2D>, Context: $Ref<DrawToRenderTargetContext>): void;

        static BreakSkinWeightInfo(InWeight: SkelMeshSkinWeightInfo, Bone0: $Ref<number>, Weight0: $Ref<number>, Bone1: $Ref<number>, Weight1: $Ref<number>, Bone2: $Ref<number>, Weight2: $Ref<number>, Bone3: $Ref<number>, Weight3: $Ref<number>): void;

        static ClearRenderTarget2D(WorldContextObject: $Nullable<Object>, TextureRenderTarget: $Nullable<TextureRenderTarget2D>, ClearColor?: LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */): void;

        static ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: $Nullable<Object>, RenderTarget: $Nullable<TextureRenderTarget2D>, Texture: $Nullable<Texture2D>): void;

        static CreateRenderTarget2D(WorldContextObject: $Nullable<Object>, Width?: number /* = 256 */, Height?: number /* = 256 */, Format?: ETextureRenderTargetFormat /* = RTF_RGBA16f */, ClearColor?: LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */, bAutoGenerateMipMaps?: boolean /* = false */): TextureRenderTarget2D;

        static CreateRenderTarget2DArray(WorldContextObject: $Nullable<Object>, Width?: number /* = 256 */, Height?: number /* = 256 */, Slices?: number /* = 1 */, Format?: ETextureRenderTargetFormat /* = RTF_RGBA16f */, ClearColor?: LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */, bAutoGenerateMipMaps?: boolean /* = false */): TextureRenderTarget2DArray;

        static CreateRenderTargetVolume(WorldContextObject: $Nullable<Object>, Width?: number /* = 16 */, Height?: number /* = 16 */, Depth?: number /* = 16 */, Format?: ETextureRenderTargetFormat /* = RTF_RGBA16f */, ClearColor?: LinearColor /* = (R=0.000000,G=0.000000,B=0.000000,A=1.000000) */, bAutoGenerateMipMaps?: boolean /* = false */): TextureRenderTargetVolume;

        static DrawMaterialToRenderTarget(WorldContextObject: $Nullable<Object>, TextureRenderTarget: $Nullable<TextureRenderTarget2D>, Material: $Nullable<MaterialInterface>): void;

        static EndDrawCanvasToRenderTarget(WorldContextObject: $Nullable<Object>, Context: DrawToRenderTargetContext): void;

        static ExportRenderTarget(WorldContextObject: $Nullable<Object>, TextureRenderTarget: $Nullable<TextureRenderTarget2D>, FilePath: string, FileName: string): void;

        static ExportTexture2D(WorldContextObject: $Nullable<Object>, Texture: $Nullable<Texture2D>, FilePath: string, FileName: string): void;

        static ImportBufferAsTexture2D(WorldContextObject: $Nullable<Object>, Buffer: TArray<number>): Texture2D;

        static ImportFileAsTexture2D(WorldContextObject: $Nullable<Object>, Filename: string): Texture2D;

        static MakeSkinWeightInfo(Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number): SkelMeshSkinWeightInfo;

        static ReadRenderTargetPixel(WorldContextObject: $Nullable<Object>, TextureRenderTarget: $Nullable<TextureRenderTarget2D>, X: number, Y: number): Color;

        static ReadRenderTargetRawPixel(WorldContextObject: $Nullable<Object>, TextureRenderTarget: $Nullable<TextureRenderTarget2D>, X: number, Y: number): LinearColor;

        static ReadRenderTargetRawUV(WorldContextObject: $Nullable<Object>, TextureRenderTarget: $Nullable<TextureRenderTarget2D>, U: number, V: number): LinearColor;

        static ReadRenderTargetUV(WorldContextObject: $Nullable<Object>, TextureRenderTarget: $Nullable<TextureRenderTarget2D>, U: number, V: number): Color;

        static ReleaseRenderTarget2D(TextureRenderTarget: $Nullable<TextureRenderTarget2D>): void;

        static RenderTargetCreateStaticTexture2DEditorOnly(RenderTarget: $Nullable<TextureRenderTarget2D>, Name?: string /* = "Texture" */, CompressionSettings?: TextureCompressionSettings /* = TC_Default */, MipSettings?: TextureMipGenSettings /* = TMGS_FromTextureGroup */): Texture2D;

        static SetCastInsetShadowForAllAttachments(PrimitiveComponent: $Nullable<PrimitiveComponent>, bCastInsetShadow: boolean, bLightAttachmentsAsGroup: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetRenderingLibrary;

        static Load(InName: string): KismetRenderingLibrary;
    }

    export enum ESearchCase { CaseSensitive, IgnoreCase, ESearchCase_MAX }

    export enum ESearchDir { FromStart, FromEnd, ESearchDir_MAX }

    export class KismetStringLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static BuildString_Bool(AppendTo: string, Prefix: string, InBool: boolean, Suffix: string): string;

        static BuildString_Color(AppendTo: string, Prefix: string, InColor: LinearColor, Suffix: string): string;

        static BuildString_Float(AppendTo: string, Prefix: string, InFloat: number, Suffix: string): string;

        static BuildString_Int(AppendTo: string, Prefix: string, InInt: number, Suffix: string): string;

        static BuildString_IntVector(AppendTo: string, Prefix: string, InIntVector: IntVector, Suffix: string): string;

        static BuildString_Name(AppendTo: string, Prefix: string, InName: string, Suffix: string): string;

        static BuildString_Object(AppendTo: string, Prefix: string, InObj: $Nullable<Object>, Suffix: string): string;

        static BuildString_Rotator(AppendTo: string, Prefix: string, InRot: Rotator, Suffix: string): string;

        static BuildString_Vector(AppendTo: string, Prefix: string, InVector: Vector, Suffix: string): string;

        static BuildString_Vector2d(AppendTo: string, Prefix: string, InVector2d: Vector2D, Suffix: string): string;

        static Concat_StrStr(A: string, B: string): string;

        static Contains(SearchIn: string, Substring: string, bUseCase?: boolean /* = false */, bSearchFromEnd?: boolean /* = false */): boolean;

        static Conv_BoolToString(InBool: boolean): string;

        static Conv_ByteToString(InByte: number): string;

        static Conv_ColorToString(InColor: LinearColor): string;

        static Conv_FloatToString(InFloat: number): string;

        static Conv_IntPointToString(InIntPoint: IntPoint): string;

        static Conv_IntToString(InInt: number): string;

        static Conv_IntVectorToString(InIntVec: IntVector): string;

        static Conv_MatrixToString(InMatrix: Matrix): string;

        static Conv_NameToString(InName: string): string;

        static Conv_ObjectToString(InObj: $Nullable<Object>): string;

        static Conv_RotatorToString(InRot: Rotator): string;

        static Conv_StringToColor(InString: string, OutConvertedColor: $Ref<LinearColor>, OutIsValid: $Ref<boolean>): void;

        static Conv_StringToFloat(InString: string): number;

        static Conv_StringToInt(InString: string): number;

        static Conv_StringToName(InString: string): string;

        static Conv_StringToRotator(InString: string, OutConvertedRotator: $Ref<Rotator>, OutIsValid: $Ref<boolean>): void;

        static Conv_StringToVector(InString: string, OutConvertedVector: $Ref<Vector>, OutIsValid: $Ref<boolean>): void;

        static Conv_StringToVector2D(InString: string, OutConvertedVector2D: $Ref<Vector2D>, OutIsValid: $Ref<boolean>): void;

        static Conv_TransformToString(InTrans: Transform): string;

        static Conv_Vector2dToString(InVec: Vector2D): string;

        static Conv_VectorToString(InVec: Vector): string;

        static CullArray(SourceString: string, InArray: $Ref<TArray<string>>): number;

        static EndsWith(SourceString: string, InSuffix: string, SearchCase?: ESearchCase /* = IgnoreCase */): boolean;

        static EqualEqual_StriStri(A: string, B: string): boolean;

        static EqualEqual_StrStr(A: string, B: string): boolean;

        static FindSubstring(SearchIn: string, Substring: string, bUseCase?: boolean /* = false */, bSearchFromEnd?: boolean /* = false */, StartPosition?: number /* = -1 */): number;

        static GetCharacterArrayFromString(SourceString: string): TArray<string>;

        static GetCharacterAsNumber(SourceString: string, Index?: number /* = 0 */): number;

        static GetSubstring(SourceString: string, StartIndex?: number /* = 0 */, Length?: number /* = 1 */): string;

        static IsEmpty(InString: string): boolean;

        static IsNumeric(SourceString: string): boolean;

        static JoinStringArray(SourceArray: TArray<string>, Separator?: string /* = " " */): string;

        static Left(SourceString: string, Count: number): string;

        static LeftChop(SourceString: string, Count: number): string;

        static LeftPad(SourceString: string, ChCount: number): string;

        static Len(S: string): number;

        static MatchesWildcard(SourceString: string, Wildcard: string, SearchCase?: ESearchCase /* = IgnoreCase */): boolean;

        static Mid(SourceString: string, Start: number, Count: number): string;

        static NotEqual_StriStri(A: string, B: string): boolean;

        static NotEqual_StrStr(A: string, B: string): boolean;

        static ParseIntoArray(SourceString: string, Delimiter?: string /* = " " */, CullEmptyStrings?: boolean /* = true */): TArray<string>;

        static Replace(SourceString: string, From: string, To: string, SearchCase?: ESearchCase /* = IgnoreCase */): string;

        static ReplaceInline(SourceString: $Ref<string>, SearchText: string, ReplacementText: string, SearchCase?: ESearchCase /* = IgnoreCase */): number;

        static Reverse(SourceString: string): string;

        static Right(SourceString: string, Count: number): string;

        static RightChop(SourceString: string, Count: number): string;

        static RightPad(SourceString: string, ChCount: number): string;

        static Split(SourceString: string, InStr: string, LeftS: $Ref<string>, RightS: $Ref<string>, SearchCase?: ESearchCase /* = IgnoreCase */, SearchDir?: ESearchDir /* = FromStart */): boolean;

        static StartsWith(SourceString: string, InPrefix: string, SearchCase?: ESearchCase /* = IgnoreCase */): boolean;

        static TimeSecondsToString(InSeconds: number): string;

        static ToLower(SourceString: string): string;

        static ToUpper(SourceString: string): string;

        static Trim(SourceString: string): string;

        static TrimTrailing(SourceString: string): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetStringLibrary;

        static Load(InName: string): KismetStringLibrary;
    }

    export class KismetStringTableLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetKeysFromStringTable(TableId: string): TArray<string>;

        static GetMetaDataIdsFromStringTableEntry(TableId: string, Key: string): TArray<string>;

        static GetRegisteredStringTables(): TArray<string>;

        static GetTableEntryMetaData(TableId: string, Key: string, MetaDataId: string): string;

        static GetTableEntrySourceString(TableId: string, Key: string): string;

        static GetTableNamespace(TableId: string): string;

        static IsRegisteredTableEntry(TableId: string, Key: string): boolean;

        static IsRegisteredTableId(TableId: string): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetStringTableLibrary;

        static Load(InName: string): KismetStringTableLibrary;
    }

    export class UserActivity {
        constructor();
        constructor(ActionName: string);

        ActionName: string;

        static StaticClass(): Class;
    }

    export class GenericStruct {
        constructor();
        constructor(Data: number);

        Data: number;

        static StaticClass(): Class;
    }

    export enum EPropertyAccessChangeNotifyMode { Default, Never, Always, EPropertyAccessChangeNotifyMode_MAX }

    export enum EQuitPreference { Quit, Background, EQuitPreference_MAX }

    export enum EMoveComponentAction { Move, Stop, Return, EMoveComponentAction_MAX }

    export class TimerHandle {
        constructor();
        constructor(Handle: bigint);

        Handle: bigint;

        static StaticClass(): Class;
    }

    export class DebugFloatHistory {
        constructor();
        constructor(Samples: TArray<number>, MaxSamples: number, MinValue: number, MaxValue: number, bAutoAdjustMinMax: boolean);

        Samples: TArray<number>;
        MaxSamples: number;
        MinValue: number;
        MaxValue: number;
        bAutoAdjustMinMax: boolean;

        static StaticClass(): Class;
    }

    export class KismetSystemLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnAssetClassLoaded__DelegateSignature(Loaded: $Nullable<Class>): void;

        OnAssetLoaded__DelegateSignature(Loaded: $Nullable<Object>): void;

        static AddFloatHistorySample(Value: number, FloatHistory: DebugFloatHistory): DebugFloatHistory;

        static BeginTransaction(Context: string, Description: string, PrimaryObject: $Nullable<Object>): number;

        static BoxOverlapActors(WorldContextObject: $Nullable<Object>, BoxPos: Vector, BoxExtent: Vector, ObjectTypes: TArray<EObjectTypeQuery>, ActorClassFilter: $Nullable<Class>, ActorsToIgnore: TArray<Actor>, OutActors: $Ref<TArray<Actor>>): boolean;

        static BoxOverlapComponents(WorldContextObject: $Nullable<Object>, BoxPos: Vector, Extent: Vector, ObjectTypes: TArray<EObjectTypeQuery>, ComponentClassFilter: $Nullable<Class>, ActorsToIgnore: TArray<Actor>, OutComponents: $Ref<TArray<PrimitiveComponent>>): boolean;

        static BoxTraceMulti(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static BoxTraceMultiByProfile(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static BoxTraceMultiForObjects(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static BoxTraceSingle(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static BoxTraceSingleByProfile(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static BoxTraceSingleForObjects(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static BreakSoftClassPath(InSoftClassPath: SoftClassPath, PathString: $Ref<string>): void;

        static BreakSoftObjectPath(InSoftObjectPath: SoftObjectPath, PathString: $Ref<string>): void;

        static CancelTransaction(Index: number): void;

        static CanLaunchURL(URL: string): boolean;

        static CapsuleOverlapActors(WorldContextObject: $Nullable<Object>, CapsulePos: Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<EObjectTypeQuery>, ActorClassFilter: $Nullable<Class>, ActorsToIgnore: TArray<Actor>, OutActors: $Ref<TArray<Actor>>): boolean;

        static CapsuleOverlapComponents(WorldContextObject: $Nullable<Object>, CapsulePos: Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<EObjectTypeQuery>, ComponentClassFilter: $Nullable<Class>, ActorsToIgnore: TArray<Actor>, OutComponents: $Ref<TArray<PrimitiveComponent>>): boolean;

        static CapsuleTraceMulti(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, HalfHeight: number, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static CapsuleTraceMultiByProfile(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, HalfHeight: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static CapsuleTraceMultiForObjects(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static CapsuleTraceSingle(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, HalfHeight: number, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static CapsuleTraceSingleByProfile(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, HalfHeight: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static CapsuleTraceSingleForObjects(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static CollectGarbage(): void;

        static ComponentOverlapActors(Component: $Nullable<PrimitiveComponent>, ComponentTransform: Transform, ObjectTypes: TArray<EObjectTypeQuery>, ActorClassFilter: $Nullable<Class>, ActorsToIgnore: TArray<Actor>, OutActors: $Ref<TArray<Actor>>): boolean;

        static ComponentOverlapComponents(Component: $Nullable<PrimitiveComponent>, ComponentTransform: Transform, ObjectTypes: TArray<EObjectTypeQuery>, ComponentClassFilter: $Nullable<Class>, ActorsToIgnore: TArray<Actor>, OutComponents: $Ref<TArray<PrimitiveComponent>>): boolean;

        static ControlScreensaver(bAllowScreenSaver: boolean): void;

        static Conv_ClassToSoftClassReference(Class: Class): TSoftClassPtr<Object>;

        static Conv_InterfaceToObject(Interface: Interface): Object;

        static Conv_ObjectToSoftObjectReference(Object: $Nullable<Object>): TSoftObjectPtr<Object>;

        static Conv_PrimaryAssetIdToString(PrimaryAssetId: PrimaryAssetId): string;

        static Conv_PrimaryAssetTypeToString(PrimaryAssetType: PrimaryAssetType): string;

        static Conv_SoftClassPathToSoftClassRef(SoftClassPath: SoftClassPath): TSoftClassPtr<Object>;

        static Conv_SoftClassReferenceToClass(SoftClass: TSoftClassPtr<Object>): Class;

        static Conv_SoftClassReferenceToString(SoftClassReference: TSoftClassPtr<Object>): string;

        static Conv_SoftObjectReferenceToObject(SoftObject: TSoftObjectPtr<Object>): Object;

        static Conv_SoftObjectReferenceToString(SoftObjectReference: TSoftObjectPtr<Object>): string;

        static Conv_SoftObjPathToSoftObjRef(SoftObjectPath: SoftObjectPath): TSoftObjectPtr<Object>;

        static ConvertToAbsolutePath(Filename: string): string;

        static ConvertToRelativePath(Filename: string): string;

        static CreateCopyForUndoBuffer(ObjectToModify: $Nullable<Object>): void;

        static Delay(WorldContextObject: $Nullable<Object>, Duration: number, LatentInfo: LatentActionInfo): void;

        static DoesImplementInterface(TestObject: $Nullable<Object>, Interface: $Nullable<Class>): boolean;

        static DrawDebugArrow(WorldContextObject: $Nullable<Object>, LineStart: Vector, LineEnd: Vector, ArrowSize: number, LineColor: LinearColor, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugBox(WorldContextObject: $Nullable<Object>, Center: Vector, Extent: Vector, LineColor: LinearColor, Rotation?: Rotator /* =  */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugCamera(CameraActor: $Nullable<CameraActor>, CameraColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */): void;

        static DrawDebugCapsule(WorldContextObject: $Nullable<Object>, Center: Vector, HalfHeight: number, Radius: number, Rotation: Rotator, LineColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugCircle(WorldContextObject: $Nullable<Object>, Center: Vector, Radius: number, NumSegments?: number /* = 12 */, LineColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */, YAxis?: Vector /* = 0.000000,1.000000,0.000000 */, ZAxis?: Vector /* = 0.000000,0.000000,1.000000 */, bDrawAxis?: boolean /* = false */): void;

        static DrawDebugCone(WorldContextObject: $Nullable<Object>, Origin: Vector, Direction: Vector, Length: number, AngleWidth: number, AngleHeight: number, NumSides: number, LineColor: LinearColor, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugConeInDegrees(WorldContextObject: $Nullable<Object>, Origin: Vector, Direction: Vector, Length?: number /* = 100.000000 */, AngleWidth?: number /* = 45.000000 */, AngleHeight?: number /* = 45.000000 */, NumSides?: number /* = 12 */, LineColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugCoordinateSystem(WorldContextObject: $Nullable<Object>, AxisLoc: Vector, AxisRot: Rotator, Scale?: number /* = 1.000000 */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugCylinder(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius?: number /* = 100.000000 */, Segments?: number /* = 12 */, LineColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugFloatHistoryLocation(WorldContextObject: $Nullable<Object>, FloatHistory: DebugFloatHistory, DrawLocation: Vector, DrawSize: Vector2D, DrawColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */): void;

        static DrawDebugFloatHistoryTransform(WorldContextObject: $Nullable<Object>, FloatHistory: DebugFloatHistory, DrawTransform: Transform, DrawSize: Vector2D, DrawColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */): void;

        static DrawDebugFrustum(WorldContextObject: $Nullable<Object>, FrustumTransform: Transform, FrustumColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugLine(WorldContextObject: $Nullable<Object>, LineStart: Vector, LineEnd: Vector, LineColor: LinearColor, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugPlane(WorldContextObject: $Nullable<Object>, PlaneCoordinates: Plane, Location: Vector, Size: number, PlaneColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */): void;

        static DrawDebugPoint(WorldContextObject: $Nullable<Object>, Position: Vector, Size: number, PointColor: LinearColor, Duration?: number /* = 0.000000 */): void;

        static DrawDebugSphere(WorldContextObject: $Nullable<Object>, Center: Vector, Radius?: number /* = 100.000000 */, Segments?: number /* = 12 */, LineColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */, Thickness?: number /* = 0.000000 */): void;

        static DrawDebugString(WorldContextObject: $Nullable<Object>, TextLocation: Vector, Text: string, TestBaseActor?: Actor /* = None */, TextColor?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */): void;

        static EndTransaction(): number;

        static EqualEqual_PrimaryAssetId(A: PrimaryAssetId, B: PrimaryAssetId): boolean;

        static EqualEqual_PrimaryAssetType(A: PrimaryAssetType, B: PrimaryAssetType): boolean;

        static EqualEqual_SoftClassReference(A: TSoftClassPtr<Object>, B: TSoftClassPtr<Object>): boolean;

        static EqualEqual_SoftObjectReference(A: TSoftObjectPtr<Object>, B: TSoftObjectPtr<Object>): boolean;

        static ExecuteConsoleCommand(WorldContextObject: $Nullable<Object>, Command: string, SpecificPlayer?: PlayerController /* = None */): void;

        static FlushDebugStrings(WorldContextObject: $Nullable<Object>): void;

        static FlushPersistentDebugLines(WorldContextObject: $Nullable<Object>): void;

        static ForceCloseAdBanner(): void;

        static GetActorBounds(Actor: $Nullable<Actor>, Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>): void;

        static GetActorListFromComponentList(ComponentList: TArray<PrimitiveComponent>, ActorClassFilter: $Nullable<Class>, OutActorList: $Ref<TArray<Actor>>): void;

        static GetAdIDCount(): number;

        static GetClassDisplayName(Class: $Nullable<Class>): string;

        static GetClassFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): Class;

        static GetCommandLine(): string;

        static GetComponentBounds(Component: $Nullable<SceneComponent>, Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>, SphereRadius: $Ref<number>): void;

        static GetConsoleVariableBoolValue(VariableName: string): boolean;

        static GetConsoleVariableFloatValue(VariableName: string): number;

        static GetConsoleVariableIntValue(VariableName: string): number;

        static GetConvenientWindowedResolutions(Resolutions: $Ref<TArray<IntPoint>>): boolean;

        static GetCurrentBundleState(PrimaryAssetId: PrimaryAssetId, bForceCurrentState: boolean, OutBundles: $Ref<TArray<string>>): boolean;

        static GetDefaultLanguage(): string;

        static GetDefaultLocale(): string;

        static GetDeviceId(): string;

        static GetDisplayName(Object: $Nullable<Object>): string;

        static GetEditorProperty(Object: $Nullable<Object>, PropertyName: string, PropertyValue: $Ref<number>): boolean;

        static GetEngineVersion(): string;

        static GetFrameCount(): bigint;

        static GetGameBundleId(): string;

        static GetGameName(): string;

        static GetGamepadButtonGlyph(ButtonKey: string, ControllerIndex: number): Texture2D;

        static GetGamepadControllerName(ControllerId: number): string;

        static GetGameTimeInSeconds(WorldContextObject: $Nullable<Object>): number;

        static GetLocalCurrencyCode(): string;

        static GetLocalCurrencySymbol(): string;

        static GetMinYResolutionFor3DView(): number;

        static GetMinYResolutionForUI(): number;

        static GetObjectFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): Object;

        static GetObjectName(Object: $Nullable<Object>): string;

        static GetOuterObject(Object: $Nullable<Object>): Object;

        static GetPathName(Object: $Nullable<Object>): string;

        static GetPlatformUserDir(): string;

        static GetPlatformUserName(): string;

        static GetPreferredLanguages(): TArray<string>;

        static GetPrimaryAssetIdFromClass(Class: $Nullable<Class>): PrimaryAssetId;

        static GetPrimaryAssetIdFromObject(Object: $Nullable<Object>): PrimaryAssetId;

        static GetPrimaryAssetIdFromSoftClassReference(SoftClassReference: TSoftClassPtr<Object>): PrimaryAssetId;

        static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: TSoftObjectPtr<Object>): PrimaryAssetId;

        static GetPrimaryAssetIdList(PrimaryAssetType: PrimaryAssetType, OutPrimaryAssetIdList: $Ref<TArray<PrimaryAssetId>>): void;

        static GetPrimaryAssetsWithBundleState(RequiredBundles: TArray<string>, ExcludedBundles: TArray<string>, ValidTypes: TArray<PrimaryAssetType>, bForceCurrentState: boolean, OutPrimaryAssetIdList: $Ref<TArray<PrimaryAssetId>>): void;

        static GetProjectContentDirectory(): string;

        static GetProjectDirectory(): string;

        static GetProjectSavedDirectory(): string;

        static GetRenderingDetailMode(): number;

        static GetRenderingMaterialQualityLevel(): number;

        static GetSoftClassReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): TSoftClassPtr<Object>;

        static GetSoftObjectReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): TSoftObjectPtr<Object>;

        static GetSupportedFullscreenResolutions(Resolutions: $Ref<TArray<IntPoint>>): boolean;

        static GetSystemPath(Object: $Nullable<Object>): string;

        static GetUniqueDeviceId(): string;

        static GetVolumeButtonsHandledBySystem(): boolean;

        static HideAdBanner(): void;

        static IsControllerAssignedToGamepad(ControllerId: number): boolean;

        static IsDedicatedServer(WorldContextObject: $Nullable<Object>): boolean;

        static IsInterstitialAdAvailable(): boolean;

        static IsInterstitialAdRequested(): boolean;

        static IsLoggedIn(SpecificPlayer: $Nullable<PlayerController>): boolean;

        static IsPackagedForDistribution(): boolean;

        static IsScreensaverEnabled(): boolean;

        static IsServer(WorldContextObject: $Nullable<Object>): boolean;

        static IsSplitScreen(WorldContextObject: $Nullable<Object>): boolean;

        static IsStandalone(WorldContextObject: $Nullable<Object>): boolean;

        static IsUnattended(): boolean;

        static IsValid(Object: $Nullable<Object>): boolean;

        static IsValidClass(Class: $Nullable<Class>): boolean;

        static IsValidPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): boolean;

        static IsValidPrimaryAssetType(PrimaryAssetType: PrimaryAssetType): boolean;

        static IsValidSoftClassReference(SoftClassReference: TSoftClassPtr<Object>): boolean;

        static IsValidSoftObjectReference(SoftObjectReference: TSoftObjectPtr<Object>): boolean;

        static K2_ClearAndInvalidateTimerHandle(WorldContextObject: $Nullable<Object>, Handle: $Ref<TimerHandle>): void;

        static K2_ClearTimer(Object: $Nullable<Object>, FunctionName: string): void;

        static K2_ClearTimerDelegate(Delegate: $Delegate<() => void>): void;

        static K2_ClearTimerHandle(WorldContextObject: $Nullable<Object>, Handle: TimerHandle): void;

        static K2_GetTimerElapsedTime(Object: $Nullable<Object>, FunctionName: string): number;

        static K2_GetTimerElapsedTimeDelegate(Delegate: $Delegate<() => void>): number;

        static K2_GetTimerElapsedTimeHandle(WorldContextObject: $Nullable<Object>, Handle: TimerHandle): number;

        static K2_GetTimerRemainingTime(Object: $Nullable<Object>, FunctionName: string): number;

        static K2_GetTimerRemainingTimeDelegate(Delegate: $Delegate<() => void>): number;

        static K2_GetTimerRemainingTimeHandle(WorldContextObject: $Nullable<Object>, Handle: TimerHandle): number;

        static K2_InvalidateTimerHandle(Handle: $Ref<TimerHandle>): TimerHandle;

        static K2_IsTimerActive(Object: $Nullable<Object>, FunctionName: string): boolean;

        static K2_IsTimerActiveDelegate(Delegate: $Delegate<() => void>): boolean;

        static K2_IsTimerActiveHandle(WorldContextObject: $Nullable<Object>, Handle: TimerHandle): boolean;

        static K2_IsTimerPaused(Object: $Nullable<Object>, FunctionName: string): boolean;

        static K2_IsTimerPausedDelegate(Delegate: $Delegate<() => void>): boolean;

        static K2_IsTimerPausedHandle(WorldContextObject: $Nullable<Object>, Handle: TimerHandle): boolean;

        static K2_IsValidTimerHandle(Handle: TimerHandle): boolean;

        static K2_PauseTimer(Object: $Nullable<Object>, FunctionName: string): void;

        static K2_PauseTimerDelegate(Delegate: $Delegate<() => void>): void;

        static K2_PauseTimerHandle(WorldContextObject: $Nullable<Object>, Handle: TimerHandle): void;

        static K2_SetTimer(Object: $Nullable<Object>, FunctionName: string, Time: number, bLooping: boolean, InitialStartDelay?: number /* = 0.000000 */, InitialStartDelayVariance?: number /* = 0.000000 */): TimerHandle;

        static K2_SetTimerDelegate(Delegate: $Delegate<() => void>, Time: number, bLooping: boolean, InitialStartDelay?: number /* = 0.000000 */, InitialStartDelayVariance?: number /* = 0.000000 */): TimerHandle;

        static K2_TimerExists(Object: $Nullable<Object>, FunctionName: string): boolean;

        static K2_TimerExistsDelegate(Delegate: $Delegate<() => void>): boolean;

        static K2_TimerExistsHandle(WorldContextObject: $Nullable<Object>, Handle: TimerHandle): boolean;

        static K2_UnPauseTimer(Object: $Nullable<Object>, FunctionName: string): void;

        static K2_UnPauseTimerDelegate(Delegate: $Delegate<() => void>): void;

        static K2_UnPauseTimerHandle(WorldContextObject: $Nullable<Object>, Handle: TimerHandle): void;

        static LaunchURL(URL: string): void;

        static LineTraceMulti(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static LineTraceMultiByProfile(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static LineTraceMultiForObjects(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static LineTraceSingle(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static LineTraceSingleByProfile(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static LineTraceSingleForObjects(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static LoadAsset(WorldContextObject: $Nullable<Object>, Asset: TSoftObjectPtr<Object>, OnLoaded: $Delegate<(Loaded: $Nullable<Object>) => void>, LatentInfo: LatentActionInfo): void;

        static LoadAsset_Blocking(Asset: TSoftObjectPtr<Object>): Object;

        static LoadAssetClass(WorldContextObject: $Nullable<Object>, AssetClass: TSoftClassPtr<Object>, OnLoaded: $Delegate<(Loaded: $Nullable<Class>) => void>, LatentInfo: LatentActionInfo): void;

        static LoadClassAsset_Blocking(AssetClass: TSoftClassPtr<Object>): Class;

        static LoadInterstitialAd(AdIdIndex: number): void;

        static MakeLiteralBool(Value: boolean): boolean;

        static MakeLiteralByte(Value: number): number;

        static MakeLiteralFloat(Value: number): number;

        static MakeLiteralInt(Value: number): number;

        static MakeLiteralName(Value: string): string;

        static MakeLiteralString(Value: string): string;

        static MakeLiteralText(Value: string): string;

        static MakeSoftClassPath(PathString: string): SoftClassPath;

        static MakeSoftObjectPath(PathString: string): SoftObjectPath;

        static MoveComponentTo(Component: $Nullable<SceneComponent>, TargetRelativeLocation: Vector, TargetRelativeRotation: Rotator, bEaseOut: boolean, bEaseIn: boolean, OverTime: number, bForceShortestRotationPath: boolean, MoveAction: EMoveComponentAction, LatentInfo: LatentActionInfo): void;

        static NormalizeFilename(InFilename: string): string;

        static NotEqual_PrimaryAssetId(A: PrimaryAssetId, B: PrimaryAssetId): boolean;

        static NotEqual_PrimaryAssetType(A: PrimaryAssetType, B: PrimaryAssetType): boolean;

        static NotEqual_SoftClassReference(A: TSoftClassPtr<Object>, B: TSoftClassPtr<Object>): boolean;

        static NotEqual_SoftObjectReference(A: TSoftObjectPtr<Object>, B: TSoftObjectPtr<Object>): boolean;

        static ParseCommandLine(InCmdLine: string, OutTokens: $Ref<TArray<string>>, OutSwitches: $Ref<TArray<string>>, OutParams: $Ref<TMap<string, string>>): void;

        static ParseParam(InString: string, InParam: string): boolean;

        static ParseParamValue(InString: string, InParam: string, OutValue: $Ref<string>): boolean;

        static PrintString(WorldContextObject: $Nullable<Object>, InString?: string /* = "Hello" */, bPrintToScreen?: boolean /* = true */, bPrintToLog?: boolean /* = true */, TextColor?: LinearColor /* = (R=0.000000,G=0.660000,B=1.000000,A=1.000000) */, Duration?: number /* = 2.000000 */): void;

        static PrintText(WorldContextObject: $Nullable<Object>, InText?: string /* = "INVTEXT("Hello")" */, bPrintToScreen?: boolean /* = true */, bPrintToLog?: boolean /* = true */, TextColor?: LinearColor /* = (R=0.000000,G=0.660000,B=1.000000,A=1.000000) */, Duration?: number /* = 2.000000 */): void;

        static PrintWarning(InString: string): void;

        static QuitEditor(): void;

        static QuitGame(WorldContextObject: $Nullable<Object>, SpecificPlayer: $Nullable<PlayerController>, QuitPreference: EQuitPreference, bIgnorePlatformRestrictions: boolean): void;

        static RegisterForRemoteNotifications(): void;

        static ResetGamepadAssignments(): void;

        static ResetGamepadAssignmentToController(ControllerId: number): void;

        static RetriggerableDelay(WorldContextObject: $Nullable<Object>, Duration: number, LatentInfo: LatentActionInfo): void;

        static SetBoolPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: boolean): void;

        static SetBytePropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: number): void;

        static SetClassPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: $Nullable<Class>): void;

        static SetCollisionProfileNameProperty(Object: $Nullable<Object>, PropertyName: string, Value: CollisionProfileName): void;

        static SetColorPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: Color): void;

        static SetEditorProperty(Object: $Nullable<Object>, PropertyName: string, PropertyValue: number, ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;

        static SetFloatPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: number): void;

        static SetGamepadsBlockDeviceFeedback(bBlock: boolean): void;

        static SetInt64PropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: bigint): void;

        static SetInterfacePropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: Interface): void;

        static SetIntPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: number): void;

        static SetLinearColorPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: LinearColor): void;

        static SetNamePropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: string): void;

        static SetObjectPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: $Nullable<Object>): void;

        static SetRotatorPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: Rotator): void;

        static SetSoftClassPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: TSoftClassPtr<Object>): void;

        static SetSoftObjectPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: TSoftObjectPtr<Object>): void;

        static SetStringPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: string): void;

        static SetStructurePropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: GenericStruct): void;

        static SetSuppressViewportTransitionMessage(WorldContextObject: $Nullable<Object>, bState: boolean): void;

        static SetTextPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: string): void;

        static SetTransformPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: Transform): void;

        static SetUserActivity(UserActivity: UserActivity): void;

        static SetVectorPropertyByName(Object: $Nullable<Object>, PropertyName: string, Value: Vector): void;

        static SetVolumeButtonsHandledBySystem(bEnabled: boolean): void;

        static SetWindowTitle(Title: string): void;

        static ShowAdBanner(AdIdIndex: number, bShowOnBottomOfScreen: boolean): void;

        static ShowInterstitialAd(): void;

        static ShowPlatformSpecificAchievementsScreen(SpecificPlayer: $Nullable<PlayerController>): void;

        static ShowPlatformSpecificLeaderboardScreen(CategoryName: string): void;

        static SnapshotObject(Object: $Nullable<Object>): void;

        static SphereOverlapActors(WorldContextObject: $Nullable<Object>, SpherePos: Vector, SphereRadius: number, ObjectTypes: TArray<EObjectTypeQuery>, ActorClassFilter: $Nullable<Class>, ActorsToIgnore: TArray<Actor>, OutActors: $Ref<TArray<Actor>>): boolean;

        static SphereOverlapComponents(WorldContextObject: $Nullable<Object>, SpherePos: Vector, SphereRadius: number, ObjectTypes: TArray<EObjectTypeQuery>, ComponentClassFilter: $Nullable<Class>, ActorsToIgnore: TArray<Actor>, OutComponents: $Ref<TArray<PrimitiveComponent>>): boolean;

        static SphereTraceMulti(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static SphereTraceMultiByProfile(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static SphereTraceMultiForObjects(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static SphereTraceSingle(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, TraceChannel: ETraceTypeQuery, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static SphereTraceSingleByProfile(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static SphereTraceSingleForObjects(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, Radius: number, ObjectTypes: TArray<EObjectTypeQuery>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: EDrawDebugTrace, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor?: LinearColor /* = (R=1.000000,G=0.000000,B=0.000000,A=1.000000) */, TraceHitColor?: LinearColor /* = (R=0.000000,G=1.000000,B=0.000000,A=1.000000) */, DrawTime?: number /* = 5.000000 */): boolean;

        static StackTrace(): void;

        static TransactObject(Object: $Nullable<Object>): void;

        static UnloadPrimaryAsset(PrimaryAssetId: PrimaryAssetId): void;

        static UnloadPrimaryAssetList(PrimaryAssetIdList: TArray<PrimaryAssetId>): void;

        static UnregisterForRemoteNotifications(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetSystemLibrary;

        static Load(InName: string): KismetSystemLibrary;
    }

    export class PolyglotTextData {
        constructor();
        constructor(Category: ELocalizedTextSourceCategory, NativeCulture: string, Namespace: string, Key: string, NativeString: string, LocalizedStrings: TMap<string, string>, bIsMinimalPatch: boolean, CachedText: string);

        Category: ELocalizedTextSourceCategory;
        NativeCulture: string;
        Namespace: string;
        Key: string;
        NativeString: string;
        LocalizedStrings: TMap<string, string>;
        bIsMinimalPatch: boolean;
        CachedText: string;

        static StaticClass(): Class;
    }

    export enum EFormatArgumentType { Int, UInt, Float, Double, Text, Gender, EFormatArgumentType_MAX }

    export enum ETextGender { Masculine, Feminine, Neuter, ETextGender_MAX }

    export class FormatArgumentData {
        constructor();
        constructor(ArgumentName: string, ArgumentValueType: EFormatArgumentType, ArgumentValue: string, ArgumentValueInt: number, ArgumentValueFloat: number, ArgumentValueGender: ETextGender);

        ArgumentName: string;
        ArgumentValueType: EFormatArgumentType;
        ArgumentValue: string;
        ArgumentValueInt: number;
        ArgumentValueFloat: number;
        ArgumentValueGender: ETextGender;

        static StaticClass(): Class;
    }

    export enum ERoundingMode {
        HalfToEven,
        HalfFromZero,
        HalfToZero,
        FromZero,
        ToZero,
        ToNegativeInfinity,
        ToPositiveInfinity,
        ERoundingMode_MAX
    }

    export class KismetTextLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AsCurrency_Float(Value: number, RoundingMode: ERoundingMode, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */, MinimumFractionalDigits?: number /* = 0 */, MaximumFractionalDigits?: number /* = 3 */, CurrencyCode?: string /* = "" */): string;

        static AsCurrency_Integer(Value: number, RoundingMode: ERoundingMode, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */, MinimumFractionalDigits?: number /* = 0 */, MaximumFractionalDigits?: number /* = 3 */, CurrencyCode?: string /* = "" */): string;

        static AsCurrencyBase(BaseValue: number, CurrencyCode: string): string;

        static AsDate_DateTime(InDateTime: DateTime): string;

        static AsDateTime_DateTime(In: DateTime): string;

        static AsPercent_Float(Value: number, RoundingMode: ERoundingMode, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */, MinimumFractionalDigits?: number /* = 0 */, MaximumFractionalDigits?: number /* = 3 */): string;

        static AsTime_DateTime(In: DateTime): string;

        static AsTimespan_Timespan(InTimespan: Timespan): string;

        static AsTimeZoneDate_DateTime(InDateTime: DateTime, InTimeZone?: string /* = "" */): string;

        static AsTimeZoneDateTime_DateTime(InDateTime: DateTime, InTimeZone?: string /* = "" */): string;

        static AsTimeZoneTime_DateTime(InDateTime: DateTime, InTimeZone?: string /* = "" */): string;

        static Conv_BoolToText(InBool: boolean): string;

        static Conv_ByteToText(Value: number): string;

        static Conv_ColorToText(InColor: LinearColor): string;

        static Conv_FloatToText(Value: number, RoundingMode: ERoundingMode, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */, MinimumFractionalDigits?: number /* = 0 */, MaximumFractionalDigits?: number /* = 3 */): string;

        static Conv_Int64ToText(Value: bigint, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */): string;

        static Conv_IntToText(Value: number, bAlwaysSign?: boolean /* = false */, bUseGrouping?: boolean /* = true */, MinimumIntegralDigits?: number /* = 1 */, MaximumIntegralDigits?: number /* = 324 */): string;

        static Conv_NameToText(InName: string): string;

        static Conv_ObjectToText(InObj: $Nullable<Object>): string;

        static Conv_RotatorToText(InRot: Rotator): string;

        static Conv_StringToText(InString: string): string;

        static Conv_TextToString(InText: string): string;

        static Conv_TransformToText(InTrans: Transform): string;

        static Conv_Vector2dToText(InVec: Vector2D): string;

        static Conv_VectorToText(InVec: Vector): string;

        static EqualEqual_IgnoreCase_TextText(A: string, B: string): boolean;

        static EqualEqual_TextText(A: string, B: string): boolean;

        static FindTextInLocalizationTable(Namespace: string, Key: string, OutText: $Ref<string>): boolean;

        static Format(InPattern: string, InArgs: TArray<FormatArgumentData>): string;

        static GetEmptyText(): string;

        static IsPolyglotDataValid(PolyglotData: PolyglotTextData, IsValid: $Ref<boolean>, ErrorMessage: $Ref<string>): void;

        static NotEqual_IgnoreCase_TextText(A: string, B: string): boolean;

        static NotEqual_TextText(A: string, B: string): boolean;

        static PolyglotDataToText(PolyglotData: PolyglotTextData): string;

        static StringTableIdAndKeyFromText(Text: string, OutTableId: $Ref<string>, OutKey: $Ref<string>): boolean;

        static TextFromStringTable(TableId: string, Key: string): string;

        static TextIsCultureInvariant(InText: string): boolean;

        static TextIsEmpty(InText: string): boolean;

        static TextIsFromStringTable(Text: string): boolean;

        static TextIsTransient(InText: string): boolean;

        static TextToLower(InText: string): string;

        static TextToUpper(InText: string): string;

        static TextTrimPreceding(InText: string): string;

        static TextTrimPrecedingAndTrailing(InText: string): string;

        static TextTrimTrailing(InText: string): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): KismetTextLibrary;

        static Load(InName: string): KismetTextLibrary;
    }

    export class LandscapeSplineSegmentConnection {
        constructor();
        constructor(ControlPoint: LandscapeSplineControlPoint, TangentLen: number, SocketName: string);

        ControlPoint: LandscapeSplineControlPoint;
        TangentLen: number;
        SocketName: string;

        static StaticClass(): Class;
    }

    export enum LandscapeSplineMeshOrientation { LSMO_XUp, LSMO_YUp, LSMO_MAX }

    export class LandscapeSplineMeshEntry {
        constructor();
        constructor(Mesh: StaticMesh, MaterialOverrides: TArray<MaterialInterface>, bCenterH: boolean, CenterAdjust: Vector2D, bScaleToWidth: boolean, Scale: Vector, Orientation: LandscapeSplineMeshOrientation, ForwardAxis: ESplineMeshAxis, UpAxis: ESplineMeshAxis);

        Mesh: StaticMesh;
        MaterialOverrides: TArray<MaterialInterface>;
        bCenterH: boolean;
        CenterAdjust: Vector2D;
        bScaleToWidth: boolean;
        Scale: Vector;
        Orientation: LandscapeSplineMeshOrientation;
        ForwardAxis: ESplineMeshAxis;
        UpAxis: ESplineMeshAxis;

        static StaticClass(): Class;
    }

    export class LandscapeSplineInterpPoint {
        constructor();
        constructor(Center: Vector, Left: Vector, Right: Vector, FalloffLeft: Vector, FalloffRight: Vector, LayerLeft: Vector, LayerRight: Vector, LayerFalloffLeft: Vector, LayerFalloffRight: Vector, StartEndFalloff: number);

        Center: Vector;
        Left: Vector;
        Right: Vector;
        FalloffLeft: Vector;
        FalloffRight: Vector;
        LayerLeft: Vector;
        LayerRight: Vector;
        LayerFalloffLeft: Vector;
        LayerFalloffRight: Vector;
        StartEndFalloff: number;

        static StaticClass(): Class;
    }

    export class LandscapeSplineSegment extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Connections: FixSizeArray<LandscapeSplineSegmentConnection>;
        LayerName: string;
        bRaiseTerrain: boolean;
        bLowerTerrain: boolean;
        SplineMeshes: TArray<LandscapeSplineMeshEntry>;
        bEnableCollision: boolean;
        CollisionProfileName: string;
        bCastShadow: boolean;
        bHiddenInGame: boolean;
        bPlaceSplineMeshesInStreamingLevels: boolean;
        RandomSeed: number;
        LDMaxDrawDistance: number;
        TranslucencySortPriority: number;
        bRenderCustomDepth: boolean;
        CustomDepthStencilWriteMask: ERendererStencilMask;
        CustomDepthStencilValue: number;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMainPassMaxDrawDistance: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        BodyInstance: BodyInstance;
        bSelected: boolean;
        bNavDirty: boolean;
        SplineInfo: InterpCurveVector;
        Points: TArray<LandscapeSplineInterpPoint>;
        Bounds: Box;
        LocalMeshComponents: TArray<SplineMeshComponent>;
        ForeignWorlds: TArray<TSoftObjectPtr<World>>;
        ModificationKey: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeSplineSegment;

        static Load(InName: string): LandscapeSplineSegment;
    }

    export class LandscapeSplineConnection {
        constructor();
        constructor(Segment: LandscapeSplineSegment, End: boolean);

        Segment: LandscapeSplineSegment;
        End: boolean;

        static StaticClass(): Class;
    }

    export class LandscapeSplineControlPoint extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Location: Vector;
        Rotation: Rotator;
        Width: number;
        LayerWidthRatio: number;
        SideFalloff: number;
        LeftSideFalloffFactor: number;
        RightSideFalloffFactor: number;
        LeftSideLayerFalloffFactor: number;
        RightSideLayerFalloffFactor: number;
        EndFalloff: number;
        SegmentMeshOffset: number;
        LayerName: string;
        bRaiseTerrain: boolean;
        bLowerTerrain: boolean;
        Mesh: StaticMesh;
        MaterialOverrides: TArray<MaterialInterface>;
        MeshScale: Vector;
        bEnableCollision: boolean;
        CollisionProfileName: string;
        bCastShadow: boolean;
        bHiddenInGame: boolean;
        bPlaceSplineMeshesInStreamingLevels: boolean;
        LDMaxDrawDistance: number;
        TranslucencySortPriority: number;
        bRenderCustomDepth: boolean;
        CustomDepthStencilWriteMask: ERendererStencilMask;
        CustomDepthStencilValue: number;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMainPassMaxDrawDistance: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        BodyInstance: BodyInstance;
        bSelected: boolean;
        bNavDirty: boolean;
        ConnectedSegments: TArray<LandscapeSplineConnection>;
        Points: TArray<LandscapeSplineInterpPoint>;
        Bounds: Box;
        LocalMeshComponent: ControlPointMeshComponent;
        ForeignWorld: TSoftObjectPtr<World>;
        ModificationKey: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeSplineControlPoint;

        static Load(InName: string): LandscapeSplineControlPoint;
    }

    export class ForeignControlPointData {
        constructor();
        constructor(ModificationKey: Guid, MeshComponent: ControlPointMeshComponent, Identifier: TLazyObjectPtr<LandscapeSplineControlPoint>);

        ModificationKey: Guid;
        MeshComponent: ControlPointMeshComponent;
        Identifier: TLazyObjectPtr<LandscapeSplineControlPoint>;

        static StaticClass(): Class;
    }

    export class ForeignSplineSegmentData {
        constructor();
        constructor(ModificationKey: Guid, MeshComponents: TArray<SplineMeshComponent>, Identifier: TLazyObjectPtr<LandscapeSplineSegment>);

        ModificationKey: Guid;
        MeshComponents: TArray<SplineMeshComponent>;
        Identifier: TLazyObjectPtr<LandscapeSplineSegment>;

        static StaticClass(): Class;
    }

    export class ForeignWorldSplineData {
        constructor();
        constructor(ForeignControlPointDataMap: TMap<TLazyObjectPtr<LandscapeSplineControlPoint>, ForeignControlPointData>, ForeignControlPointData: TArray<ForeignControlPointData>, ForeignSplineSegmentDataMap: TMap<TLazyObjectPtr<LandscapeSplineSegment>, ForeignSplineSegmentData>, ForeignSplineSegmentData: TArray<ForeignSplineSegmentData>);

        ForeignControlPointDataMap: TMap<TLazyObjectPtr<LandscapeSplineControlPoint>, ForeignControlPointData>;
        ForeignControlPointData: TArray<ForeignControlPointData>;
        ForeignSplineSegmentDataMap: TMap<TLazyObjectPtr<LandscapeSplineSegment>, ForeignSplineSegmentData>;
        ForeignSplineSegmentData: TArray<ForeignSplineSegmentData>;

        static StaticClass(): Class;
    }

    export class LandscapeSplinesComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SplineResolution: number;
        SplineColor: Color;
        ControlPointSprite: Texture2D;
        SplineEditorMesh: StaticMesh;
        bShowSplineEditorMesh: boolean;
        ControlPoints: TArray<LandscapeSplineControlPoint>;
        Segments: TArray<LandscapeSplineSegment>;
        ForeignWorldSplineDataMap: TMap<TSoftObjectPtr<World>, ForeignWorldSplineData>;
        CookedForeignMeshComponents: TArray<MeshComponent>;

        GetSplineMeshComponents(): TArray<SplineMeshComponent>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeSplinesComponent;

        static Load(InName: string): LandscapeSplinesComponent;
    }

    export enum ELandscapeLODFalloff { Linear, SquareRoot, ELandscapeLODFalloff_MAX }

    export enum ELandscapeLayerDisplayMode { Default, Alphabetical, UserSpecific, ELandscapeLayerDisplayMode_MAX }

    export class LandscapeProxyMaterialOverride {
        constructor();
        constructor(LODIndex: PerPlatformInt, Material: MaterialInterface);

        LODIndex: PerPlatformInt;
        Material: MaterialInterface;

        static StaticClass(): Class;
    }

    export class LandscapeComponentMaterialOverride {
        constructor();
        constructor(LODIndex: PerPlatformInt, Material: MaterialInterface);

        LODIndex: PerPlatformInt;
        Material: MaterialInterface;

        static StaticClass(): Class;
    }

    export enum ESplineModulationColorMask { Red, Green, Blue, Alpha, ESplineModulationColorMask_MAX }

    export class LandscapeLayerInfoObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LayerName: string;
        PhysMaterial: PhysicalMaterial;
        Hardness: number;
        MinimumCollisionRelevanceWeight: number;
        bNoWeightBlend: boolean;
        SplineFalloffModulationTexture: Texture2D;
        SplineFalloffModulationColorMask: ESplineModulationColorMask;
        SplineFalloffModulationTiling: number;
        SplineFalloffModulationBias: number;
        SplineFalloffModulationScale: number;
        IsReferencedFromLoadedData: boolean;
        LayerUsageDebugColor: LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeLayerInfoObject;

        static Load(InName: string): LandscapeLayerInfoObject;
    }

    export class LandscapeHeightfieldCollisionComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ComponentLayerInfos: TArray<LandscapeLayerInfoObject>;
        SectionBaseX: number;
        SectionBaseY: number;
        CollisionSizeQuads: number;
        CollisionScale: number;
        SimpleCollisionSizeQuads: number;
        CollisionQuadFlags: TArray<number>;
        HeightfieldGuid: Guid;
        CachedLocalBox: Box;
        RenderComponent: TLazyObjectPtr<LandscapeComponent>;
        PhysicalMaterialRenderObjects: TArray<PhysicalMaterial>;
        CookedPhysicalMaterials: TArray<PhysicalMaterial>;

        GetRenderComponent(): LandscapeComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeHeightfieldCollisionComponent;

        static Load(InName: string): LandscapeHeightfieldCollisionComponent;
    }

    export class HeightmapData {
        constructor();
        constructor(Texture: Texture2D);

        Texture: Texture2D;

        static StaticClass(): Class;
    }

    export class WeightmapLayerAllocationInfo {
        constructor();
        constructor(LayerInfo: LandscapeLayerInfoObject, WeightmapTextureIndex: number, WeightmapTextureChannel: number);

        LayerInfo: LandscapeLayerInfoObject;
        WeightmapTextureIndex: number;
        WeightmapTextureChannel: number;

        static StaticClass(): Class;
    }

    export class LandscapeWeightmapUsage extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChannelUsage: FixSizeArray<LandscapeComponent>;
        LayerGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeWeightmapUsage;

        static Load(InName: string): LandscapeWeightmapUsage;
    }

    export class WeightmapData {
        constructor();
        constructor(Textures: TArray<Texture2D>, LayerAllocations: TArray<WeightmapLayerAllocationInfo>, TextureUsages: TArray<LandscapeWeightmapUsage>);

        Textures: TArray<Texture2D>;
        LayerAllocations: TArray<WeightmapLayerAllocationInfo>;
        TextureUsages: TArray<LandscapeWeightmapUsage>;

        static StaticClass(): Class;
    }

    export class LandscapeLayerComponentData {
        constructor();
        constructor(HeightmapData: HeightmapData, WeightmapData: WeightmapData);

        HeightmapData: HeightmapData;
        WeightmapData: WeightmapData;

        static StaticClass(): Class;
    }

    export class LandscapeLODStreamingProxy extends StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeLODStreamingProxy;

        static Load(InName: string): LandscapeLODStreamingProxy;
    }

    export class LandscapeEditToolRenderData {
        constructor();
        constructor(ToolMaterial: MaterialInterface, GizmoMaterial: MaterialInterface, SelectedType: number, DebugChannelR: number, DebugChannelG: number, DebugChannelB: number, DataTexture: Texture2D, LayerContributionTexture: Texture2D, DirtyTexture: Texture2D);

        ToolMaterial: MaterialInterface;
        GizmoMaterial: MaterialInterface;
        SelectedType: number;
        DebugChannelR: number;
        DebugChannelG: number;
        DebugChannelB: number;
        DataTexture: Texture2D;
        LayerContributionTexture: Texture2D;
        DirtyTexture: Texture2D;

        static StaticClass(): Class;
    }

    export class LandscapeComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SectionBaseX: number;
        SectionBaseY: number;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        NumSubsections: number;
        OverrideMaterial: MaterialInterface;
        OverrideHoleMaterial: MaterialInterface;
        OverrideMaterials: TArray<LandscapeComponentMaterialOverride>;
        MaterialInstance: MaterialInstanceConstant;
        MaterialInstances: TArray<MaterialInstanceConstant>;
        MaterialInstancesDynamic: TArray<MaterialInstanceDynamic>;
        LODIndexToMaterialIndex: TArray<number>;
        MaterialIndexToDisabledTessellationMaterial: TArray<number>;
        XYOffsetmapTexture: Texture2D;
        WeightmapScaleBias: Vector4;
        WeightmapSubsectionOffset: number;
        HeightmapScaleBias: Vector4;
        CachedLocalBox: Box;
        CollisionComponent: TLazyObjectPtr<LandscapeHeightfieldCollisionComponent>;
        LightingGuid: Guid;
        LayersData: TMap<Guid, LandscapeLayerComponentData>;
        WeightmapTexturesUsage: TArray<LandscapeWeightmapUsage>;
        LayerUpdateFlagPerMode: number;
        HeightmapTexture: Texture2D;
        WeightmapLayerAllocations: TArray<WeightmapLayerAllocationInfo>;
        WeightmapTextures: TArray<Texture2D>;
        LODStreamingProxy: LandscapeLODStreamingProxy;
        MapBuildDataId: Guid;
        IrrelevantLights: TArray<Guid>;
        CollisionMipLevel: number;
        SimpleCollisionMipLevel: number;
        NegativeZBoundsExtension: number;
        PositiveZBoundsExtension: number;
        StaticLightingResolution: number;
        ForcedLOD: number;
        LODBias: number;
        StateId: Guid;
        BakedTextureMaterialGuid: Guid;
        GIBakedBaseColorTexture: Texture2D;
        LightingLODBias: number;
        LayerWhitelist: TArray<LandscapeLayerInfoObject>;
        EditToolRenderData: LandscapeEditToolRenderData;
        MobileDataSourceHash: Guid;
        MaterialPerLOD: TMap<MaterialInterface, number>;
        SplineHash: number;
        PhysicalMaterialHash: number;
        MobileBlendableLayerMask: number;
        MobileMaterialInterface: MaterialInterface;
        MobileMaterialInterfaces: TArray<MaterialInterface>;
        MobileWeightmapTextures: TArray<Texture2D>;
        MobileCombinationMaterialInstances: TArray<MaterialInstanceConstant>;
        MobileCombinationMaterialInstance: MaterialInstanceConstant;

        EditorGetPaintLayerWeightAtLocation(InLocation: Vector, PaintLayer: $Nullable<LandscapeLayerInfoObject>): number;

        EditorGetPaintLayerWeightByNameAtLocation(InLocation: Vector, InPaintLayerName: string): number;

        GetMaterialInstanceDynamic(InIndex: number): MaterialInstanceDynamic;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeComponent;

        static Load(InName: string): LandscapeComponent;
    }

    export class LandscapeEditorLayerSettings {
        constructor();
        constructor(LayerInfoObj: LandscapeLayerInfoObject, ReimportLayerFilePath: string);

        LayerInfoObj: LandscapeLayerInfoObject;
        ReimportLayerFilePath: string;

        static StaticClass(): Class;
    }

    export class LandscapeProxy extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SplineComponent: LandscapeSplinesComponent;
        LandscapeGuid: Guid;
        LandscapeSectionOffset: IntPoint;
        MaxLODLevel: number;
        LODDistanceFactor: number;
        LODFalloff: ELandscapeLODFalloff;
        ComponentScreenSizeToUseSubSections: number;
        LOD0ScreenSize: number;
        LOD0DistributionSetting: number;
        LODDistributionSetting: number;
        TessellationComponentScreenSize: number;
        UseTessellationComponentScreenSizeFalloff: boolean;
        TessellationComponentScreenSizeFalloff: number;
        OccluderGeometryLOD: number;
        ExportLOD: number;
        TargetDisplayOrderList: TArray<string>;
        TargetDisplayOrder: ELandscapeLayerDisplayMode;
        StaticLightingLOD: number;
        DefaultPhysMaterial: PhysicalMaterial;
        StreamingDistanceMultiplier: number;
        LandscapeMaterial: MaterialInterface;
        LandscapeHoleMaterial: MaterialInterface;
        LandscapeMaterialsOverride: TArray<LandscapeProxyMaterialOverride>;
        PreEditLandscapeMaterial: MaterialInterface;
        PreEditLandscapeHoleMaterial: MaterialInterface;
        PreEditLandscapeMaterialsOverride: TArray<LandscapeProxyMaterialOverride>;
        bIsPerformingInteractiveActionOnLandscapeMaterialOverride: boolean;
        bMeshHoles: boolean;
        MeshHolesMaxLod: number;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureNumLods: number;
        VirtualTextureLodBias: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        NegativeZBoundsExtension: number;
        PositiveZBoundsExtension: number;
        LandscapeComponents: TArray<LandscapeComponent>;
        CollisionComponents: TArray<LandscapeHeightfieldCollisionComponent>;
        FoliageComponents: TArray<HierarchicalInstancedStaticMeshComponent>;
        bHasLandscapeGrass: boolean;
        StaticLightingResolution: number;
        CastShadow: boolean;
        bCastDynamicShadow: boolean;
        bCastStaticShadow: boolean;
        bCastFarShadow: boolean;
        bCastHiddenShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bAffectDistanceFieldLighting: boolean;
        LightingChannels: LightingChannels;
        bUseMaterialPositionOffsetInStaticLighting: boolean;
        bRenderCustomDepth: boolean;
        CustomDepthStencilWriteMask: ERendererStencilMask;
        CustomDepthStencilValue: number;
        LDMaxDrawDistance: number;
        bIsMovingToLevel: boolean;
        LightmassSettings: LightmassPrimitiveSettings;
        CollisionMipLevel: number;
        SimpleCollisionMipLevel: number;
        CollisionThickness: number;
        BodyInstance: BodyInstance;
        bGenerateOverlapEvents: boolean;
        bBakeMaterialPositionOffsetIntoCollision: boolean;
        EditorCachedLayerInfos: TArray<LandscapeLayerInfoObject>;
        ReimportHeightmapFilePath: string;
        ReimportDestinationLayerGuid: Guid;
        EditorLayerSettings: TArray<LandscapeEditorLayerSettings>;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        NumSubsections: number;
        bUsedForNavigation: boolean;
        bFillCollisionUnderLandscapeForNavmesh: boolean;
        bUseDynamicMaterialInstance: boolean;
        NavigationGeometryGatheringMode: ENavDataGatheringMode;
        MaxPaintedLayersPerComponent: number;
        bUseLandscapeForCullingInvisibleHLODVertices: boolean;
        bHasLayersContent: boolean;
        WeightmapUsageMap: TMap<Texture2D, LandscapeWeightmapUsage>;

        ChangeComponentScreenSizeToUseSubSections(InComponentScreenSizeToUseSubSections: number): void;

        ChangeLODDistanceFactor(InLODDistanceFactor: number): void;

        ChangeTessellationComponentScreenSize(InTessellationComponentScreenSize: number): void;

        ChangeTessellationComponentScreenSizeFalloff(InUseTessellationComponentScreenSizeFalloff: number): void;

        ChangeUseTessellationComponentScreenSizeFalloff(InComponentScreenSizeToUseSubSections: boolean): void;

        EditorApplySpline(InSplineComponent: $Nullable<SplineComponent>, StartWidth?: number /* = 200.000000 */, EndWidth?: number /* = 200.000000 */, StartSideFalloff?: number /* = 200.000000 */, EndSideFalloff?: number /* = 200.000000 */, StartRoll?: number /* = 0.000000 */, EndRoll?: number /* = 0.000000 */, NumSubdivisions?: number /* = 20 */, bRaiseHeights?: boolean /* = true */, bLowerHeights?: boolean /* = true */, PaintLayer?: LandscapeLayerInfoObject /* = None */, EditLayerName?: string /* = "" */): void;

        EditorSetLandscapeMaterial(NewLandscapeMaterial: $Nullable<MaterialInterface>): void;

        LandscapeExportHeightmapToRenderTarget(InRenderTarget: $Nullable<TextureRenderTarget2D>, InExportHeightIntoRGChannel?: boolean /* = false */, InExportLandscapeProxies?: boolean /* = true */): boolean;

        LandscapeExportWeightmapToRenderTarget(InRenderTarget: $Nullable<TextureRenderTarget2D>, InLayerName: string): boolean;

        LandscapeImportHeightmapFromRenderTarget(InRenderTarget: $Nullable<TextureRenderTarget2D>, InImportHeightFromRGChannel?: boolean /* = false */): boolean;

        LandscapeImportWeightmapFromRenderTarget(InRenderTarget: $Nullable<TextureRenderTarget2D>, InLayerName: string): boolean;

        SetLandscapeMaterialScalarParameterValue(ParameterName: string, Value: number): void;

        SetLandscapeMaterialTextureParameterValue(ParameterName: string, Value: $Nullable<Texture>): void;

        SetLandscapeMaterialVectorParameterValue(ParameterName: string, Value: LinearColor): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeProxy;

        static Load(InName: string): LandscapeProxy;
    }

    export enum ELandscapeBlendMode { LSBM_AdditiveBlend, LSBM_AlphaBlend, LSBM_MAX }

    export class LandscapeBlueprintBrushBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwningLandscape: Landscape;
        AffectHeightmap: boolean;
        AffectWeightmap: boolean;
        AffectedWeightmapLayers: TArray<string>;
        bIsVisible: boolean;

        GetBlueprintRenderDependencies(OutStreamableAssets: $Ref<TArray<Object>>): void;

        Initialize(InLandscapeTransform: Transform, InLandscapeSize: IntPoint, InLandscapeRenderTargetSize: IntPoint): void;

        Render(InIsHeightmap: boolean, InCombinedResult: $Nullable<TextureRenderTarget2D>, InWeightmapLayerName: string): TextureRenderTarget2D;

        RequestLandscapeUpdate(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeBlueprintBrushBase;

        static Load(InName: string): LandscapeBlueprintBrushBase;
    }

    export class LandscapeLayerBrush {
        constructor();
        constructor(BlueprintBrush: LandscapeBlueprintBrushBase);

        BlueprintBrush: LandscapeBlueprintBrushBase;

        static StaticClass(): Class;
    }

    export class LandscapeLayer {
        constructor();
        constructor(Guid: Guid, Name: string, bVisible: boolean, bLocked: boolean, HeightmapAlpha: number, WeightmapAlpha: number, BlendMode: ELandscapeBlendMode, Brushes: TArray<LandscapeLayerBrush>, WeightmapLayerAllocationBlend: TMap<LandscapeLayerInfoObject, boolean>);

        Guid: Guid;
        Name: string;
        bVisible: boolean;
        bLocked: boolean;
        HeightmapAlpha: number;
        WeightmapAlpha: number;
        BlendMode: ELandscapeBlendMode;
        Brushes: TArray<LandscapeLayerBrush>;
        WeightmapLayerAllocationBlend: TMap<LandscapeLayerInfoObject, boolean>;

        static StaticClass(): Class;
    }

    export class Landscape extends LandscapeProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCanHaveLayersContent: boolean;
        LandscapeSplinesTargetLayerGuid: Guid;
        LandscapeLayers: TArray<LandscapeLayer>;
        HeightmapRTList: TArray<TextureRenderTarget2D>;
        WeightmapRTList: TArray<TextureRenderTarget2D>;
        LandscapeSplinesAffectedComponents: TSet<LandscapeComponent>;
        bLandscapeLayersAreInitialized: boolean;
        WasCompilingShaders: boolean;
        LayerContentUpdateModes: number;
        bSplineLayerUpdateRequested: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Landscape;

        static Load(InName: string): Landscape;
    }

    export class LandscapeBlueprintBrush extends LandscapeBlueprintBrushBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeBlueprintBrush;

        static Load(InName: string): LandscapeBlueprintBrush;
    }

    export enum ELandscapeToolFlattenMode {
        Invalid,
        Both,
        Raise,
        Lower,
        Interval,
        Terrace,
        ELandscapeToolFlattenMode_MAX
    }

    export enum ELandscapeToolErosionMode { Invalid, Both, Raise, Lower, ELandscapeToolErosionMode_MAX }

    export enum ELandscapeToolHydroErosionMode { Invalid, Both, Positive, ELandscapeToolHydroErosionMode_MAX }

    export enum ELandscapeToolNoiseMode { Invalid, Both, Add, Sub, ELandscapeToolNoiseMode_MAX }

    export enum ELandscapeToolPasteMode { Invalid, Both, Raise, Lower, ELandscapeToolPasteMode_MAX }

    export class GizmoImportLayer {
        constructor();
        constructor(LayerFilename: string, LayerName: string, bNoImport: boolean);

        LayerFilename: string;
        LayerName: string;
        bNoImport: boolean;

        static StaticClass(): Class;
    }

    export enum ELandscapeMirrorOperation {
        MinusXToPlusX,
        PlusXToMinusX,
        MinusYToPlusY,
        PlusYToMinusY,
        RotateMinusXToPlusX,
        RotatePlusXToMinusX,
        RotateMinusYToPlusY,
        RotatePlusYToMinusY,
        ELandscapeMirrorOperation_MAX
    }

    export enum ELandscapeConvertMode { Invalid, Expand, Clip, Resample, ELandscapeConvertMode_MAX }

    export enum ELandscapeImportResult { Success, Warning, Error, ELandscapeImportResult_MAX }

    export enum ELandscapeImportAlphamapType { Additive, Layered, ELandscapeImportAlphamapType_MAX }

    export class LandscapeImportLayerInfo {
        constructor();
        constructor(LayerName: string, LayerInfo: LandscapeLayerInfoObject, SourceFilePath: string);

        LayerName: string;
        LayerInfo: LandscapeLayerInfoObject;
        SourceFilePath: string;

        static StaticClass(): Class;
    }

    export class LandscapeMaterialTextureStreamingInfo {
        constructor();
        constructor(TextureName: string, TexelFactor: number);

        TextureName: string;
        TexelFactor: number;

        static StaticClass(): Class;
    }

    export class LandscapeMaterialInstanceConstant extends MaterialInstanceConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureStreamingInfo: TArray<LandscapeMaterialTextureStreamingInfo>;
        bIsLayerThumbnail: boolean;
        bDisableTessellation: boolean;
        bMobile: boolean;
        bEditorToolUsage: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeMaterialInstanceConstant;

        static Load(InName: string): LandscapeMaterialInstanceConstant;
    }

    export class LandscapeImportLayer extends LandscapeImportLayerInfo {
        constructor();
        constructor(ThumbnailMIC: LandscapeMaterialInstanceConstant, ImportResult: ELandscapeImportResult, ErrorMessage: string);

        ThumbnailMIC: LandscapeMaterialInstanceConstant;
        ImportResult: ELandscapeImportResult;
        ErrorMessage: string;

        static StaticClass(): Class;
    }

    export class LandscapePatternBrushWorldSpaceSettings {
        constructor();
        constructor(Origin: Vector2D, Rotation: number, bCenterTextureOnOrigin: boolean, RepeatSize: number);

        Origin: Vector2D;
        Rotation: number;
        bCenterTextureOnOrigin: boolean;
        RepeatSize: number;

        static StaticClass(): Class;
    }

    export enum EColorChannel { Red, Green, Blue, Alpha, EColorChannel_MAX }

    export enum ELandscapeLayerPaintingRestriction {
        None,
        UseMaxLayers,
        ExistingOnly,
        UseComponentWhitelist,
        ELandscapeLayerPaintingRestriction_MAX
    }

    export class LandscapeEditorObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ToolStrength: number;
        bUseWeightTargetValue: boolean;
        WeightTargetValue: number;
        MaximumValueRadius: number;
        bCombinedLayersOperation: boolean;
        FlattenMode: ELandscapeToolFlattenMode;
        bUseSlopeFlatten: boolean;
        bPickValuePerApply: boolean;
        bUseFlattenTarget: boolean;
        FlattenTarget: number;
        bShowFlattenTargetPreview: boolean;
        TerraceInterval: number;
        TerraceSmooth: number;
        bFlattenEyeDropperModeActivated: boolean;
        FlattenEyeDropperModeDesiredTarget: number;
        RampWidth: number;
        RampSideFalloff: number;
        SmoothFilterKernelSize: number;
        bDetailSmooth: boolean;
        DetailScale: number;
        ErodeThresh: number;
        ErodeSurfaceThickness: number;
        ErodeIterationNum: number;
        ErosionNoiseMode: ELandscapeToolErosionMode;
        ErosionNoiseScale: number;
        RainAmount: number;
        SedimentCapacity: number;
        HErodeIterationNum: number;
        RainDistMode: ELandscapeToolHydroErosionMode;
        RainDistScale: number;
        bHErosionDetailSmooth: boolean;
        HErosionDetailScale: number;
        NoiseMode: ELandscapeToolNoiseMode;
        NoiseScale: number;
        bUseSelectedRegion: boolean;
        bUseNegativeMask: boolean;
        PasteMode: ELandscapeToolPasteMode;
        bApplyToAllTargets: boolean;
        bSnapGizmo: boolean;
        bSmoothGizmoBrush: boolean;
        GizmoHeightmapFilenameString: string;
        GizmoImportSize: IntPoint;
        GizmoImportLayers: TArray<GizmoImportLayer>;
        MirrorPoint: Vector2D;
        MirrorOp: ELandscapeMirrorOperation;
        MirrorSmoothingWidth: number;
        BlueprintBrush: Class;
        ResizeLandscape_QuadsPerSection: number;
        ResizeLandscape_SectionsPerComponent: number;
        ResizeLandscape_ComponentCount: IntPoint;
        ResizeLandscape_ConvertMode: ELandscapeConvertMode;
        NewLandscape_Material: TWeakObjectPtr<MaterialInterface>;
        NewLandscape_QuadsPerSection: number;
        NewLandscape_SectionsPerComponent: number;
        NewLandscape_ComponentCount: IntPoint;
        NewLandscape_Location: Vector;
        NewLandscape_Rotation: Rotator;
        NewLandscape_Scale: Vector;
        ImportLandscape_HeightmapImportResult: ELandscapeImportResult;
        ImportLandscape_HeightmapErrorMessage: string;
        ImportLandscape_HeightmapFilename: string;
        ImportLandscape_Width: number;
        ImportLandscape_Height: number;
        ImportLandscape_Data: TArray<number>;
        bCanHaveLayersContent: boolean;
        ImportLandscape_AlphamapType: ELandscapeImportAlphamapType;
        ImportLandscape_Layers: TArray<LandscapeImportLayer>;
        BrushRadius: number;
        BrushFalloff: number;
        bUseClayBrush: boolean;
        AlphaBrushScale: number;
        bAlphaBrushAutoRotate: boolean;
        AlphaBrushRotation: number;
        AlphaBrushPanU: number;
        AlphaBrushPanV: number;
        bUseWorldSpacePatternBrush: boolean;
        WorldSpacePatternBrushSettings: LandscapePatternBrushWorldSpaceSettings;
        AlphaTexture: Texture2D;
        AlphaTextureChannel: EColorChannel;
        AlphaTextureSizeX: number;
        AlphaTextureSizeY: number;
        AlphaTextureData: TArray<number>;
        BrushComponentSize: number;
        PaintingRestriction: ELandscapeLayerPaintingRestriction;
        TargetDisplayOrder: ELandscapeLayerDisplayMode;
        ShowUnusedLayers: boolean;
        CurrentLayerIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeEditorObject;

        static Load(InName: string): LandscapeEditorObject;
    }

    export class LandscapeInfoLayerSettings {
        constructor();
        constructor(LayerInfoObj: LandscapeLayerInfoObject, LayerName: string, ThumbnailMIC: MaterialInstanceConstant, Owner: LandscapeProxy, DebugColorChannel: number, bValid: boolean);

        LayerInfoObj: LandscapeLayerInfoObject;
        LayerName: string;
        ThumbnailMIC: MaterialInstanceConstant;
        Owner: LandscapeProxy;
        DebugColorChannel: number;
        bValid: boolean;

        static StaticClass(): Class;
    }

    export class LandscapeStreamingProxy extends LandscapeProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LandscapeActor: TLazyObjectPtr<Landscape>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeStreamingProxy;

        static Load(InName: string): LandscapeStreamingProxy;
    }

    export class LandscapeInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LandscapeActor: TLazyObjectPtr<Landscape>;
        LandscapeGuid: Guid;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        ComponentNumSubsections: number;
        DrawScale: Vector;
        Layers: TArray<LandscapeInfoLayerSettings>;
        Proxies: TArray<LandscapeStreamingProxy>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeInfo;

        static Load(InName: string): LandscapeInfo;
    }

    export class LandscapeGizmoActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Width: number;
        Height: number;
        LengthZ: number;
        MarginZ: number;
        MinRelativeZ: number;
        RelativeScaleZ: number;
        TargetLandscapeInfo: LandscapeInfo;
        SpriteComponent: BillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoActor;

        static Load(InName: string): LandscapeGizmoActor;
    }

    export enum ELandscapeGizmoType { LGT_None, LGT_Height, LGT_Weight, LGT_MAX }

    export class LandscapeGizmoActiveActor extends LandscapeGizmoActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DataType: ELandscapeGizmoType;
        GizmoTexture: Texture2D;
        TextureScale: Vector2D;
        SampledHeight: TArray<Vector>;
        SampledNormal: TArray<Vector>;
        SampleSizeX: number;
        SampleSizeY: number;
        CachedWidth: number;
        CachedHeight: number;
        CachedScaleXY: number;
        FrustumVerts: FixSizeArray<Vector>;
        GizmoMaterial: Material;
        GizmoDataMaterial: MaterialInstance;
        GizmoMeshMaterial: Material;
        LayerInfos: TArray<LandscapeLayerInfoObject>;
        bSnapToLandscapeGrid: boolean;
        UnsnappedRotation: Rotator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoActiveActor;

        static Load(InName: string): LandscapeGizmoActiveActor;
    }

    export class LandscapeGizmoRenderComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoRenderComponent;

        static Load(InName: string): LandscapeGizmoRenderComponent;
    }

    export class LandscapeGrassTypeFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeGrassTypeFactory;

        static Load(InName: string): LandscapeGrassTypeFactory;
    }

    export class LandscapeInfoMap extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeInfoMap;

        static Load(InName: string): LandscapeInfoMap;
    }

    export class LandscapeMeshCollisionComponent extends LandscapeHeightfieldCollisionComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MeshGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeMeshCollisionComponent;

        static Load(InName: string): LandscapeMeshCollisionComponent;
    }

    export class LandscapeMeshProxyComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LandscapeGuid: Guid;
        ProxyComponentBases: TArray<IntPoint>;
        ProxyLOD: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeMeshProxyComponent;

        static Load(InName: string): LandscapeMeshProxyComponent;
    }

    export class LandscapeMeshProxyActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LandscapeMeshProxyComponent: LandscapeMeshProxyComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeMeshProxyActor;

        static Load(InName: string): LandscapeMeshProxyActor;
    }

    export class LandscapePlaceholder extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapePlaceholder;

        static Load(InName: string): LandscapePlaceholder;
    }

    export class LandscapeSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxNumberOfLayers: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeSettings;

        static Load(InName: string): LandscapeSettings;
    }

    export class LandscapeSubsystem extends WorldSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LandscapeSubsystem;

        static Load(InName: string): LandscapeSubsystem;
    }

    export class ActorLayer {
        constructor();
        constructor(Name: string);

        Name: string;

        static StaticClass(): Class;
    }

    export class LayersBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddActorToLayer(InActor: $Nullable<Actor>, Layer: ActorLayer): void;

        static GetActors(WorldContextObject: $Nullable<Object>, ActorLayer: ActorLayer): TArray<Actor>;

        static RemoveActorFromLayer(InActor: $Nullable<Actor>, Layer: ActorLayer): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LayersBlueprintLibrary;

        static Load(InName: string): LayersBlueprintLibrary;
    }

    export class LayersSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddActorsToLayer(Actors: TArray<Actor>, LayerName: string): boolean;

        AddActorsToLayers(Actors: TArray<Actor>, LayerNames: TArray<string>): boolean;

        AddActorToLayer(Actor: $Nullable<Actor>, LayerName: string): boolean;

        AddActorToLayers(Actor: $Nullable<Actor>, LayerNames: TArray<string>): boolean;

        AddAllLayerNamesTo(OutLayerNames: $Ref<TArray<string>>): void;

        AddAllLayersTo(OutLayers: $Ref<TArray<Layer>>): void;

        AddLevelLayerInformation(Level: $Nullable<Level>): void;

        AddSelectedActorsToLayer(LayerName: string): boolean;

        AddSelectedActorsToLayers(LayerNames: TArray<string>): boolean;

        AppendActorsFromLayer(LayerName: string, InOutActors: $Ref<TArray<Actor>>): void;

        AppendActorsFromLayers(LayerNames: TArray<string>, InOutActors: $Ref<TArray<Actor>>): void;

        CreateLayer(LayerName: string): Layer;

        DeleteLayer(LayerToDelete: string): void;

        DeleteLayers(LayersToDelete: TArray<string>): void;

        DisassociateActorFromLayers(Actor: $Nullable<Actor>): boolean;

        EditorMapChange(): void;

        EditorRefreshLayerBrowser(): void;

        GetActorsFromLayer(LayerName: string): TArray<Actor>;

        GetActorsFromLayers(LayerNames: TArray<string>): TArray<Actor>;

        GetLayer(LayerName: string): Layer;

        GetSelectedActors(): TArray<Actor>;

        GetWorld(): World;

        InitializeNewActorLayers(Actor: $Nullable<Actor>): boolean;

        IsActorValidForLayer(Actor: $Nullable<Actor>): boolean;

        IsLayer(LayerName: string): boolean;

        MakeAllLayersVisible(): void;

        RemoveActorFromLayer(Actor: $Nullable<Actor>, LayerToRemove: string, bUpdateStats?: boolean /* = true */): boolean;

        RemoveActorFromLayers(Actor: $Nullable<Actor>, LayerNames: TArray<string>, bUpdateStats?: boolean /* = true */): boolean;

        RemoveActorsFromLayer(Actors: TArray<Actor>, LayerName: string, bUpdateStats?: boolean /* = true */): boolean;

        RemoveActorsFromLayers(Actors: TArray<Actor>, LayerNames: TArray<string>, bUpdateStats?: boolean /* = true */): boolean;

        RemoveLevelLayerInformation(Level: $Nullable<Level>): void;

        RemoveSelectedActorsFromLayer(LayerName: string): boolean;

        RemoveSelectedActorsFromLayers(LayerNames: TArray<string>): boolean;

        RenameLayer(OriginalLayerName: string, NewLayerName: string): boolean;

        SelectActorsInLayer(LayerName: string, bSelect: boolean, bNotify: boolean, bSelectEvenIfHidden?: boolean /* = false */): boolean;

        SelectActorsInLayers(LayerNames: TArray<string>, bSelect: boolean, bNotify: boolean, bSelectEvenIfHidden?: boolean /* = false */): boolean;

        SetLayersVisibility(LayerNames: TArray<string>, bIsVisible: boolean): void;

        SetLayerVisibility(LayerName: string, bIsVisible: boolean): void;

        ToggleLayersVisibility(LayerNames: TArray<string>): void;

        ToggleLayerVisibility(LayerName: string): void;

        TryGetLayer(LayerName: string, OutLayer: $Ref<Layer>): boolean;

        UpdateActorAllViewsVisibility(Actor: $Nullable<Actor>): void;

        UpdateActorVisibility(Actor: $Nullable<Actor>, bOutSelectionChanged: $Ref<boolean>, bOutActorModified: $Ref<boolean>, bNotifySelectionChange: boolean, bRedrawViewports: boolean): boolean;

        UpdateAllActorsVisibility(bNotifySelectionChange: boolean, bRedrawViewports: boolean): boolean;

        UpdateAllViewVisibility(LayerThatChanged: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LayersSubsystem;

        static Load(InName: string): LayersSubsystem;
    }

    export class LazyObjectProperty extends ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LazyObjectProperty;

        static Load(InName: string): LazyObjectProperty;
    }

    export class LeaderboardBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static WriteLeaderboardInteger(PlayerController: $Nullable<PlayerController>, StatName: string, StatValue: number): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LeaderboardBlueprintLibrary;

        static Load(InName: string): LeaderboardBlueprintLibrary;
    }

    export class LeaderboardFlushCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(SessionName: string) => void>;
        OnFailure: $MulticastDelegate<(SessionName: string) => void>;

        static CreateProxyObjectForFlush(PlayerController: $Nullable<PlayerController>, SessionName: string): LeaderboardFlushCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LeaderboardFlushCallbackProxy;

        static Load(InName: string): LeaderboardFlushCallbackProxy;
    }

    export class LeaderboardQueryCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(LeaderboardValue: number) => void>;
        OnFailure: $MulticastDelegate<(LeaderboardValue: number) => void>;

        static CreateProxyObjectForIntQuery(PlayerController: $Nullable<PlayerController>, StatName: string): LeaderboardQueryCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LeaderboardQueryCallbackProxy;

        static Load(InName: string): LeaderboardQueryCallbackProxy;
    }

    export class LegacyEdModeWrapper extends EdMode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LegacyEdModeWrapper;

        static Load(InName: string): LegacyEdModeWrapper;
    }

    export class LegacyLevelSequenceDirectorBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LegacyLevelSequenceDirectorBlueprint;

        static Load(InName: string): LegacyLevelSequenceDirectorBlueprint;
    }

    export class LevelBounds extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoxComponent: BoxComponent;
        bAutoUpdateBounds: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelBounds;

        static Load(InName: string): LevelBounds;
    }

    export class LevelCapture extends MovieSceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoStartCapture: boolean;
        PrerequisiteActorId: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelCapture;

        static Load(InName: string): LevelCapture;
    }

    export enum ELevelEditor2DAxis { X, Y, Z, ELevelEditor2DAxis_MAX }

    export class Mode2DLayer {
        constructor();
        constructor(Name: string, Depth: number);

        Name: string;
        Depth: number;

        static StaticClass(): Class;
    }

    export class LevelEditor2DSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bEnable2DWidget: boolean;
        bEnableSnapLayers: boolean;
        SnapAxis: ELevelEditor2DAxis;
        SnapLayers: TArray<Mode2DLayer>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelEditor2DSettings;

        static Load(InName: string): LevelEditor2DSettings;
    }

    export class LevelEditorContextMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelEditorContextMenuContext;

        static Load(InName: string): LevelEditorContextMenuContext;
    }

    export class LevelEditorMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelEditorMenuContext;

        static Load(InName: string): LevelEditorMenuContext;
    }

    export class LevelEditorMiscSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoApplyLightingEnable: boolean;
        bBSPAutoUpdate: boolean;
        bAutoMoveBSPPivotOffset: boolean;
        bNavigationAutoUpdate: boolean;
        bReplaceRespectsScale: boolean;
        bEnableLegacyMeshPaintMode: boolean;
        bAvoidRelabelOnPasteSelected: boolean;
        bAllowBackgroundAudio: boolean;
        bCreateNewAudioDeviceForPlayInEditor: boolean;
        bEnableRealTimeAudio: boolean;
        EditorVolumeLevel: number;
        bEnableEditorSounds: boolean;
        DefaultLevelStreamingClass: Class;
        bPromptWhenAddingToLevelBeforeCheckout: boolean;
        bPromptWhenAddingToLevelOutsideBounds: boolean;
        PercentageThresholdForPrompt: number;
        MinimumBoundsForCheckingSize: Vector;
        EditorScreenshotSaveDirectory: DirectoryPath;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelEditorMiscSettings;

        static Load(InName: string): LevelEditorMiscSettings;
    }

    export enum ELabelAnchorMode {
        LabelAnchorMode_TopLeft,
        LabelAnchorMode_TopCenter,
        LabelAnchorMode_TopRight,
        LabelAnchorMode_CenterLeft,
        LabelAnchorMode_Centered,
        LabelAnchorMode_CenterRight,
        LabelAnchorMode_BottomLeft,
        LabelAnchorMode_BottomCenter,
        LabelAnchorMode_BottomRight,
        LabelAnchorMode_MAX
    }

    export enum EPlayOnBuildMode {
        PlayOnBuild_Always,
        PlayOnBuild_Never,
        PlayOnBuild_Default,
        PlayOnBuild_IfEditorBuiltLocally,
        PlayOnBuild_MAX
    }

    export enum EPlayOnLaunchConfiguration {
        LaunchConfig_Default,
        LaunchConfig_Debug,
        LaunchConfig_Development,
        LaunchConfig_Test,
        LaunchConfig_Shipping,
        LaunchConfig_MAX
    }

    export enum EPlayNetMode { PIE_Standalone, PIE_ListenServer, PIE_Client, PIE_MAX }

    export enum NetworkEmulationTarget { Server, Client, Any, NetworkEmulationTarget_MAX }

    export class NetworkEmulationPacketSettings {
        constructor();
        constructor(MinLatency: number, MaxLatency: number, PacketLossPercentage: number);

        MinLatency: number;
        MaxLatency: number;
        PacketLossPercentage: number;

        static StaticClass(): Class;
    }

    export class LevelEditorPlayNetworkEmulationSettings {
        constructor();
        constructor(bIsNetworkEmulationEnabled: boolean, EmulationTarget: NetworkEmulationTarget, CurrentProfile: string, OutPackets: NetworkEmulationPacketSettings, InPackets: NetworkEmulationPacketSettings);

        bIsNetworkEmulationEnabled: boolean;
        EmulationTarget: NetworkEmulationTarget;
        CurrentProfile: string;
        OutPackets: NetworkEmulationPacketSettings;
        InPackets: NetworkEmulationPacketSettings;

        static StaticClass(): Class;
    }

    export enum ELaunchModeType { LaunchMode_OnDevice, LaunchMode_MAX }

    export enum EPlayModeLocations {
        PlayLocation_CurrentCameraLocation,
        PlayLocation_DefaultPlayerStart,
        PlayLocation_MAX
    }

    export enum EPlayModeType {
        PlayMode_InViewPort,
        PlayMode_InEditorFloating,
        PlayMode_InMobilePreview,
        PlayMode_InTargetedMobilePreview,
        PlayMode_InVulkanPreview,
        PlayMode_InNewProcess,
        PlayMode_InVR,
        PlayMode_Simulate,
        PlayMode_Count,
        PlayMode_MAX
    }

    export class PlayScreenResolution {
        constructor();
        constructor(Description: string, Width: number, Height: number, AspectRatio: string, bCanSwapAspectRatio: boolean, ProfileName: string, ScaleFactor: number, LogicalHeight: number, LogicalWidth: number);

        Description: string;
        Width: number;
        Height: number;
        AspectRatio: string;
        bCanSwapAspectRatio: boolean;
        ProfileName: string;
        ScaleFactor: number;
        LogicalHeight: number;
        LogicalWidth: number;

        static StaticClass(): Class;
    }

    export class LevelEditorPlaySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayFromHerePlayerStartClassName: string;
        GameGetsMouseControl: boolean;
        UseMouseForTouch: boolean;
        ShowMouseControlLabel: boolean;
        MouseControlLabelPosition: ELabelAnchorMode;
        ViewportGetsHMDControl: boolean;
        ShouldMinimizeEditorOnVRPIE: boolean;
        AutoRecompileBlueprints: boolean;
        EnableGameSound: boolean;
        EnablePIEEnterAndExitSounds: boolean;
        PlayInEditorSoundQualityLevel: number;
        bUseNonRealtimeAudioDevice: boolean;
        bOnlyLoadVisibleLevelsInPIE: boolean;
        bPreferToStreamLevelsInPIE: boolean;
        NewWindowWidth: number;
        NewWindowHeight: number;
        NewWindowPosition: IntPoint;
        CenterNewWindow: boolean;
        PIEAlwaysOnTop: boolean;
        DisableStandaloneSound: boolean;
        AdditionalLaunchParameters: string;
        AdditionalLaunchParametersForMobile: string;
        BuildGameBeforeLaunch: EPlayOnBuildMode;
        LaunchConfiguration: EPlayOnLaunchConfiguration;
        bAutoCompileBlueprintsOnLaunch: boolean;
        bLaunchSeparateServer: boolean;
        PlayNetMode: EPlayNetMode;
        RunUnderOneProcess: boolean;
        PlayNetDedicated: boolean;
        PlayNumberOfClients: number;
        ServerPort: number;
        ClientWindowWidth: number;
        AutoConnectToServer: boolean;
        RouteGamepadToSecondWindow: boolean;
        CreateAudioDeviceForEveryPlayer: boolean;
        ClientWindowHeight: number;
        ServerMapNameOverride: string;
        AdditionalServerGameOptions: string;
        AdditionalLaunchOptions: string;
        bShowServerDebugDrawingByDefault: boolean;
        ServerDebugDrawingColorTintStrength: number;
        ServerDebugDrawingColorTint: LinearColor;
        AdditionalServerLaunchParameters: string;
        ServerFixedFPS: number;
        ClientFixedFPS: TArray<number>;
        NetworkEmulationSettings: LevelEditorPlayNetworkEmulationSettings;
        LastSize: IntPoint;
        MultipleInstancePositions: TArray<IntPoint>;
        LastExecutedLaunchDevice: string;
        LastExecutedLaunchName: string;
        LastExecutedLaunchModeType: ELaunchModeType;
        LastExecutedPlayModeLocation: EPlayModeLocations;
        LastExecutedPlayModeType: EPlayModeType;
        LastExecutedPIEPreviewDevice: string;
        LaptopScreenResolutions: TArray<PlayScreenResolution>;
        MonitorScreenResolutions: TArray<PlayScreenResolution>;
        PhoneScreenResolutions: TArray<PlayScreenResolution>;
        TabletScreenResolutions: TArray<PlayScreenResolution>;
        TelevisionScreenResolutions: TArray<PlayScreenResolution>;
        DeviceToEmulate: string;
        PIESafeZoneOverride: Margin;
        CustomUnsafeZoneStarts: TArray<Vector2D>;
        CustomUnsafeZoneDimensions: TArray<Vector2D>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelEditorPlaySettings;

        static Load(InName: string): LevelEditorPlaySettings;
    }

    export enum EWASDType { WASD_Always, WASD_RMBOnly, WASD_Never, WASD_MAX }

    export enum ELandscapeFoliageEditorControlType {
        IgnoreCtrl,
        RequireCtrl,
        RequireNoCtrl,
        ELandscapeFoliageEditorControlType_MAX
    }

    export enum EScrollGestureDirection { UseSystemSetting, Standard, Natural, EScrollGestureDirection_MAX }

    export class SnapToSurfaceSettings {
        constructor();
        constructor(bEnabled: boolean, SnapOffsetExtent: number, bSnapRotation: boolean);

        bEnabled: boolean;
        SnapOffsetExtent: number;
        bSnapRotation: boolean;

        static StaticClass(): Class;
    }

    export enum ERotationGridMode { GridMode_DivisionsOf360, GridMode_Common, GridMode_MAX }

    export enum EMeasuringToolUnits {
        MeasureUnits_Centimeters,
        MeasureUnits_Meters,
        MeasureUnits_Kilometers,
        MeasureUnits_MAX
    }

    export enum ELevelViewportType {
        LVT_OrthoXY,
        LVT_OrthoXZ,
        LVT_OrthoYZ,
        LVT_Perspective,
        LVT_OrthoFreelook,
        LVT_OrthoNegativeXY,
        LVT_OrthoNegativeXZ,
        LVT_OrthoNegativeYZ,
        LVT_MAX,
        LVT_None
    }

    export class ExposureSettings {
        constructor();
        constructor(FixedEV100: number, bFixed: boolean);

        FixedEV100: number;
        bFixed: boolean;

        static StaticClass(): Class;
    }

    export class LevelEditorViewportInstanceSettings {
        constructor();
        constructor(ViewportType: ELevelViewportType, PerspViewModeIndex: EViewModeIndex, OrthoViewModeIndex: EViewModeIndex, EditorShowFlagsString: string, GameShowFlagsString: string, BufferVisualizationMode: string, RayTracingDebugVisualizationMode: string, ExposureSettings: ExposureSettings, FOVAngle: number, FarViewPlane: number, bIsRealtime: boolean, bShowFPS: boolean, bShowOnScreenStats: boolean, EnabledStats: TArray<string>, bShowFullToolbar: boolean);

        ViewportType: ELevelViewportType;
        PerspViewModeIndex: EViewModeIndex;
        OrthoViewModeIndex: EViewModeIndex;
        EditorShowFlagsString: string;
        GameShowFlagsString: string;
        BufferVisualizationMode: string;
        RayTracingDebugVisualizationMode: string;
        ExposureSettings: ExposureSettings;
        FOVAngle: number;
        FarViewPlane: number;
        bIsRealtime: boolean;
        bShowFPS: boolean;
        bShowOnScreenStats: boolean;
        EnabledStats: TArray<string>;
        bShowFullToolbar: boolean;

        static StaticClass(): Class;
    }

    export class LevelEditorViewportInstanceSettingsKeyValuePair {
        constructor();
        constructor(ConfigName: string, ConfigSettings: LevelEditorViewportInstanceSettings);

        ConfigName: string;
        ConfigSettings: LevelEditorViewportInstanceSettings;

        static StaticClass(): Class;
    }

    export class LevelEditorViewportSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FlightCameraControlType: EWASDType;
        FlightCameraControlExperimentalNavigation: boolean;
        LandscapeEditorControlType: ELandscapeFoliageEditorControlType;
        FoliageEditorControlType: ELandscapeFoliageEditorControlType;
        bPanMovesCanvas: boolean;
        bCenterZoomAroundCursor: boolean;
        MinimumOrthographicZoom: number;
        bAllowTranslateRotateZWidget: boolean;
        bAllowArcballRotate: boolean;
        bAllowScreenRotate: boolean;
        bClickBSPSelectsBrush: boolean;
        CameraSpeed: number;
        CameraSpeedScalar: number;
        MouseScrollCameraSpeed: number;
        MouseSensitivty: number;
        bInvertMouseLookYAxis: boolean;
        bInvertOrbitYAxis: boolean;
        bInvertMiddleMousePan: boolean;
        bInvertRightMouseDollyYAxis: boolean;
        bUseAbsoluteTranslation: boolean;
        bLevelStreamingVolumePrevis: boolean;
        bUseUE3OrbitControls: boolean;
        ScrollGestureDirectionFor3DViewports: EScrollGestureDirection;
        ScrollGestureDirectionForOrthoViewports: EScrollGestureDirection;
        bLevelEditorJoystickControls: boolean;
        bUseDistanceScaledCameraSpeed: boolean;
        bOrbitCameraAroundSelection: boolean;
        bUsePowerOf2SnapSize: boolean;
        DecimalGridSizes: TArray<number>;
        DecimalGridIntervals: TArray<number>;
        Pow2GridSizes: TArray<number>;
        Pow2GridIntervals: TArray<number>;
        CommonRotGridSizes: TArray<number>;
        DivisionsOf360RotGridSizes: TArray<number>;
        ScalingGridSizes: TArray<number>;
        GridEnabled: boolean;
        RotGridEnabled: boolean;
        SnapScaleEnabled: boolean;
        SnapToSurface: SnapToSurfaceSettings;
        bUsePercentageBasedScaling: boolean;
        bEnableLayerSnap: boolean;
        ActiveSnapLayerIndex: number;
        bEnableActorSnap: boolean;
        ActorSnapScale: number;
        ActorSnapDistance: number;
        bSnapVertices: boolean;
        SnapDistance: number;
        CurrentPosGridSize: number;
        CurrentRotGridSize: number;
        CurrentScalingGridSize: number;
        PreserveNonUniformScale: boolean;
        CurrentRotGridMode: ERotationGridMode;
        bUseLegacyPostEditBehavior: boolean;
        AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
        bEnableViewportHoverFeedback: boolean;
        bHighlightWithBrackets: boolean;
        bUseLinkedOrthographicViewports: boolean;
        bStrictBoxSelection: boolean;
        bTransparentBoxSelection: boolean;
        bUseSelectionOutline: boolean;
        SelectionHighlightIntensity: number;
        BSPSelectionHighlightIntensity: number;
        bEnableViewportCameraToUpdateFromPIV: boolean;
        bPreviewSelectedCameras: boolean;
        CameraPreviewSize: number;
        BackgroundDropDistance: number;
        PreviewMeshes: TArray<SoftObjectPath>;
        BillboardScale: number;
        TransformWidgetSizeAdjustment: number;
        bSaveEngineStats: boolean;
        MeasuringToolUnits: EMeasuringToolUnits;
        SelectedSplinePointSizeAdjustment: number;
        SplineLineThicknessAdjustment: number;
        SplineTangentHandleSizeAdjustment: number;
        SplineTangentScale: number;
        PerInstanceSettings: TArray<LevelEditorViewportInstanceSettingsKeyValuePair>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelEditorViewportSettings;

        static Load(InName: string): LevelEditorViewportSettings;
    }

    export class LevelExporterFBX extends ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelExporterFBX;

        static Load(InName: string): LevelExporterFBX;
    }

    export class LevelExporterLOD extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelExporterLOD;

        static Load(InName: string): LevelExporterLOD;
    }

    export class LevelExporterOBJ extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelExporterOBJ;

        static Load(InName: string): LevelExporterOBJ;
    }

    export class LevelExporterSTL extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelExporterSTL;

        static Load(InName: string): LevelExporterSTL;
    }

    export class LevelExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelExporterT3D;

        static Load(InName: string): LevelExporterT3D;
    }

    export class LevelFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelFactory;

        static Load(InName: string): LevelFactory;
    }

    export class LevelSequenceAnimSequenceLinkItem {
        constructor();
        constructor(SkelTrackGuid: Guid, PathToAnimSequence: SoftObjectPath, bExportTransforms: boolean, bExportCurves: boolean, bRecordInWorldSpace: boolean);

        SkelTrackGuid: Guid;
        PathToAnimSequence: SoftObjectPath;
        bExportTransforms: boolean;
        bExportCurves: boolean;
        bRecordInWorldSpace: boolean;

        static StaticClass(): Class;
    }

    export class LevelSequenceAnimSequenceLink extends AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimSequenceLinks: TArray<LevelSequenceAnimSequenceLinkItem>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequenceAnimSequenceLink;

        static Load(InName: string): LevelSequenceAnimSequenceLink;
    }

    export class LevelSequenceDirector extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Player: LevelSequencePlayer;

        OnCreated(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequenceDirector;

        static Load(InName: string): LevelSequenceDirector;
    }

    export enum MediaTextureOutputFormat { MTOF_Default, MTOF_SRGB_LINOUT, MTOF_MAX }

    export enum MediaTextureOrientation { MTORI_Original, MTORI_CW90, MTORI_CW180, MTORI_CW270, MTORI_MAX }

    export class MediaPlaylist extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Items: TArray<MediaSource>;

        Add(MediaSource: $Nullable<MediaSource>): boolean;

        AddFile(FilePath: string): boolean;

        AddUrl(Url: string): boolean;

        Get(Index: number): MediaSource;

        GetNext(InOutIndex: $Ref<number>): MediaSource;

        GetPrevious(InOutIndex: $Ref<number>): MediaSource;

        GetRandom(OutIndex: $Ref<number>): MediaSource;

        Insert(MediaSource: $Nullable<MediaSource>, Index: number): void;

        Num(): number;

        Remove(MediaSource: $Nullable<MediaSource>): boolean;

        RemoveAt(Index: number): boolean;

        Replace(Index: number, Replacement: $Nullable<MediaSource>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MediaPlaylist;

        static Load(InName: string): MediaPlaylist;
    }

    export enum EMediaPlayerTrack { Audio, Caption, Metadata, Script, Subtitle, Text, Video, EMediaPlayerTrack_MAX }

    export class MediaPlayerTrackOptions {
        constructor();
        constructor(Audio: number, Caption: number, Metadata: number, Script: number, Subtitle: number, Text: number, Video: number);

        Audio: number;
        Caption: number;
        Metadata: number;
        Script: number;
        Subtitle: number;
        Text: number;
        Video: number;

        static StaticClass(): Class;
    }

    export enum EMediaPlayerOptionBooleanOverride {
        UseMediaPlayerSetting,
        Enabled,
        Disabled,
        EMediaPlayerOptionBooleanOverride_MAX
    }

    export class MediaPlayerOptions {
        constructor();
        constructor(Tracks: MediaPlayerTrackOptions, SeekTime: Timespan, PlayOnOpen: EMediaPlayerOptionBooleanOverride, Loop: EMediaPlayerOptionBooleanOverride);

        Tracks: MediaPlayerTrackOptions;
        SeekTime: Timespan;
        PlayOnOpen: EMediaPlayerOptionBooleanOverride;
        Loop: EMediaPlayerOptionBooleanOverride;

        static StaticClass(): Class;
    }

    export class MediaTimeStampInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Time: Timespan;
        SequenceIndex: bigint;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MediaTimeStampInfo;

        static Load(InName: string): MediaTimeStampInfo;
    }

    export class MediaPlayer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnEndReached: $MulticastDelegate<() => void>;
        OnMediaClosed: $MulticastDelegate<() => void>;
        OnMediaOpened: $MulticastDelegate<(OpenedUrl: string) => void>;
        OnMediaOpenFailed: $MulticastDelegate<(FailedUrl: string) => void>;
        OnPlaybackResumed: $MulticastDelegate<() => void>;
        OnPlaybackSuspended: $MulticastDelegate<() => void>;
        OnSeekCompleted: $MulticastDelegate<() => void>;
        OnTracksChanged: $MulticastDelegate<() => void>;
        CacheAhead: Timespan;
        CacheBehind: Timespan;
        CacheBehindGame: Timespan;
        NativeAudioOut: boolean;
        PlayOnOpen: boolean;
        Shuffle: boolean;
        Loop: boolean;
        Playlist: MediaPlaylist;
        PlaylistIndex: number;
        TimeDelay: Timespan;
        HorizontalFieldOfView: number;
        VerticalFieldOfView: number;
        ViewRotation: Rotator;
        PlayerGuid: Guid;
        AffectedByPIEHandling: boolean;

        CanPause(): boolean;

        CanPlaySource(MediaSource: $Nullable<MediaSource>): boolean;

        CanPlayUrl(Url: string): boolean;

        Close(): void;

        GetAudioTrackChannels(TrackIndex: number, FormatIndex: number): number;

        GetAudioTrackSampleRate(TrackIndex: number, FormatIndex: number): number;

        GetAudioTrackType(TrackIndex: number, FormatIndex: number): string;

        GetDesiredPlayerName(): string;

        GetDuration(): Timespan;

        GetHorizontalFieldOfView(): number;

        GetMediaName(): string;

        GetNumTrackFormats(TrackType: EMediaPlayerTrack, TrackIndex: number): number;

        GetNumTracks(TrackType: EMediaPlayerTrack): number;

        GetPlayerName(): string;

        GetPlaylist(): MediaPlaylist;

        GetPlaylistIndex(): number;

        GetRate(): number;

        GetSelectedTrack(TrackType: EMediaPlayerTrack): number;

        GetSupportedRates(OutRates: $Ref<TArray<FloatRange>>, Unthinned: boolean): void;

        GetTime(): Timespan;

        GetTimeDelay(): Timespan;

        GetTimeStamp(): MediaTimeStampInfo;

        GetTrackDisplayName(TrackType: EMediaPlayerTrack, TrackIndex: number): string;

        GetTrackFormat(TrackType: EMediaPlayerTrack, TrackIndex: number): number;

        GetTrackLanguage(TrackType: EMediaPlayerTrack, TrackIndex: number): string;

        GetUrl(): string;

        GetVerticalFieldOfView(): number;

        GetVideoTrackAspectRatio(TrackIndex: number, FormatIndex: number): number;

        GetVideoTrackDimensions(TrackIndex: number, FormatIndex: number): IntPoint;

        GetVideoTrackFrameRate(TrackIndex: number, FormatIndex: number): number;

        GetVideoTrackFrameRates(TrackIndex: number, FormatIndex: number): FloatRange;

        GetVideoTrackType(TrackIndex: number, FormatIndex: number): string;

        GetViewRotation(): Rotator;

        HasError(): boolean;

        IsBuffering(): boolean;

        IsClosed(): boolean;

        IsConnecting(): boolean;

        IsLooping(): boolean;

        IsPaused(): boolean;

        IsPlaying(): boolean;

        IsPreparing(): boolean;

        IsReady(): boolean;

        Next(): boolean;

        OpenFile(FilePath: string): boolean;

        OpenPlaylist(InPlaylist: $Nullable<MediaPlaylist>): boolean;

        OpenPlaylistIndex(InPlaylist: $Nullable<MediaPlaylist>, Index: number): boolean;

        OpenSource(MediaSource: $Nullable<MediaSource>): boolean;

        OpenSourceLatent(WorldContextObject: $Nullable<Object>, LatentInfo: LatentActionInfo, MediaSource: $Nullable<MediaSource>, Options: MediaPlayerOptions, bSuccess: $Ref<boolean>): void;

        OpenSourceWithOptions(MediaSource: $Nullable<MediaSource>, Options: MediaPlayerOptions): boolean;

        OpenUrl(Url: string): boolean;

        Pause(): boolean;

        Play(): boolean;

        PlayAndSeek(): void;

        Previous(): boolean;

        Reopen(): boolean;

        Rewind(): boolean;

        Seek(Time: Timespan): boolean;

        SelectTrack(TrackType: EMediaPlayerTrack, TrackIndex: number): boolean;

        SetBlockOnTime(Time: Timespan): void;

        SetDesiredPlayerName(PlayerName: string): void;

        SetLooping(Looping: boolean): boolean;

        SetMediaOptions(Options: $Nullable<MediaSource>): void;

        SetNativeVolume(Volume: number): boolean;

        SetRate(Rate: number): boolean;

        SetTimeDelay(TimeDelay: Timespan): void;

        SetTrackFormat(TrackType: EMediaPlayerTrack, TrackIndex: number, FormatIndex: number): boolean;

        SetVideoTrackFrameRate(TrackIndex: number, FormatIndex: number, FrameRate: number): boolean;

        SetViewField(Horizontal: number, Vertical: number, Absolute: boolean): boolean;

        SetViewRotation(Rotation: Rotator, Absolute: boolean): boolean;

        SupportsRate(Rate: number, Unthinned: boolean): boolean;

        SupportsScrubbing(): boolean;

        SupportsSeeking(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MediaPlayer;

        static Load(InName: string): MediaPlayer;
    }

    export class MediaTexture extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddressX: TextureAddress;
        AddressY: TextureAddress;
        AutoClear: boolean;
        ClearColor: LinearColor;
        EnableGenMips: boolean;
        NumMips: number;
        NewStyleOutput: boolean;
        OutputFormat: MediaTextureOutputFormat;
        CurrentAspectRatio: number;
        CurrentOrientation: MediaTextureOrientation;
        MediaPlayer: MediaPlayer;

        GetAspectRatio(): number;

        GetHeight(): number;

        GetMediaPlayer(): MediaPlayer;

        GetWidth(): number;

        SetMediaPlayer(NewMediaPlayer: $Nullable<MediaPlayer>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MediaTexture;

        static Load(InName: string): MediaTexture;
    }

    export class MediaComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MediaTexture: MediaTexture;
        MediaPlayer: MediaPlayer;

        GetMediaPlayer(): MediaPlayer;

        GetMediaTexture(): MediaTexture;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MediaComponent;

        static Load(InName: string): MediaComponent;
    }

    export class LevelSequenceMediaController extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sequence: LevelSequenceActor;
        MediaComponent: MediaComponent;
        ServerStartTimeSeconds: number;

        GetMediaComponent(): MediaComponent;

        GetSequence(): LevelSequenceActor;

        OnRep_ServerStartTimeSeconds(): void;

        Play(): void;

        SynchronizeToServer(DesyncThresholdSeconds?: number /* = 2.000000 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequenceMediaController;

        static Load(InName: string): LevelSequenceMediaController;
    }

    export class LevelSequenceMetaData extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelSequenceMetaData;

        static Load(InName: string): LevelSequenceMetaData;
    }

    export class LevelStreamingAlwaysLoaded extends LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelStreamingAlwaysLoaded;

        static Load(InName: string): LevelStreamingAlwaysLoaded;
    }

    export class LevelStreamingPersistent extends LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelStreamingPersistent;

        static Load(InName: string): LevelStreamingPersistent;
    }

    export class LevelThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelThumbnailRenderer;

        static Load(InName: string): LevelThumbnailRenderer;
    }

    export class LevelViewportToolBarContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LevelViewportToolBarContext;

        static Load(InName: string): LevelViewportToolBarContext;
    }

    export class LightingBuildInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Object: TWeakObjectPtr<Object>;
        LightingTime: number;
        UnmappedTexelsPercentage: number;
        UnmappedTexelsMemory: number;
        TotalTexelMemory: number;
        LevelName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightingBuildInfo;

        static Load(InName: string): LightingBuildInfo;
    }

    export class LightmappedSurfaceCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceModel: Model;
        Surfaces: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightmappedSurfaceCollection;

        static Load(InName: string): LightmappedSurfaceCollection;
    }

    export class LightMapTexture2D extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightMapTexture2D;

        static Load(InName: string): LightMapTexture2D;
    }

    export class VirtualTexture extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VirtualTexture;

        static Load(InName: string): VirtualTexture;
    }

    export class LightMapVirtualTexture extends VirtualTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightMapVirtualTexture;

        static Load(InName: string): LightMapVirtualTexture;
    }

    export class LightMapVirtualTexture2D extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TypeToLayer: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightMapVirtualTexture2D;

        static Load(InName: string): LightMapVirtualTexture2D;
    }

    export class LightmassCharacterIndirectDetailVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightmassCharacterIndirectDetailVolume;

        static Load(InName: string): LightmassCharacterIndirectDetailVolume;
    }

    export class LightmassImportanceVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightmassImportanceVolume;

        static Load(InName: string): LightmassImportanceVolume;
    }

    export class LightmassDebugOptions {
        constructor();
        constructor(bDebugMode: boolean, bStatsEnabled: boolean, bGatherBSPSurfacesAcrossComponents: boolean, CoplanarTolerance: number, bUseImmediateImport: boolean, bImmediateProcessMappings: boolean, bSortMappings: boolean, bDumpBinaryFiles: boolean, bDebugMaterials: boolean, bPadMappings: boolean, bDebugPaddings: boolean, bOnlyCalcDebugTexelMappings: boolean, bUseRandomColors: boolean, bColorBordersGreen: boolean, bColorByExecutionTime: boolean, ExecutionTimeDivisor: number);

        bDebugMode: boolean;
        bStatsEnabled: boolean;
        bGatherBSPSurfacesAcrossComponents: boolean;
        CoplanarTolerance: number;
        bUseImmediateImport: boolean;
        bImmediateProcessMappings: boolean;
        bSortMappings: boolean;
        bDumpBinaryFiles: boolean;
        bDebugMaterials: boolean;
        bPadMappings: boolean;
        bDebugPaddings: boolean;
        bOnlyCalcDebugTexelMappings: boolean;
        bUseRandomColors: boolean;
        bColorBordersGreen: boolean;
        bColorByExecutionTime: boolean;
        ExecutionTimeDivisor: number;

        static StaticClass(): Class;
    }

    export class SwarmDebugOptions {
        constructor();
        constructor(bDistributionEnabled: boolean, bForceContentExport: boolean, bInitialized: boolean);

        bDistributionEnabled: boolean;
        bForceContentExport: boolean;
        bInitialized: boolean;

        static StaticClass(): Class;
    }

    export class LightmassOptionsObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DebugSettings: LightmassDebugOptions;
        SwarmSettings: SwarmDebugOptions;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightmassOptionsObject;

        static Load(InName: string): LightmassOptionsObject;
    }

    export class LightmassPortalComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PreviewBox: BoxComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightmassPortalComponent;

        static Load(InName: string): LightmassPortalComponent;
    }

    export class LightmassPortal extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PortalComponent: LightmassPortalComponent;
        SpriteComponent: BillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightmassPortal;

        static Load(InName: string): LightmassPortal;
    }

    export class LightmassPrimitiveSettingsObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LightmassSettings: LightmassPrimitiveSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightmassPrimitiveSettingsObject;

        static Load(InName: string): LightmassPrimitiveSettingsObject;
    }

    export class LightPropagationVolumeSettings {
        constructor();
        constructor(bOverride_LPVIntensity: boolean, bOverride_LPVDirectionalOcclusionIntensity: boolean, bOverride_LPVDirectionalOcclusionRadius: boolean, bOverride_LPVDiffuseOcclusionExponent: boolean, bOverride_LPVSpecularOcclusionExponent: boolean, bOverride_LPVDiffuseOcclusionIntensity: boolean, bOverride_LPVSpecularOcclusionIntensity: boolean, bOverride_LPVSize: boolean, bOverride_LPVSecondaryOcclusionIntensity: boolean, bOverride_LPVSecondaryBounceIntensity: boolean, bOverride_LPVGeometryVolumeBias: boolean, bOverride_LPVVplInjectionBias: boolean, bOverride_LPVEmissiveInjectionIntensity: boolean, LPVIntensity: number, LPVVplInjectionBias: number, LPVSize: number, LPVSecondaryOcclusionIntensity: number, LPVSecondaryBounceIntensity: number, LPVGeometryVolumeBias: number, LPVEmissiveInjectionIntensity: number, LPVDirectionalOcclusionIntensity: number, LPVDirectionalOcclusionRadius: number, LPVDiffuseOcclusionExponent: number, LPVSpecularOcclusionExponent: number, LPVDiffuseOcclusionIntensity: number, LPVSpecularOcclusionIntensity: number, LPVFadeRange: number, LPVDirectionalOcclusionFadeRange: number);

        bOverride_LPVIntensity: boolean;
        bOverride_LPVDirectionalOcclusionIntensity: boolean;
        bOverride_LPVDirectionalOcclusionRadius: boolean;
        bOverride_LPVDiffuseOcclusionExponent: boolean;
        bOverride_LPVSpecularOcclusionExponent: boolean;
        bOverride_LPVDiffuseOcclusionIntensity: boolean;
        bOverride_LPVSpecularOcclusionIntensity: boolean;
        bOverride_LPVSize: boolean;
        bOverride_LPVSecondaryOcclusionIntensity: boolean;
        bOverride_LPVSecondaryBounceIntensity: boolean;
        bOverride_LPVGeometryVolumeBias: boolean;
        bOverride_LPVVplInjectionBias: boolean;
        bOverride_LPVEmissiveInjectionIntensity: boolean;
        LPVIntensity: number;
        LPVVplInjectionBias: number;
        LPVSize: number;
        LPVSecondaryOcclusionIntensity: number;
        LPVSecondaryBounceIntensity: number;
        LPVGeometryVolumeBias: number;
        LPVEmissiveInjectionIntensity: number;
        LPVDirectionalOcclusionIntensity: number;
        LPVDirectionalOcclusionRadius: number;
        LPVDiffuseOcclusionExponent: number;
        LPVSpecularOcclusionExponent: number;
        LPVDiffuseOcclusionIntensity: number;
        LPVSpecularOcclusionIntensity: number;
        LPVFadeRange: number;
        LPVDirectionalOcclusionFadeRange: number;

        static StaticClass(): Class;
    }

    export class LightPropagationVolumeBlendable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: LightPropagationVolumeSettings;
        BlendWeight: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightPropagationVolumeBlendable;

        static Load(InName: string): LightPropagationVolumeBlendable;
    }

    export class LightPropagationVolumeBlendableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LightPropagationVolumeBlendableFactory;

        static Load(InName: string): LightPropagationVolumeBlendableFactory;
    }

    export class LinearStairBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StepLength: number;
        StepHeight: number;
        StepWidth: number;
        NumSteps: number;
        AddToFirstStep: number;
        GroupName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LinearStairBuilder;

        static Load(InName: string): LinearStairBuilder;
    }

    export class LineSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumberOfPoints: number;
        Length: number;
        bEnableUpToNextPoint: boolean;
        bUpToNextPoint: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LineSplineGenerator;

        static Load(InName: string): LineSplineGenerator;
    }

    export class LinkerPlaceholderClass extends Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderClass;

        static Load(InName: string): LinkerPlaceholderClass;
    }

    export class LinkerPlaceholderExportObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderExportObject;

        static Load(InName: string): LinkerPlaceholderExportObject;
    }

    export class LinkerPlaceholderFunction extends Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderFunction;

        static Load(InName: string): LinkerPlaceholderFunction;
    }

    export class LinuxTargetSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        SoundCueCookQualityIndex: number;
        TargetedRHIs: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LinuxTargetSettings;

        static Load(InName: string): LinuxTargetSettings;
    }

    export class ListMaterialsUsedWithMeshEmittersCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ListMaterialsUsedWithMeshEmittersCommandlet;

        static Load(InName: string): ListMaterialsUsedWithMeshEmittersCommandlet;
    }

    export class ListStaticMeshesImportedFromSpeedTreesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ListStaticMeshesImportedFromSpeedTreesCommandlet;

        static Load(InName: string): ListStaticMeshesImportedFromSpeedTreesCommandlet;
    }

    export class ListViewBase extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EntryWidgetClass: Class;
        WheelScrollMultiplier: number;
        bEnableScrollAnimation: boolean;
        bEnableFixedLineOffset: boolean;
        FixedLineScrollOffset: number;
        BP_OnEntryGenerated: $MulticastDelegate<(Widget: $Nullable<UserWidget>) => void>;
        BP_OnEntryReleased: $MulticastDelegate<(Widget: $Nullable<UserWidget>) => void>;
        NumDesignerPreviewEntries: number;
        EntryWidgetPool: UserWidgetPool;

        GetDisplayedEntryWidgets(): TArray<UserWidget>;

        RegenerateAllEntries(): void;

        RequestRefresh(): void;

        ScrollToBottom(): void;

        ScrollToTop(): void;

        SetScrollbarVisibility(InVisibility: ESlateVisibility): void;

        SetScrollOffset(InScrollOffset: number): void;

        SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ListViewBase;

        static Load(InName: string): ListViewBase;
    }

    export enum EOrientation { Orient_Horizontal, Orient_Vertical, Orient_MAX }

    export enum ESelectionMode { None, Single, SingleToggle, Multi, ESelectionMode_MAX }

    export enum EConsumeMouseWheel { WhenScrollingPossible, Always, Never, EConsumeMouseWheel_MAX }

    export class ListView extends ListViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Orientation: EOrientation;
        SelectionMode: ESelectionMode;
        ConsumeMouseWheel: EConsumeMouseWheel;
        bClearSelectionOnClick: boolean;
        bIsFocusable: boolean;
        EntrySpacing: number;
        bReturnFocusToSelection: boolean;
        ListItems: TArray<Object>;
        BP_OnEntryInitialized: $MulticastDelegate<(Item: $Nullable<Object>, Widget: $Nullable<UserWidget>) => void>;
        BP_OnItemClicked: $MulticastDelegate<(Item: $Nullable<Object>) => void>;
        BP_OnItemDoubleClicked: $MulticastDelegate<(Item: $Nullable<Object>) => void>;
        BP_OnItemIsHoveredChanged: $MulticastDelegate<(Item: $Nullable<Object>, bIsHovered: boolean) => void>;
        BP_OnItemSelectionChanged: $MulticastDelegate<(Item: $Nullable<Object>, bIsSelected: boolean) => void>;
        BP_OnItemScrolledIntoView: $MulticastDelegate<(Item: $Nullable<Object>, Widget: $Nullable<UserWidget>) => void>;

        AddItem(Item: $Nullable<Object>): void;

        BP_CancelScrollIntoView(): void;

        BP_ClearSelection(): void;

        BP_GetNumItemsSelected(): number;

        BP_GetSelectedItem(): Object;

        BP_GetSelectedItems(Items: $Ref<TArray<Object>>): boolean;

        BP_IsItemVisible(Item: $Nullable<Object>): boolean;

        BP_NavigateToItem(Item: $Nullable<Object>): void;

        BP_ScrollItemIntoView(Item: $Nullable<Object>): void;

        BP_SetItemSelection(Item: $Nullable<Object>, bSelected: boolean): void;

        BP_SetListItems(InListItems: TArray<Object>): void;

        BP_SetSelectedItem(Item: $Nullable<Object>): void;

        ClearListItems(): void;

        GetIndexForItem(Item: $Nullable<Object>): number;

        GetItemAt(Index: number): Object;

        GetListItems(): TArray<Object>;

        GetNumItems(): number;

        IsRefreshPending(): boolean;

        NavigateToIndex(Index: number): void;

        RemoveItem(Item: $Nullable<Object>): void;

        ScrollIndexIntoView(Index: number): void;

        SetSelectedIndex(Index: number): void;

        SetSelectionMode(SelectionMode: ESelectionMode): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ListView;

        static Load(InName: string): ListView;
    }

    export class ListViewDesignerPreviewItem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ListViewDesignerPreviewItem;

        static Load(InName: string): ListViewDesignerPreviewItem;
    }

    export enum ELiveCodingStartupMode { Automatic, AutomaticButHidden, Manual, ELiveCodingStartupMode_MAX }

    export class LiveCodingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bEnabled: boolean;
        Startup: ELiveCodingStartupMode;
        bPreloadEngineModules: boolean;
        bPreloadEnginePluginModules: boolean;
        bPreloadProjectModules: boolean;
        bPreloadProjectPluginModules: boolean;
        PreloadNamedModules: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveCodingSettings;

        static Load(InName: string): LiveCodingSettings;
    }

    export class LiveLinkRole extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkRole;

        static Load(InName: string): LiveLinkRole;
    }

    export class LiveLinkBasicRole extends LiveLinkRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkBasicRole;

        static Load(InName: string): LiveLinkBasicRole;
    }

    export class LiveLinkAnimationRole extends LiveLinkBasicRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkAnimationRole;

        static Load(InName: string): LiveLinkAnimationRole;
    }

    export class LiveLinkTransformRole extends LiveLinkBasicRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkTransformRole;

        static Load(InName: string): LiveLinkTransformRole;
    }

    export class LiveLinkCameraRole extends LiveLinkTransformRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkCameraRole;

        static Load(InName: string): LiveLinkCameraRole;
    }

    export class LiveLinkController extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkController;

        static Load(InName: string): LiveLinkController;
    }

    export enum ELiveLinkSourceMode { Latest, EngineTime, Timecode, ELiveLinkSourceMode_MAX }

    export class LiveLinkSourceBufferManagementSettings {
        constructor();
        constructor(bValidEngineTimeEnabled: boolean, ValidEngineTime: number, EngineTimeOffset: number, EngineTimeClockOffset: number, TimecodeFrameRate: FrameRate, bGenerateSubFrame: boolean, DetectedFrameRate: FrameRate, bUseTimecodeSmoothLatest: boolean, SourceTimecodeFrameRate: FrameRate, bValidTimecodeFrameEnabled: boolean, ValidTimecodeFrame: number, TimecodeFrameOffset: number, TimecodeClockOffset: number, LatestOffset: number, MaxNumberOfFrameToBuffered: number, bKeepAtLeastOneFrame: boolean);

        bValidEngineTimeEnabled: boolean;
        ValidEngineTime: number;
        EngineTimeOffset: number;
        EngineTimeClockOffset: number;
        TimecodeFrameRate: FrameRate;
        bGenerateSubFrame: boolean;
        DetectedFrameRate: FrameRate;
        bUseTimecodeSmoothLatest: boolean;
        SourceTimecodeFrameRate: FrameRate;
        bValidTimecodeFrameEnabled: boolean;
        ValidTimecodeFrame: number;
        TimecodeFrameOffset: number;
        TimecodeClockOffset: number;
        LatestOffset: number;
        MaxNumberOfFrameToBuffered: number;
        bKeepAtLeastOneFrame: boolean;

        static StaticClass(): Class;
    }

    export class LiveLinkSubjectName {
        constructor();
        constructor(Name: string);

        Name: string;

        static StaticClass(): Class;
    }

    export class LiveLinkSourceDebugInfo {
        constructor();
        constructor(SubjectName: LiveLinkSubjectName, SnapshotIndex: number, NumberOfBufferAtSnapshot: number);

        SubjectName: LiveLinkSubjectName;
        SnapshotIndex: number;
        NumberOfBufferAtSnapshot: number;

        static StaticClass(): Class;
    }

    export class LiveLinkSourceSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Mode: ELiveLinkSourceMode;
        BufferSettings: LiveLinkSourceBufferManagementSettings;
        ConnectionString: string;
        Factory: Class;
        SourceDebugInfos: TArray<LiveLinkSourceDebugInfo>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkSourceSettings;

        static Load(InName: string): LiveLinkSourceSettings;
    }

    export class LiveLinkCurveConversionSettings {
        constructor();
        constructor(CurveConversionAssetMap: TMap<string, SoftObjectPath>);

        CurveConversionAssetMap: TMap<string, SoftObjectPath>;

        static StaticClass(): Class;
    }

    export class LiveLinkCurveRemapSettings extends LiveLinkSourceSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurveConversionSettings: LiveLinkCurveConversionSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkCurveRemapSettings;

        static Load(InName: string): LiveLinkCurveRemapSettings;
    }

    export class LiveLinkFrameInterpolationProcessor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkFrameInterpolationProcessor;

        static Load(InName: string): LiveLinkFrameInterpolationProcessor;
    }

    export class LiveLinkFramePreProcessor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkFramePreProcessor;

        static Load(InName: string): LiveLinkFramePreProcessor;
    }

    export class LiveLinkFrameTranslator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkFrameTranslator;

        static Load(InName: string): LiveLinkFrameTranslator;
    }

    export class LiveLinkLightRole extends LiveLinkTransformRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkLightRole;

        static Load(InName: string): LiveLinkLightRole;
    }

    export class LiveLinkSourceFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkSourceFactory;

        static Load(InName: string): LiveLinkSourceFactory;
    }

    export class LiveLinkSubjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PreProcessors: TArray<LiveLinkFramePreProcessor>;
        InterpolationProcessor: LiveLinkFrameInterpolationProcessor;
        Translators: TArray<LiveLinkFrameTranslator>;
        Role: Class;
        FrameRate: FrameRate;
        bRebroadcastSubject: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkSubjectSettings;

        static Load(InName: string): LiveLinkSubjectSettings;
    }

    export class LiveLinkVirtualSubject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Role: Class;
        Subjects: TArray<LiveLinkSubjectName>;
        FrameTranslators: TArray<LiveLinkFrameTranslator>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LiveLinkVirtualSubject;

        static Load(InName: string): LiveLinkVirtualSubject;
    }

    export class LoadPackageCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LoadPackageCommandlet;

        static Load(InName: string): LoadPackageCommandlet;
    }

    export class LocalClickDragInputBehavior extends ClickDragInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalClickDragInputBehavior;

        static Load(InName: string): LocalClickDragInputBehavior;
    }

    export enum ELocalizationTargetConflictStatus {
        Unknown,
        ConflictsPresent,
        Clear,
        ELocalizationTargetConflictStatus_MAX
    }

    export enum ELocalizationGatherPathRoot { Auto, Engine, Project, ELocalizationGatherPathRoot_MAX }

    export class GatherTextSearchDirectory {
        constructor();
        constructor(PathRoot: ELocalizationGatherPathRoot, Path: string);

        PathRoot: ELocalizationGatherPathRoot;
        Path: string;

        static StaticClass(): Class;
    }

    export class GatherTextExcludePath {
        constructor();
        constructor(PathRoot: ELocalizationGatherPathRoot, Pattern: string);

        PathRoot: ELocalizationGatherPathRoot;
        Pattern: string;

        static StaticClass(): Class;
    }

    export class GatherTextFileExtension {
        constructor();
        constructor(Pattern: string);

        Pattern: string;

        static StaticClass(): Class;
    }

    export class GatherTextFromTextFilesConfiguration {
        constructor();
        constructor(IsEnabled: boolean, SearchDirectories: TArray<GatherTextSearchDirectory>, ExcludePathWildcards: TArray<GatherTextExcludePath>, FileExtensions: TArray<GatherTextFileExtension>, ShouldGatherFromEditorOnlyData: boolean);

        IsEnabled: boolean;
        SearchDirectories: TArray<GatherTextSearchDirectory>;
        ExcludePathWildcards: TArray<GatherTextExcludePath>;
        FileExtensions: TArray<GatherTextFileExtension>;
        ShouldGatherFromEditorOnlyData: boolean;

        static StaticClass(): Class;
    }

    export class GatherTextIncludePath {
        constructor();
        constructor(PathRoot: ELocalizationGatherPathRoot, Pattern: string);

        PathRoot: ELocalizationGatherPathRoot;
        Pattern: string;

        static StaticClass(): Class;
    }

    export class GatherTextFromPackagesConfiguration {
        constructor();
        constructor(IsEnabled: boolean, IncludePathWildcards: TArray<GatherTextIncludePath>, ExcludePathWildcards: TArray<GatherTextExcludePath>, FileExtensions: TArray<GatherTextFileExtension>, Collections: TArray<string>, ExcludeClasses: TArray<SoftClassPath>, ShouldExcludeDerivedClasses: boolean, ShouldGatherFromEditorOnlyData: boolean, SkipGatherCache: boolean);

        IsEnabled: boolean;
        IncludePathWildcards: TArray<GatherTextIncludePath>;
        ExcludePathWildcards: TArray<GatherTextExcludePath>;
        FileExtensions: TArray<GatherTextFileExtension>;
        Collections: TArray<string>;
        ExcludeClasses: TArray<SoftClassPath>;
        ShouldExcludeDerivedClasses: boolean;
        ShouldGatherFromEditorOnlyData: boolean;
        SkipGatherCache: boolean;

        static StaticClass(): Class;
    }

    export class MetaDataKeyName {
        constructor();
        constructor(Name: string);

        Name: string;

        static StaticClass(): Class;
    }

    export class MetaDataTextKeyPattern {
        constructor();
        constructor(Pattern: string);

        Pattern: string;

        static StaticClass(): Class;
    }

    export class MetaDataKeyGatherSpecification {
        constructor();
        constructor(MetaDataKey: MetaDataKeyName, TextNamespace: string, TextKeyPattern: MetaDataTextKeyPattern);

        MetaDataKey: MetaDataKeyName;
        TextNamespace: string;
        TextKeyPattern: MetaDataTextKeyPattern;

        static StaticClass(): Class;
    }

    export class GatherTextFromMetaDataConfiguration {
        constructor();
        constructor(IsEnabled: boolean, IncludePathWildcards: TArray<GatherTextIncludePath>, ExcludePathWildcards: TArray<GatherTextExcludePath>, KeySpecifications: TArray<MetaDataKeyGatherSpecification>, ShouldGatherFromEditorOnlyData: boolean);

        IsEnabled: boolean;
        IncludePathWildcards: TArray<GatherTextIncludePath>;
        ExcludePathWildcards: TArray<GatherTextExcludePath>;
        KeySpecifications: TArray<MetaDataKeyGatherSpecification>;
        ShouldGatherFromEditorOnlyData: boolean;

        static StaticClass(): Class;
    }

    export enum ELocalizedTextCollapseMode {
        IdenticalTextIdAndSource,
        IdenticalPackageIdTextIdAndSource,
        IdenticalNamespaceAndSource,
        ELocalizedTextCollapseMode_MAX
    }

    export enum EPortableObjectFormat { Unreal, Crowdin, EPortableObjectFormat_MAX }

    export class LocalizationExportingSettings {
        constructor();
        constructor(CollapseMode: ELocalizedTextCollapseMode, POFormat: EPortableObjectFormat, ShouldPersistCommentsOnExport: boolean, ShouldAddSourceLocationsAsComments: boolean);

        CollapseMode: ELocalizedTextCollapseMode;
        POFormat: EPortableObjectFormat;
        ShouldPersistCommentsOnExport: boolean;
        ShouldAddSourceLocationsAsComments: boolean;

        static StaticClass(): Class;
    }

    export class LocalizationCompilationSettings {
        constructor();
        constructor(SkipSourceCheck: boolean, ValidateFormatPatterns: boolean, ValidateSafeWhitespace: boolean);

        SkipSourceCheck: boolean;
        ValidateFormatPatterns: boolean;
        ValidateSafeWhitespace: boolean;

        static StaticClass(): Class;
    }

    export class LocalizationImportDialogueSettings {
        constructor();
        constructor(RawAudioPath: DirectoryPath, ImportedDialogueFolder: string, bImportNativeAsSource: boolean);

        RawAudioPath: DirectoryPath;
        ImportedDialogueFolder: string;
        bImportNativeAsSource: boolean;

        static StaticClass(): Class;
    }

    export class CultureStatistics {
        constructor();
        constructor(CultureName: string, WordCount: number);

        CultureName: string;
        WordCount: number;

        static StaticClass(): Class;
    }

    export class LocalizationTargetSettings {
        constructor();
        constructor(Name: string, Guid: Guid, ConflictStatus: ELocalizationTargetConflictStatus, TargetDependencies: TArray<Guid>, AdditionalManifestDependencies: TArray<FilePath>, RequiredModuleNames: TArray<string>, GatherFromTextFiles: GatherTextFromTextFilesConfiguration, GatherFromPackages: GatherTextFromPackagesConfiguration, GatherFromMetaData: GatherTextFromMetaDataConfiguration, ExportSettings: LocalizationExportingSettings, CompileSettings: LocalizationCompilationSettings, ImportDialogueSettings: LocalizationImportDialogueSettings, NativeCultureIndex: number, SupportedCulturesStatistics: TArray<CultureStatistics>);

        Name: string;
        Guid: Guid;
        ConflictStatus: ELocalizationTargetConflictStatus;
        TargetDependencies: TArray<Guid>;
        AdditionalManifestDependencies: TArray<FilePath>;
        RequiredModuleNames: TArray<string>;
        GatherFromTextFiles: GatherTextFromTextFilesConfiguration;
        GatherFromPackages: GatherTextFromPackagesConfiguration;
        GatherFromMetaData: GatherTextFromMetaDataConfiguration;
        ExportSettings: LocalizationExportingSettings;
        CompileSettings: LocalizationCompilationSettings;
        ImportDialogueSettings: LocalizationImportDialogueSettings;
        NativeCultureIndex: number;
        SupportedCulturesStatistics: TArray<CultureStatistics>;

        static StaticClass(): Class;
    }

    export class LocalizationTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: LocalizationTargetSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalizationTarget;

        static Load(InName: string): LocalizationTarget;
    }

    export class LocalizationTargetSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetObjects: TArray<LocalizationTarget>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalizationTargetSet;

        static Load(InName: string): LocalizationTargetSet;
    }

    export class LocalizationSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EngineTargetSet: LocalizationTargetSet;
        EngineTargetsSettings: TArray<LocalizationTargetSettings>;
        GameTargetSet: LocalizationTargetSet;
        GameTargetsSettings: TArray<LocalizationTargetSettings>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalizationSettings;

        static Load(InName: string): LocalizationSettings;
    }

    export class LocalizedOverlays extends Overlays {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultOverlays: BasicOverlays;
        LocaleToOverlaysMap: TMap<string, BasicOverlays>;
        AssetImportData: AssetImportData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalizedOverlays;

        static Load(InName: string): LocalizedOverlays;
    }

    export class LocalizedOverlaysFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalizedOverlaysFactoryNew;

        static Load(InName: string): LocalizedOverlaysFactoryNew;
    }

    export class LocalPlayerSubsystem extends Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalPlayerSubsystem;

        static Load(InName: string): LocalPlayerSubsystem;
    }

    export class LocalProfiles extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Profiles: TArray<PreviewSceneProfile>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocalProfiles;

        static Load(InName: string): LocalProfiles;
    }

    export enum ELocationAccuracy {
        LA_ThreeKilometers,
        LA_OneKilometer,
        LA_HundredMeters,
        LA_TenMeters,
        LA_Best,
        LA_Navigation,
        LA_MAX
    }

    export class LocationServicesData {
        constructor();
        constructor(Timestamp: number, Longitude: number, Latitude: number, HorizontalAccuracy: number, VerticalAccuracy: number, Altitude: number);

        Timestamp: number;
        Longitude: number;
        Latitude: number;
        HorizontalAccuracy: number;
        VerticalAccuracy: number;
        Altitude: number;

        static StaticClass(): Class;
    }

    export class LocationServicesImpl extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnLocationChanged: $MulticastDelegate<(LocationData: LocationServicesData) => void>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocationServicesImpl;

        static Load(InName: string): LocationServicesImpl;
    }

    export class LocationServices extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AreLocationServicesEnabled(): boolean;

        static GetLastKnownLocation(): LocationServicesData;

        static GetLocationServicesImpl(): LocationServicesImpl;

        static InitLocationServices(Accuracy: ELocationAccuracy, UpdateFrequency: number, MinDistanceFilter: number): boolean;

        static IsLocationAccuracyAvailable(Accuracy: ELocationAccuracy): boolean;

        static StartLocationServices(): boolean;

        static StopLocationServices(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LocationServices;

        static Load(InName: string): LocationServices;
    }

    export class LODInfoUILayout extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LODInfo: SkeletalMeshLODInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LODInfoUILayout;

        static Load(InName: string): LODInfoUILayout;
    }

    export enum ESyncOption { Drive, Passive, Disabled, ESyncOption_MAX }

    export class ComponentSync {
        constructor();
        constructor(Name: string, SyncOption: ESyncOption);

        Name: string;
        SyncOption: ESyncOption;

        static StaticClass(): Class;
    }

    export class LODMappingData {
        constructor();
        constructor(Mapping: TArray<number>, InverseMapping: TArray<number>);

        Mapping: TArray<number>;
        InverseMapping: TArray<number>;

        static StaticClass(): Class;
    }

    export class LODSyncComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumLODs: number;
        ForcedLOD: number;
        ComponentsToSync: TArray<ComponentSync>;
        CustomLODMapping: TMap<string, LODMappingData>;
        CurrentLOD: number;
        CurrentNumLODs: number;
        DriveComponents: TArray<PrimitiveComponent>;
        SubComponents: TArray<PrimitiveComponent>;

        GetLODSyncDebugText(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LODSyncComponent;

        static Load(InName: string): LODSyncComponent;
    }

    export class LODSyncInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LODSyncInterface;

        static Load(InName: string): LODSyncInterface;
    }

    export class LogoutCallbackProxy extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(PlayerController: $Nullable<PlayerController>) => void>;
        OnFailure: $MulticastDelegate<(PlayerController: $Nullable<PlayerController>) => void>;

        static Logout(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>): LogoutCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): LogoutCallbackProxy;

        static Load(InName: string): LogoutCallbackProxy;
    }

    export enum EMacTargetArchitecture {
        MacTargetArchitectureIntel,
        MacTargetArchitectureUniversal,
        MacTargetArchitectureAppleSil,
        EMacTargetArchitecture_MAX
    }

    export class MacTargetSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetedRHIs: TArray<string>;
        TargetArchitecture: EMacTargetArchitecture;
        MaxShaderLanguageVersion: number;
        UseFastIntrinsics: boolean;
        ForceFloats: boolean;
        EnableMathOptimisations: boolean;
        IndirectArgumentTier: number;
        AudioSampleRate: number;
        AudioCallbackBufferFrameSize: number;
        AudioNumBuffersToEnqueue: number;
        AudioMaxChannels: number;
        AudioNumSourceWorkers: number;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        SoundCueCookQualityIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MacTargetSettings;

        static Load(InName: string): MacTargetSettings;
    }

    export class Manipulator extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssociatedComponent: SceneComponent;
        StaticMeshComponent: StaticMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Manipulator;

        static Load(InName: string): Manipulator;
    }

    export class MapProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MapProperty;

        static Load(InName: string): MapProperty;
    }

    export class MasterAudioSubmixCaptureProtocol extends MovieSceneAudioCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FileName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MasterAudioSubmixCaptureProtocol;

        static Load(InName: string): MasterAudioSubmixCaptureProtocol;
    }

    export enum EMaterialUsage {
        MATUSAGE_SkeletalMesh,
        MATUSAGE_ParticleSprites,
        MATUSAGE_BeamTrails,
        MATUSAGE_MeshParticles,
        MATUSAGE_StaticLighting,
        MATUSAGE_MorphTargets,
        MATUSAGE_SplineMesh,
        MATUSAGE_InstancedStaticMeshes,
        MATUSAGE_GeometryCollections,
        MATUSAGE_Clothing,
        MATUSAGE_NiagaraSprites,
        MATUSAGE_NiagaraRibbons,
        MATUSAGE_NiagaraMeshParticles,
        MATUSAGE_GeometryCache,
        MATUSAGE_Water,
        MATUSAGE_HairStrands,
        MATUSAGE_LidarPointCloud,
        MATUSAGE_VirtualHeightfieldMesh,
        MATUSAGE_MAX
    }

    export enum EMaterialProperty {
        MP_EmissiveColor,
        MP_Opacity,
        MP_OpacityMask,
        MP_DiffuseColor,
        MP_SpecularColor,
        MP_BaseColor,
        MP_Metallic,
        MP_Specular,
        MP_Roughness,
        MP_Anisotropy,
        MP_Normal,
        MP_Tangent,
        MP_WorldPositionOffset,
        MP_WorldDisplacement,
        MP_TessellationMultiplier,
        MP_SubsurfaceColor,
        MP_CustomData0,
        MP_CustomData1,
        MP_AmbientOcclusion,
        MP_Refraction,
        MP_CustomizedUVs0,
        MP_CustomizedUVs1,
        MP_CustomizedUVs2,
        MP_CustomizedUVs3,
        MP_CustomizedUVs4,
        MP_CustomizedUVs5,
        MP_CustomizedUVs6,
        MP_CustomizedUVs7,
        MP_PixelDepthOffset,
        MP_ShadingModel,
        MP_MaterialAttributes,
        MP_CustomOutput,
        MP_MAX
    }

    export class MaterialEditingLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ClearAllMaterialInstanceParameters(Instance: $Nullable<MaterialInstanceConstant>): void;

        static ConnectMaterialExpressions(FromExpression: $Nullable<MaterialExpression>, FromOutputName: string, ToExpression: $Nullable<MaterialExpression>, ToInputName: string): boolean;

        static ConnectMaterialProperty(FromExpression: $Nullable<MaterialExpression>, FromOutputName: string, Property: EMaterialProperty): boolean;

        static CreateMaterialExpression(Material: $Nullable<Material>, ExpressionClass: $Nullable<Class>, NodePosX?: number /* = 0 */, NodePosY?: number /* = 0 */): MaterialExpression;

        static CreateMaterialExpressionInFunction(MaterialFunction: $Nullable<MaterialFunction>, ExpressionClass: $Nullable<Class>, NodePosX?: number /* = 0 */, NodePosY?: number /* = 0 */): MaterialExpression;

        static DeleteAllMaterialExpressions(Material: $Nullable<Material>): void;

        static DeleteAllMaterialExpressionsInFunction(MaterialFunction: $Nullable<MaterialFunction>): void;

        static DeleteMaterialExpression(Material: $Nullable<Material>, Expression: $Nullable<MaterialExpression>): void;

        static DeleteMaterialExpressionInFunction(MaterialFunction: $Nullable<MaterialFunction>, Expression: $Nullable<MaterialExpression>): void;

        static GetChildInstances(Parent: $Nullable<MaterialInterface>, ChildInstances: $Ref<TArray<AssetData>>): void;

        static GetInputsForMaterialExpression(Material: $Nullable<Material>, MaterialExpression: $Nullable<MaterialExpression>): TArray<MaterialExpression>;

        static GetMaterialDefaultScalarParameterValue(Material: $Nullable<Material>, ParameterName: string): number;

        static GetMaterialDefaultStaticSwitchParameterValue(Material: $Nullable<Material>, ParameterName: string): boolean;

        static GetMaterialDefaultTextureParameterValue(Material: $Nullable<Material>, ParameterName: string): Texture;

        static GetMaterialDefaultVectorParameterValue(Material: $Nullable<Material>, ParameterName: string): LinearColor;

        static GetMaterialInstanceScalarParameterValue(Instance: $Nullable<MaterialInstanceConstant>, ParameterName: string): number;

        static GetMaterialInstanceStaticSwitchParameterValue(Instance: $Nullable<MaterialInstanceConstant>, ParameterName: string): boolean;

        static GetMaterialInstanceTextureParameterValue(Instance: $Nullable<MaterialInstanceConstant>, ParameterName: string): Texture;

        static GetMaterialInstanceVectorParameterValue(Instance: $Nullable<MaterialInstanceConstant>, ParameterName: string): LinearColor;

        static GetMaterialPropertyInputNode(Material: $Nullable<Material>, Property: EMaterialProperty): MaterialExpression;

        static GetMaterialSelectedNodes(Material: $Nullable<Material>): TSet<Object>;

        static GetNumMaterialExpressions(Material: $Nullable<Material>): number;

        static GetNumMaterialExpressionsInFunction(MaterialFunction: $Nullable<MaterialFunction>): number;

        static GetScalarParameterNames(Material: $Nullable<MaterialInterface>, ParameterNames: $Ref<TArray<string>>): void;

        static GetScalarParameterSource(Material: $Nullable<MaterialInterface>, ParameterName: string, ParameterSource: $Ref<SoftObjectPath>): boolean;

        static GetStaticSwitchParameterNames(Material: $Nullable<MaterialInterface>, ParameterNames: $Ref<TArray<string>>): void;

        static GetStaticSwitchParameterSource(Material: $Nullable<MaterialInterface>, ParameterName: string, ParameterSource: $Ref<SoftObjectPath>): boolean;

        static GetTextureParameterNames(Material: $Nullable<MaterialInterface>, ParameterNames: $Ref<TArray<string>>): void;

        static GetTextureParameterSource(Material: $Nullable<MaterialInterface>, ParameterName: string, ParameterSource: $Ref<SoftObjectPath>): boolean;

        static GetUsedTextures(Material: $Nullable<Material>): TArray<Texture>;

        static GetVectorParameterNames(Material: $Nullable<MaterialInterface>, ParameterNames: $Ref<TArray<string>>): void;

        static GetVectorParameterSource(Material: $Nullable<MaterialInterface>, ParameterName: string, ParameterSource: $Ref<SoftObjectPath>): boolean;

        static HasMaterialUsage(Material: $Nullable<Material>, Usage: EMaterialUsage): boolean;

        static LayoutMaterialExpressions(Material: $Nullable<Material>): void;

        static LayoutMaterialFunctionExpressions(MaterialFunction: $Nullable<MaterialFunction>): void;

        static RecompileMaterial(Material: $Nullable<Material>): void;

        static SetMaterialInstanceParent(Instance: $Nullable<MaterialInstanceConstant>, NewParent: $Nullable<MaterialInterface>): void;

        static SetMaterialInstanceScalarParameterValue(Instance: $Nullable<MaterialInstanceConstant>, ParameterName: string, Value: number): boolean;

        static SetMaterialInstanceTextureParameterValue(Instance: $Nullable<MaterialInstanceConstant>, ParameterName: string, Value: $Nullable<Texture>): boolean;

        static SetMaterialInstanceVectorParameterValue(Instance: $Nullable<MaterialInstanceConstant>, ParameterName: string, Value: LinearColor): boolean;

        static SetMaterialUsage(Material: $Nullable<Material>, Usage: EMaterialUsage, bNeedsRecompile: $Ref<boolean>): boolean;

        static UpdateMaterialFunction(MaterialFunction: $Nullable<MaterialFunctionInterface>, PreviewMaterial?: Material /* = None */): void;

        static UpdateMaterialInstance(Instance: $Nullable<MaterialInstanceConstant>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialEditingLibrary;

        static Load(InName: string): MaterialEditingLibrary;
    }

    export class EditorParameterGroup {
        constructor();
        constructor(GroupName: string, GroupAssociation: EMaterialParameterAssociation, Parameters: TArray<DEditorParameterValue>, GroupSortPriority: number);

        GroupName: string;
        GroupAssociation: EMaterialParameterAssociation;
        Parameters: TArray<DEditorParameterValue>;
        GroupSortPriority: number;

        static StaticClass(): Class;
    }

    export class MaterialFunctionInstance extends MaterialFunctionInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Parent: MaterialFunctionInterface;
        Base: MaterialFunctionInterface;
        ScalarParameterValues: TArray<ScalarParameterValue>;
        VectorParameterValues: TArray<VectorParameterValue>;
        TextureParameterValues: TArray<TextureParameterValue>;
        FontParameterValues: TArray<FontParameterValue>;
        StaticSwitchParameterValues: TArray<StaticSwitchParameter>;
        StaticComponentMaskParameterValues: TArray<StaticComponentMaskParameter>;
        RuntimeVirtualTextureParameterValues: TArray<RuntimeVirtualTextureParameterValue>;
        PreviewMaterial: MaterialInstanceConstant;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInstance;

        static Load(InName: string): MaterialFunctionInstance;
    }

    export class LightmassParameterValue {
        constructor();
        constructor(bOverride: boolean);

        bOverride: boolean;

        static StaticClass(): Class;
    }

    export class LightmassBooleanParameterValue extends LightmassParameterValue {
        constructor();
        constructor(ParameterValue: boolean);

        ParameterValue: boolean;

        static StaticClass(): Class;
    }

    export class LightmassScalarParameterValue extends LightmassParameterValue {
        constructor();
        constructor(ParameterValue: number);

        ParameterValue: number;

        static StaticClass(): Class;
    }

    export class LightmassParameterizedMaterialSettings {
        constructor();
        constructor(CastShadowAsMasked: LightmassBooleanParameterValue, EmissiveBoost: LightmassScalarParameterValue, DiffuseBoost: LightmassScalarParameterValue, ExportResolutionScale: LightmassScalarParameterValue);

        CastShadowAsMasked: LightmassBooleanParameterValue;
        EmissiveBoost: LightmassScalarParameterValue;
        DiffuseBoost: LightmassScalarParameterValue;
        ExportResolutionScale: LightmassScalarParameterValue;

        static StaticClass(): Class;
    }

    export class MaterialEditorInstanceConstant extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysMaterial: PhysicalMaterial;
        Parent: MaterialInterface;
        ParameterGroups: TArray<EditorParameterGroup>;
        RefractionDepthBias: number;
        SubsurfaceProfile: SubsurfaceProfile;
        bOverrideSubsurfaceProfile: boolean;
        bOverrideBaseProperties: boolean;
        bIsFunctionPreviewMaterial: boolean;
        bIsFunctionInstanceDirty: boolean;
        BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
        SourceInstance: MaterialInstanceConstant;
        SourceFunction: MaterialFunctionInstance;
        VisibleExpressions: TArray<MaterialParameterInfo>;
        LightmassSettings: LightmassParameterizedMaterialSettings;
        bUseOldStyleMICEditorGroups: boolean;
        StoredLayerPreviews: TArray<MaterialInstanceConstant>;
        StoredBlendPreviews: TArray<MaterialInstanceConstant>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialEditorInstanceConstant;

        static Load(InName: string): MaterialEditorInstanceConstant;
    }

    export class MaterialEditorMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialEditorMenuContext;

        static Load(InName: string): MaterialEditorMenuContext;
    }

    export class MaterialEditorMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialEditorMeshComponent;

        static Load(InName: string): MaterialEditorMeshComponent;
    }

    export class MaterialEditorOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bShowGrid: boolean;
        bHideUnusedConnectors: boolean;
        bRealtimeMaterialViewport: boolean;
        bRealtimeExpressionViewport: boolean;
        bLivePreviewUpdate: boolean;
        bHideUnrelatedNodes: boolean;
        bAlwaysRefreshAllPreviews: boolean;
        bUseUnsortedMenus: boolean;
        FavoriteExpressions: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialEditorOptions;

        static Load(InName: string): MaterialEditorOptions;
    }

    export class MaterialEditorPreviewParameters extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterGroups: TArray<EditorParameterGroup>;
        PreviewMaterial: Material;
        OriginalFunction: MaterialFunction;
        OriginalMaterial: Material;
        StoredLayerPreviews: TArray<MaterialInstanceConstant>;
        StoredBlendPreviews: TArray<MaterialInstanceConstant>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialEditorPreviewParameters;

        static Load(InName: string): MaterialEditorPreviewParameters;
    }

    export class MaterialEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaliOfflineCompilerPath: FilePath;
        DefaultPreviewWidth: number;
        DefaultPreviewHeight: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialEditorSettings;

        static Load(InName: string): MaterialEditorSettings;
    }

    export class MaterialExpressionAbs extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAbs;

        static Load(InName: string): MaterialExpressionAbs;
    }

    export class MaterialExpressionActorPositionWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionActorPositionWS;

        static Load(InName: string): MaterialExpressionActorPositionWS;
    }

    export class MaterialExpressionAdd extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAdd;

        static Load(InName: string): MaterialExpressionAdd;
    }

    export enum EMaterialSamplerType {
        SAMPLERTYPE_Color,
        SAMPLERTYPE_Grayscale,
        SAMPLERTYPE_Alpha,
        SAMPLERTYPE_Normal,
        SAMPLERTYPE_Masks,
        SAMPLERTYPE_DistanceFieldFont,
        SAMPLERTYPE_LinearColor,
        SAMPLERTYPE_LinearGrayscale,
        SAMPLERTYPE_Data,
        SAMPLERTYPE_External,
        SAMPLERTYPE_VirtualColor,
        SAMPLERTYPE_VirtualGrayscale,
        SAMPLERTYPE_VirtualAlpha,
        SAMPLERTYPE_VirtualNormal,
        SAMPLERTYPE_VirtualMasks,
        SAMPLERTYPE_VirtualLinearColor,
        SAMPLERTYPE_VirtualLinearGrayscale,
        SAMPLERTYPE_MAX
    }

    export class MaterialExpressionTextureBase extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Texture: Texture;
        SamplerType: EMaterialSamplerType;
        IsDefaultMeshpaintTexture: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureBase;

        static Load(InName: string): MaterialExpressionTextureBase;
    }

    export enum ETextureMipValueMode { TMVM_None, TMVM_MipLevel, TMVM_MipBias, TMVM_Derivative, TMVM_MAX }

    export enum ESamplerSourceMode {
        SSM_FromTextureAsset,
        SSM_Wrap_WorldGroupSettings,
        SSM_Clamp_WorldGroupSettings,
        SSM_MAX
    }

    export class MaterialExpressionTextureSample extends MaterialExpressionTextureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Coordinates: ExpressionInput;
        TextureObject: ExpressionInput;
        MipValue: ExpressionInput;
        CoordinatesDX: ExpressionInput;
        CoordinatesDY: ExpressionInput;
        AutomaticViewMipBiasValue: ExpressionInput;
        MipValueMode: ETextureMipValueMode;
        SamplerSource: ESamplerSourceMode;
        AutomaticViewMipBias: boolean;
        ConstCoordinate: number;
        ConstMipValue: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSample;

        static Load(InName: string): MaterialExpressionTextureSample;
    }

    export class MaterialExpressionTextureSampleParameter extends MaterialExpressionTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterName: string;
        ExpressionGUID: Guid;
        Group: string;
        SortPriority: number;
        ChannelNames: ParameterChannelNames;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter;

        static Load(InName: string): MaterialExpressionTextureSampleParameter;
    }

    export class MaterialExpressionTextureSampleParameter2D extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter2D;

        static Load(InName: string): MaterialExpressionTextureSampleParameter2D;
    }

    export enum ETextureColorChannel { TCC_Red, TCC_Green, TCC_Blue, TCC_Alpha, TCC_MAX }

    export class MaterialExpressionAntialiasedTextureMask extends MaterialExpressionTextureSampleParameter2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Threshold: number;
        Channel: ETextureColorChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAntialiasedTextureMask;

        static Load(InName: string): MaterialExpressionAntialiasedTextureMask;
    }

    export class MaterialExpressionAppendVector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAppendVector;

        static Load(InName: string): MaterialExpressionAppendVector;
    }

    export class MaterialExpressionArccosine extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArccosine;

        static Load(InName: string): MaterialExpressionArccosine;
    }

    export class MaterialExpressionArccosineFast extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArccosineFast;

        static Load(InName: string): MaterialExpressionArccosineFast;
    }

    export class MaterialExpressionArcsine extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArcsine;

        static Load(InName: string): MaterialExpressionArcsine;
    }

    export class MaterialExpressionArcsineFast extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArcsineFast;

        static Load(InName: string): MaterialExpressionArcsineFast;
    }

    export class MaterialExpressionArctangent extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent;

        static Load(InName: string): MaterialExpressionArctangent;
    }

    export class MaterialExpressionArctangent2 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Y: ExpressionInput;
        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent2;

        static Load(InName: string): MaterialExpressionArctangent2;
    }

    export class MaterialExpressionArctangent2Fast extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Y: ExpressionInput;
        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent2Fast;

        static Load(InName: string): MaterialExpressionArctangent2Fast;
    }

    export class MaterialExpressionArctangentFast extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangentFast;

        static Load(InName: string): MaterialExpressionArctangentFast;
    }

    export class MaterialExpressionAtmosphericFogColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WorldPosition: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericFogColor;

        static Load(InName: string): MaterialExpressionAtmosphericFogColor;
    }

    export class MaterialExpressionAtmosphericLightColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericLightColor;

        static Load(InName: string): MaterialExpressionAtmosphericLightColor;
    }

    export class MaterialExpressionAtmosphericLightVector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericLightVector;

        static Load(InName: string): MaterialExpressionAtmosphericLightVector;
    }

    export class MaterialExpressionBentNormalCustomOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBentNormalCustomOutput;

        static Load(InName: string): MaterialExpressionBentNormalCustomOutput;
    }

    export class MaterialExpressionBlackBody extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Temp: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBlackBody;

        static Load(InName: string): MaterialExpressionBlackBody;
    }

    export enum EMaterialAttributeBlend { Blend, UseA, UseB, EMaterialAttributeBlend_MAX }

    export class MaterialExpressionBlendMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: MaterialAttributesInput;
        B: MaterialAttributesInput;
        Alpha: ExpressionInput;
        PixelAttributeBlendType: EMaterialAttributeBlend;
        VertexAttributeBlendType: EMaterialAttributeBlend;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBlendMaterialAttributes;

        static Load(InName: string): MaterialExpressionBlendMaterialAttributes;
    }

    export class MaterialExpressionBreakMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialAttributes: MaterialAttributesInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBreakMaterialAttributes;

        static Load(InName: string): MaterialExpressionBreakMaterialAttributes;
    }

    export class MaterialExpressionBumpOffset extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Coordinate: ExpressionInput;
        Height: ExpressionInput;
        HeightRatioInput: ExpressionInput;
        HeightRatio: number;
        ReferencePlane: number;
        ConstCoordinate: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBumpOffset;

        static Load(InName: string): MaterialExpressionBumpOffset;
    }

    export class MaterialExpressionCameraPositionWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCameraPositionWS;

        static Load(InName: string): MaterialExpressionCameraPositionWS;
    }

    export class MaterialExpressionCameraVectorWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCameraVectorWS;

        static Load(InName: string): MaterialExpressionCameraVectorWS;
    }

    export class MaterialExpressionCeil extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCeil;

        static Load(InName: string): MaterialExpressionCeil;
    }

    export class MaterialExpressionParameter extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterName: string;
        ExpressionGUID: Guid;
        Group: string;
        SortPriority: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParameter;

        static Load(InName: string): MaterialExpressionParameter;
    }

    export class MaterialExpressionVectorParameter extends MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultValue: LinearColor;
        bUseCustomPrimitiveData: boolean;
        PrimitiveDataIndex: number;
        ChannelNames: ParameterChannelNames;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVectorParameter;

        static Load(InName: string): MaterialExpressionVectorParameter;
    }

    export enum EChannelMaskParameterColor { Red, Green, Blue, Alpha, EChannelMaskParameterColor_MAX }

    export class MaterialExpressionChannelMaskParameter extends MaterialExpressionVectorParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaskChannel: EChannelMaskParameterColor;
        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionChannelMaskParameter;

        static Load(InName: string): MaterialExpressionChannelMaskParameter;
    }

    export enum EClampMode { CMODE_Clamp, CMODE_ClampMin, CMODE_ClampMax, CMODE_MAX }

    export class MaterialExpressionClamp extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        Min: ExpressionInput;
        Max: ExpressionInput;
        ClampMode: EClampMode;
        MinDefault: number;
        MaxDefault: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionClamp;

        static Load(InName: string): MaterialExpressionClamp;
    }

    export class MaterialExpressionClampedPow extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Base: ExpressionInput;
        Exponent: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionClampedPow;

        static Load(InName: string): MaterialExpressionClampedPow;
    }

    export class MaterialExpressionClearCoatNormalCustomOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionClearCoatNormalCustomOutput;

        static Load(InName: string): MaterialExpressionClearCoatNormalCustomOutput;
    }

    export class MaterialExpressionCloudSampleAttribute extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCloudSampleAttribute;

        static Load(InName: string): MaterialExpressionCloudSampleAttribute;
    }

    export class MaterialExpressionCollectionParameter extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Collection: MaterialParameterCollection;
        ParameterName: string;
        ParameterId: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCollectionParameter;

        static Load(InName: string): MaterialExpressionCollectionParameter;
    }

    export class MaterialExpressionComponentMask extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionComponentMask;

        static Load(InName: string): MaterialExpressionComponentMask;
    }

    export class MaterialExpressionConstant extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        R: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant;

        static Load(InName: string): MaterialExpressionConstant;
    }

    export class MaterialExpressionConstant2Vector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        R: number;
        G: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant2Vector;

        static Load(InName: string): MaterialExpressionConstant2Vector;
    }

    export class MaterialExpressionConstant3Vector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Constant: LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant3Vector;

        static Load(InName: string): MaterialExpressionConstant3Vector;
    }

    export class MaterialExpressionConstant4Vector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Constant: LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant4Vector;

        static Load(InName: string): MaterialExpressionConstant4Vector;
    }

    export class MaterialExpressionConstantBiasScale extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        Bias: number;
        Scale: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstantBiasScale;

        static Load(InName: string): MaterialExpressionConstantBiasScale;
    }

    export class MaterialExpressionCosine extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        Period: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCosine;

        static Load(InName: string): MaterialExpressionCosine;
    }

    export class MaterialExpressionCrossProduct extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCrossProduct;

        static Load(InName: string): MaterialExpressionCrossProduct;
    }

    export class MaterialExpressionScalarParameter extends MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultValue: number;
        bUseCustomPrimitiveData: boolean;
        PrimitiveDataIndex: number;
        SliderMin: number;
        SliderMax: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionScalarParameter;

        static Load(InName: string): MaterialExpressionScalarParameter;
    }

    export class MaterialExpressionCurveAtlasRowParameter extends MaterialExpressionScalarParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Curve: CurveLinearColor;
        Atlas: CurveLinearColorAtlas;
        InputTime: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCurveAtlasRowParameter;

        static Load(InName: string): MaterialExpressionCurveAtlasRowParameter;
    }

    export enum ECustomMaterialOutputType {
        CMOT_Float1,
        CMOT_Float2,
        CMOT_Float3,
        CMOT_Float4,
        CMOT_MaterialAttributes,
        CMOT_MAX
    }

    export class CustomInput {
        constructor();
        constructor(InputName: string, Input: ExpressionInput);

        InputName: string;
        Input: ExpressionInput;

        static StaticClass(): Class;
    }

    export class CustomOutput {
        constructor();
        constructor(OutputName: string, OutputType: ECustomMaterialOutputType);

        OutputName: string;
        OutputType: ECustomMaterialOutputType;

        static StaticClass(): Class;
    }

    export class CustomDefine {
        constructor();
        constructor(DefineName: string, DefineValue: string);

        DefineName: string;
        DefineValue: string;

        static StaticClass(): Class;
    }

    export class MaterialExpressionCustom extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Code: string;
        OutputType: ECustomMaterialOutputType;
        Description: string;
        Inputs: TArray<CustomInput>;
        AdditionalOutputs: TArray<CustomOutput>;
        AdditionalDefines: TArray<CustomDefine>;
        IncludeFilePaths: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCustom;

        static Load(InName: string): MaterialExpressionCustom;
    }

    export class MaterialExpressionDDX extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Value: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDDX;

        static Load(InName: string): MaterialExpressionDDX;
    }

    export class MaterialExpressionDDY extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Value: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDDY;

        static Load(InName: string): MaterialExpressionDDY;
    }

    export class MaterialExpressionDecalDerivative extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalDerivative;

        static Load(InName: string): MaterialExpressionDecalDerivative;
    }

    export class MaterialExpressionDecalLifetimeOpacity extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalLifetimeOpacity;

        static Load(InName: string): MaterialExpressionDecalLifetimeOpacity;
    }

    export class MaterialExpressionDecalMipmapLevel extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureSize: ExpressionInput;
        ConstWidth: number;
        ConstHeight: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalMipmapLevel;

        static Load(InName: string): MaterialExpressionDecalMipmapLevel;
    }

    export class MaterialExpressionDeltaTime extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDeltaTime;

        static Load(InName: string): MaterialExpressionDeltaTime;
    }

    export class MaterialExpressionDepthFade extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InOpacity: ExpressionInput;
        FadeDistance: ExpressionInput;
        OpacityDefault: number;
        FadeDistanceDefault: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDepthFade;

        static Load(InName: string): MaterialExpressionDepthFade;
    }

    export enum EDepthOfFieldFunctionValue {
        TDOF_NearAndFarMask,
        TDOF_NearMask,
        TDOF_FarMask,
        TDOF_CircleOfConfusionRadius,
        TDOF_MAX
    }

    export class MaterialExpressionDepthOfFieldFunction extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FunctionValue: EDepthOfFieldFunctionValue;
        Depth: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDepthOfFieldFunction;

        static Load(InName: string): MaterialExpressionDepthOfFieldFunction;
    }

    export class MaterialExpressionDeriveNormalZ extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InXY: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDeriveNormalZ;

        static Load(InName: string): MaterialExpressionDeriveNormalZ;
    }

    export class MaterialExpressionDesaturation extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        Fraction: ExpressionInput;
        LuminanceFactors: LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDesaturation;

        static Load(InName: string): MaterialExpressionDesaturation;
    }

    export class MaterialExpressionDistance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistance;

        static Load(InName: string): MaterialExpressionDistance;
    }

    export class MaterialExpressionDistanceCullFade extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceCullFade;

        static Load(InName: string): MaterialExpressionDistanceCullFade;
    }

    export class MaterialExpressionDistanceFieldGradient extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Position: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceFieldGradient;

        static Load(InName: string): MaterialExpressionDistanceFieldGradient;
    }

    export class MaterialExpressionDistanceToNearestSurface extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Position: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceToNearestSurface;

        static Load(InName: string): MaterialExpressionDistanceToNearestSurface;
    }

    export class MaterialExpressionDivide extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDivide;

        static Load(InName: string): MaterialExpressionDivide;
    }

    export class MaterialExpressionDotProduct extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDotProduct;

        static Load(InName: string): MaterialExpressionDotProduct;
    }

    export class MaterialExpressionDynamicParameter extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParamNames: TArray<string>;
        DefaultValue: LinearColor;
        ParameterIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDynamicParameter;

        static Load(InName: string): MaterialExpressionDynamicParameter;
    }

    export class MaterialExpressionExp extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionExp;

        static Load(InName: string): MaterialExpressionExp;
    }

    export class MaterialExpressionExp2 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionExp2;

        static Load(InName: string): MaterialExpressionExp2;
    }

    export class MaterialExpressionEyeAdaptation extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionEyeAdaptation;

        static Load(InName: string): MaterialExpressionEyeAdaptation;
    }

    export class MaterialExpressionFeatureLevelSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Default: ExpressionInput;
        Inputs: FixSizeArray<ExpressionInput>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFeatureLevelSwitch;

        static Load(InName: string): MaterialExpressionFeatureLevelSwitch;
    }

    export class MaterialExpressionFloor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFloor;

        static Load(InName: string): MaterialExpressionFloor;
    }

    export class MaterialExpressionFmod extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFmod;

        static Load(InName: string): MaterialExpressionFmod;
    }

    export class MaterialExpressionFontSample extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Font: Font;
        FontTexturePage: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFontSample;

        static Load(InName: string): MaterialExpressionFontSample;
    }

    export class MaterialExpressionFontSampleParameter extends MaterialExpressionFontSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterName: string;
        ExpressionGUID: Guid;
        Group: string;
        SortPriority: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFontSampleParameter;

        static Load(InName: string): MaterialExpressionFontSampleParameter;
    }

    export class MaterialExpressionFrac extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFrac;

        static Load(InName: string): MaterialExpressionFrac;
    }

    export class MaterialExpressionFresnel extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ExponentIn: ExpressionInput;
        Exponent: number;
        BaseReflectFractionIn: ExpressionInput;
        BaseReflectFraction: number;
        Normal: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFresnel;

        static Load(InName: string): MaterialExpressionFresnel;
    }

    export class MaterialExpressionGetMaterialAOTerm extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ViewportUV: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGetMaterialAOTerm;

        static Load(InName: string): MaterialExpressionGetMaterialAOTerm;
    }

    export class MaterialExpressionGetMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialAttributes: MaterialAttributesInput;
        AttributeGetTypes: TArray<Guid>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGetMaterialAttributes;

        static Load(InName: string): MaterialExpressionGetMaterialAttributes;
    }

    export class MaterialExpressionGetMaterialIBLTerm extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UVW: ExpressionInput;
        AbsoluteMipLevel: ExpressionInput;
        ConstAbsoluteMipLevel: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGetMaterialIBLTerm;

        static Load(InName: string): MaterialExpressionGetMaterialIBLTerm;
    }

    export class MaterialExpressionGetMaterialShadowTerm extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        XBias: ExpressionInput;
        YBias: ExpressionInput;
        ConstXBias: number;
        ConstYBias: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGetMaterialShadowTerm;

        static Load(InName: string): MaterialExpressionGetMaterialShadowTerm;
    }

    export class MaterialExpressionGetMobileReflectionCaptureParams extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGetMobileReflectionCaptureParams;

        static Load(InName: string): MaterialExpressionGetMobileReflectionCaptureParams;
    }

    export class MaterialExpressionGetTextureSize extends MaterialExpressionTextureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureObject: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGetTextureSize;

        static Load(InName: string): MaterialExpressionGetTextureSize;
    }

    export class MaterialExpressionGIReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Default: ExpressionInput;
        StaticIndirect: ExpressionInput;
        DynamicIndirect: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGIReplace;

        static Load(InName: string): MaterialExpressionGIReplace;
    }

    export class MaterialExpressionHairAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseTangentSpace: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionHairAttributes;

        static Load(InName: string): MaterialExpressionHairAttributes;
    }

    export class MaterialExpressionHairColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Melanin: ExpressionInput;
        Redness: ExpressionInput;
        DyeColor: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionHairColor;

        static Load(InName: string): MaterialExpressionHairColor;
    }

    export class MaterialExpressionIf extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        AGreaterThanB: ExpressionInput;
        AEqualsB: ExpressionInput;
        ALessThanB: ExpressionInput;
        EqualsThreshold: number;
        ConstB: number;
        ConstAEqualsB: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionIf;

        static Load(InName: string): MaterialExpressionIf;
    }

    export class MaterialExpressionInverseLinearInterpolate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        Value: ExpressionInput;
        ConstA: number;
        ConstB: number;
        ConstValue: number;
        bClampResult: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionInverseLinearInterpolate;

        static Load(InName: string): MaterialExpressionInverseLinearInterpolate;
    }

    export class GrassInput {
        constructor();
        constructor(Name: string, GrassType: LandscapeGrassType, Input: ExpressionInput);

        Name: string;
        GrassType: LandscapeGrassType;
        Input: ExpressionInput;

        static StaticClass(): Class;
    }

    export class MaterialExpressionLandscapeGrassOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GrassTypes: TArray<GrassInput>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeGrassOutput;

        static Load(InName: string): MaterialExpressionLandscapeGrassOutput;
    }

    export enum ELandscapeLayerBlendType { LB_WeightBlend, LB_AlphaBlend, LB_HeightBlend, LB_MAX }

    export class LayerBlendInput {
        constructor();
        constructor(LayerName: string, BlendType: ELandscapeLayerBlendType, LayerInput: ExpressionInput, HeightInput: ExpressionInput, PreviewWeight: number, ConstLayerInput: Vector, ConstHeightInput: number);

        LayerName: string;
        BlendType: ELandscapeLayerBlendType;
        LayerInput: ExpressionInput;
        HeightInput: ExpressionInput;
        PreviewWeight: number;
        ConstLayerInput: Vector;
        ConstHeightInput: number;

        static StaticClass(): Class;
    }

    export class MaterialExpressionLandscapeLayerBlend extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Layers: TArray<LayerBlendInput>;
        ExpressionGUID: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerBlend;

        static Load(InName: string): MaterialExpressionLandscapeLayerBlend;
    }

    export enum ETerrainCoordMappingType { TCMT_Auto, TCMT_XY, TCMT_XZ, TCMT_YZ, TCMT_MAX }

    export enum ELandscapeCustomizedCoordType {
        LCCT_None,
        LCCT_CustomUV0,
        LCCT_CustomUV1,
        LCCT_CustomUV2,
        LCCT_WeightMapUV,
        LCCT_MAX
    }

    export class MaterialExpressionLandscapeLayerCoords extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MappingType: ETerrainCoordMappingType;
        CustomUVType: ELandscapeCustomizedCoordType;
        MappingScale: number;
        MappingRotation: number;
        MappingPanU: number;
        MappingPanV: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerCoords;

        static Load(InName: string): MaterialExpressionLandscapeLayerCoords;
    }

    export class MaterialExpressionLandscapeLayerSample extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterName: string;
        PreviewWeight: number;
        ExpressionGUID: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerSample;

        static Load(InName: string): MaterialExpressionLandscapeLayerSample;
    }

    export class MaterialExpressionLandscapeLayerSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LayerUsed: ExpressionInput;
        LayerNotUsed: ExpressionInput;
        ParameterName: string;
        PreviewUsed: boolean;
        ExpressionGUID: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerSwitch;

        static Load(InName: string): MaterialExpressionLandscapeLayerSwitch;
    }

    export class MaterialExpressionLandscapeLayerWeight extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Base: ExpressionInput;
        Layer: ExpressionInput;
        ParameterName: string;
        PreviewWeight: number;
        ConstBase: Vector;
        ExpressionGUID: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerWeight;

        static Load(InName: string): MaterialExpressionLandscapeLayerWeight;
    }

    export class PhysicalMaterialInput {
        constructor();
        constructor(PhysicalMaterial: PhysicalMaterial, Input: ExpressionInput);

        PhysicalMaterial: PhysicalMaterial;
        Input: ExpressionInput;

        static StaticClass(): Class;
    }

    export class MaterialExpressionLandscapePhysicalMaterialOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Inputs: TArray<PhysicalMaterialInput>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapePhysicalMaterialOutput;

        static Load(InName: string): MaterialExpressionLandscapePhysicalMaterialOutput;
    }

    export class MaterialExpressionLandscapeVisibilityMask extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ExpressionGUID: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeVisibilityMask;

        static Load(InName: string): MaterialExpressionLandscapeVisibilityMask;
    }

    export class MaterialExpressionLightmapUVs extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightmapUVs;

        static Load(InName: string): MaterialExpressionLightmapUVs;
    }

    export class MaterialExpressionLightmassReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Realtime: ExpressionInput;
        Lightmass: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightmassReplace;

        static Load(InName: string): MaterialExpressionLightmassReplace;
    }

    export class MaterialExpressionLightReflection extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightReflection;

        static Load(InName: string): MaterialExpressionLightReflection;
    }

    export class MaterialExpressionLightVector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightVector;

        static Load(InName: string): MaterialExpressionLightVector;
    }

    export class MaterialExpressionLinearInterpolate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        Alpha: ExpressionInput;
        ConstA: number;
        ConstB: number;
        ConstAlpha: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLinearInterpolate;

        static Load(InName: string): MaterialExpressionLinearInterpolate;
    }

    export class MaterialExpressionLogarithm10 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLogarithm10;

        static Load(InName: string): MaterialExpressionLogarithm10;
    }

    export class MaterialExpressionLogarithm2 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLogarithm2;

        static Load(InName: string): MaterialExpressionLogarithm2;
    }

    export class MaterialExpressionLuminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLuminance;

        static Load(InName: string): MaterialExpressionLuminance;
    }

    export class MaterialExpressionMakeMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BaseColor: ExpressionInput;
        Metallic: ExpressionInput;
        Specular: ExpressionInput;
        Roughness: ExpressionInput;
        Anisotropy: ExpressionInput;
        EmissiveColor: ExpressionInput;
        Opacity: ExpressionInput;
        OpacityMask: ExpressionInput;
        Normal: ExpressionInput;
        Tangent: ExpressionInput;
        WorldPositionOffset: ExpressionInput;
        WorldDisplacement: ExpressionInput;
        TessellationMultiplier: ExpressionInput;
        SubsurfaceColor: ExpressionInput;
        ClearCoat: ExpressionInput;
        ClearCoatRoughness: ExpressionInput;
        AmbientOcclusion: ExpressionInput;
        Refraction: ExpressionInput;
        CustomizedUVs: FixSizeArray<ExpressionInput>;
        PixelDepthOffset: ExpressionInput;
        ShadingModel: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMakeMaterialAttributes;

        static Load(InName: string): MaterialExpressionMakeMaterialAttributes;
    }

    export class MaterialExpressionMapARPassthroughCameraUV extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Coordinates: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMapARPassthroughCameraUV;

        static Load(InName: string): MaterialExpressionMapARPassthroughCameraUV;
    }

    export class MaterialExpressionMaterialAttributeLayers extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterName: string;
        ExpressionGUID: Guid;
        Input: MaterialAttributesInput;
        DefaultLayers: MaterialLayersFunctions;
        LayerCallers: TArray<MaterialExpressionMaterialFunctionCall>;
        NumActiveLayerCallers: number;
        BlendCallers: TArray<MaterialExpressionMaterialFunctionCall>;
        NumActiveBlendCallers: number;
        bIsLayerGraphBuilt: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialAttributeLayers;

        static Load(InName: string): MaterialExpressionMaterialAttributeLayers;
    }

    export class MaterialExpressionMaterialLayerOutput extends MaterialExpressionFunctionOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialLayerOutput;

        static Load(InName: string): MaterialExpressionMaterialLayerOutput;
    }

    export class MaterialExpressionMaterialProxyReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Realtime: ExpressionInput;
        MaterialProxy: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialProxyReplace;

        static Load(InName: string): MaterialExpressionMaterialProxyReplace;
    }

    export class MaterialExpressionMax extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMax;

        static Load(InName: string): MaterialExpressionMax;
    }

    export class MaterialExpressionMin extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMin;

        static Load(InName: string): MaterialExpressionMin;
    }

    export class MaterialExpressionMultipleSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputIndex0: ExpressionInput;
        InputIndex1: ExpressionInput;
        InputIndex2: ExpressionInput;
        InputIndex3: ExpressionInput;
        InputIndex4: ExpressionInput;
        InputIndex5: ExpressionInput;
        InputIndex6: ExpressionInput;
        InputIndex7: ExpressionInput;
        InputIndex8: ExpressionInput;
        InputIndex9: ExpressionInput;
        InputIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMultipleSwitch;

        static Load(InName: string): MaterialExpressionMultipleSwitch;
    }

    export class MaterialExpressionMultiply extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMultiply;

        static Load(InName: string): MaterialExpressionMultiply;
    }

    export class MaterialExpressionRerouteBase extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRerouteBase;

        static Load(InName: string): MaterialExpressionRerouteBase;
    }

    export class MaterialExpressionNamedRerouteBase extends MaterialExpressionRerouteBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNamedRerouteBase;

        static Load(InName: string): MaterialExpressionNamedRerouteBase;
    }

    export class MaterialExpressionNamedRerouteDeclaration extends MaterialExpressionNamedRerouteBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        Name: string;
        NodeColor: LinearColor;
        VariableGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNamedRerouteDeclaration;

        static Load(InName: string): MaterialExpressionNamedRerouteDeclaration;
    }

    export class MaterialExpressionNamedRerouteUsage extends MaterialExpressionNamedRerouteBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Declaration: MaterialExpressionNamedRerouteDeclaration;
        DeclarationGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNamedRerouteUsage;

        static Load(InName: string): MaterialExpressionNamedRerouteUsage;
    }

    export class MaterialExpressionNoH extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNoH;

        static Load(InName: string): MaterialExpressionNoH;
    }

    export enum ENoiseFunction {
        NOISEFUNCTION_SimplexTex,
        NOISEFUNCTION_GradientTex,
        NOISEFUNCTION_GradientTex3D,
        NOISEFUNCTION_GradientALU,
        NOISEFUNCTION_ValueALU,
        NOISEFUNCTION_VoronoiALU,
        NOISEFUNCTION_MAX
    }

    export class MaterialExpressionNoise extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Position: ExpressionInput;
        FilterWidth: ExpressionInput;
        Scale: number;
        Quality: number;
        NoiseFunction: ENoiseFunction;
        bTurbulence: boolean;
        Levels: number;
        OutputMin: number;
        OutputMax: number;
        LevelScale: number;
        bTiling: boolean;
        RepeatSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNoise;

        static Load(InName: string): MaterialExpressionNoise;
    }

    export class MaterialExpressionNoL extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNoL;

        static Load(InName: string): MaterialExpressionNoL;
    }

    export class MaterialExpressionNormalize extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VectorInput: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNormalize;

        static Load(InName: string): MaterialExpressionNormalize;
    }

    export class MaterialExpressionNoV extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNoV;

        static Load(InName: string): MaterialExpressionNoV;
    }

    export class MaterialExpressionObjectBounds extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectBounds;

        static Load(InName: string): MaterialExpressionObjectBounds;
    }

    export class MaterialExpressionObjectOrientation extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectOrientation;

        static Load(InName: string): MaterialExpressionObjectOrientation;
    }

    export class MaterialExpressionObjectPositionWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectPositionWS;

        static Load(InName: string): MaterialExpressionObjectPositionWS;
    }

    export class MaterialExpressionObjectRadius extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectRadius;

        static Load(InName: string): MaterialExpressionObjectRadius;
    }

    export class MaterialExpressionOneMinus extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionOneMinus;

        static Load(InName: string): MaterialExpressionOneMinus;
    }

    export class MaterialExpressionPanner extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Coordinate: ExpressionInput;
        Time: ExpressionInput;
        Speed: ExpressionInput;
        SpeedX: number;
        SpeedY: number;
        ConstCoordinate: number;
        bFractionalPart: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPanner;

        static Load(InName: string): MaterialExpressionPanner;
    }

    export class MaterialExpressionParticleColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleColor;

        static Load(InName: string): MaterialExpressionParticleColor;
    }

    export class MaterialExpressionParticleDirection extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleDirection;

        static Load(InName: string): MaterialExpressionParticleDirection;
    }

    export class MaterialExpressionParticleMacroUV extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleMacroUV;

        static Load(InName: string): MaterialExpressionParticleMacroUV;
    }

    export class MaterialExpressionParticleMotionBlurFade extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleMotionBlurFade;

        static Load(InName: string): MaterialExpressionParticleMotionBlurFade;
    }

    export class MaterialExpressionParticlePositionWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticlePositionWS;

        static Load(InName: string): MaterialExpressionParticlePositionWS;
    }

    export class MaterialExpressionParticleRadius extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRadius;

        static Load(InName: string): MaterialExpressionParticleRadius;
    }

    export class MaterialExpressionParticleRandom extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRandom;

        static Load(InName: string): MaterialExpressionParticleRandom;
    }

    export class MaterialExpressionParticleRelativeTime extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRelativeTime;

        static Load(InName: string): MaterialExpressionParticleRelativeTime;
    }

    export class MaterialExpressionParticleSize extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSize;

        static Load(InName: string): MaterialExpressionParticleSize;
    }

    export class MaterialExpressionParticleSpeed extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSpeed;

        static Load(InName: string): MaterialExpressionParticleSpeed;
    }

    export class MaterialExpressionParticleSubUV extends MaterialExpressionTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bBlend: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSubUV;

        static Load(InName: string): MaterialExpressionParticleSubUV;
    }

    export class MaterialExpressionParticleSubUVProperties extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSubUVProperties;

        static Load(InName: string): MaterialExpressionParticleSubUVProperties;
    }

    export class MaterialExpressionPerInstanceCustomData extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultValue: ExpressionInput;
        ConstDefaultValue: number;
        DataIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPerInstanceCustomData;

        static Load(InName: string): MaterialExpressionPerInstanceCustomData;
    }

    export class MaterialExpressionPerInstanceFadeAmount extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPerInstanceFadeAmount;

        static Load(InName: string): MaterialExpressionPerInstanceFadeAmount;
    }

    export class MaterialExpressionPerInstanceRandom extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPerInstanceRandom;

        static Load(InName: string): MaterialExpressionPerInstanceRandom;
    }

    export class MaterialExpressionPixelDepth extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPixelDepth;

        static Load(InName: string): MaterialExpressionPixelDepth;
    }

    export class MaterialExpressionPixelNormalWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPixelNormalWS;

        static Load(InName: string): MaterialExpressionPixelNormalWS;
    }

    export class MaterialExpressionPower extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Base: ExpressionInput;
        Exponent: ExpressionInput;
        ConstExponent: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPower;

        static Load(InName: string): MaterialExpressionPower;
    }

    export class MaterialExpressionPower2 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPower2;

        static Load(InName: string): MaterialExpressionPower2;
    }

    export class MaterialExpressionPower3 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPower3;

        static Load(InName: string): MaterialExpressionPower3;
    }

    export class MaterialExpressionPower4 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPower4;

        static Load(InName: string): MaterialExpressionPower4;
    }

    export class MaterialExpressionPower5 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPower5;

        static Load(InName: string): MaterialExpressionPower5;
    }

    export class MaterialExpressionPower6 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPower6;

        static Load(InName: string): MaterialExpressionPower6;
    }

    export class MaterialExpressionPrecomputedAOMask extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPrecomputedAOMask;

        static Load(InName: string): MaterialExpressionPrecomputedAOMask;
    }

    export class MaterialExpressionPreSkinnedLocalBounds extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedLocalBounds;

        static Load(InName: string): MaterialExpressionPreSkinnedLocalBounds;
    }

    export class MaterialExpressionPreSkinnedNormal extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedNormal;

        static Load(InName: string): MaterialExpressionPreSkinnedNormal;
    }

    export class MaterialExpressionPreSkinnedPosition extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedPosition;

        static Load(InName: string): MaterialExpressionPreSkinnedPosition;
    }

    export class MaterialExpressionPreviousFrameSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentFrame: ExpressionInput;
        PreviousFrame: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreviousFrameSwitch;

        static Load(InName: string): MaterialExpressionPreviousFrameSwitch;
    }

    export class MaterialExpressionQualitySwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Default: ExpressionInput;
        Inputs: FixSizeArray<ExpressionInput>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionQualitySwitch;

        static Load(InName: string): MaterialExpressionQualitySwitch;
    }

    export class MaterialExpressionRayTracingQualitySwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Normal: ExpressionInput;
        RayTraced: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRayTracingQualitySwitch;

        static Load(InName: string): MaterialExpressionRayTracingQualitySwitch;
    }

    export class MaterialExpressionRcp extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRcp;

        static Load(InName: string): MaterialExpressionRcp;
    }

    export class MaterialExpressionReflectionCapturePassSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Default: ExpressionInput;
        Reflection: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionReflectionCapturePassSwitch;

        static Load(InName: string): MaterialExpressionReflectionCapturePassSwitch;
    }

    export class MaterialExpressionReflectionVectorWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CustomWorldNormal: ExpressionInput;
        bNormalizeCustomWorldNormal: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionReflectionVectorWS;

        static Load(InName: string): MaterialExpressionReflectionVectorWS;
    }

    export class MaterialExpressionReroute extends MaterialExpressionRerouteBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionReroute;

        static Load(InName: string): MaterialExpressionReroute;
    }

    export class MaterialExpressionRoL extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRoL;

        static Load(InName: string): MaterialExpressionRoL;
    }

    export class MaterialExpressionRotateAboutAxis extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NormalizedRotationAxis: ExpressionInput;
        RotationAngle: ExpressionInput;
        PivotPoint: ExpressionInput;
        Position: ExpressionInput;
        Period: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRotateAboutAxis;

        static Load(InName: string): MaterialExpressionRotateAboutAxis;
    }

    export class MaterialExpressionRotator extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Coordinate: ExpressionInput;
        Time: ExpressionInput;
        CenterX: number;
        CenterY: number;
        Speed: number;
        ConstCoordinate: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRotator;

        static Load(InName: string): MaterialExpressionRotator;
    }

    export class MaterialExpressionRound extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRound;

        static Load(InName: string): MaterialExpressionRound;
    }

    export class MaterialExpressionRuntimeVirtualTextureOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BaseColor: ExpressionInput;
        Specular: ExpressionInput;
        Roughness: ExpressionInput;
        Normal: ExpressionInput;
        WorldHeight: ExpressionInput;
        Opacity: ExpressionInput;
        Mask: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureOutput;

        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureOutput;
    }

    export class MaterialExpressionRuntimeVirtualTextureReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Default: ExpressionInput;
        VirtualTextureOutput: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureReplace;

        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureReplace;
    }

    export enum ERuntimeVirtualTextureMipValueMode { RVTMVM_None, RVTMVM_MipLevel, RVTMVM_MipBias, RVTMVM_MAX }

    export enum ERuntimeVirtualTextureTextureAddressMode { RVTTA_Clamp, RVTTA_Wrap, RVTTA_MAX }

    export class MaterialExpressionRuntimeVirtualTextureSample extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Coordinates: ExpressionInput;
        WorldPosition: ExpressionInput;
        MipValue: ExpressionInput;
        VirtualTexture: RuntimeVirtualTexture;
        MaterialType: ERuntimeVirtualTextureMaterialType;
        bSinglePhysicalSpace: boolean;
        bAdaptive: boolean;
        MipValueMode: ERuntimeVirtualTextureMipValueMode;
        TextureAddressMode: ERuntimeVirtualTextureTextureAddressMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureSample;

        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureSample;
    }

    export class MaterialExpressionRuntimeVirtualTextureSampleParameter extends MaterialExpressionRuntimeVirtualTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParameterName: string;
        ExpressionGUID: Guid;
        Group: string;
        SortPriority: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureSampleParameter;

        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureSampleParameter;
    }

    export class MaterialExpressionSaturate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSaturate;

        static Load(InName: string): MaterialExpressionSaturate;
    }

    export enum EMaterialSceneAttributeInputMode { Coordinates, OffsetFraction, EMaterialSceneAttributeInputMode_MAX }

    export class MaterialExpressionSceneColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputMode: EMaterialSceneAttributeInputMode;
        Input: ExpressionInput;
        OffsetFraction: ExpressionInput;
        ConstInput: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneColor;

        static Load(InName: string): MaterialExpressionSceneColor;
    }

    export class MaterialExpressionSceneDepth extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputMode: EMaterialSceneAttributeInputMode;
        Input: ExpressionInput;
        Coordinates: ExpressionInput;
        ConstInput: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneDepth;

        static Load(InName: string): MaterialExpressionSceneDepth;
    }

    export class MaterialExpressionSceneDepthWithoutWater extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputMode: EMaterialSceneAttributeInputMode;
        Input: ExpressionInput;
        ConstInput: Vector2D;
        FallbackDepth: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneDepthWithoutWater;

        static Load(InName: string): MaterialExpressionSceneDepthWithoutWater;
    }

    export class MaterialExpressionSceneTexelSize extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneTexelSize;

        static Load(InName: string): MaterialExpressionSceneTexelSize;
    }

    export enum ESceneTextureId {
        PPI_SceneColor,
        PPI_SceneDepth,
        PPI_DiffuseColor,
        PPI_SpecularColor,
        PPI_SubsurfaceColor,
        PPI_BaseColor,
        PPI_Specular,
        PPI_Metallic,
        PPI_WorldNormal,
        PPI_SeparateTranslucency,
        PPI_Opacity,
        PPI_Roughness,
        PPI_MaterialAO,
        PPI_CustomDepth,
        PPI_PostProcessInput0,
        PPI_PostProcessInput1,
        PPI_PostProcessInput2,
        PPI_PostProcessInput3,
        PPI_PostProcessInput4,
        PPI_PostProcessInput5,
        PPI_PostProcessInput6,
        PPI_DecalMask,
        PPI_ShadingModelColor,
        PPI_ShadingModelID,
        PPI_AmbientOcclusion,
        PPI_CustomStencil,
        PPI_StoredBaseColor,
        PPI_StoredSpecular,
        PPI_Velocity,
        PPI_WorldTangent,
        PPI_Anisotropy,
        PPI_MAX
    }

    export class MaterialExpressionSceneTexture extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Coordinates: ExpressionInput;
        SceneTextureId: ESceneTextureId;
        bFiltered: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneTexture;

        static Load(InName: string): MaterialExpressionSceneTexture;
    }

    export class MaterialExpressionScreenPosition extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionScreenPosition;

        static Load(InName: string): MaterialExpressionScreenPosition;
    }

    export class MaterialExpressionSetMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Inputs: TArray<ExpressionInput>;
        AttributeSetTypes: TArray<Guid>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSetMaterialAttributes;

        static Load(InName: string): MaterialExpressionSetMaterialAttributes;
    }

    export class MaterialExpressionShaderStageSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PixelShader: ExpressionInput;
        VertexShader: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShaderStageSwitch;

        static Load(InName: string): MaterialExpressionShaderStageSwitch;
    }

    export class MaterialExpressionShadingModel extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShadingModel: EMaterialShadingModel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadingModel;

        static Load(InName: string): MaterialExpressionShadingModel;
    }

    export class MaterialExpressionShadingPathSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Default: ExpressionInput;
        Inputs: FixSizeArray<ExpressionInput>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadingPathSwitch;

        static Load(InName: string): MaterialExpressionShadingPathSwitch;
    }

    export class MaterialExpressionShadowReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Default: ExpressionInput;
        Shadow: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadowReplace;

        static Load(InName: string): MaterialExpressionShadowReplace;
    }

    export class MaterialExpressionSign extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSign;

        static Load(InName: string): MaterialExpressionSign;
    }

    export class MaterialExpressionSine extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        Period: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSine;

        static Load(InName: string): MaterialExpressionSine;
    }

    export class MaterialExpressionSingleLayerWaterMaterialOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScatteringCoefficients: ExpressionInput;
        AbsorptionCoefficients: ExpressionInput;
        PhaseG: ExpressionInput;
        ColorScaleBehindWater: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSingleLayerWaterMaterialOutput;

        static Load(InName: string): MaterialExpressionSingleLayerWaterMaterialOutput;
    }

    export class MaterialExpressionSkinningVertexOffsets extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkinningVertexOffsets;

        static Load(InName: string): MaterialExpressionSkinningVertexOffsets;
    }

    export class MaterialExpressionSkyAtmosphereAerialPerspective extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WorldPosition: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereAerialPerspective;

        static Load(InName: string): MaterialExpressionSkyAtmosphereAerialPerspective;
    }

    export class MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;

        static Load(InName: string): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
    }

    export class MaterialExpressionSkyAtmosphereLightDirection extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LightIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightDirection;

        static Load(InName: string): MaterialExpressionSkyAtmosphereLightDirection;
    }

    export class MaterialExpressionSkyAtmosphereLightDiskLuminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LightIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightDiskLuminance;

        static Load(InName: string): MaterialExpressionSkyAtmosphereLightDiskLuminance;
    }

    export class MaterialExpressionSkyAtmosphereLightIlluminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LightIndex: number;
        WorldPosition: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightIlluminance;

        static Load(InName: string): MaterialExpressionSkyAtmosphereLightIlluminance;
    }

    export class MaterialExpressionSkyAtmosphereViewLuminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereViewLuminance;

        static Load(InName: string): MaterialExpressionSkyAtmosphereViewLuminance;
    }

    export class MaterialExpressionSmoothStep extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: ExpressionInput;
        Max: ExpressionInput;
        Value: ExpressionInput;
        ConstMin: number;
        ConstMax: number;
        ConstValue: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSmoothStep;

        static Load(InName: string): MaterialExpressionSmoothStep;
    }

    export class MaterialExpressionSobol extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Cell: ExpressionInput;
        Index: ExpressionInput;
        Seed: ExpressionInput;
        ConstIndex: number;
        ConstSeed: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSobol;

        static Load(InName: string): MaterialExpressionSobol;
    }

    export enum ESpeedTreeGeometryType { STG_Branch, STG_Frond, STG_Leaf, STG_FacingLeaf, STG_Billboard, STG_MAX }

    export enum ESpeedTreeWindType {
        STW_None,
        STW_Fastest,
        STW_Fast,
        STW_Better,
        STW_Best,
        STW_Palm,
        STW_BestPlus,
        STW_MAX
    }

    export enum ESpeedTreeLODType { STLOD_Pop, STLOD_Smooth, STLOD_MAX }

    export class MaterialExpressionSpeedTree extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GeometryInput: ExpressionInput;
        WindInput: ExpressionInput;
        LODInput: ExpressionInput;
        ExtraBendWS: ExpressionInput;
        GeometryType: ESpeedTreeGeometryType;
        WindType: ESpeedTreeWindType;
        LODType: ESpeedTreeLODType;
        BillboardThreshold: number;
        bAccurateWindVelocities: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSpeedTree;

        static Load(InName: string): MaterialExpressionSpeedTree;
    }

    export class MaterialExpressionSphereMask extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        Radius: ExpressionInput;
        Hardness: ExpressionInput;
        AttenuationRadius: number;
        HardnessPercent: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSphereMask;

        static Load(InName: string): MaterialExpressionSphereMask;
    }

    export class MaterialExpressionSphericalParticleOpacity extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Density: ExpressionInput;
        ConstantDensity: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSphericalParticleOpacity;

        static Load(InName: string): MaterialExpressionSphericalParticleOpacity;
    }

    export class MaterialExpressionSquare extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSquare;

        static Load(InName: string): MaterialExpressionSquare;
    }

    export class MaterialExpressionSquareRoot extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSquareRoot;

        static Load(InName: string): MaterialExpressionSquareRoot;
    }

    export class MaterialExpressionStaticBool extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Value: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticBool;

        static Load(InName: string): MaterialExpressionStaticBool;
    }

    export class MaterialExpressionStaticBoolParameter extends MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultValue: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticBoolParameter;

        static Load(InName: string): MaterialExpressionStaticBoolParameter;
    }

    export class MaterialExpressionStaticComponentMaskParameter extends MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        DefaultR: boolean;
        DefaultG: boolean;
        DefaultB: boolean;
        DefaultA: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticComponentMaskParameter;

        static Load(InName: string): MaterialExpressionStaticComponentMaskParameter;
    }

    export class MaterialExpressionStaticSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultValue: boolean;
        A: ExpressionInput;
        B: ExpressionInput;
        Value: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticSwitch;

        static Load(InName: string): MaterialExpressionStaticSwitch;
    }

    export class MaterialExpressionStaticSwitchParameter extends MaterialExpressionStaticBoolParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticSwitchParameter;

        static Load(InName: string): MaterialExpressionStaticSwitchParameter;
    }

    export class MaterialExpressionStep extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Y: ExpressionInput;
        X: ExpressionInput;
        ConstY: number;
        ConstX: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStep;

        static Load(InName: string): MaterialExpressionStep;
    }

    export class MaterialExpressionSubtract extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSubtract;

        static Load(InName: string): MaterialExpressionSubtract;
    }

    export class MaterialExpressionTangent extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        Period: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTangent;

        static Load(InName: string): MaterialExpressionTangent;
    }

    export class MaterialExpressionTangentOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTangentOutput;

        static Load(InName: string): MaterialExpressionTangentOutput;
    }

    export class MaterialExpressionTemporalSobol extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Index: ExpressionInput;
        Seed: ExpressionInput;
        ConstIndex: number;
        ConstSeed: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTemporalSobol;

        static Load(InName: string): MaterialExpressionTemporalSobol;
    }

    export class MaterialExpressionTextureCoordinate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CoordinateIndex: number;
        UTiling: number;
        VTiling: number;
        UnMirrorU: boolean;
        UnMirrorV: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureCoordinate;

        static Load(InName: string): MaterialExpressionTextureCoordinate;
    }

    export class MaterialExpressionTextureObject extends MaterialExpressionTextureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureObject;

        static Load(InName: string): MaterialExpressionTextureObject;
    }

    export class MaterialExpressionTextureObjectParameter extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureObjectParameter;

        static Load(InName: string): MaterialExpressionTextureObjectParameter;
    }

    export enum EMaterialExposedTextureProperty { TMTM_TextureSize, TMTM_TexelSize, TMTM_MAX }

    export class MaterialExpressionTextureProperty extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureObject: ExpressionInput;
        Property: EMaterialExposedTextureProperty;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureProperty;

        static Load(InName: string): MaterialExpressionTextureProperty;
    }

    export class MaterialExpressionTextureSampleParameter2DArray extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter2DArray;

        static Load(InName: string): MaterialExpressionTextureSampleParameter2DArray;
    }

    export class MaterialExpressionTextureSampleParameterCube extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterCube;

        static Load(InName: string): MaterialExpressionTextureSampleParameterCube;
    }

    export class MaterialExpressionTextureSampleParameterSubUV extends MaterialExpressionTextureSampleParameter2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bBlend: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterSubUV;

        static Load(InName: string): MaterialExpressionTextureSampleParameterSubUV;
    }

    export class MaterialExpressionTextureSampleParameterVolume extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterVolume;

        static Load(InName: string): MaterialExpressionTextureSampleParameterVolume;
    }

    export class MaterialExpressionThinTranslucentMaterialOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TransmittanceColor: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionThinTranslucentMaterialOutput;

        static Load(InName: string): MaterialExpressionThinTranslucentMaterialOutput;
    }

    export class MaterialExpressionTime extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIgnorePause: boolean;
        bOverride_Period: boolean;
        Period: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTime;

        static Load(InName: string): MaterialExpressionTime;
    }

    export enum EMaterialVectorCoordTransformSource {
        TRANSFORMSOURCE_Tangent,
        TRANSFORMSOURCE_Local,
        TRANSFORMSOURCE_World,
        TRANSFORMSOURCE_View,
        TRANSFORMSOURCE_Camera,
        TRANSFORMSOURCE_ParticleWorld,
        TRANSFORMSOURCE_MAX
    }

    export enum EMaterialVectorCoordTransform {
        TRANSFORM_Tangent,
        TRANSFORM_Local,
        TRANSFORM_World,
        TRANSFORM_View,
        TRANSFORM_Camera,
        TRANSFORM_ParticleWorld,
        TRANSFORM_MAX
    }

    export class MaterialExpressionTransform extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        TransformSourceType: EMaterialVectorCoordTransformSource;
        TransformType: EMaterialVectorCoordTransform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTransform;

        static Load(InName: string): MaterialExpressionTransform;
    }

    export enum EMaterialPositionTransformSource {
        TRANSFORMPOSSOURCE_Local,
        TRANSFORMPOSSOURCE_World,
        TRANSFORMPOSSOURCE_TranslatedWorld,
        TRANSFORMPOSSOURCE_View,
        TRANSFORMPOSSOURCE_Camera,
        TRANSFORMPOSSOURCE_Particle,
        TRANSFORMPOSSOURCE_MAX
    }

    export class MaterialExpressionTransformPosition extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;
        TransformSourceType: EMaterialPositionTransformSource;
        TransformType: EMaterialPositionTransformSource;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTransformPosition;

        static Load(InName: string): MaterialExpressionTransformPosition;
    }

    export class MaterialExpressionTruncate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTruncate;

        static Load(InName: string): MaterialExpressionTruncate;
    }

    export class MaterialExpressionTwoSidedSign extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTwoSidedSign;

        static Load(InName: string): MaterialExpressionTwoSidedSign;
    }

    export class MaterialExpressionUV2UVW extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UV: ExpressionInput;
        ConstUV: Vector2D;
        UShift: ExpressionInput;
        ConstUShift: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionUV2UVW;

        static Load(InName: string): MaterialExpressionUV2UVW;
    }

    export class MaterialExpressionUVW2UV extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UVW: ExpressionInput;
        ConstUVW: Vector;
        UShift: ExpressionInput;
        ConstUShift: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionUVW2UV;

        static Load(InName: string): MaterialExpressionUVW2UV;
    }

    export enum EVectorNoiseFunction {
        VNF_CellnoiseALU,
        VNF_VectorALU,
        VNF_GradientALU,
        VNF_CurlALU,
        VNF_VoronoiALU,
        VNF_MAX
    }

    export class MaterialExpressionVectorNoise extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Position: ExpressionInput;
        NoiseFunction: EVectorNoiseFunction;
        Quality: number;
        bTiling: boolean;
        TileSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVectorNoise;

        static Load(InName: string): MaterialExpressionVectorNoise;
    }

    export class MaterialExpressionVertexColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexColor;

        static Load(InName: string): MaterialExpressionVertexColor;
    }

    export class MaterialExpressionVertexInterpolator extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexInterpolator;

        static Load(InName: string): MaterialExpressionVertexInterpolator;
    }

    export class MaterialExpressionVertexNormalWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexNormalWS;

        static Load(InName: string): MaterialExpressionVertexNormalWS;
    }

    export class MaterialExpressionVertexTangentWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexTangentWS;

        static Load(InName: string): MaterialExpressionVertexTangentWS;
    }

    export enum EMaterialExposedViewProperty {
        MEVP_BufferSize,
        MEVP_FieldOfView,
        MEVP_TanHalfFieldOfView,
        MEVP_ViewSize,
        MEVP_WorldSpaceViewPosition,
        MEVP_WorldSpaceCameraPosition,
        MEVP_ViewportOffset,
        MEVP_TemporalSampleCount,
        MEVP_TemporalSampleIndex,
        MEVP_TemporalSampleOffset,
        MEVP_RuntimeVirtualTextureOutputLevel,
        MEVP_RuntimeVirtualTextureOutputDerivative,
        MEVP_PreExposure,
        MEVP_RuntimeVirtualTextureMaxLevel,
        MEVP_MAX
    }

    export class MaterialExpressionViewProperty extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Property: EMaterialExposedViewProperty;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionViewProperty;

        static Load(InName: string): MaterialExpressionViewProperty;
    }

    export class MaterialExpressionViewReflection extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionViewReflection;

        static Load(InName: string): MaterialExpressionViewReflection;
    }

    export class MaterialExpressionViewSize extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionViewSize;

        static Load(InName: string): MaterialExpressionViewSize;
    }

    export class MaterialExpressionVirtualTextureFeatureSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        No: ExpressionInput;
        Yes: ExpressionInput;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVirtualTextureFeatureSwitch;

        static Load(InName: string): MaterialExpressionVirtualTextureFeatureSwitch;
    }

    export class MaterialExpressionVolumetricAdvancedMaterialInput extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVolumetricAdvancedMaterialInput;

        static Load(InName: string): MaterialExpressionVolumetricAdvancedMaterialInput;
    }

    export class MaterialExpressionVolumetricAdvancedMaterialOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhaseG: ExpressionInput;
        PhaseG2: ExpressionInput;
        PhaseBlend: ExpressionInput;
        MultiScatteringContribution: ExpressionInput;
        MultiScatteringOcclusion: ExpressionInput;
        MultiScatteringEccentricity: ExpressionInput;
        ConservativeDensity: ExpressionInput;
        ConstPhaseG: number;
        ConstPhaseG2: number;
        ConstPhaseBlend: number;
        PerSamplePhaseEvaluation: boolean;
        MultiScatteringApproximationOctaveCount: number;
        ConstMultiScatteringContribution: number;
        ConstMultiScatteringOcclusion: number;
        ConstMultiScatteringEccentricity: number;
        bGroundContribution: boolean;
        bGrayScaleMaterial: boolean;
        bRayMarchVolumeShadow: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVolumetricAdvancedMaterialOutput;

        static Load(InName: string): MaterialExpressionVolumetricAdvancedMaterialOutput;
    }

    export enum EWorldPositionIncludedOffsets {
        WPT_Default,
        WPT_ExcludeAllShaderOffsets,
        WPT_CameraRelative,
        WPT_CameraRelativeNoOffsets,
        WPT_MAX
    }

    export class MaterialExpressionWorldPosition extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WorldPositionShaderOffset: EWorldPositionIncludedOffsets;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialExpressionWorldPosition;

        static Load(InName: string): MaterialExpressionWorldPosition;
    }

    export class MaterialFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialTexture: Texture;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFactoryNew;

        static Load(InName: string): MaterialFactoryNew;
    }

    export class MaterialFunctionFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionFactoryNew;

        static Load(InName: string): MaterialFunctionFactoryNew;
    }

    export class MaterialFunctionInstanceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialParent: MaterialFunctionInterface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInstanceFactory;

        static Load(InName: string): MaterialFunctionInstanceFactory;
    }

    export class MaterialFunctionMaterialLayer extends MaterialFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayer;

        static Load(InName: string): MaterialFunctionMaterialLayer;
    }

    export class MaterialFunctionMaterialLayerBlend extends MaterialFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlend;

        static Load(InName: string): MaterialFunctionMaterialLayerBlend;
    }

    export class MaterialFunctionMaterialLayerBlendFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendFactory;

        static Load(InName: string): MaterialFunctionMaterialLayerBlendFactory;
    }

    export class MaterialFunctionMaterialLayerBlendInstance extends MaterialFunctionInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendInstance;

        static Load(InName: string): MaterialFunctionMaterialLayerBlendInstance;
    }

    export class MaterialFunctionMaterialLayerBlendInstanceFactory extends MaterialFunctionInstanceFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendInstanceFactory;

        static Load(InName: string): MaterialFunctionMaterialLayerBlendInstanceFactory;
    }

    export class MaterialFunctionMaterialLayerFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerFactory;

        static Load(InName: string): MaterialFunctionMaterialLayerFactory;
    }

    export class MaterialFunctionMaterialLayerInstance extends MaterialFunctionInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerInstance;

        static Load(InName: string): MaterialFunctionMaterialLayerInstance;
    }

    export class MaterialFunctionMaterialLayerInstanceFactory extends MaterialFunctionInstanceFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerInstanceFactory;

        static Load(InName: string): MaterialFunctionMaterialLayerInstanceFactory;
    }

    export class MaterialFunctionThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialFunctionThumbnailRenderer;

        static Load(InName: string): MaterialFunctionThumbnailRenderer;
    }

    export class MaterialGraphNode_Base extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Base;

        static Load(InName: string): MaterialGraphNode_Base;
    }

    export class MaterialGraphNode_Root extends MaterialGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Material: Material;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Root;

        static Load(InName: string): MaterialGraphNode_Root;
    }

    export class MaterialGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Material: Material;
        MaterialFunction: MaterialFunction;
        RootNode: MaterialGraphNode_Root;
        OriginalMaterialFullName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialGraph;

        static Load(InName: string): MaterialGraph;
    }

    export class MaterialGraphNode extends MaterialGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialExpression: MaterialExpression;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode;

        static Load(InName: string): MaterialGraphNode;
    }

    export class MaterialGraphNode_Comment extends EdGraphNode_Comment {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialExpressionComment: MaterialExpressionComment;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Comment;

        static Load(InName: string): MaterialGraphNode_Comment;
    }

    export class MaterialGraphNode_Knot extends MaterialGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Knot;

        static Load(InName: string): MaterialGraphNode_Knot;
    }

    export class MaterialGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialGraphSchema;

        static Load(InName: string): MaterialGraphSchema;
    }

    export class MaterialImportHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static FindExistingMaterial(BasePath: string, MaterialFullName: string, bRecursivePaths: boolean, OutError: $Ref<string>): MaterialInterface;

        static FindExistingMaterialFromSearchLocation(MaterialFullName: string, BasePackagePath: string, SearchLocation: EMaterialSearchLocation, OutError: $Ref<string>): MaterialInterface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialImportHelpers;

        static Load(InName: string): MaterialImportHelpers;
    }

    export class MaterialInstanceActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetActors: TArray<Actor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialInstanceActor;

        static Load(InName: string): MaterialInstanceActor;
    }

    export class MaterialInstanceConstantFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialParent: MaterialInterface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialInstanceConstantFactoryNew;

        static Load(InName: string): MaterialInstanceConstantFactoryNew;
    }

    export class MaterialInstanceThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialInstanceThumbnailRenderer;

        static Load(InName: string): MaterialInstanceThumbnailRenderer;
    }

    export enum EMaterialBakeMethod { IndividualMaterial, AtlasMaterial, BinnedMaterial, EMaterialBakeMethod_MAX }

    export class MaterialMergeOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Method: EMaterialBakeMethod;
        BlendMode: EBlendMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialMergeOptions;

        static Load(InName: string): MaterialMergeOptions;
    }

    export class PropertyEntry {
        constructor();
        constructor(Property: EMaterialProperty, bUseCustomSize: boolean, CustomSize: IntPoint, bUseConstantValue: boolean, ConstantValue: number);

        Property: EMaterialProperty;
        bUseCustomSize: boolean;
        CustomSize: IntPoint;
        bUseConstantValue: boolean;
        ConstantValue: number;

        static StaticClass(): Class;
    }

    export class MaterialOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Properties: TArray<PropertyEntry>;
        TextureSize: IntPoint;
        LODIndices: TArray<number>;
        bUseMeshData: boolean;
        bUseSpecificUVIndex: boolean;
        TextureCoordinateIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialOptions;

        static Load(InName: string): MaterialOptions;
    }

    export class MaterialParameterCollectionFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollectionFactoryNew;

        static Load(InName: string): MaterialParameterCollectionFactoryNew;
    }

    export enum EMobileShadowQuality { NoFiltering, PCF_1x1, PCF_2x2, PCF_3x3, EMobileShadowQuality_MAX }

    export class MaterialQualityOverrides {
        constructor();
        constructor(bDiscardQualityDuringCook: boolean, bEnableOverride: boolean, bForceFullyRough: boolean, bForceNonMetal: boolean, bForceDisableLMDirectionality: boolean, bForceLQReflections: boolean, bForceDisablePreintegratedGF: boolean, bDisableMaterialNormalCalculation: boolean, MobileShadowQuality: EMobileShadowQuality);

        bDiscardQualityDuringCook: boolean;
        bEnableOverride: boolean;
        bForceFullyRough: boolean;
        bForceNonMetal: boolean;
        bForceDisableLMDirectionality: boolean;
        bForceLQReflections: boolean;
        bForceDisablePreintegratedGF: boolean;
        bDisableMaterialNormalCalculation: boolean;
        MobileShadowQuality: EMobileShadowQuality;

        static StaticClass(): Class;
    }

    export class ShaderPlatformQualitySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QualityOverrides: FixSizeArray<MaterialQualityOverrides>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ShaderPlatformQualitySettings;

        static Load(InName: string): ShaderPlatformQualitySettings;
    }

    export class MaterialShaderQualitySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ForwardSettingMap: TMap<string, ShaderPlatformQualitySettings>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialShaderQualitySettings;

        static Load(InName: string): MaterialShaderQualitySettings;
    }

    export class MaterialStatsOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bPlatformUsed: FixSizeArray<number>;
        bMaterialQualityUsed: FixSizeArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MaterialStatsOptions;

        static Load(InName: string): MaterialStatsOptions;
    }

    export class MatineeActorCameraAnim extends MatineeActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraAnim: CameraAnim;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MatineeActorCameraAnim;

        static Load(InName: string): MatineeActorCameraAnim;
    }

    export class MatineeAnimInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MatineeAnimInterface;

        static Load(InName: string): MatineeAnimInterface;
    }

    export class MatineeInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MatineeInterface;

        static Load(InName: string): MatineeInterface;
    }

    export class MediaCaptureDevice {
        constructor();
        constructor(DisplayName: string, Url: string);

        DisplayName: string;
        Url: string;

        static StaticClass(): Class;
    }

    export class MediaBlueprintFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static EnumerateAudioCaptureDevices(OutDevices: $Ref<TArray<MediaCaptureDevice>>, Filter?: number /* = -1 */): void;

        static EnumerateVideoCaptureDevices(OutDevices: $Ref<TArray<MediaCaptureDevice>>, Filter?: number /* = -1 */): void;

        static EnumerateWebcamCaptureDevices(OutDevices: $Ref<TArray<MediaCaptureDevice>>, Filter?: number /* = -1 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MediaBlueprintFunctionLibrary;

        static Load(InName: string): MediaBlueprintFunctionLibrary;
    }

    export enum EMediaSoundChannels { Mono, Stereo, Surround, EMediaSoundChannels_MAX }

    export enum EMediaSoundComponentFFTSize {
        Min_64,
        Small_256,
        Medium_512,
        Large_1024,
        EMediaSoundComponentFFTSize_MAX
    }

    export class MediaSoundComponentSpectralData {
        constructor();
        constructor(FrequencyHz: number, Magnitude: number);

        FrequencyHz: number;
        Magnitude: number;

        static StaticClass(): Class;
    }

    export class MediaSoundComponent extends SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Channels: EMediaSoundChannels;
        DynamicRateAdjustment: boolean;
        RateAdjustmentFactor: number;
        RateAdjustmentRange: FloatRange;
        MediaPlayer: MediaPlayer;

        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<SoundAttenuationSettings>): boolean;

        GetEnvelopeValue(): number;

        GetMediaPlayer(): MediaPlayer;

        GetNormalizedSpectralData(): TArray<MediaSoundComponentSpectralData>;

        GetSpectralData(): TArray<MediaSoundComponentSpectralData>;

        SetEnableEnvelopeFollowing(bInEnvelopeFollowing: boolean): void;

        SetEnableSpectralAnalysis(bInSpectralAnalysisEnabled: boolean): void;

        SetEnvelopeFollowingsettings(AttackTimeMsec: number, ReleaseTimeMsec: number): void;

        SetMediaPlayer(NewMediaPlayer: $Nullable<MediaPlayer>): void;

        SetSpectralAnalysisSettings(InFrequenciesToAnalyze: TArray<number>, InFFTSize?: EMediaSoundComponentFFTSize /* = Medium_512 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MediaSoundComponent;

        static Load(InName: string): MediaSoundComponent;
    }

    export enum EMenuPlacement {
        MenuPlacement_BelowAnchor,
        MenuPlacement_CenteredBelowAnchor,
        MenuPlacement_BelowRightAnchor,
        MenuPlacement_ComboBox,
        MenuPlacement_ComboBoxRight,
        MenuPlacement_MenuRight,
        MenuPlacement_AboveAnchor,
        MenuPlacement_CenteredAboveAnchor,
        MenuPlacement_AboveRightAnchor,
        MenuPlacement_MenuLeft,
        MenuPlacement_Center,
        MenuPlacement_RightLeftCenter,
        MenuPlacement_MatchBottomLeft,
        MenuPlacement_MAX
    }

    export class MenuAnchor extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MenuClass: Class;
        OnGetMenuContentEvent: $Delegate<() => Widget>;
        OnGetUserMenuContentEvent: $Delegate<() => UserWidget>;
        Placement: EMenuPlacement;
        bFitInWindow: boolean;
        ShouldDeferPaintingAfterWindowContent: boolean;
        UseApplicationMenuStack: boolean;
        OnMenuOpenChanged: $MulticastDelegate<(bIsOpen: boolean) => void>;

        Close(): void;

        FitInWindow(bFit: boolean): void;

        GetMenuPosition(): Vector2D;

        GetUserWidget__DelegateSignature(): UserWidget;

        HasOpenSubMenus(): boolean;

        IsOpen(): boolean;

        Open(bFocusMenu: boolean): void;

        SetPlacement(InPlacement: EMenuPlacement): void;

        ShouldOpenDueToClick(): boolean;

        ToggleOpen(bFocusOnOpen: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MenuAnchor;

        static Load(InName: string): MenuAnchor;
    }

    export class MergeShaderPipelineCachesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MergeShaderPipelineCachesCommandlet;

        static Load(InName: string): MergeShaderPipelineCachesCommandlet;
    }

    export class MeshDescription extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshDescription;

        static Load(InName: string): MeshDescription;
    }

    export class MeshMergeCullingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshMergeCullingVolume;

        static Load(InName: string): MeshMergeCullingVolume;
    }

    export class MeshPaintSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VertexPreviewSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshPaintSettings;

        static Load(InName: string): MeshPaintSettings;
    }

    export class MeshReconstructorBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConnectMRMesh(Mesh: $Nullable<MRMeshComponent>): void;

        DisconnectMRMesh(): void;

        IsReconstructionPaused(): boolean;

        IsReconstructionStarted(): boolean;

        PauseReconstruction(): void;

        StartReconstruction(): void;

        StopReconstruction(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshReconstructorBase;

        static Load(InName: string): MeshReconstructorBase;
    }

    export class SelectionSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SelectionSet;

        static Load(InName: string): SelectionSet;
    }

    export class MeshSelectionSet extends SelectionSet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Vertices: TArray<number>;
        Edges: TArray<number>;
        Faces: TArray<number>;
        Groups: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshSelectionSet;

        static Load(InName: string): MeshSelectionSet;
    }

    export class MeshSimplificationSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MeshReductionModuleName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshSimplificationSettings;

        static Load(InName: string): MeshSimplificationSettings;
    }

    export class MeshSurfacePointToolBuilder extends InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshSurfacePointToolBuilder;

        static Load(InName: string): MeshSurfacePointToolBuilder;
    }

    export enum EVertexPaintAxis { X, Y, Z, EVertexPaintAxis_MAX }

    export class MeshVertexPainterKismetLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static PaintVerticesLerpAlongAxis(StaticMeshComponent: $Nullable<StaticMeshComponent>, StartColor: LinearColor, EndColor: LinearColor, Axis: EVertexPaintAxis, bConvertToSRGB?: boolean /* = true */): void;

        static PaintVerticesSingleColor(StaticMeshComponent: $Nullable<StaticMeshComponent>, FillColor: LinearColor, bConvertToSRGB?: boolean /* = true */): void;

        static RemovePaintedVertices(StaticMeshComponent: $Nullable<StaticMeshComponent>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MeshVertexPainterKismetLibrary;

        static Load(InName: string): MeshVertexPainterKismetLibrary;
    }

    export class MetaData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MetaData;

        static Load(InName: string): MetaData;
    }

    export class ConvertScreenResult {
        constructor();
        constructor(Result: boolean, WorldLocation: Vector, WorldDirection: Vector, ScreenPosition: Vector2D);

        Result: boolean;
        WorldLocation: Vector;
        WorldDirection: Vector;
        ScreenPosition: Vector2D;

        static StaticClass(): Class;
    }

    export class MetaWorldStatics extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AppendAsset(AssetGuid: string): void;

        static AssetIsLoaded(InAssetId: string): boolean;

        static AssetLoad(InAssetId: string): boolean;

        static BackupProject(GameName: string): boolean;

        static BeginCloneActor(ActorGuid: string, Callback: $Delegate<(bSuccess: boolean, Actor: $Nullable<Actor>, Msg: string) => void>): void;

        static BeginLoadFromGlobal(InAssetId: string, Callback: $Delegate<(Result: boolean) => void>): void;

        static BeginSpawnActor(AssetGuid: string, Callback: $Delegate<(bSuccess: boolean, Actor: $Nullable<Actor>, Msg: string) => void>, InNetStatus: ENetStatus, bStatic: boolean): void;

        static CloneActor(ActorGuid: string): Actor;

        static ConvertScreenLocationToWorldSpace(Player: $Nullable<PlayerController>, ScreenPosition: Vector2D): ConvertScreenResult;

        static CopyCurrentProject(NewGameName: string): boolean;

        static CopyProject(GameName: string, NewGameName: string): boolean;

        static CreateGuid(): string;

        static FindActorByGuid(InGuid: string): MWActor;

        static FindActorsByName(InName: string, OutActors: $Ref<TArray<MWActor>>): void;

        static FindActorsByParentGuid(InGuid: string, OutActors: $Ref<TArray<MWActor>>): void;

        static FindActorsBySource(InSourceGuid: string, OutActors: $Ref<TArray<MWActor>>): void;

        static FindActorsByTag(InTag: string, OutActors: $Ref<TArray<MWActor>>): void;

        static FindAsset(AssetGuid: string): Object;

        static GetBoundingBoxSize(InActor: $Nullable<Actor>, bNonColliding?: boolean /* = false */, bIncludeFromChildActors?: boolean /* = false */): Vector;

        static GetCurrentCPULevel(): number;

        static GetCurrentEnv(): string;

        static GetCurrentGPULevel(): number;

        static GetCurrentVer(): string;

        static GetGameViewport(): GameViewportClient;

        static GetMachineId(): string;

        static GetMWWorld(): MWWorld;

        static GetScriptAssetGuidByPath(Path: string): string;

        static HasAsset(InAssetId: string): boolean;

        static HidePIELoading(): boolean;

        static ManuallySetDeviceLevels(CPULevel: number, GPULevel: number): void;

        static ProjectWorldLocationToWidgetPosition(Player: $Nullable<PlayerController>, WorldLocation: Vector, bPlayerViewportRelative: boolean): ConvertScreenResult;

        static SaveAsProject(GameName: string): void;

        static SaveProject(): void;

        static SpawnActor(AssetGuid: string): Actor;

        static SpawnActorForTS(AssetGuid: string, InNetStatus: ENetStatus, bStatic: boolean): Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MetaWorldStatics;

        static Load(InName: string): MetaWorldStatics;
    }

    export class PurchaseInfo {
        constructor();
        constructor(Identifier: string, DisplayName: string, DisplayDescription: string, DisplayPrice: string);

        Identifier: string;
        DisplayName: string;
        DisplayDescription: string;
        DisplayPrice: string;

        static StaticClass(): Class;
    }

    export class MicroTransactionBase extends PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AvailableProducts: TArray<PurchaseInfo>;
        LastError: string;
        LastErrorSolution: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MicroTransactionBase;

        static Load(InName: string): MicroTransactionBase;
    }

    export class MobileInstalledContent extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetDiskFreeSpace(): number;

        GetInstalledContentSize(): number;

        Mount(PakOrder: number, MountPoint: string): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MobileInstalledContent;

        static Load(InName: string): MobileInstalledContent;
    }

    export class MobilePendingContent extends MobileInstalledContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetDownloadSize(): number;

        GetDownloadSpeed(): number;

        GetDownloadStatusText(): string;

        GetInstallProgress(): number;

        GetRequiredDiskSpace(): number;

        GetTotalDownloadedSize(): number;

        StartInstall(OnSucceeded: $Delegate<() => void>, OnFailed: $Delegate<(ErrorText: string, ErrorCode: number) => void>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MobilePendingContent;

        static Load(InName: string): MobilePendingContent;
    }

    export class MobilePatchingLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetActiveDeviceProfileName(): string;

        static GetInstalledContent(InstallDirectory: string): MobileInstalledContent;

        static GetSupportedPlatformNames(): TArray<string>;

        static HasActiveWiFiConnection(): boolean;

        static RequestContent(RemoteManifestURL: string, CloudURL: string, InstallDirectory: string, OnSucceeded: $Delegate<(MobilePendingContent: $Nullable<MobilePendingContent>) => void>, OnFailed: $Delegate<(ErrorText: string, ErrorCode: number) => void>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MobilePatchingLibrary;

        static Load(InName: string): MobilePatchingLibrary;
    }

    export class MockAI extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BBComp: BlackboardComponent;
        BrainComp: BrainComponent;
        PerceptionComp: AIPerceptionComponent;
        PawnActionComp: PawnActionsComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MockAI;

        static Load(InName: string): MockAI;
    }

    export class MockAI_BT extends MockAI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BTComp: BehaviorTreeComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MockAI_BT;

        static Load(InName: string): MockAI_BT;
    }

    export enum EMeshTrackerVertexColorMode { None, Confidence, Block, EMeshTrackerVertexColorMode_MAX }

    export class MockDataMeshTrackerComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnMeshTrackerUpdated: $MulticastDelegate<(Index: number, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, Confidence: TArray<number>) => void>;
        ScanWorld: boolean;
        RequestNormals: boolean;
        RequestVertexConfidence: boolean;
        VertexColorMode: EMeshTrackerVertexColorMode;
        BlockVertexColors: TArray<Color>;
        VertexColorFromConfidenceZero: LinearColor;
        VertexColorFromConfidenceOne: LinearColor;
        UpdateInterval: number;
        MRMesh: MRMeshComponent;

        ConnectMRMesh(InMRMeshPtr: $Nullable<MRMeshComponent>): void;

        DisconnectMRMesh(InMRMeshPtr: $Nullable<MRMeshComponent>): void;

        OnMockDataMeshTrackerUpdated__DelegateSignature(Index: number, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, Confidence: TArray<number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MockDataMeshTrackerComponent;

        static Load(InName: string): MockDataMeshTrackerComponent;
    }

    export class MockGameplayTaskOwner extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GTComponent: GameplayTasksComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MockGameplayTaskOwner;

        static Load(InName: string): MockGameplayTaskOwner;
    }

    export class MockGameplayTasksComponent extends GameplayTasksComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MockGameplayTasksComponent;

        static Load(InName: string): MockGameplayTasksComponent;
    }

    export class MockTask_Log extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MockTask_Log;

        static Load(InName: string): MockTask_Log;
    }

    export class ModelExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ModelExporterT3D;

        static Load(InName: string): ModelExporterT3D;
    }

    export class ModelFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ModelFactory;

        static Load(InName: string): ModelFactory;
    }

    export class MWAnimInstanceProxy_ModifyBone extends AnimInstanceProxy {
        constructor();
        constructor(BonesTranslation: TArray<Vector>, BonesRotation: TArray<Rotator>, BonesScale: TArray<Vector>, BonesName: TArray<string>);

        BonesTranslation: TArray<Vector>;
        BonesRotation: TArray<Rotator>;
        BonesScale: TArray<Vector>;
        BonesName: TArray<string>;

        static StaticClass(): Class;
    }

    export class ModifyBonesAnimInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Proxy: MWAnimInstanceProxy_ModifyBone;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ModifyBonesAnimInstance;

        static Load(InName: string): ModifyBonesAnimInstance;
    }

    export class MotionControllerComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerIndex: number;
        Hand: EControllerHand;
        MotionSource: string;
        bDisableLowLatencyUpdate: boolean;
        CurrentTrackingStatus: ETrackingStatus;
        bDisplayDeviceModel: boolean;
        DisplayModelSource: string;
        CustomDisplayMesh: StaticMesh;
        DisplayMeshMaterialOverrides: TArray<MaterialInterface>;
        DisplayComponent: PrimitiveComponent;

        GetHandJointPosition(jointIndex: number, bValueFound: $Ref<boolean>): Vector;

        GetParameterValue(InName: string, bValueFound: $Ref<boolean>): number;

        GetTrackingSource(): EControllerHand;

        IsTracked(): boolean;

        OnMotionControllerUpdated(): void;

        SetAssociatedPlayerIndex(NewPlayer: number): void;

        SetCustomDisplayMesh(NewDisplayMesh: $Nullable<StaticMesh>): void;

        SetDisplayModelSource(NewDisplayModelSource: string): void;

        SetShowDeviceModel(bShowControllerModel: boolean): void;

        SetTrackingMotionSource(NewSource: string): void;

        SetTrackingSource(NewSource: EControllerHand): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MotionControllerComponent;

        static Load(InName: string): MotionControllerComponent;
    }

    export class MotionTrackedDeviceFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static DisableMotionTrackingForComponent(MotionControllerComponent: $Nullable<MotionControllerComponent>): void;

        static DisableMotionTrackingOfAllControllers(): void;

        static DisableMotionTrackingOfControllersForPlayer(PlayerIndex: number): void;

        static DisableMotionTrackingOfDevice(PlayerIndex: number, Hand: EControllerHand): void;

        static DisableMotionTrackingOfSource(PlayerIndex: number, SourceName: string): void;

        static EnableMotionTrackingForComponent(MotionControllerComponent: $Nullable<MotionControllerComponent>): boolean;

        static EnableMotionTrackingOfDevice(PlayerIndex: number, Hand: EControllerHand): boolean;

        static EnableMotionTrackingOfSource(PlayerIndex: number, SourceName: string): boolean;

        static EnumerateMotionSources(): TArray<string>;

        static GetActiveTrackingSystemName(): string;

        static GetMaximumMotionTrackedControllerCount(): number;

        static GetMotionTrackingEnabledControllerCount(): number;

        static IsMotionSourceTracking(PlayerIndex: number, SourceName: string): boolean;

        static IsMotionTrackedDeviceCountManagementNecessary(): boolean;

        static IsMotionTrackingEnabledForComponent(MotionControllerComponent: $Nullable<MotionControllerComponent>): boolean;

        static IsMotionTrackingEnabledForDevice(PlayerIndex: number, Hand: EControllerHand): boolean;

        static IsMotionTrackingEnabledForSource(PlayerIndex: number, SourceName: string): boolean;

        static SetIsControllerMotionTrackingEnabledByDefault(Enable: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MotionTrackedDeviceFunctionLibrary;

        static Load(InName: string): MotionTrackedDeviceFunctionLibrary;
    }

    export class MouseCursorBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetValue(): EMouseCursor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MouseCursorBinding;

        static Load(InName: string): MouseCursorBinding;
    }

    export class MouseHoverBehavior extends InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MouseHoverBehavior;

        static Load(InName: string): MouseHoverBehavior;
    }

    export class MoviePlayerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bWaitForMoviesToComplete: boolean;
        bMoviesAreSkippable: boolean;
        StartupMovies: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MoviePlayerSettings;

        static Load(InName: string): MoviePlayerSettings;
    }

    export class MovieSceneEntityInstantiatorSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEntityInstantiatorSystem;

        static Load(InName: string): MovieSceneEntityInstantiatorSystem;
    }

    export class MovieScenePropertyInstantiatorSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePropertyInstantiatorSystem;

        static Load(InName: string): MovieScenePropertyInstantiatorSystem;
    }

    export class MovieScenePropertySystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InstantiatorSystem: MovieScenePropertyInstantiatorSystem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePropertySystem;

        static Load(InName: string): MovieScenePropertySystem;
    }

    export class MovieScene2DTransformPropertySystem extends MovieScenePropertySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene2DTransformPropertySystem;

        static Load(InName: string): MovieScene2DTransformPropertySystem;
    }

    export class MovieScene2DTransformMask {
        constructor();
        constructor(Mask: number);

        Mask: number;

        static StaticClass(): Class;
    }

    export class MovieSceneChannel {
        constructor();

        static StaticClass(): Class;
    }

    export class KeyHandleLookupTable {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneKeyHandleMap extends KeyHandleLookupTable {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneFloatChannel extends MovieSceneChannel {
        constructor();
        constructor(PreInfinityExtrap: ERichCurveExtrapolation, PostInfinityExtrap: ERichCurveExtrapolation, Times: TArray<FrameNumber>, Values: TArray<MovieSceneFloatValue>, DefaultValue: number, bHasDefaultValue: boolean, KeyHandles: MovieSceneKeyHandleMap, TickResolution: FrameRate);

        PreInfinityExtrap: ERichCurveExtrapolation;
        PostInfinityExtrap: ERichCurveExtrapolation;
        Times: TArray<FrameNumber>;
        Values: TArray<MovieSceneFloatValue>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        KeyHandles: MovieSceneKeyHandleMap;
        TickResolution: FrameRate;

        static StaticClass(): Class;
    }

    export class MovieScene2DTransformSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TransformMask: MovieScene2DTransformMask;
        Translation: FixSizeArray<MovieSceneFloatChannel>;
        Rotation: MovieSceneFloatChannel;
        Scale: FixSizeArray<MovieSceneFloatChannel>;
        Shear: FixSizeArray<MovieSceneFloatChannel>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene2DTransformSection;

        static Load(InName: string): MovieScene2DTransformSection;
    }

    export class MovieSceneNameableTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DisplayName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNameableTrack;

        static Load(InName: string): MovieSceneNameableTrack;
    }

    export class MovieScenePropertyBinding {
        constructor();
        constructor(PropertyName: string, PropertyPath: string, bCanUseClassLookup: boolean);

        PropertyName: string;
        PropertyPath: string;
        bCanUseClassLookup: boolean;

        static StaticClass(): Class;
    }

    export class MovieScenePropertyTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UniqueTrackName: string;
        PropertyName: string;
        PropertyPath: string;
        SectionToKey: MovieSceneSection;
        PropertyBinding: MovieScenePropertyBinding;
        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePropertyTrack;

        static Load(InName: string): MovieScenePropertyTrack;
    }

    export class MovieScene2DTransformTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene2DTransformTrack;

        static Load(InName: string): MovieScene2DTransformTrack;
    }

    export class MovieScene3DConstraintSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstraintId: Guid;
        ConstraintBindingID: MovieSceneObjectBindingID;

        GetConstraintBindingID(): MovieSceneObjectBindingID;

        SetConstraintBindingID(InConstraintBindingID: MovieSceneObjectBindingID): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DConstraintSection;

        static Load(InName: string): MovieScene3DConstraintSection;
    }

    export class MovieScene3DAttachSection extends MovieScene3DConstraintSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AttachSocketName: string;
        AttachComponentName: string;
        bFullRevertOnDetach: boolean;
        ReAttachOnDetach: TSoftObjectPtr<Actor>;
        AttachmentLocationRule: EAttachmentRule;
        AttachmentRotationRule: EAttachmentRule;
        AttachmentScaleRule: EAttachmentRule;
        DetachmentLocationRule: EDetachmentRule;
        DetachmentRotationRule: EDetachmentRule;
        DetachmentScaleRule: EDetachmentRule;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DAttachSection;

        static Load(InName: string): MovieScene3DAttachSection;
    }

    export class MovieScene3DConstraintTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstraintSections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DConstraintTrack;

        static Load(InName: string): MovieScene3DConstraintTrack;
    }

    export class MovieScene3DAttachTrack extends MovieScene3DConstraintTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DAttachTrack;

        static Load(InName: string): MovieScene3DAttachTrack;
    }

    export enum MovieScene3DPathSection_Axis { X, Y, Z, NEG_X, NEG_Y, NEG_Z, MovieScene3DPathSection_MAX }

    export class MovieScene3DPathSection extends MovieScene3DConstraintSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TimingCurve: MovieSceneFloatChannel;
        FrontAxisEnum: MovieScene3DPathSection_Axis;
        UpAxisEnum: MovieScene3DPathSection_Axis;
        bFollow: boolean;
        bReverse: boolean;
        bForceUpright: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DPathSection;

        static Load(InName: string): MovieScene3DPathSection;
    }

    export class MovieScene3DPathTrack extends MovieScene3DConstraintTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DPathTrack;

        static Load(InName: string): MovieScene3DPathTrack;
    }

    export class MovieScene3DTransformPropertySystem extends MovieScenePropertySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformPropertySystem;

        static Load(InName: string): MovieScene3DTransformPropertySystem;
    }

    export class MovieSceneTransformMask {
        constructor();
        constructor(Mask: number);

        Mask: number;

        static StaticClass(): Class;
    }

    export enum EShow3DTrajectory { EST_OnlyWhenSelected, EST_Always, EST_Never, EST_MAX }

    export class MovieScene3DTransformSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TransformMask: MovieSceneTransformMask;
        Translation: FixSizeArray<MovieSceneFloatChannel>;
        Rotation: FixSizeArray<MovieSceneFloatChannel>;
        Scale: FixSizeArray<MovieSceneFloatChannel>;
        ManualWeight: MovieSceneFloatChannel;
        bUseQuaternionInterpolation: boolean;
        Show3DTrajectory: EShow3DTrajectory;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformSection;

        static Load(InName: string): MovieScene3DTransformSection;
    }

    export class MovieScene3DTransformSectionRecorderSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bRecordTransforms: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformSectionRecorderSettings;

        static Load(InName: string): MovieScene3DTransformSectionRecorderSettings;
    }

    export class MovieScene3DTransformTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformTrack;

        static Load(InName: string): MovieScene3DTransformTrack;
    }

    export class MovieSceneActorReferenceKey {
        constructor();
        constructor(Object: MovieSceneObjectBindingID, ComponentName: string, SocketName: string);

        Object: MovieSceneObjectBindingID;
        ComponentName: string;
        SocketName: string;

        static StaticClass(): Class;
    }

    export class MovieSceneActorReferenceData extends MovieSceneChannel {
        constructor();
        constructor(KeyTimes: TArray<FrameNumber>, KeyValues: TArray<MovieSceneActorReferenceKey>);

        KeyTimes: TArray<FrameNumber>;
        KeyValues: TArray<MovieSceneActorReferenceKey>;

        static StaticClass(): Class;
    }

    export class MovieSceneActorReferenceSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActorReferenceData: MovieSceneActorReferenceData;
        ActorGuidIndexCurve: IntegralCurve;
        ActorGuidStrings: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneActorReferenceSection;

        static Load(InName: string): MovieSceneActorReferenceSection;
    }

    export class MovieSceneActorReferenceTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneActorReferenceTrack;

        static Load(InName: string): MovieSceneActorReferenceTrack;
    }

    export class MovieSceneAudioSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sound: SoundBase;
        StartFrameOffset: FrameNumber;
        StartOffset: number;
        AudioStartTime: number;
        AudioDilationFactor: number;
        AudioVolume: number;
        SoundVolume: MovieSceneFloatChannel;
        PitchMultiplier: MovieSceneFloatChannel;
        AttachActorData: MovieSceneActorReferenceData;
        bLooping: boolean;
        bSuppressSubtitles: boolean;
        bOverrideAttenuation: boolean;
        AttenuationSettings: SoundAttenuation;
        OnQueueSubtitles: $Delegate<(Subtitles: TArray<SubtitleCue>, CueDuration: number) => void>;
        OnAudioFinished: $MulticastDelegate<() => void>;
        OnAudioPlaybackPercent: $MulticastDelegate<(PlayingSoundWave: $Nullable<SoundWave>, PlaybackPercent: number) => void>;

        GetSound(): SoundBase;

        GetStartOffset(): FrameNumber;

        SetSound(InSound: $Nullable<SoundBase>): void;

        SetStartOffset(InStartOffset: FrameNumber): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioSection;

        static Load(InName: string): MovieSceneAudioSection;
    }

    export class MovieSceneAudioTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AudioSections: TArray<MovieSceneSection>;
        RowHeight: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioTrack;

        static Load(InName: string): MovieSceneAudioTrack;
    }

    export class MovieSceneBaseValueEvaluatorSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneBaseValueEvaluatorSystem;

        static Load(InName: string): MovieSceneBaseValueEvaluatorSystem;
    }

    export class MovieSceneBindingOwnerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneBindingOwnerInterface;

        static Load(InName: string): MovieSceneBindingOwnerInterface;
    }

    export class MovieSceneBlenderSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneBlenderSystem;

        static Load(InName: string): MovieSceneBlenderSystem;
    }

    export class MovieSceneBoolChannel extends MovieSceneChannel {
        constructor();
        constructor(Times: TArray<FrameNumber>, DefaultValue: boolean, bHasDefaultValue: boolean, Values: TArray<boolean>);

        Times: TArray<FrameNumber>;
        DefaultValue: boolean;
        bHasDefaultValue: boolean;
        Values: TArray<boolean>;

        static StaticClass(): Class;
    }

    export class MovieSceneBoolSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultValue: boolean;
        BoolCurve: MovieSceneBoolChannel;
        bIsExternallyInverted: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneBoolSection;

        static Load(InName: string): MovieSceneBoolSection;
    }

    export class MovieSceneBoolTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneBoolTrack;

        static Load(InName: string): MovieSceneBoolTrack;
    }

    export class MovieSceneBoundSceneComponentInstantiator extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneBoundSceneComponentInstantiator;

        static Load(InName: string): MovieSceneBoundSceneComponentInstantiator;
    }

    export enum EMovieSceneBuiltInEasing {
        Linear,
        SinIn,
        SinOut,
        SinInOut,
        QuadIn,
        QuadOut,
        QuadInOut,
        CubicIn,
        CubicOut,
        CubicInOut,
        QuartIn,
        QuartOut,
        QuartInOut,
        QuintIn,
        QuintOut,
        QuintInOut,
        ExpoIn,
        ExpoOut,
        ExpoInOut,
        CircIn,
        CircOut,
        CircInOut,
        EMovieSceneBuiltInEasing_MAX
    }

    export class MovieSceneBuiltInEasingFunction extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Type: EMovieSceneBuiltInEasing;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneBuiltInEasingFunction;

        static Load(InName: string): MovieSceneBuiltInEasingFunction;
    }

    export class MovieSceneByteChannel extends MovieSceneChannel {
        constructor();
        constructor(Times: TArray<FrameNumber>, DefaultValue: number, bHasDefaultValue: boolean, Values: TArray<number>, Enum: Enum);

        Times: TArray<FrameNumber>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        Values: TArray<number>;

        static StaticClass(): Class;
    }

    export class MovieSceneByteSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ByteCurve: MovieSceneByteChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneByteSection;

        static Load(InName: string): MovieSceneByteSection;
    }

    export class MovieSceneByteTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneByteTrack;

        static Load(InName: string): MovieSceneByteTrack;
    }

    export class MovieSceneCachePreAnimatedStateSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCachePreAnimatedStateSystem;

        static Load(InName: string): MovieSceneCachePreAnimatedStateSystem;
    }

    export class MovieSceneCameraAnimSectionData {
        constructor();
        constructor(CameraAnim: CameraAnim, PlayRate: number, PlayScale: number, BlendInTime: number, BlendOutTime: number, bLooping: boolean);

        CameraAnim: CameraAnim;
        PlayRate: number;
        PlayScale: number;
        BlendInTime: number;
        BlendOutTime: number;
        bLooping: boolean;

        static StaticClass(): Class;
    }

    export class MovieSceneCameraAnimSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimData: MovieSceneCameraAnimSectionData;
        CameraAnim: CameraAnim;
        PlayRate: number;
        PlayScale: number;
        BlendInTime: number;
        BlendOutTime: number;
        bLooping: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraAnimSection;

        static Load(InName: string): MovieSceneCameraAnimSection;
    }

    export class MovieSceneCameraAnimTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraAnimSections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraAnimTrack;

        static Load(InName: string): MovieSceneCameraAnimTrack;
    }

    export class MovieSceneCameraCutSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bLockPreviousCamera: boolean;
        CameraGuid: Guid;
        CameraBindingID: MovieSceneObjectBindingID;
        InitialCameraCutTransform: Transform;
        bHasInitialCameraCutTransform: boolean;
        ThumbnailReferenceOffset: number;

        GetCameraBindingID(): MovieSceneObjectBindingID;

        SetCameraBindingID(InCameraBindingID: MovieSceneObjectBindingID): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraCutSection;

        static Load(InName: string): MovieSceneCameraCutSection;
    }

    export class MovieSceneCameraCutTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCanBlend: boolean;
        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraCutTrack;

        static Load(InName: string): MovieSceneCameraCutTrack;
    }

    export class MovieSceneTrackInstanceInput {
        constructor();
        constructor(Section: MovieSceneSection);

        Section: MovieSceneSection;

        static StaticClass(): Class;
    }

    export class MovieSceneTrackInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimatedObject: Object;
        bIsMasterTrackInstance: boolean;
        Linker: MovieSceneEntitySystemLinker;
        Inputs: TArray<MovieSceneTrackInstanceInput>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneTrackInstance;

        static Load(InName: string): MovieSceneTrackInstance;
    }

    export class MovieSceneCameraCutTrackInstance extends MovieSceneTrackInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraCutTrackInstance;

        static Load(InName: string): MovieSceneCameraCutTrackInstance;
    }

    export class MovieSceneCameraShakeSectionData {
        constructor();
        constructor(ShakeClass: Class, PlayScale: number, PlaySpace: ECameraShakePlaySpace, UserDefinedPlaySpace: Rotator);

        ShakeClass: Class;
        PlayScale: number;
        PlaySpace: ECameraShakePlaySpace;
        UserDefinedPlaySpace: Rotator;

        static StaticClass(): Class;
    }

    export class MovieSceneCameraShakeSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShakeData: MovieSceneCameraShakeSectionData;
        ShakeClass: Class;
        PlayScale: number;
        PlaySpace: ECameraShakePlaySpace;
        UserDefinedPlaySpace: Rotator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeSection;

        static Load(InName: string): MovieSceneCameraShakeSection;
    }

    export class MovieSceneCameraShakeSourceShakeSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShakeData: MovieSceneCameraShakeSectionData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeSourceShakeSection;

        static Load(InName: string): MovieSceneCameraShakeSourceShakeSection;
    }

    export class MovieSceneCameraShakeSourceShakeTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraShakeSections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeSourceShakeTrack;

        static Load(InName: string): MovieSceneCameraShakeSourceShakeTrack;
    }

    export class MovieSceneCameraShakeSourceTrigger {
        constructor();
        constructor(ShakeClass: Class, PlayScale: number, PlaySpace: ECameraShakePlaySpace, UserDefinedPlaySpace: Rotator);

        ShakeClass: Class;
        PlayScale: number;
        PlaySpace: ECameraShakePlaySpace;
        UserDefinedPlaySpace: Rotator;

        static StaticClass(): Class;
    }

    export class MovieSceneCameraShakeSourceTriggerChannel extends MovieSceneChannel {
        constructor();
        constructor(KeyTimes: TArray<FrameNumber>, KeyValues: TArray<MovieSceneCameraShakeSourceTrigger>);

        KeyTimes: TArray<FrameNumber>;
        KeyValues: TArray<MovieSceneCameraShakeSourceTrigger>;

        static StaticClass(): Class;
    }

    export class MovieSceneCameraShakeSourceTriggerSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Channel: MovieSceneCameraShakeSourceTriggerChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeSourceTriggerSection;

        static Load(InName: string): MovieSceneCameraShakeSourceTriggerSection;
    }

    export class MovieSceneCameraShakeSourceTriggerTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeSourceTriggerTrack;

        static Load(InName: string): MovieSceneCameraShakeSourceTriggerTrack;
    }

    export class MovieSceneCameraShakeTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraShakeSections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeTrack;

        static Load(InName: string): MovieSceneCameraShakeTrack;
    }

    export class MovieSceneCaptureEnvironment extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static FindAudioCaptureProtocol(): MovieSceneAudioCaptureProtocolBase;

        static FindImageCaptureProtocol(): MovieSceneImageCaptureProtocolBase;

        static GetCaptureElapsedTime(): number;

        static GetCaptureFrameNumber(): number;

        static IsCaptureInProgress(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureEnvironment;

        static Load(InName: string): MovieSceneCaptureEnvironment;
    }

    export class MovieSceneCaptureInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureInterface;

        static Load(InName: string): MovieSceneCaptureInterface;
    }

    export class MovieSceneSectionParameters {
        constructor();
        constructor(StartFrameOffset: FrameNumber, bCanLoop: boolean, EndFrameOffset: FrameNumber, FirstLoopStartFrameOffset: FrameNumber, TimeScale: number, HierarchicalBias: number, StartOffset: number, PrerollTime: number, PostrollTime: number);

        StartFrameOffset: FrameNumber;
        bCanLoop: boolean;
        EndFrameOffset: FrameNumber;
        FirstLoopStartFrameOffset: FrameNumber;
        TimeScale: number;
        HierarchicalBias: number;
        StartOffset: number;
        PrerollTime: number;
        PostrollTime: number;

        static StaticClass(): Class;
    }

    export class MovieSceneSubSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Parameters: MovieSceneSectionParameters;
        StartOffset: number;
        TimeScale: number;
        PrerollTime: number;
        SubSequence: MovieSceneSequence;
        ActorToRecord: TLazyObjectPtr<Actor>;
        TargetSequenceName: string;
        TargetPathToRecordTo: DirectoryPath;

        GetSequence(): MovieSceneSequence;

        SetSequence(Sequence: $Nullable<MovieSceneSequence>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSubSection;

        static Load(InName: string): MovieSceneSubSection;
    }

    export class MovieSceneCinematicShotSection extends MovieSceneSubSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShotDisplayName: string;
        DisplayName: string;
        ThumbnailReferenceOffset: number;

        GetShotDisplayName(): string;

        SetShotDisplayName(InShotDisplayName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCinematicShotSection;

        static Load(InName: string): MovieSceneCinematicShotSection;
    }

    export class MovieSceneSubTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSubTrack;

        static Load(InName: string): MovieSceneSubTrack;
    }

    export class MovieSceneCinematicShotTrack extends MovieSceneSubTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCinematicShotTrack;

        static Load(InName: string): MovieSceneCinematicShotTrack;
    }

    export class MovieSceneColorSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RedCurve: MovieSceneFloatChannel;
        GreenCurve: MovieSceneFloatChannel;
        BlueCurve: MovieSceneFloatChannel;
        AlphaCurve: MovieSceneFloatChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneColorSection;

        static Load(InName: string): MovieSceneColorSection;
    }

    export class MovieSceneColorTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsSlateColor: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneColorTrack;

        static Load(InName: string): MovieSceneColorTrack;
    }

    export class MovieSceneComponentAttachmentInvalidatorSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneComponentAttachmentInvalidatorSystem;

        static Load(InName: string): MovieSceneComponentAttachmentInvalidatorSystem;
    }

    export class MovieSceneComponentAttachmentSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneComponentAttachmentSystem;

        static Load(InName: string): MovieSceneComponentAttachmentSystem;
    }

    export class MovieSceneMaterialTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneMaterialTrack;

        static Load(InName: string): MovieSceneMaterialTrack;
    }

    export class MovieSceneComponentMaterialTrack extends MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneComponentMaterialTrack;

        static Load(InName: string): MovieSceneComponentMaterialTrack;
    }

    export class MovieSceneComponentMobilitySystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneComponentMobilitySystem;

        static Load(InName: string): MovieSceneComponentMobilitySystem;
    }

    export class MovieSceneComponentTransformSystem extends MovieScenePropertySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneComponentTransformSystem;

        static Load(InName: string): MovieSceneComponentTransformSystem;
    }

    export class MovieSceneCopyableBinding extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpawnableObjectTemplate: Object;
        Tracks: TArray<MovieSceneTrack>;
        Binding: MovieSceneBinding;
        Spawnable: MovieSceneSpawnable;
        Possessable: MovieScenePossessable;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCopyableBinding;

        static Load(InName: string): MovieSceneCopyableBinding;
    }

    export class MovieSceneCopyableTrack extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Track: MovieSceneTrack;
        bIsAMasterTrack: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCopyableTrack;

        static Load(InName: string): MovieSceneCopyableTrack;
    }

    export class MovieSceneCustomClockSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnRequestCurrentTime(InCurrentTime: QualifiedFrameTime, InPlayRate: number): FrameTime;

        OnStartPlaying(InStartTime: QualifiedFrameTime): void;

        OnStopPlaying(InStopTime: QualifiedFrameTime): void;

        OnTick(DeltaSeconds: number, InPlayRate: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneCustomClockSource;

        static Load(InName: string): MovieSceneCustomClockSource;
    }

    export class MovieSceneEasingExternalCurve extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Curve: CurveFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEasingExternalCurve;

        static Load(InName: string): MovieSceneEasingExternalCurve;
    }

    export class MovieSceneEntityProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEntityProvider;

        static Load(InName: string): MovieSceneEntityProvider;
    }

    export class MovieSceneEnumSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEnumSection;

        static Load(InName: string): MovieSceneEnumSection;
    }

    export class MovieSceneEnumTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEnumTrack;

        static Load(InName: string): MovieSceneEnumTrack;
    }

    export class MovieSceneEulerTransformPropertySystem extends MovieScenePropertySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEulerTransformPropertySystem;

        static Load(InName: string): MovieSceneEulerTransformPropertySystem;
    }

    export class MovieSceneEulerTransformTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEulerTransformTrack;

        static Load(InName: string): MovieSceneEulerTransformTrack;
    }

    export class MovieSceneEvalTimeSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEvalTimeSystem;

        static Load(InName: string): MovieSceneEvalTimeSystem;
    }

    export class MovieSceneEventSectionBase extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEventSectionBase;

        static Load(InName: string): MovieSceneEventSectionBase;
    }

    export class MovieSceneEventBlueprintExtension extends BlueprintExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventSections: TArray<MovieSceneEventSectionBase>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEventBlueprintExtension;

        static Load(InName: string): MovieSceneEventBlueprintExtension;
    }

    export class MovieSceneEventPtrs {
        Function: Function;

        static StaticClass(): Class;
    }

    export class MovieSceneEventPayloadVariable {
        constructor();
        constructor(Value: string);

        Value: string;

        static StaticClass(): Class;
    }

    export class MovieSceneEvent {
        constructor();
        constructor(Ptrs: MovieSceneEventPtrs, PayloadVariables: TMap<string, MovieSceneEventPayloadVariable>, CompiledFunctionName: string, BoundObjectPinName: string, WeakEndpoint: TWeakObjectPtr<Object>, GraphGuid: Guid, NodeGuid: Guid, FunctionEntry: TWeakObjectPtr<Object>);

        Ptrs: MovieSceneEventPtrs;
        PayloadVariables: TMap<string, MovieSceneEventPayloadVariable>;
        CompiledFunctionName: string;
        BoundObjectPinName: string;
        WeakEndpoint: TWeakObjectPtr<Object>;
        GraphGuid: Guid;
        NodeGuid: Guid;
        FunctionEntry: TWeakObjectPtr<Object>;

        static StaticClass(): Class;
    }

    export class MovieSceneEventRepeaterSection extends MovieSceneEventSectionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Event: MovieSceneEvent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEventRepeaterSection;

        static Load(InName: string): MovieSceneEventRepeaterSection;
    }

    export class NameCurveKey {
        constructor();
        constructor(Time: number, Value: string);

        Time: number;
        Value: string;

        static StaticClass(): Class;
    }

    export class NameCurve extends IndexedCurve {
        constructor();
        constructor(Keys: TArray<NameCurveKey>);

        Keys: TArray<NameCurveKey>;

        static StaticClass(): Class;
    }

    export class MovieSceneEventParameters {
        constructor();

        static StaticClass(): Class;
    }

    export class EventPayload {
        constructor();
        constructor(EventName: string, Parameters: MovieSceneEventParameters);

        EventName: string;
        Parameters: MovieSceneEventParameters;

        static StaticClass(): Class;
    }

    export class MovieSceneEventSectionData extends MovieSceneChannel {
        constructor();
        constructor(Times: TArray<FrameNumber>, KeyValues: TArray<EventPayload>, KeyTimes: TArray<number>);

        Times: TArray<FrameNumber>;
        KeyValues: TArray<EventPayload>;
        KeyTimes: TArray<number>;

        static StaticClass(): Class;
    }

    export class MovieSceneEventSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Events: NameCurve;
        EventData: MovieSceneEventSectionData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEventSection;

        static Load(InName: string): MovieSceneEventSection;
    }

    export class MovieSceneEventSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEventSystem;

        static Load(InName: string): MovieSceneEventSystem;
    }

    export enum EFireEventsAtPosition { AtStartOfEvaluation, AtEndOfEvaluation, AfterSpawn, EFireEventsAtPosition_MAX }

    export class MovieSceneEventTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        EventPosition: EFireEventsAtPosition;
        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEventTrack;

        static Load(InName: string): MovieSceneEventTrack;
    }

    export class MovieSceneEventChannel extends MovieSceneChannel {
        constructor();
        constructor(KeyTimes: TArray<FrameNumber>, KeyValues: TArray<MovieSceneEvent>);

        KeyTimes: TArray<FrameNumber>;
        KeyValues: TArray<MovieSceneEvent>;

        static StaticClass(): Class;
    }

    export class MovieSceneEventTriggerSection extends MovieSceneEventSectionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventChannel: MovieSceneEventChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneEventTriggerSection;

        static Load(InName: string): MovieSceneEventTriggerSection;
    }

    export class MovieSceneFadeSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatCurve: MovieSceneFloatChannel;
        FadeColor: LinearColor;
        bFadeAudio: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneFadeSection;

        static Load(InName: string): MovieSceneFadeSection;
    }

    export class MovieSceneFloatTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneFloatTrack;

        static Load(InName: string): MovieSceneFloatTrack;
    }

    export class MovieSceneFadeTrack extends MovieSceneFloatTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneFadeTrack;

        static Load(InName: string): MovieSceneFadeTrack;
    }

    export class MovieSceneFloatDecomposer extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneFloatDecomposer;

        static Load(InName: string): MovieSceneFloatDecomposer;
    }

    export class MovieSceneFloatPropertySystem extends MovieScenePropertySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneFloatPropertySystem;

        static Load(InName: string): MovieSceneFloatPropertySystem;
    }

    export class MovieSceneFloatSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatCurve: MovieSceneFloatChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneFloatSection;

        static Load(InName: string): MovieSceneFloatSection;
    }

    export class MovieSceneGenericBoundObjectInstantiator extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneGenericBoundObjectInstantiator;

        static Load(InName: string): MovieSceneGenericBoundObjectInstantiator;
    }

    export class MovieSceneHierarchicalBiasSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneHierarchicalBiasSystem;

        static Load(InName: string): MovieSceneHierarchicalBiasSystem;
    }

    export class MovieSceneHierarchicalEasingInstantiatorSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneHierarchicalEasingInstantiatorSystem;

        static Load(InName: string): MovieSceneHierarchicalEasingInstantiatorSystem;
    }

    export class MovieSceneIntegerChannel extends MovieSceneChannel {
        constructor();
        constructor(Times: TArray<FrameNumber>, DefaultValue: number, bHasDefaultValue: boolean, Values: TArray<number>);

        Times: TArray<FrameNumber>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        Values: TArray<number>;

        static StaticClass(): Class;
    }

    export class MovieSceneIntegerSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IntegerCurve: MovieSceneIntegerChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneIntegerSection;

        static Load(InName: string): MovieSceneIntegerSection;
    }

    export class MovieSceneIntegerTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneIntegerTrack;

        static Load(InName: string): MovieSceneIntegerTrack;
    }

    export class MovieSceneInterrogatedPropertyInstantiatorSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneInterrogatedPropertyInstantiatorSystem;

        static Load(InName: string): MovieSceneInterrogatedPropertyInstantiatorSystem;
    }

    export class MovieSceneKeyProxy extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneKeyProxy;

        static Load(InName: string): MovieSceneKeyProxy;
    }

    export class MovieSceneKeyStructType extends ScriptStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneKeyStructType;

        static Load(InName: string): MovieSceneKeyStructType;
    }

    export enum ELevelVisibility { Visible, Hidden, ELevelVisibility_MAX }

    export class MovieSceneLevelVisibilitySection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Visibility: ELevelVisibility;
        LevelNames: TArray<string>;

        GetLevelNames(): TArray<string>;

        GetVisibility(): ELevelVisibility;

        SetLevelNames(InLevelNames: TArray<string>): void;

        SetVisibility(InVisibility: ELevelVisibility): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneLevelVisibilitySection;

        static Load(InName: string): MovieSceneLevelVisibilitySection;
    }

    export class MovieSceneLevelVisibilitySystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneLevelVisibilitySystem;

        static Load(InName: string): MovieSceneLevelVisibilitySystem;
    }

    export class MovieSceneLevelVisibilityTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneLevelVisibilityTrack;

        static Load(InName: string): MovieSceneLevelVisibilityTrack;
    }

    export class MovieSceneMarginSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TopCurve: MovieSceneFloatChannel;
        LeftCurve: MovieSceneFloatChannel;
        RightCurve: MovieSceneFloatChannel;
        BottomCurve: MovieSceneFloatChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneMarginSection;

        static Load(InName: string): MovieSceneMarginSection;
    }

    export class MovieSceneMarginTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneMarginTrack;

        static Load(InName: string): MovieSceneMarginTrack;
    }

    export class MovieSceneMasterInstantiatorSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneMasterInstantiatorSystem;

        static Load(InName: string): MovieSceneMasterInstantiatorSystem;
    }

    export class MovieSceneMaterialParameterCollectionTrack extends MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MPC: MaterialParameterCollection;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneMaterialParameterCollectionTrack;

        static Load(InName: string): MovieSceneMaterialParameterCollectionTrack;
    }

    export class MovieSceneNiagaraTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraTrack;

        static Load(InName: string): MovieSceneNiagaraTrack;
    }

    export class MovieSceneNiagaraParameterTrack extends MovieSceneNiagaraTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Parameter: NiagaraVariable;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraParameterTrack;

        static Load(InName: string): MovieSceneNiagaraParameterTrack;
    }

    export class MovieSceneNiagaraBoolParameterTrack extends MovieSceneNiagaraParameterTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraBoolParameterTrack;

        static Load(InName: string): MovieSceneNiagaraBoolParameterTrack;
    }

    export class MovieSceneNiagaraColorParameterTrack extends MovieSceneNiagaraParameterTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraColorParameterTrack;

        static Load(InName: string): MovieSceneNiagaraColorParameterTrack;
    }

    export class MovieSceneNiagaraEmitterSectionBase extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraEmitterSectionBase;

        static Load(InName: string): MovieSceneNiagaraEmitterSectionBase;
    }

    export class MovieSceneNiagaraEmitterSection extends MovieSceneNiagaraEmitterSectionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumLoops: number;
        bStartTimeIncludedInFirstLoopOnly: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraEmitterSection;

        static Load(InName: string): MovieSceneNiagaraEmitterSection;
    }

    export class MovieSceneNiagaraEmitterTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sections: TArray<MovieSceneSection>;
        bSectionsWereModified: boolean;
        EmitterHandleId: Guid;
        SystemPath: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraEmitterTrack;

        static Load(InName: string): MovieSceneNiagaraEmitterTrack;
    }

    export class MovieSceneNiagaraFloatParameterTrack extends MovieSceneNiagaraParameterTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraFloatParameterTrack;

        static Load(InName: string): MovieSceneNiagaraFloatParameterTrack;
    }

    export class MovieSceneNiagaraIntegerParameterTrack extends MovieSceneNiagaraParameterTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraIntegerParameterTrack;

        static Load(InName: string): MovieSceneNiagaraIntegerParameterTrack;
    }

    export enum ENiagaraSystemSpawnSectionStartBehavior { Activate, ENiagaraSystemSpawnSectionStartBehavior_MAX }

    export enum ENiagaraSystemSpawnSectionEvaluateBehavior {
        ActivateIfInactive,
        None,
        ENiagaraSystemSpawnSectionEvaluateBehavior_MAX
    }

    export enum ENiagaraSystemSpawnSectionEndBehavior {
        SetSystemInactive,
        Deactivate,
        None,
        ENiagaraSystemSpawnSectionEndBehavior_MAX
    }

    export class MovieSceneNiagaraSystemSpawnSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SectionStartBehavior: ENiagaraSystemSpawnSectionStartBehavior;
        SectionEvaluateBehavior: ENiagaraSystemSpawnSectionEvaluateBehavior;
        SectionEndBehavior: ENiagaraSystemSpawnSectionEndBehavior;
        AgeUpdateMode: ENiagaraAgeUpdateMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraSystemSpawnSection;

        static Load(InName: string): MovieSceneNiagaraSystemSpawnSection;
    }

    export class MovieSceneNiagaraSystemTrack extends MovieSceneNiagaraTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraSystemTrack;

        static Load(InName: string): MovieSceneNiagaraSystemTrack;
    }

    export class MovieSceneNiagaraVectorParameterTrack extends MovieSceneNiagaraParameterTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChannelsUsed: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneNiagaraVectorParameterTrack;

        static Load(InName: string): MovieSceneNiagaraVectorParameterTrack;
    }

    export class MovieSceneObjectPathChannelKeyValue {
        constructor();
        constructor(SoftPtr: TSoftObjectPtr<Object>, HardPtr: Object);

        SoftPtr: TSoftObjectPtr<Object>;
        HardPtr: Object;

        static StaticClass(): Class;
    }

    export class MovieSceneObjectPathChannel extends MovieSceneChannel {
        constructor();
        constructor(PropertyClass: Class, Times: TArray<FrameNumber>, Values: TArray<MovieSceneObjectPathChannelKeyValue>, DefaultValue: MovieSceneObjectPathChannelKeyValue);

        PropertyClass: Class;
        Times: TArray<FrameNumber>;
        Values: TArray<MovieSceneObjectPathChannelKeyValue>;
        DefaultValue: MovieSceneObjectPathChannelKeyValue;

        static StaticClass(): Class;
    }

    export class MovieSceneObjectPropertySection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ObjectChannel: MovieSceneObjectPathChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneObjectPropertySection;

        static Load(InName: string): MovieSceneObjectPropertySection;
    }

    export class MovieSceneObjectPropertyTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PropertyClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneObjectPropertyTrack;

        static Load(InName: string): MovieSceneObjectPropertyTrack;
    }

    export class BoolParameterNameAndCurve {
        constructor();
        constructor(ParameterName: string, ParameterCurve: MovieSceneBoolChannel);

        ParameterName: string;
        ParameterCurve: MovieSceneBoolChannel;

        static StaticClass(): Class;
    }

    export class ScalarParameterNameAndCurve {
        constructor();
        constructor(ParameterName: string, ParameterCurve: MovieSceneFloatChannel);

        ParameterName: string;
        ParameterCurve: MovieSceneFloatChannel;

        static StaticClass(): Class;
    }

    export class Vector2DParameterNameAndCurves {
        constructor();
        constructor(ParameterName: string, XCurve: MovieSceneFloatChannel, YCurve: MovieSceneFloatChannel);

        ParameterName: string;
        XCurve: MovieSceneFloatChannel;
        YCurve: MovieSceneFloatChannel;

        static StaticClass(): Class;
    }

    export class VectorParameterNameAndCurves {
        constructor();
        constructor(ParameterName: string, XCurve: MovieSceneFloatChannel, YCurve: MovieSceneFloatChannel, ZCurve: MovieSceneFloatChannel);

        ParameterName: string;
        XCurve: MovieSceneFloatChannel;
        YCurve: MovieSceneFloatChannel;
        ZCurve: MovieSceneFloatChannel;

        static StaticClass(): Class;
    }

    export class ColorParameterNameAndCurves {
        constructor();
        constructor(ParameterName: string, RedCurve: MovieSceneFloatChannel, GreenCurve: MovieSceneFloatChannel, BlueCurve: MovieSceneFloatChannel, AlphaCurve: MovieSceneFloatChannel);

        ParameterName: string;
        RedCurve: MovieSceneFloatChannel;
        GreenCurve: MovieSceneFloatChannel;
        BlueCurve: MovieSceneFloatChannel;
        AlphaCurve: MovieSceneFloatChannel;

        static StaticClass(): Class;
    }

    export class TransformParameterNameAndCurves {
        constructor();
        constructor(ParameterName: string, Translation: FixSizeArray<MovieSceneFloatChannel>, Rotation: FixSizeArray<MovieSceneFloatChannel>, Scale: FixSizeArray<MovieSceneFloatChannel>);

        ParameterName: string;
        Translation: FixSizeArray<MovieSceneFloatChannel>;
        Rotation: FixSizeArray<MovieSceneFloatChannel>;
        Scale: FixSizeArray<MovieSceneFloatChannel>;

        static StaticClass(): Class;
    }

    export class MovieSceneParameterSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoolParameterNamesAndCurves: TArray<BoolParameterNameAndCurve>;
        ScalarParameterNamesAndCurves: TArray<ScalarParameterNameAndCurve>;
        Vector2DParameterNamesAndCurves: TArray<Vector2DParameterNameAndCurves>;
        VectorParameterNamesAndCurves: TArray<VectorParameterNameAndCurves>;
        ColorParameterNamesAndCurves: TArray<ColorParameterNameAndCurves>;
        TransformParameterNamesAndCurves: TArray<TransformParameterNameAndCurves>;

        AddBoolParameterKey(InParameterName: string, InTime: FrameNumber, InValue: boolean): void;

        AddColorParameterKey(InParameterName: string, InTime: FrameNumber, InValue: LinearColor): void;

        AddScalarParameterKey(InParameterName: string, InTime: FrameNumber, InValue: number): void;

        AddTransformParameterKey(InParameterName: string, InTime: FrameNumber, InValue: Transform): void;

        AddVector2DParameterKey(InParameterName: string, InTime: FrameNumber, InValue: Vector2D): void;

        AddVectorParameterKey(InParameterName: string, InTime: FrameNumber, InValue: Vector): void;

        GetParameterNames(ParameterNames: $Ref<TSet<string>>): void;

        RemoveBoolParameter(InParameterName: string): boolean;

        RemoveColorParameter(InParameterName: string): boolean;

        RemoveScalarParameter(InParameterName: string): boolean;

        RemoveTransformParameter(InParameterName: string): boolean;

        RemoveVector2DParameter(InParameterName: string): boolean;

        RemoveVectorParameter(InParameterName: string): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneParameterSection;

        static Load(InName: string): MovieSceneParameterSection;
    }

    export class MovieSceneParticleParameterTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleParameterTrack;

        static Load(InName: string): MovieSceneParticleParameterTrack;
    }

    export class MovieSceneParticleChannel extends MovieSceneByteChannel {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneParticleSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParticleKeys: MovieSceneParticleChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleSection;

        static Load(InName: string): MovieSceneParticleSection;
    }

    export class MovieSceneParticleTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParticleSections: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleTrack;

        static Load(InName: string): MovieSceneParticleTrack;
    }

    export class MovieScenePiecewiseFloatBlenderSystem extends MovieSceneBlenderSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePiecewiseFloatBlenderSystem;

        static Load(InName: string): MovieScenePiecewiseFloatBlenderSystem;
    }

    export class MovieScenePostEvalEventSystem extends MovieSceneEventSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePostEvalEventSystem;

        static Load(InName: string): MovieScenePostEvalEventSystem;
    }

    export class MovieScenePostSpawnEventSystem extends MovieSceneEventSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePostSpawnEventSystem;

        static Load(InName: string): MovieScenePostSpawnEventSystem;
    }

    export class MovieScenePreAnimatedComponentTransformSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePreAnimatedComponentTransformSystem;

        static Load(InName: string): MovieScenePreAnimatedComponentTransformSystem;
    }

    export class MovieScenePreAnimatedStateSystemInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePreAnimatedStateSystemInterface;

        static Load(InName: string): MovieScenePreAnimatedStateSystemInterface;
    }

    export class MovieScenePreSpawnEventSystem extends MovieSceneEventSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePreSpawnEventSystem;

        static Load(InName: string): MovieScenePreSpawnEventSystem;
    }

    export class MovieScenePrimitiveMaterialSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialChannel: MovieSceneObjectPathChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePrimitiveMaterialSection;

        static Load(InName: string): MovieScenePrimitiveMaterialSection;
    }

    export class MovieScenePrimitiveMaterialTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieScenePrimitiveMaterialTrack;

        static Load(InName: string): MovieScenePrimitiveMaterialTrack;
    }

    export class MovieSceneQuaternionInterpolationRotationSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneQuaternionInterpolationRotationSystem;

        static Load(InName: string): MovieSceneQuaternionInterpolationRotationSystem;
    }

    export class MovieSceneRestorePreAnimatedStateSystem extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneRestorePreAnimatedStateSystem;

        static Load(InName: string): MovieSceneRestorePreAnimatedStateSystem;
    }

    export class MovieSceneSceneComponentImpersonator extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSceneComponentImpersonator;

        static Load(InName: string): MovieSceneSceneComponentImpersonator;
    }

    export class MovieSceneSkeletalAnimationParams {
        constructor();
        constructor(Animation: AnimSequenceBase, FirstLoopStartFrameOffset: FrameNumber, StartFrameOffset: FrameNumber, EndFrameOffset: FrameNumber, PlayRate: number, bReverse: boolean, SlotName: string, Weight: MovieSceneFloatChannel, bSkipAnimNotifiers: boolean, bForceCustomMode: boolean, StartOffset: number, EndOffset: number);

        Animation: AnimSequenceBase;
        FirstLoopStartFrameOffset: FrameNumber;
        StartFrameOffset: FrameNumber;
        EndFrameOffset: FrameNumber;
        PlayRate: number;
        bReverse: boolean;
        SlotName: string;
        Weight: MovieSceneFloatChannel;
        bSkipAnimNotifiers: boolean;
        bForceCustomMode: boolean;
        StartOffset: number;
        EndOffset: number;

        static StaticClass(): Class;
    }

    export class MovieSceneSkeletalAnimationSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Params: MovieSceneSkeletalAnimationParams;
        AnimSequence: AnimSequence;
        Animation: AnimSequenceBase;
        StartOffset: number;
        EndOffset: number;
        PlayRate: number;
        bReverse: boolean;
        SlotName: string;
        StartLocationOffset: Vector;
        StartRotationOffset: Rotator;
        bMatchWithPrevious: boolean;
        MatchedBoneName: string;
        MatchedLocationOffset: Vector;
        MatchedRotationOffset: Rotator;
        bMatchTranslation: boolean;
        bMatchIncludeZHeight: boolean;
        bMatchRotationYaw: boolean;
        bMatchRotationPitch: boolean;
        bMatchRotationRoll: boolean;
        bShowSkeleton: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSkeletalAnimationSection;

        static Load(InName: string): MovieSceneSkeletalAnimationSection;
    }

    export class MovieSceneSkeletalAnimRootMotionTrackParams {
        constructor();

        static StaticClass(): Class;
    }

    export class MovieSceneSkeletalAnimationTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimationSections: TArray<MovieSceneSection>;
        bUseLegacySectionIndexBlend: boolean;
        RootMotionParams: MovieSceneSkeletalAnimRootMotionTrackParams;
        bBlendFirstChildOfRoot: boolean;
        bShowRootMotionTrail: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSkeletalAnimationTrack;

        static Load(InName: string): MovieSceneSkeletalAnimationTrack;
    }

    export class MovieSceneSlomoSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatCurve: MovieSceneFloatChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSlomoSection;

        static Load(InName: string): MovieSceneSlomoSection;
    }

    export class MovieSceneSlomoTrack extends MovieSceneFloatTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSlomoTrack;

        static Load(InName: string): MovieSceneSlomoTrack;
    }

    export class MovieSceneSpawnablesSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSpawnablesSystem;

        static Load(InName: string): MovieSceneSpawnablesSystem;
    }

    export class MovieSceneSpawnSection extends MovieSceneBoolSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSpawnSection;

        static Load(InName: string): MovieSceneSpawnSection;
    }

    export class MovieSceneSpawnTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Sections: TArray<MovieSceneSection>;
        ObjectGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneSpawnTrack;

        static Load(InName: string): MovieSceneSpawnTrack;
    }

    export class MovieSceneStringChannel extends MovieSceneChannel {
        constructor();
        constructor(Times: TArray<FrameNumber>, Values: TArray<string>, DefaultValue: string, bHasDefaultValue: boolean);

        Times: TArray<FrameNumber>;
        Values: TArray<string>;
        DefaultValue: string;
        bHasDefaultValue: boolean;

        static StaticClass(): Class;
    }

    export class MovieSceneStringSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StringCurve: MovieSceneStringChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneStringSection;

        static Load(InName: string): MovieSceneStringSection;
    }

    export class MovieSceneStringTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneStringTrack;

        static Load(InName: string): MovieSceneStringTrack;
    }

    export class MovieSceneToolsPropertyTrackSettings {
        constructor();
        constructor(ComponentName: string, PropertyName: string);

        ComponentName: string;
        PropertyName: string;

        static StaticClass(): Class;
    }

    export class MovieSceneToolsFbxSettings {
        constructor();
        constructor(FbxPropertyName: string, PropertyPath: MovieSceneToolsPropertyTrackSettings);

        FbxPropertyName: string;
        PropertyPath: MovieSceneToolsPropertyTrackSettings;

        static StaticClass(): Class;
    }

    export class MovieSceneToolsProjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultStartTime: number;
        DefaultDuration: number;
        ShotDirectory: string;
        ShotPrefix: string;
        FirstShotNumber: number;
        ShotIncrement: number;
        ShotNumDigits: number;
        TakeNumDigits: number;
        FirstTakeNumber: number;
        TakeSeparator: string;
        SubSequenceSeparator: string;
        FbxSettings: TArray<MovieSceneToolsFbxSettings>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneToolsProjectSettings;

        static Load(InName: string): MovieSceneToolsProjectSettings;
    }

    export class MovieSceneTrackInstanceInstantiator extends MovieSceneEntityInstantiatorSystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneTrackInstanceInstantiator;

        static Load(InName: string): MovieSceneTrackInstanceInstantiator;
    }

    export class MovieSceneTrackInstanceSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Instantiator: MovieSceneTrackInstanceInstantiator;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneTrackInstanceSystem;

        static Load(InName: string): MovieSceneTrackInstanceSystem;
    }

    export class MovieSceneTrackTemplateProducer extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneTrackTemplateProducer;

        static Load(InName: string): MovieSceneTrackTemplateProducer;
    }

    export class MovieSceneTransformOrigin extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BP_GetTransformOrigin(): Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneTransformOrigin;

        static Load(InName: string): MovieSceneTransformOrigin;
    }

    export class MovieSceneTransformOriginSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneTransformOriginSystem;

        static Load(InName: string): MovieSceneTransformOriginSystem;
    }

    export class MovieSceneTransformTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneTransformTrack;

        static Load(InName: string): MovieSceneTransformTrack;
    }

    export class ControlFindReplaceString {
        constructor();
        constructor(Find: string, Replace: string);

        Find: string;
        Replace: string;

        static StaticClass(): Class;
    }

    export enum FControlRigChannelEnum {
        Bool,
        Enum,
        Integer,
        Float,
        Vector2DX,
        Vector2DY,
        PositionX,
        PositionY,
        PositionZ,
        RotatorX,
        RotatorY,
        RotatorZ,
        ScaleX,
        ScaleY,
        ScaleZ,
        FControlRigChannelEnum_MAX
    }

    export enum FTransformChannelEnum {
        TranslateX,
        TranslateY,
        TranslateZ,
        RotateX,
        RotateY,
        RotateZ,
        ScaleX,
        ScaleY,
        ScaleZ,
        FTransformChannelEnum_MAX
    }

    export class ControlToTransformMappings {
        constructor();
        constructor(ControlChannel: FControlRigChannelEnum, FBXChannel: FTransformChannelEnum, bNegate: boolean);

        ControlChannel: FControlRigChannelEnum;
        FBXChannel: FTransformChannelEnum;
        bNegate: boolean;

        static StaticClass(): Class;
    }

    export class MovieSceneUserImportFBXControlRigSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImportedFileName: string;
        ImportedStartTime: FrameNumber;
        ImportedEndTime: FrameNumber;
        ImportedNodeNames: TArray<string>;
        ImportedFrameRate: string;
        FindAndReplaceStrings: TArray<ControlFindReplaceString>;
        bForceFrontXAxis: boolean;
        bImportOntoSelectedControls: boolean;
        TimeToInsertOrReplaceAnimation: FrameNumber;
        bInsertAnimation: boolean;
        bSpecifyTimeRange: boolean;
        StartTimeRange: FrameNumber;
        EndTimeRange: FrameNumber;
        ControlChannelMappings: TArray<ControlToTransformMappings>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneUserImportFBXControlRigSettings;

        static Load(InName: string): MovieSceneUserImportFBXControlRigSettings;
    }

    export class MovieSceneUserImportFBXSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bMatchByNameOnly: boolean;
        bForceFrontXAxis: boolean;
        bCreateCameras: boolean;
        bReduceKeys: boolean;
        ReduceKeysTolerance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneUserImportFBXSettings;

        static Load(InName: string): MovieSceneUserImportFBXSettings;
    }

    export enum EThumbnailQuality { Draft, Normal, Best, EThumbnailQuality_MAX }

    export class MovieSceneUserThumbnailSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDrawThumbnails: boolean;
        bDrawSingleThumbnails: boolean;
        ThumbnailSize: IntPoint;
        Quality: EThumbnailQuality;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneUserThumbnailSettings;

        static Load(InName: string): MovieSceneUserThumbnailSettings;
    }

    export class MovieSceneVectorSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Curves: FixSizeArray<MovieSceneFloatChannel>;
        ChannelsUsed: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneVectorSection;

        static Load(InName: string): MovieSceneVectorSection;
    }

    export class MovieSceneVectorTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumChannelsUsed: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneVectorTrack;

        static Load(InName: string): MovieSceneVectorTrack;
    }

    export class MovieSceneVisibilityTrack extends MovieSceneBoolTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneVisibilityTrack;

        static Load(InName: string): MovieSceneVisibilityTrack;
    }

    export class MovieSceneWidgetMaterialTrack extends MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BrushPropertyNamePath: TArray<string>;
        TrackName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MovieSceneWidgetMaterialTrack;

        static Load(InName: string): MovieSceneWidgetMaterialTrack;
    }

    export class MulticastDelegateProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MulticastDelegateProperty;

        static Load(InName: string): MulticastDelegateProperty;
    }

    export class PropertyWrapper extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyWrapper;

        static Load(InName: string): PropertyWrapper;
    }

    export class MulticastDelegatePropertyWrapper extends PropertyWrapper {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MulticastDelegatePropertyWrapper;

        static Load(InName: string): MulticastDelegatePropertyWrapper;
    }

    export class MulticastInlineDelegateProperty extends MulticastDelegateProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MulticastInlineDelegateProperty;

        static Load(InName: string): MulticastInlineDelegateProperty;
    }

    export class MulticastInlineDelegatePropertyWrapper extends MulticastDelegatePropertyWrapper {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MulticastInlineDelegatePropertyWrapper;

        static Load(InName: string): MulticastInlineDelegatePropertyWrapper;
    }

    export class MulticastSparseDelegateProperty extends MulticastDelegateProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MulticastSparseDelegateProperty;

        static Load(InName: string): MulticastSparseDelegateProperty;
    }

    export class MultiClickSequenceInputBehavior extends AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MultiClickSequenceInputBehavior;

        static Load(InName: string): MultiClickSequenceInputBehavior;
    }

    export class MultiLineEditableText extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Text: string;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: TextBlockStyle;
        bIsReadOnly: boolean;
        Font: SlateFontInfo;
        SelectAllTextWhenFocused: boolean;
        ClearTextSelectionOnFocusLoss: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        AllowContextMenu: boolean;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;

        GetHintText(): string;

        GetText(): string;

        OnMultiLineEditableTextChangedEvent__DelegateSignature(Text: string): void;

        OnMultiLineEditableTextCommittedEvent__DelegateSignature(Text: string, CommitMethod: ETextCommit): void;

        SetHintText(InHintText: string): void;

        SetIsReadOnly(bReadOnly: boolean): void;

        SetText(InText: string): void;

        SetWidgetStyle(InWidgetStyle: TextBlockStyle): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MultiLineEditableText;

        static Load(InName: string): MultiLineEditableText;
    }

    export class MultiLineEditableTextBox extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Text: string;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: EditableTextBoxStyle;
        TextStyle: TextBlockStyle;
        bIsReadOnly: boolean;
        AllowContextMenu: boolean;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        Style: SlateWidgetStyleAsset;
        Font: SlateFontInfo;
        ForegroundColor: LinearColor;
        BackgroundColor: LinearColor;
        ReadOnlyForegroundColor: LinearColor;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;

        GetHintText(): string;

        GetText(): string;

        OnMultiLineEditableTextBoxChangedEvent__DelegateSignature(Text: string): void;

        OnMultiLineEditableTextBoxCommittedEvent__DelegateSignature(Text: string, CommitMethod: ETextCommit): void;

        SetError(InError: string): void;

        SetHintText(InHintText: string): void;

        SetIsReadOnly(bReadOnly: boolean): void;

        SetText(InText: string): void;

        SetTextStyle(InTextStyle: TextBlockStyle): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MultiLineEditableTextBox;

        static Load(InName: string): MultiLineEditableTextBox;
    }

    export class MultiSelectionTool extends InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MultiSelectionTool;

        static Load(InName: string): MultiSelectionTool;
    }

    export class WheelSetup {
        constructor();
        constructor(WheelClass: Class, BoneName: string, AdditionalOffset: Vector, bDisableSteering: boolean);

        WheelClass: Class;
        BoneName: string;
        AdditionalOffset: Vector;
        bDisableSteering: boolean;

        static StaticClass(): Class;
    }

    export class TireType extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FrictionScale: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TireType;

        static Load(InName: string): TireType;
    }

    export class TireConfigMaterialFriction {
        constructor();
        constructor(PhysicalMaterial: PhysicalMaterial, FrictionScale: number);

        PhysicalMaterial: PhysicalMaterial;
        FrictionScale: number;

        static StaticClass(): Class;
    }

    export class TireConfig extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FrictionScale: number;
        TireFrictionScales: TArray<TireConfigMaterialFriction>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TireConfig;

        static Load(InName: string): TireConfig;
    }

    export enum EWheelSweepType { SimpleAndComplex, Simple, Complex, EWheelSweepType_MAX }

    export class VehicleWheel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CollisionMesh: StaticMesh;
        bDontCreateShape: boolean;
        bAutoAdjustCollisionSize: boolean;
        Offset: Vector;
        ShapeRadius: number;
        ShapeWidth: number;
        Mass: number;
        DampingRate: number;
        SteerAngle: number;
        bAffectedByHandbrake: boolean;
        TireType: TireType;
        TireConfig: TireConfig;
        LatStiffMaxLoad: number;
        LatStiffValue: number;
        LongStiffValue: number;
        SuspensionForceOffset: number;
        SuspensionMaxRaise: number;
        SuspensionMaxDrop: number;
        SuspensionNaturalFrequency: number;
        SuspensionDampingRatio: number;
        SweepType: EWheelSweepType;
        MaxBrakeTorque: number;
        MaxHandBrakeTorque: number;
        VehicleSim: WheeledVehicleMovementComponent;
        WheelIndex: number;
        DebugLongSlip: number;
        DebugLatSlip: number;
        DebugNormalizedTireLoad: number;
        DebugWheelTorque: number;
        DebugLongForce: number;
        DebugLatForce: number;
        Location: Vector;
        OldLocation: Vector;
        Velocity: Vector;

        GetRotationAngle(): number;

        GetSteerAngle(): number;

        GetSuspensionOffset(): number;

        IsInAir(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VehicleWheel;

        static Load(InName: string): VehicleWheel;
    }

    export class ReplicatedVehicleState {
        constructor();
        constructor(SteeringInput: number, ThrottleInput: number, BrakeInput: number, HandbrakeInput: number, CurrentGear: number);

        SteeringInput: number;
        ThrottleInput: number;
        BrakeInput: number;
        HandbrakeInput: number;
        CurrentGear: number;

        static StaticClass(): Class;
    }

    export class VehicleInputRate {
        constructor();
        constructor(RiseRate: number, FallRate: number);

        RiseRate: number;
        FallRate: number;

        static StaticClass(): Class;
    }

    export class WheeledVehicleMovementComponent extends PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDeprecatedSpringOffsetMode: boolean;
        bReverseAsBrake: boolean;
        bUseRVOAvoidance: boolean;
        bRawHandbrakeInput: boolean;
        bRawGearUpInput: boolean;
        bRawGearDownInput: boolean;
        bWasAvoidanceUpdated: boolean;
        Mass: number;
        WheelSetups: TArray<WheelSetup>;
        DragCoefficient: number;
        ChassisWidth: number;
        ChassisHeight: number;
        DragArea: number;
        EstimatedMaxEngineSpeed: number;
        MaxEngineRPM: number;
        DebugDragMagnitude: number;
        InertiaTensorScale: Vector;
        MinNormalizedTireLoad: number;
        MinNormalizedTireLoadFiltered: number;
        MaxNormalizedTireLoad: number;
        MaxNormalizedTireLoadFiltered: number;
        ThresholdLongitudinalSpeed: number;
        LowForwardSpeedSubStepCount: number;
        HighForwardSpeedSubStepCount: number;
        Wheels: TArray<VehicleWheel>;
        RVOAvoidanceRadius: number;
        RVOAvoidanceHeight: number;
        AvoidanceConsiderationRadius: number;
        RVOSteeringStep: number;
        RVOThrottleStep: number;
        AvoidanceUID: number;
        AvoidanceGroup: NavAvoidanceMask;
        GroupsToAvoid: NavAvoidanceMask;
        GroupsToIgnore: NavAvoidanceMask;
        AvoidanceWeight: number;
        PendingLaunchVelocity: Vector;
        ReplicatedState: ReplicatedVehicleState;
        RawSteeringInput: number;
        RawThrottleInput: number;
        RawBrakeInput: number;
        SteeringInput: number;
        ThrottleInput: number;
        BrakeInput: number;
        HandbrakeInput: number;
        IdleBrakeInput: number;
        StopThreshold: number;
        WrongDirectionThreshold: number;
        ThrottleInputRate: VehicleInputRate;
        BrakeInputRate: VehicleInputRate;
        HandbrakeInputRate: VehicleInputRate;
        SteeringInputRate: VehicleInputRate;
        OverrideController: Controller;

        GetCurrentGear(): number;

        GetEngineMaxRotationSpeed(): number;

        GetEngineRotationSpeed(): number;

        GetForwardSpeed(): number;

        GetTargetGear(): number;

        GetUseAutoGears(): boolean;

        ServerUpdateState(InSteeringInput: number, InThrottleInput: number, InBrakeInput: number, InHandbrakeInput: number, CurrentGear: number): void;

        SetAvoidanceEnabled(bEnable: boolean): void;

        SetAvoidanceGroup(GroupFlags: number): void;

        SetAvoidanceGroupMask(GroupMask: NavAvoidanceMask): void;

        SetBrakeInput(Brake: number): void;

        SetGearDown(bNewGearDown: boolean): void;

        SetGearUp(bNewGearUp: boolean): void;

        SetGroupsToAvoid(GroupFlags: number): void;

        SetGroupsToAvoidMask(GroupMask: NavAvoidanceMask): void;

        SetGroupsToIgnore(GroupFlags: number): void;

        SetGroupsToIgnoreMask(GroupMask: NavAvoidanceMask): void;

        SetHandbrakeInput(bNewHandbrake: boolean): void;

        SetSteeringInput(Steering: number): void;

        SetTargetGear(GearNum: number, bImmediate: boolean): void;

        SetThrottleInput(Throttle: number): void;

        SetUseAutoGears(bUseAuto: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WheeledVehicleMovementComponent;

        static Load(InName: string): WheeledVehicleMovementComponent;
    }

    export class VehicleEngineData {
        constructor();
        constructor(TorqueCurve: RuntimeFloatCurve, MaxRPM: number, MOI: number, DampingRateFullThrottle: number, DampingRateZeroThrottleClutchEngaged: number, DampingRateZeroThrottleClutchDisengaged: number);

        TorqueCurve: RuntimeFloatCurve;
        MaxRPM: number;
        MOI: number;
        DampingRateFullThrottle: number;
        DampingRateZeroThrottleClutchEngaged: number;
        DampingRateZeroThrottleClutchDisengaged: number;

        static StaticClass(): Class;
    }

    export enum EVehicleDifferential4W {
        LimitedSlip_4W,
        LimitedSlip_FrontDrive,
        LimitedSlip_RearDrive,
        Open_4W,
        Open_FrontDrive,
        Open_RearDrive,
        EVehicleDifferential4W_MAX
    }

    export class VehicleDifferential4WData {
        constructor();
        constructor(DifferentialType: EVehicleDifferential4W, FrontRearSplit: number, FrontLeftRightSplit: number, RearLeftRightSplit: number, CentreBias: number, FrontBias: number, RearBias: number);

        DifferentialType: EVehicleDifferential4W;
        FrontRearSplit: number;
        FrontLeftRightSplit: number;
        RearLeftRightSplit: number;
        CentreBias: number;
        FrontBias: number;
        RearBias: number;

        static StaticClass(): Class;
    }

    export class VehicleGearData {
        constructor();
        constructor(Ratio: number, DownRatio: number, UpRatio: number);

        Ratio: number;
        DownRatio: number;
        UpRatio: number;

        static StaticClass(): Class;
    }

    export class VehicleTransmissionData {
        constructor();
        constructor(bUseGearAutoBox: boolean, GearSwitchTime: number, GearAutoBoxLatency: number, FinalRatio: number, ForwardGears: TArray<VehicleGearData>, ReverseGearRatio: number, NeutralGearUpRatio: number, ClutchStrength: number);

        bUseGearAutoBox: boolean;
        GearSwitchTime: number;
        GearAutoBoxLatency: number;
        FinalRatio: number;
        ForwardGears: TArray<VehicleGearData>;
        ReverseGearRatio: number;
        NeutralGearUpRatio: number;
        ClutchStrength: number;

        static StaticClass(): Class;
    }

    export class WheeledVehicleMovementComponent4W extends WheeledVehicleMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EngineSetup: VehicleEngineData;
        DifferentialSetup: VehicleDifferential4WData;
        AckermannAccuracy: number;
        TransmissionSetup: VehicleTransmissionData;
        SteeringCurve: RuntimeFloatCurve;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WheeledVehicleMovementComponent4W;

        static Load(InName: string): WheeledVehicleMovementComponent4W;
    }

    export class MWSysVehicleMoveComp4W extends WheeledVehicleMovementComponent4W {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Mass_Rep: number;
        bShouldSleepImmediately: boolean;

        GetVehicleMass(): number;

        GetWheelsNumber(): number;

        GetWheelTransform(OutLocation: $Ref<Vector>, OutSteerAngel: $Ref<number>, OutRotationAngel: $Ref<number>, WheelIndex: number): void;

        OnServerBodySleep(SleepingComponent: $Nullable<PrimitiveComponent>, BoneName: string): void;

        OnServerBodyWake(SleepingComponent: $Nullable<PrimitiveComponent>, BoneName: string): void;

        SetClientSleep(): void;

        SetSuspConfigData(InMaxCompression: number, InMaxDroop: number, InSuspensionNaturalFrequency: number, InSuspensionDampingRatio: number): void;

        SetTireConfigData(InDampingRate: number, InLatStiffMaxLoad: number, InLatStiffValue: number, InLongStiffValue: number): void;

        SetVehicleMass(NewMass: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysVehicleMoveComp4W;

        static Load(InName: string): MWSysVehicleMoveComp4W;
    }

    export enum MWExtrapolationMode { UNLIMITED, LIMITED, NONE, MWExtrapolationMode_MAX }

    export enum MWSyncMode { XYZ, XY, XZ, YZ, X, Y, Z, NONE, MWSyncMode_MAX }

    export class MWSmoothSyncComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        interpolationBackTime: number;
        extrapolationMode: MWExtrapolationMode;
        useExtrapolationTimeLimit: boolean;
        extrapolationTimeLimit: number;
        useExtrapolationDistanceLimit: boolean;
        extrapolationDistanceLimit: number;
        sendPositionThreshold: number;
        sendRotationThreshold: number;
        sendScaleThreshold: number;
        sendVelocityThreshold: number;
        sendAngularVelocityThreshold: number;
        receivedPositionThreshold: number;
        receivedRotationThreshold: number;
        positionSnapThreshold: number;
        rotationSnapThreshold: number;
        scaleSnapThreshold: number;
        timeSmoothing: number;
        positionLerpSpeed: number;
        rotationLerpSpeed: number;
        scaleLerpSpeed: number;
        syncPosition: MWSyncMode;
        syncRotation: MWSyncMode;
        syncScale: MWSyncMode;
        syncVelocity: MWSyncMode;
        syncAngularVelocity: MWSyncMode;
        syncMovementMode: boolean;
        isPositionCompressed: boolean;
        isRotationCompressed: boolean;
        isScaleCompressed: boolean;
        isVelocityCompressed: boolean;
        isAngularVelocityCompressed: boolean;
        sendRate: number;
        isUsingOriginRebasing: boolean;
        alwaysSendOrigin: boolean;
        syncOwnershipChange: boolean;
        realComponentToSync: SceneComponent;
        interpolationTime: number;
        atRestPositionThreshold: number;
        atRestRotationThreshold: number;

        clearBuffer(): void;

        ClientSendsTransformToServer(value: TArray<number>): void;

        enableSmoothSync(enable: boolean): void;

        forceStateSendNextFrame(): void;

        ServerSendsTransformToEveryone(value: TArray<number>): void;

        setSceneComponentToSync(theComponent: $Nullable<SceneComponent>): void;

        SmoothSyncEnableClientToServer(enable: boolean): void;

        SmoothSyncEnableServerToClients(enable: boolean): void;

        SmoothSyncTeleportClientToServer(position: Vector, rotation: Vector, scale: Vector, tempOwnerTime: number): void;

        SmoothSyncTeleportServerToClients(position: Vector, rotation: Vector, scale: Vector, tempOwnerTime: number): void;

        teleport(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSmoothSyncComponent;

        static Load(InName: string): MWSmoothSyncComponent;
    }

    export class MWAdvancedVehicleBase extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Mesh: SkeletalMeshComponent;
        VehicleMovement: MWSysVehicleMoveComp4W;
        BoxFrameComp: BoxComponent;
        IconSprite: BillboardComponent;
        MWSmoothSyncComponent: MWSmoothSyncComponent;
        bUseSmoothSync: boolean;

        MoveForward(Val: number): void;

        MoveRight(Val: number): void;

        OnHandbrakePressed(): void;

        OnHandbrakeReleased(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWAdvancedVehicleBase;

        static Load(InName: string): MWAdvancedVehicleBase;
    }

    export class MWAndroidBusiness extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWAndroidBusiness;

        static Load(InName: string): MWAndroidBusiness;
    }

    export enum EMWMontagePlayMode { Default, PlayOnStance, EMWMontagePlayMode_MAX }

    export class MWAnimation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Montage: AnimMontage;
        PlayMode: EMWMontagePlayMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWAnimation;

        static Load(InName: string): MWAnimation;
    }

    export class MWAssetNameStandardInfo {
        constructor();
        constructor(NameStandards: TArray<string>);

        NameStandards: TArray<string>;

        static StaticClass(): Class;
    }

    export class MWAssetNameStandard extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssetNameStandard: TMap<string, MWAssetNameStandardInfo>;
        NonsupportAsset: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWAssetNameStandard;

        static Load(InName: string): MWAssetNameStandard;
    }

    export class MWSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSettings;

        static Load(InName: string): MWSettings;
    }

    export class MWAssetSettings extends MWSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GlobalEnableStreaming: boolean;
        UseAssetChecked: boolean;

        OnGlobalEnableStreamingChanged(InValue: boolean): void;

        OnUseAssetCheckedChanged(InValue: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWAssetSettings;

        static Load(InName: string): MWAssetSettings;
    }

    export class MWAudioComponent extends AudioComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetGuid(): string;

        SetSoundWaveAsset(InAssetGuid: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWAudioComponent;

        static Load(InName: string): MWAudioComponent;
    }

    export class MWInstance extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetGuid(): string;

        GetLocalID(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWInstance;

        static Load(InName: string): MWInstance;
    }

    export class MWBehavior extends MWInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnDestroy(): void;

        OnDraw(): void;

        OnPlay(): void;

        OnSelect(IsSelected: boolean): void;

        OnSelected(): void;

        OnStart(): void;

        OnStop(): void;

        OnUpdate(DeltaTime: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWBehavior;

        static Load(InName: string): MWBehavior;
    }

    export enum ETextVerticalJustify { Top, Center, Bottom, ETextVerticalJustify_MAX }

    export enum EMWUITextHorizontalLayout { AutoWarpText, Clipping, NoClipping, EMWUITextHorizontalLayout_MAX }

    export enum EMWTextJustify { Left, Center, Right, EMWTextJustify_MAX }

    export enum EMWUIFontGlyph { Normal, Bold, Light, Italics, BoldItalics, EMWUIFontGlyph_MAX }

    export class MWUIFontInfo {
        constructor();
        constructor(Glyph: EMWUIFontGlyph, bStrikeline: boolean, bUnderline: boolean, ContentColor: LinearColor, ShadowColor: LinearColor, ShadowOffset: Vector2D, TextAlign: EMWTextJustify, TextVerticalAlign: ETextVerticalJustify, FontFamily: string, FontSize: number, LetterSpacing: number, OutlineColor: LinearColor, OutlineSize: number);

        Glyph: EMWUIFontGlyph;
        bStrikeline: boolean;
        bUnderline: boolean;
        ContentColor: LinearColor;
        ShadowColor: LinearColor;
        ShadowOffset: Vector2D;
        TextAlign: EMWTextJustify;
        TextVerticalAlign: ETextVerticalJustify;
        FontFamily: string;
        FontSize: number;
        LetterSpacing: number;
        OutlineColor: LinearColor;
        OutlineSize: number;

        static StaticClass(): Class;
    }

    export class MWButton extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnClicked: $MulticastDelegate<() => void>;
        OnPressed: $MulticastDelegate<() => void>;
        OnReleased: $MulticastDelegate<() => void>;
        OnHovered: $MulticastDelegate<() => void>;
        OnUnhovered: $MulticastDelegate<() => void>;
        NormalUIAsset: MWAssetRecorder;
        PressedUIAsset: MWAssetRecorder;
        DisableUIAsset: MWAssetRecorder;

        GetBrushDrawAs(): ESlateBrushDrawType;

        GetBrushSize(): Vector2D;

        GetbStrikeline(): boolean;

        GetbUnderline(): boolean;

        GetButtonDisableBrush(): SlateBrushWithGuid;

        GetButtonDisableBrushGuid(): string;

        GetButtonFont(): MWUIFontInfo;

        GetButtonNormalBrush(): SlateBrushWithGuid;

        GetButtonNormalBrushGuid(): string;

        GetButtonNormalColor(): LinearColor;

        GetButtonPressedBrush(): SlateBrushWithGuid;

        GetButtonPressedBrushGuid(): string;

        GetButtonStringByText(): string;

        GetColorAndOpacity(): LinearColor;

        GetContentColor(): LinearColor;

        GetDisableBrushColor(): LinearColor;

        GetDisableBrushDrawAs(): ESlateBrushDrawType;

        GetDisableBrushMargin(): Margin;

        GetDisableBrushSize(): Vector2D;

        GetFocusable(): boolean;

        GetFontColor(): LinearColor;

        GetFontInfo(): MWUIFontInfo;

        GetFontLitterSpace(): number;

        GetFontSize(): number;

        GetGlyph(): EMWUIFontGlyph;

        GetHasTransition(): boolean;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        GetOutlineColor(): LinearColor;

        GetOutlineSize(): number;

        GetPressColorAndOpacity(): LinearColor;

        GetPressedBrushDrawAs(): ESlateBrushDrawType;

        GetPressedBrushMargin(): Margin;

        GetPressedBrushSize(): Vector2D;

        GetRenderBlankScale(): number;

        GetRenderOffset(): Vector2D;

        GetShadowColor(): LinearColor;

        GetShadowOffset(): Vector2D;

        GetTextAlign(): EMWTextJustify;

        GetTextVerticalAlign(): ETextVerticalJustify;

        IsPressed(): boolean;

        SetAutoWrapText(InAutoTextWrap: boolean): void;

        SetBrushDrawAs(InDrawAs: ESlateBrushDrawType): void;

        SetBrushSize(InBrushSize: Vector2D): void;

        SetbStrikeline(InbStrikeline: boolean): void;

        SetbUnderline(InbUnderline: boolean): void;

        SetButtonDisableBrush(InBrush: SlateBrushWithGuid): void;

        SetButtonDisableBrushByGuid(InGuid: string, bMatchSize?: boolean /* = true */): void;

        SetButtonDisabledColor(InColor: LinearColor): void;

        SetButtonFont(InFontInfo: MWUIFontInfo): void;

        SetButtonNormalBrush(InBrush: SlateBrushWithGuid): void;

        SetButtonNormalBrushByGuid(InGuid: string, bMatchSize?: boolean /* = true */): void;

        SetButtonNormalColor(InColor: LinearColor): void;

        SetButtonPressedBrush(InBrush: SlateBrushWithGuid): void;

        SetButtonPressedBrushByGuid(InGuid: string, bMatchSize?: boolean /* = true */): void;

        SetButtonPressedColor(InColor: LinearColor): void;

        SetButtonString(InString: string): void;

        SetClickMethod(InClickMethod: EButtonClickMethod): void;

        SetContentColor(InContentColor: LinearColor): void;

        SetDisableBrushColor(InColor: LinearColor): void;

        SetDisableBrushDrawAs(InDrawAs: ESlateBrushDrawType): void;

        SetDisableBrushMargin(InMargin: Margin): void;

        SetDisableBrushSize(InBrushSize: Vector2D): void;

        SetFocusable(InIsFocusable: boolean): void;

        SetFontColor(InColor: LinearColor): void;

        SetFontInfo(InFontInfo: MWUIFontInfo): void;

        SetFontLetterSpace(InLetterSpace: number): void;

        SetFontSize(InSize: number): void;

        SetGlyph(InGlyph: EMWUIFontGlyph): void;

        SetHasTransition(InHasTransition: boolean): void;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        SetOutlineColor(InOutlineColor: LinearColor): void;

        SetOutlineSize(InOutlineSize: number): void;

        SetPressColorAndOpacity(InColorAndOpacity: LinearColor): void;

        SetPressedBrushDrawAs(InDrawAs: ESlateBrushDrawType): void;

        SetPressedBrushMargin(InMargin: Margin): void;

        SetPressedBrushSize(InBrushSize: Vector2D): void;

        SetPressMethod(InPressMethod: EButtonPressMethod): void;

        SetRenderBlankScale(BlankScale: number): void;

        SetRenderOffSet(InRenderOffset: Vector2D): void;

        SetShadowColor(InShadowColor: LinearColor): void;

        SetShadowOffset(InShadowOffset: Vector2D): void;

        SetTextAlign(InTextAlign: EMWTextJustify): void;

        SetTextHorizontalLayout(InTextHorizontalLayout: EMWUITextHorizontalLayout): void;

        SetTextVerticalAlign(InTextVerticalJustify: ETextVerticalJustify): void;

        SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWButton;

        static Load(InName: string): MWButton;
    }

    export class MWSlateBrush extends SlateBrush {
        constructor();
        constructor(ResourcePath: string, ResourceId: string, bMatchSize: boolean);

        ResourcePath: string;
        ResourceId: string;
        bMatchSize: boolean;

        static StaticClass(): Class;
    }

    export class MWButtonStyle extends ButtonStyle {
        constructor();
        constructor(NormalExtend: MWSlateBrush, HoveredExtend: MWSlateBrush, PressedExtend: MWSlateBrush, DisabledExtend: MWSlateBrush);

        NormalExtend: MWSlateBrush;
        HoveredExtend: MWSlateBrush;
        PressedExtend: MWSlateBrush;
        DisabledExtend: MWSlateBrush;

        static StaticClass(): Class;
    }

    export class MWButtonExtend extends Button {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetStyleExtend: MWButtonStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWButtonExtend;

        static Load(InName: string): MWButtonExtend;
    }

    export class MWPanelWidget extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FindChildByPath(InName: string): Widget;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWPanelWidget;

        static Load(InName: string): MWPanelWidget;
    }

    export enum EMWUILayout { EMWUIHorizontal, EMWUIVertical, EMWUILayout_MAX }

    export enum EMWUILayoutPacket {
        EMWUILeftTop,
        EMWUILeftMiddle,
        EMWUILeftBottom,
        EMWUIRightTop,
        EMWUIRightMiddle,
        EMWUIRightBottom,
        EMWUIMiddleTop,
        EMWUIMiddleMiddle,
        EMWUIMiddleBottom,
        EMWUILayoutPacket_MAX
    }

    export enum EMWUIHugContentW { EMUIFixwidth, EMUIHugcontent, EMWUIHugContentW_MAX }

    export enum EMWUIHugContentH { EMUIFixheight, EMUIHugcontent, EMWUIHugContentH_MAX }

    export class MWUIHugContent {
        constructor();
        constructor(WhugContent: EMWUIHugContentW, HhugContent: EMWUIHugContentH);

        WhugContent: EMWUIHugContentW;
        HhugContent: EMWUIHugContentH;

        static StaticClass(): Class;
    }

    export class MWUILayout {
        constructor();
        constructor(LayoutSpace: number, Padding: Margin, Layout: EMWUILayout, LayoutPacket: EMWUILayoutPacket, bAutoLayout: boolean, HugContent: MWUIHugContent, bAutoWrap: boolean);

        LayoutSpace: number;
        Padding: Margin;
        Layout: EMWUILayout;
        LayoutPacket: EMWUILayoutPacket;
        bAutoLayout: boolean;
        HugContent: MWUIHugContent;
        bAutoWrap: boolean;

        static StaticClass(): Class;
    }

    export class MWCanvas extends MWPanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetAutoLayout(): boolean;

        GetAutoLayoutHugContent(): MWUIHugContent;

        GetAutoLayoutPacketRule(): EMWUILayoutPacket;

        GetAutoLayoutPadding(): Margin;

        GetAutoLayoutRule(): EMWUILayout;

        GetAutoLayoutSpacing(): number;

        GetMWClip(): boolean;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWUIAutoLayoutRule(): MWUILayout;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        SetAutoLayout(InAutoLayout: boolean): void;

        SetAutoLayoutHugContent(InRule: MWUIHugContent): void;

        SetAutoLayoutPacketRule(InRule: EMWUILayoutPacket): void;

        SetAutoLayoutPadding(InPadding: Margin): void;

        SetAutoLayoutRule(InRule: EMWUILayout): void;

        SetAutoLayoutSpacing(InSpaceInItem: number): void;

        SetMWClip(bClip: boolean): void;

        SetMWName(InName: string): void;

        SetMWUIAutoLayoutRule(Layout: MWUILayout): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWCanvas;

        static Load(InName: string): MWCanvas;
    }

    export class MWUITransform {
        constructor();
        constructor(Position: Vector2D, Size: Vector2D);

        Position: Vector2D;
        Size: Vector2D;

        static StaticClass(): Class;
    }

    export enum EMWUIConstraintH { MWHLeft, MWHRight, MWHLeftRight, MWHCenter, MWHScale, EMWUIConstraintH_MAX }

    export enum EMWUIConstraintV { MWVTop, MWVBottom, MWVTopBottom, MWVCenter, MWVScale, EMWUIConstraintV_MAX }

    export class MWUIConstraintAnchors {
        constructor();
        constructor(ConstraintHorizontal: EMWUIConstraintH, ConstraintVertical: EMWUIConstraintV);

        ConstraintHorizontal: EMWUIConstraintH;
        ConstraintVertical: EMWUIConstraintV;

        static StaticClass(): Class;
    }

    export class MWCanvasSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetAutolayoutChildPadding(): Margin;

        GetAutoSize(): boolean;

        GetConstraints(): MWUIConstraintAnchors;

        GetfigmaScaleParam(): number;

        GetMWTransform(): MWUITransform;

        GetMWUIAutoLayoutRule(): MWUILayout;

        GetPosition(): Vector2D;

        GetSize(): Vector2D;

        GetZOrder(): number;

        SetAutolayoutChildPadding(padding: Margin): void;

        SetAutoSize(bAutoSize: boolean): void;

        SetConstraints(Constraints: MWUIConstraintAnchors): void;

        SetfigmaScaleParam(InfigmaScaleParam: number): void;

        SetMWTransform(InTransform: MWUITransform): void;

        SetMWUIAutoLayoutRule(Layout: MWUILayout): void;

        SetPosition(InFigmaPosition: Vector2D): void;

        SetSize(InSize: Vector2D): void;

        SetZOrder(InZOrder: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWCanvasSlot;

        static Load(InName: string): MWCanvasSlot;
    }

    export class MWCharacterFollowUIManager extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FollowObjectMaps: TMap<MWSysCharacter, FollowCharacterObject>;
        LocalPlayer: PlayerController;

        AddCharacter(InCharacter: $Nullable<MWSysCharacter>, InNickname: $Ref<string>): void;

        GetChatFrameVisibleDistance(): number;

        GetChatOffset(): number;

        GetNameOffset(): number;

        GetNamePlateVisibleDistance(): number;

        RemoveCharacter(InCharacter: $Nullable<MWSysCharacter>): void;

        SetCharacterChatContent(InCharacter: $Nullable<MWSysCharacter>, InChatContent: $Ref<string>): void;

        SetCharacterNickname(InCharacter: $Nullable<MWSysCharacter>, InNickname: $Ref<string>): void;

        SetChatFrameVisibleDistance(InDistance: number): void;

        SetChatOffset(InDistance: number): void;

        SetNameOffset(InDistance: number): void;

        SetNamePlateVisibleDistance(InDistance: number): void;

        static ClearInStance(): void;

        static GetInstance(WorldContextObject: $Nullable<Object>): MWCharacterFollowUIManager;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWCharacterFollowUIManager;

        static Load(InName: string): MWCharacterFollowUIManager;
    }

    export class MWCharacterWorldWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextBlock: TextBlock;

        UpdateWidgetPosition(Position: Vector2D): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWCharacterWorldWidget;

        static Load(InName: string): MWCharacterWorldWidget;
    }

    export class MWClientEvents extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnAndroidResponse: $MulticastDelegate<(Message: string) => void>;
        OnMatchFailed: $MulticastDelegate<(Message: string) => void>;
        OnDownloadFailed: $MulticastDelegate<(Message: string) => void>;
        MWReconnectDSFailed: $MulticastDelegate<() => void>;
        OnNextTSGameDataReady: $MulticastDelegate<(GameId: string, GameVersion: string, GameType: number) => void>;

        DSReconnect(): void;

        static Instance(): MWClientEvents;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWClientEvents;

        static Load(InName: string): MWClientEvents;
    }

    export class MWClientRoomActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Login(Token: string, Account: string): void;

        Match(GameId: string, Type: number, Version: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWClientRoomActor;

        static Load(InName: string): MWClientRoomActor;
    }

    export class MWSysActorCreator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CharacterActorClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysActorCreator;

        static Load(InName: string): MWSysActorCreator;
    }

    export class MWClothesActorCreator extends MWSysActorCreator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWClothesActorCreator;

        static Load(InName: string): MWClothesActorCreator;
    }

    export class SkeletalMeshOneOfCloth {
        constructor();
        constructor(SkeletalMesh: SkeletalMesh, MeshMaterials: TArray<MaterialInterface>, ParentSocket: string, bUseMasterPose: boolean, DynamicAssetPath: string);

        SkeletalMesh: SkeletalMesh;
        MeshMaterials: TArray<MaterialInterface>;
        ParentSocket: string;
        bUseMasterPose: boolean;
        DynamicAssetPath: string;

        static StaticClass(): Class;
    }

    export class MWClothingObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SkCloths: TArray<SkeletalMeshOneOfCloth>;
        ClothVersion: string;
        PartOfCloth: string;
        BodyType: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWClothingObject;

        static Load(InName: string): MWClothingObject;
    }

    export enum EClothVersion { V2, EClothVersion_MAX }

    export enum EPartOfCloth {
        Head_V2,
        UpperCloth_V2,
        LowerCloth_V2,
        Gloves_V2,
        Shoe_V2,
        FrontHair_V2,
        BehindHair_V2,
        EPartOfCloth_MAX
    }

    export class MWClothMesh extends ClothMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ClothVersion: EClothVersion;
        PartOfCloth: EPartOfCloth;
        ThumbnailPath: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWClothMesh;

        static Load(InName: string): MWClothMesh;
    }

    export class MWColorPick extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnMouseButtonDownEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        UIAsset: MWAssetRecorder;

        ColorPickerChanged(CallBack: $Delegate<(InColor: LinearColor) => void>): void;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        OnColorChanged(InColor: LinearColor): void;

        SetColorData(InColor: LinearColor): void;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWColorPick;

        static Load(InName: string): MWColorPick;
    }

    export class MWCommonTypeScriptMethods extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateWidget(World: $Nullable<World>, Class: $Nullable<Class>): UserWidget;

        static GetAllScriptActor(World: $Nullable<World>): TArray<Actor>;

        static GetAllScriptFile(ModuleName: string): TArray<string>;

        static StaticLoadClass(BaseClass: $Nullable<Class>, Name: string): Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWCommonTypeScriptMethods;

        static Load(InName: string): MWCommonTypeScriptMethods;
    }

    export class MWDBSetting extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MGSPathGet: string;
        MGSPathSet: string;
        MGSPathDel: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWDBSetting;

        static Load(InName: string): MWDBSetting;
    }

    export class MWEdBaseGizmo extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootScene: SceneComponent;
        ScalingScene: SceneComponent;
        X_AxisBox: BoxComponent;
        Y_AxisBox: BoxComponent;
        Z_AxisBox: BoxComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdBaseGizmo;

        static Load(InName: string): MWEdBaseGizmo;
    }

    export class MWEdBoxComponent extends BoxComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdBoxComponent;

        static Load(InName: string): MWEdBoxComponent;
    }

    export class MWEditorEngine extends GameEngine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAllowMultiplePIEWorlds: boolean;
        bIsSimulatingInEditor: boolean;
        MWPlayWorld: World;
        bRequestEndPlayMapQueued: boolean;
        UserEditedPlayWorldURL: string;
        InEditorGameURLOptions: string;
        PlayFromHerePlayerStartClass: Class;
        CurrentPlayWorldDestination: number;
        DetailMode: EDetailMode;
        MWEditorWorld: World;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEditorEngine;

        static Load(InName: string): MWEditorEngine;
    }

    export class MWEdEditorEngine extends MWEditorEngine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActorsThatWereSelected: TArray<TWeakObjectPtr<Actor>>;
        UnsnappedClickLocation: Vector;
        ClickLocation: Vector;
        ClickPlane: Plane;
        MouseMovement: Vector;
        PreviewSoundCue: SoundCue;
        PreviewAudioComponent: AudioComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdEditorEngine;

        static Load(InName: string): MWEdEditorEngine;
    }

    export class MWEdEngineResource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        T_Font: Font;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdEngineResource;

        static Load(InName: string): MWEdEngineResource;
    }

    export class MWGameInstance extends GameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWGameInstance;

        static Load(InName: string): MWGameInstance;
    }

    export class MWEdGameInstance extends MWGameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnLoadStart(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdGameInstance;

        static Load(InName: string): MWEdGameInstance;
    }

    export class MWEdGameMode extends GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdGameMode;

        static Load(InName: string): MWEdGameMode;
    }

    export class MWSysCharacterCreator extends MWSysActorCreator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCharacterCreator;

        static Load(InName: string): MWSysCharacterCreator;
    }

    export class MWEditableActorCreator extends MWSysCharacterCreator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEditableActorCreator;

        static Load(InName: string): MWEditableActorCreator;
    }

    export class MWEditableTextStyle extends EditableTextStyle {
        constructor();
        constructor(BackgroundImageSelectedExtend: MWSlateBrush, BackgroundImageComposingExtend: MWSlateBrush, CaretImageExtend: MWSlateBrush);

        BackgroundImageSelectedExtend: MWSlateBrush;
        BackgroundImageComposingExtend: MWSlateBrush;
        CaretImageExtend: MWSlateBrush;

        static StaticClass(): Class;
    }

    export class MWEditableTextExtend extends EditableText {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetStyleExtend: MWEditableTextStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEditableTextExtend;

        static Load(InName: string): MWEditableTextExtend;
    }

    export class MWEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEditorSettings;

        static Load(InName: string): MWEditorSettings;
    }

    export class MWEditorType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEditorType;

        static Load(InName: string): MWEditorType;
    }

    export enum EMWEdWASDType { MWEd_WASD_Always, MWEd_WASD_RMBOnly, MWEd_WASD_Never, MWEd_WASD_MAX }

    export enum EMWEdLandscapeFoliageEditorControlType {
        MWEd_IgnoreCtrl,
        MWEd_RequireCtrl,
        MWEd_RequireNoCtrl,
        MWEd_MAX
    }

    export enum EMWEdScrollGestureDirection { MWEd_UseSystemSetting, MWEd_Standard, MWEd_Natural, MWEd_MAX }

    export class MWEdSnapToSurfaceSettings {
        constructor();
        constructor(bEnabled: boolean, SnapOffsetExtent: number, bSnapRotation: boolean);

        bEnabled: boolean;
        SnapOffsetExtent: number;
        bSnapRotation: boolean;

        static StaticClass(): Class;
    }

    export enum EMWEdRotationGridMode { MWEd_GridMode_DivisionsOf360, MWEd_GridMode_Common, MWEd_GridMode_MAX }

    export enum EMWEdMeasuringToolUnits {
        MWEd_MeasureUnits_Centimeters,
        MWEd_MeasureUnits_Meters,
        MWEd_MeasureUnits_Kilometers,
        MWEd_MeasureUnits_MAX
    }

    export enum EMWLevelViewportType {
        MW_LVT_OrthoXY,
        MW_LVT_OrthoXZ,
        MW_LVT_OrthoYZ,
        MW_LVT_Perspective,
        MW_LVT_OrthoFreelook,
        MW_LVT_OrthoNegativeXY,
        MW_LVT_OrthoNegativeXZ,
        MW_LVT_OrthoNegativeYZ,
        MW_LVT_MAX,
        MW_LVT_None
    }

    export class MWEdLevelEditorViewportInstanceSettings {
        constructor();
        constructor(ViewportType: EMWLevelViewportType, PerspViewModeIndex: EViewModeIndex, OrthoViewModeIndex: EViewModeIndex, EditorShowFlagsString: string, GameShowFlagsString: string, BufferVisualizationMode: string, RayTracingDebugVisualizationMode: string, ExposureSettings: ExposureSettings, FOVAngle: number, FarViewPlane: number, bIsRealtime: boolean, bShowFPS: boolean, bShowOnScreenStats: boolean, EnabledStats: TArray<string>, bShowFullToolbar: boolean);

        ViewportType: EMWLevelViewportType;
        PerspViewModeIndex: EViewModeIndex;
        OrthoViewModeIndex: EViewModeIndex;
        EditorShowFlagsString: string;
        GameShowFlagsString: string;
        BufferVisualizationMode: string;
        RayTracingDebugVisualizationMode: string;
        ExposureSettings: ExposureSettings;
        FOVAngle: number;
        FarViewPlane: number;
        bIsRealtime: boolean;
        bShowFPS: boolean;
        bShowOnScreenStats: boolean;
        EnabledStats: TArray<string>;
        bShowFullToolbar: boolean;

        static StaticClass(): Class;
    }

    export class MWEdLevelEditorViewportInstanceSettingsKeyValuePair {
        constructor();
        constructor(ConfigName: string, ConfigSettings: MWEdLevelEditorViewportInstanceSettings);

        ConfigName: string;
        ConfigSettings: MWEdLevelEditorViewportInstanceSettings;

        static StaticClass(): Class;
    }

    export class MWEditorViewportSetting extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FlightCameraControlType: EMWEdWASDType;
        FlightCameraControlExperimentalNavigation: boolean;
        LandscapeEditorControlType: EMWEdLandscapeFoliageEditorControlType;
        FoliageEditorControlType: EMWEdLandscapeFoliageEditorControlType;
        bPanMovesCanvas: boolean;
        bCenterZoomAroundCursor: boolean;
        MinimumOrthographicZoom: number;
        bAllowTranslateRotateZWidget: boolean;
        bAllowArcballRotate: boolean;
        bAllowScreenRotate: boolean;
        bClickBSPSelectsBrush: boolean;
        CameraSpeed: number;
        CameraSpeedScalar: number;
        MouseScrollCameraSpeed: number;
        MouseSensitivty: number;
        bInvertMouseLookYAxis: boolean;
        bInvertOrbitYAxis: boolean;
        bInvertMiddleMousePan: boolean;
        bInvertRightMouseDollyYAxis: boolean;
        bUseAbsoluteTranslation: boolean;
        bLevelStreamingVolumePrevis: boolean;
        bUseUE3OrbitControls: boolean;
        ScrollGestureDirectionFor3DViewports: EMWEdScrollGestureDirection;
        ScrollGestureDirectionForOrthoViewports: EMWEdScrollGestureDirection;
        bLevelEditorJoystickControls: boolean;
        bUseDistanceScaledCameraSpeed: boolean;
        bOrbitCameraAroundSelection: boolean;
        bUsePowerOf2SnapSize: boolean;
        DecimalGridSizes: TArray<number>;
        DecimalGridIntervals: TArray<number>;
        Pow2GridSizes: TArray<number>;
        Pow2GridIntervals: TArray<number>;
        CommonRotGridSizes: TArray<number>;
        DivisionsOf360RotGridSizes: TArray<number>;
        ScalingGridSizes: TArray<number>;
        GridEnabled: boolean;
        RotGridEnabled: boolean;
        SnapScaleEnabled: boolean;
        SnapToSurface: MWEdSnapToSurfaceSettings;
        bUsePercentageBasedScaling: boolean;
        bEnableLayerSnap: boolean;
        ActiveSnapLayerIndex: number;
        bEnableActorSnap: boolean;
        ActorSnapScale: number;
        ActorSnapDistance: number;
        bSnapVertices: boolean;
        SnapDistance: number;
        CurrentPosGridSize: number;
        CurrentRotGridSize: number;
        CurrentScalingGridSize: number;
        PreserveNonUniformScale: boolean;
        CurrentRotGridMode: EMWEdRotationGridMode;
        bUseLegacyPostEditBehavior: boolean;
        AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
        bEnableViewportHoverFeedback: boolean;
        bHighlightWithBrackets: boolean;
        bUseLinkedOrthographicViewports: boolean;
        bStrictBoxSelection: boolean;
        bTransparentBoxSelection: boolean;
        bUseSelectionOutline: boolean;
        SelectionHighlightIntensity: number;
        BSPSelectionHighlightIntensity: number;
        bEnableViewportCameraToUpdateFromPIV: boolean;
        bPreviewSelectedCameras: boolean;
        CameraPreviewSize: number;
        BackgroundDropDistance: number;
        PreviewMeshes: TArray<SoftObjectPath>;
        BillboardScale: number;
        TransformWidgetSizeAdjustment: number;
        bSaveEngineStats: boolean;
        MeasuringToolUnits: EMWEdMeasuringToolUnits;
        SelectedSplinePointSizeAdjustment: number;
        SplineLineThicknessAdjustment: number;
        SplineTangentHandleSizeAdjustment: number;
        SplineTangentScale: number;
        PerInstanceSettings: TArray<MWEdLevelEditorViewportInstanceSettingsKeyValuePair>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEditorViewportSetting;

        static Load(InName: string): MWEditorViewportSetting;
    }

    export class MWEdPawn extends Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BaseTurnRate: number;
        BaseLookUpRate: number;
        MovementComponent: PawnMovementComponent;
        CollisionComponent: SphereComponent;
        MeshComponent: StaticMeshComponent;
        bAddDefaultMovementBindings: boolean;

        LookUpAtRate(Rate: number): void;

        MoveForward(Val: number): void;

        MoveRight(Val: number): void;

        MoveUp_World(Val: number): void;

        TurnAtRate(Rate: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdPawn;

        static Load(InName: string): MWEdPawn;
    }

    export class MWEdToolMenuContext {
        constructor();
        constructor(ContextObjects: TArray<Object>);

        ContextObjects: TArray<Object>;

        static StaticClass(): Class;
    }

    export class MWEdToolMenuOwner {
        constructor();

        static StaticClass(): Class;
    }

    export enum EMWToolMenuInsertType { Default, Before, After, First, EMWToolMenuInsertType_MAX }

    export class MWEdToolMenuInsert {
        constructor();
        constructor(Name: string, Position: EMWToolMenuInsertType);

        Name: string;
        Position: EMWToolMenuInsertType;

        static StaticClass(): Class;
    }

    export class MWEdToolMenuEntry {
        constructor();
        constructor(Name: string, Owner: MWEdToolMenuOwner, Type: EMultiBlockType, TutorialHighlightName: string, InsertPosition: MWEdToolMenuInsert, UserInterfaceActionType: EUserInterfaceActionType, bShouldCloseWindowAfterMenuSelection: boolean);

        Name: string;
        Owner: MWEdToolMenuOwner;
        Type: EMultiBlockType;
        TutorialHighlightName: string;
        InsertPosition: MWEdToolMenuInsert;
        UserInterfaceActionType: EUserInterfaceActionType;
        bShouldCloseWindowAfterMenuSelection: boolean;

        static StaticClass(): Class;
    }

    export class MWEdToolMenuSection {
        constructor();
        constructor(Name: string, Owner: MWEdToolMenuOwner, Blocks: TArray<MWEdToolMenuEntry>, InsertPosition: MWEdToolMenuInsert, Context: MWEdToolMenuContext);

        Name: string;
        Owner: MWEdToolMenuOwner;
        Blocks: TArray<MWEdToolMenuEntry>;
        InsertPosition: MWEdToolMenuInsert;
        Context: MWEdToolMenuContext;

        static StaticClass(): Class;
    }

    export class MWEdToolMenu extends ToolMenuBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MenuName: string;
        MenuParent: string;
        MenuType: EMultiBoxType;
        StyleName: string;
        Context: MWEdToolMenuContext;
        Sections: TArray<MWEdToolMenuSection>;
        bShouldCloseWindowAfterMenuSelection: boolean;
        bCloseSelfOnly: boolean;
        bSearchable: boolean;
        SubMenuParent: MWEdToolMenu;
        SubMenuSourceEntryName: string;
        MenuOwner: MWEdToolMenuOwner;

        InitMenu(InOwner: MWEdToolMenuOwner, InName: string, InParent: string, InType: EMultiBoxType): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdToolMenu;

        static Load(InName: string): MWEdToolMenu;
    }

    export class MWEdToolMenus extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Menus: TMap<string, MWEdToolMenu>;

        ExtendMenu(InName: string): MWEdToolMenu;

        RefreshAllWidgets(): void;

        RegisterMenu(InName: string, InParent: string, InType: EMultiBoxType, bWarnIfAlreadyRegistered: boolean): MWEdToolMenu;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdToolMenus;

        static Load(InName: string): MWEdToolMenus;
    }

    export class MWEdToolUtilsLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static BakeInstanceParametersForStaticMeshActors(InStaticMeshActors: TArray<Actor>, InUnwrappingMaterial: $Nullable<MaterialInterface>, OutTransforms: $Ref<TArray<Transform>>, OutInstanceCustomDatas: $Ref<TArray<number>>): void;

        static CalcStaticMeshCompSectionAvgColor(InUnwrappingMaterial: $Nullable<MaterialInterface>, InStaticMeshComp: $Nullable<StaticMeshComponent>, LODToUnwrap: number, InSectionID: number, InRenderTarget?: TextureRenderTarget2D /* = None */): LinearColor;

        static CalcStaticMeshCompSectionsAvgColor(OutColorForSections: $Ref<TArray<LinearColor>>, InUnwrappingMaterial: $Nullable<MaterialInterface>, InStaticMeshComp: $Nullable<StaticMeshComponent>, LODToUnwrap: number, InRenderTarget?: TextureRenderTarget2D /* = None */): void;

        static CalcStaticMeshSectionAvgColor(InUnwrappingMaterial: $Nullable<MaterialInterface>, InStaticMesh: $Nullable<StaticMesh>, InOverrideMaterials: TArray<MaterialInterface>, LODToUnwrap: number, InSectionID: number, InRenderTarget?: TextureRenderTarget2D /* = None */): LinearColor;

        static CalcStaticMeshSectionsAvgColor(OutColorForSections: $Ref<TArray<LinearColor>>, InUnwrappingMaterial: $Nullable<MaterialInterface>, InStaticMesh: $Nullable<StaticMesh>, InOverrideMaterials: TArray<MaterialInterface>, LODToUnwrap: number, InRenderTarget?: TextureRenderTarget2D /* = None */): void;

        static CombineSectionsForStaticMesh(InStaticMesh: $Nullable<StaticMesh>, InCombinedMaterial: $Nullable<MaterialInterface>, NewMeshPathName: string, SectionsToExclude: TArray<number>, ScreenSizeRate?: number /* = 0.500000 */, bAutoSave?: boolean /* = true */): boolean;

        static CombineSectionsWithCombinedTexture(InStaticMesh: $Nullable<StaticMesh>, NewMeshPathName: string, OutOffsets: $Ref<TArray<Vector2D>>, OutScales: $Ref<TArray<Vector2D>>, ScreenSizeRate?: number /* = 0.500000 */, bAutoSave?: boolean /* = true */): boolean;

        static CombineSMCsWithCombinedTexture(InStaticMeshComps: TArray<StaticMeshComponent>, NewMeshPathName: string, InCombinedMaterial: $Nullable<MaterialInterface>, OutOffsets: $Ref<TArray<Vector2D>>, OutScales: $Ref<TArray<Vector2D>>, ActorsToExclude: $Ref<TSet<Actor>>, ScreenSizeRate?: number /* = 0.500000 */, bAutoSave?: boolean /* = true */): boolean;

        static DrawCheckerBoard(OutputRenderTarget: $Nullable<TextureRenderTarget2D>): Texture2D;

        static DrawCompUnwrappedPrimitivesToRenderTarget(InRenderTarget: $Nullable<TextureRenderTarget2D>, InUnwrappingMaterial: $Nullable<MaterialInterface>, InStaticMeshComp: $Nullable<StaticMeshComponent>, LODToUnwrap: number, InSectionID: number): boolean;

        static DrawUnwrappedPrimitivesToRenderTarget(InRenderTarget: $Nullable<TextureRenderTarget2D>, InUnwrappingMaterial: $Nullable<MaterialInterface>, InStaticMesh: $Nullable<StaticMesh>, InOverrideMaterials: TArray<MaterialInterface>, LODToUnwrap: number, InSectionID: number): boolean;

        static SetISMCNumCustomDataFloats(InISMC: $Nullable<InstancedStaticMeshComponent>, NumFloats: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdToolUtilsLibrary;

        static Load(InName: string): MWEdToolUtilsLibrary;
    }

    export class MWEdTranslationGizmo extends MWEdBaseGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdTranslationGizmo;

        static Load(InName: string): MWEdTranslationGizmo;
    }

    export class MWEdViewportClient extends GameViewportClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentGizmo: MWEdTranslationGizmo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEdViewportClient;

        static Load(InName: string): MWEdViewportClient;
    }

    export class MWEnvironmentSettings extends MWSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Env: string;

        OnEnv(InValue: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWEnvironmentSettings;

        static Load(InName: string): MWEnvironmentSettings;
    }

    export class MWFolder extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWFolder;

        static Load(InName: string): MWFolder;
    }

    export class MWScrollerView_Item extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DataRow: number;

        RefreshSlot(Row: number, Col: number): void;

        RefreshView(Data: $Nullable<ScrollerData>): void;

        RefreshViewNew(): void;

        SetScrollerData(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWScrollerView_Item;

        static Load(InName: string): MWScrollerView_Item;
    }

    export class MWScrollerView extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ItemPool: TArray<MWScrollerView_Item>;
        LastItem: MWScrollerView_Item;
        bShowBar: boolean;
        ItemPrefab: Class;
        ColNumber: number;
        MaxRowNumber: number;
        LastDataRow: number;
        CurRow: number;

        AddToContent(ItemInstance: $Nullable<MWScrollerView_Item>): void;

        CalculateMaxRowNum(): void;

        CalculateMaxShowRow(InScrollOffsetFraction: number, GridHeight: number): number;

        HideEmptyTip(): void;

        MoveToTop(): void;

        RefreshView(InScrollOffsetFraction: number, GridHeight: number): void;

        ShowEmptyTip(EmptyTip: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWScrollerView;

        static Load(InName: string): MWScrollerView;
    }

    export class MWGameListController extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureMap: TMap<string, Texture2DDynamic>;
        GameSelectOptions: TArray<string>;
        Option: string;
        Key: string;
        ScrollView: MWScrollerView;
        CurrentRequestUrl: string;
        CurrentGameName: string;
        OnImageRefresh: $MulticastDelegate<(GameName: string) => void>;

        GetDyTexture(GameName: string): Texture2DDynamic;

        GetOptions(): TArray<string>;

        SelectOption(SelectOption: string, SelectKey: string): boolean;

        SetGameInfoData(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWGameListController;

        static Load(InName: string): MWGameListController;
    }

    export class MWGenerateActorGroup extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWGenerateActorGroup;

        static Load(InName: string): MWGenerateActorGroup;
    }

    export class MWHeroPackageActorCreator extends MWSysCharacterCreator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHeroPackageActorCreator;

        static Load(InName: string): MWHeroPackageActorCreator;
    }

    export class MWHierarchicalInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Data: string;
        TransformFromData: TMap<number, Transform>;
        MWLevel: MWLevel;

        OnRep_Data(): void;

        SetStaticMeshAsset(InAssetGuid: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHierarchicalInstancedStaticMeshComponent;

        static Load(InName: string): MWHierarchicalInstancedStaticMeshComponent;
    }

    export class MWHierarchicalInstancedStaticMeshActor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HISMC: MWHierarchicalInstancedStaticMeshComponent;

        GetInstancedStaticMeshComponent(): MWHierarchicalInstancedStaticMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHierarchicalInstancedStaticMeshActor;

        static Load(InName: string): MWHierarchicalInstancedStaticMeshActor;
    }

    export class MWHttpForTS extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NotifyUpload: $MulticastDelegate<(Result: boolean) => void>;
        NotifyDownload: $MulticastDelegate<(Result: string) => void>;

        HttpRequest(Url: string, JsonContent: string, RequestType?: number /* = 0 */): boolean;

        static Instance(): MWHttpForTS;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHttpForTS;

        static Load(InName: string): MWHttpForTS;
    }

    export class MWHttpResponse extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetAllHeaders(): TArray<string>;

        GetContent(): TArray<number>;

        GetContentAsString(): string;

        GetContentLength(): number;

        GetContentType(): string;

        GetHeader(HeaderName: string): string;

        GetResponseCode(): number;

        GetURL(): string;

        GetURLParameter(ParameterName: string): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHttpResponse;

        static Load(InName: string): MWHttpResponse;
    }

    export class MWHttpRequest extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnProcessRequestComplete: $MulticastDelegate<(Request: $Nullable<MWHttpRequest>, Response: $Nullable<MWHttpResponse>, bConnectedSuccessfully: boolean) => void>;
        OnRequestProgress: $MulticastDelegate<(Request: $Nullable<MWHttpRequest>, BytesSent: number, BytesReceived: number) => void>;
        OnRequestWillRetry: $MulticastDelegate<(Request: $Nullable<MWHttpRequest>, Response: $Nullable<MWHttpResponse>, SecondsToRetry: number) => void>;
        OnHeaderReceived: $MulticastDelegate<(Request: $Nullable<MWHttpRequest>, HeaderName: string, NewHeaderValue: string) => void>;

        CancelRequest(): void;

        GetAllHeaders(): TArray<string>;

        GetContent(): TArray<number>;

        GetContentLength(): number;

        GetContentType(): string;

        GetHeader(HeaderName: string): string;

        GetResponse(): MWHttpResponse;

        GetStatus(): number;

        GetURL(): string;

        GetURLParameter(ParameterName: string): string;

        ProcessRequest(): boolean;

        SetContent(InContent: string): void;

        SetHeader(InKey: string, InValue: string): void;

        SetURL(InUrl: string): void;

        SetVerb(InVerb: string): void;

        static Create(): MWHttpRequest;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHttpRequest;

        static Load(InName: string): MWHttpRequest;
    }

    export class MWHttpTest extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestDownload(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHttpTest;

        static Load(InName: string): MWHttpTest;
    }

    export class MWHttpUriSettings extends MWSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Resources: string;
        Tasks: string;
        Games: string;
        MGS: string;
        Register: string;
        Login: string;
        Release: string;
        Gateway: string;
        Match: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHttpUriSettings;

        static Load(InName: string): MWHttpUriSettings;
    }

    export class MWHumanoidActorCreator extends MWEditableActorCreator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWHumanoidActorCreator;

        static Load(InName: string): MWHumanoidActorCreator;
    }

    export class MWIconConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWIconConfig;

        static Load(InName: string): MWIconConfig;
    }

    export class MWImage extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnMouseButtonDownEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        UIAsset: MWAssetRecorder;

        GetBrushSize(): Vector2D;

        GetColorAndOpacity(): LinearColor;

        GetDrawType(): ESlateBrushDrawType;

        GetImage(): SlateBrushWithGuid;

        GetImageGuid(): string;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        SetBrush(InBrush: SlateBrushWithGuid): void;

        SetBrushFromMaterial(Material: $Nullable<MaterialInterface>): void;

        SetBrushFromTexture(Texture: $Nullable<Texture2D>, bMatchSize?: boolean /* = false */): void;

        SetBrushFromTextureDynamic(Texture: $Nullable<Texture2DDynamic>, bMatchSize?: boolean /* = false */): void;

        SetBrushResourceObject(ResourceObject: $Nullable<Object>): void;

        SetBrushSize(DesiredSize: Vector2D): void;

        SetBrushTintColor(TintColor: SlateColor): void;

        SetColorAndOpacity(InColorAndOpacity: LinearColor): void;

        SetDrawType(InDrawType: ESlateBrushDrawType): void;

        SetImage(InBrush: SlateBrushWithGuid): void;

        SetImageByGuid(InGuidBrush: string, bMatchSize?: boolean /* = true */): void;

        SetMWHexColor(HexColor: string): void;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        SetOpacity(InOpacity: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWImage;

        static Load(InName: string): MWImage;
    }

    export class MWImageExtend extends Image {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BrushExtend: MWSlateBrush;
        BrushExtendDelegate: $Delegate<() => MWSlateBrush>;

        GetBrushExtend__DelegateSignature(): MWSlateBrush;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWImageExtend;

        static Load(InName: string): MWImageExtend;
    }

    export enum EMWUIInputTextLimit {
        NoLimit,
        LimitToInt,
        LimitToFloat,
        LimitToNumberAndChar,
        LimitToPassword,
        EMWUIInputTextLimit_MAX
    }

    export class MWInputBox extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetStyle: EditableTextBoxStyle;
        bIsReadOnly: boolean;
        AllowContextMenu: boolean;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        Style: SlateWidgetStyleAsset;
        Font: SlateFontInfo;
        ForegroundColor: LinearColor;
        BackgroundColor: LinearColor;
        ReadOnlyForegroundColor: LinearColor;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
        HintTextDelegate: $Delegate<() => string>;

        GetbStrikeline(): boolean;

        GetbUnderline(): boolean;

        GetContentColor(): LinearColor;

        GetError(): string;

        GetFontColor(): LinearColor;

        GetFontInfo(): MWUIFontInfo;

        GetFontLitterSpace(): number;

        GetFontSize(): number;

        GetGlyph(): EMWUIFontGlyph;

        GetHintString(): string;

        GetHintText(): string;

        GetInputTextLimit(): EMWUIInputTextLimit;

        GetIsReadOnly(): boolean;

        GetJustification(): EMWTextJustify;

        GetMWAutoWrap(): boolean;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        GetOutlineColor(): LinearColor;

        GetOutlineSize(): number;

        GetShadowColor(): LinearColor;

        GetShadowOffset(): Vector2D;

        GetTextByString(): string;

        GetTextLengthLimit(): number;

        GetVerticalJustification(): ETextVerticalJustify;

        OnMultiLineEditableTextBoxChangedEvent__DelegateSignature(Text: string): void;

        OnMultiLineEditableTextBoxCommittedEvent__DelegateSignature(Text: string, CommitMethod: ETextCommit): void;

        SetbStrikeline(InbStrikeline: boolean): void;

        SetbUnderline(InbUnderline: boolean): void;

        SetContentColor(InColor: LinearColor): void;

        SetError(InError: string): void;

        SetFontColor(InColor: LinearColor): void;

        SetFontInfo(InFontInfo: MWUIFontInfo): void;

        SetFontLetterSpace(InLetterSpace: number): void;

        SetFontSize(InSize: number): void;

        SetGlyph(InGlyph: EMWUIFontGlyph): void;

        SetHintString(InHintString: string): void;

        SetHintText(InHintText: string): void;

        SetInputTextLimit(InLimit: EMWUIInputTextLimit): void;

        SetIsReadOnly(bReadOnly: boolean): void;

        SetMWAutoWrap(InAutoWrap: boolean): void;

        SetMWName(InName: string): void;

        SetMWTextJustification(InTextJustification: EMWTextJustify): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        SetOutlineColor(InOutlineColor: LinearColor): void;

        SetOutlineSize(InOutlineSize: number): void;

        SetShadowColor(InColor: LinearColor): void;

        SetShadowOffset(InOffset: Vector2D): void;

        SetTextByString(InText: string): void;

        SetTextLengthLimit(InTextLength: number): void;

        SetVerticalJustification(InTextJustification: ETextVerticalJustify): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWInputBox;

        static Load(InName: string): MWInputBox;
    }

    export class MWInstanceStaticMeshComponent extends InstancedStaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Data: string;
        TransformFromData: TMap<number, Transform>;
        MWLevel: MWLevel;

        OnRep_Data(): void;

        SetStaticMeshAsset(InAssetGuid: string, InNumCustomDataFloats: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWInstanceStaticMeshComponent;

        static Load(InName: string): MWInstanceStaticMeshComponent;
    }

    export class MWInstancedStaticMeshActor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ISMC: MWInstanceStaticMeshComponent;

        GetInstancedStaticMeshComponent(): MWInstanceStaticMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWInstancedStaticMeshActor;

        static Load(InName: string): MWInstancedStaticMeshActor;
    }

    export class MWInternationalizationCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWInternationalizationCommandlet;

        static Load(InName: string): MWInternationalizationCommandlet;
    }

    export class MWInternationalizationText extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWInternationalizationText;

        static Load(InName: string): MWInternationalizationText;
    }

    export class MWIOSMobileLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CheckNeedRegisterIOS(WorldContextObject: $Nullable<Object>): boolean;

        static CheckPlatformIOS(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWIOSMobileLibrary;

        static Load(InName: string): MWIOSMobileLibrary;
    }

    export class MWVisualStyle {
        constructor();
        constructor(Normal: SlateBrush, Touch: SlateBrush, Disable: SlateBrush);

        Normal: SlateBrush;
        Touch: SlateBrush;
        Disable: SlateBrush;

        static StaticClass(): Class;
    }

    export enum FMWTempControlType {
        TempControlType_None,
        TempControlType_MoveType,
        TempControlType_CameraType,
        TempControlType_MoveNoAxisType,
        TempControlType_MAX
    }

    export class MWTouchControl {
        constructor();
        constructor(CenterImage: MWVisualStyle, BackgroundImage: MWVisualStyle, EnableJoystick: boolean, ControlType: FMWTempControlType, Center: Vector2D, VisualSize: Vector2D, ThumbSize: Vector2D, InteractionSize: Vector2D, InputScale: Vector2D, bPreventRecenter: boolean, StartupDelay: number, TimeUntilDeactive: number, TimeUntilReset: number, InputDir: $MulticastDelegate<(Value: Vector2D) => void>);

        CenterImage: MWVisualStyle;
        BackgroundImage: MWVisualStyle;
        EnableJoystick: boolean;
        ControlType: FMWTempControlType;
        Center: Vector2D;
        VisualSize: Vector2D;
        ThumbSize: Vector2D;
        InteractionSize: Vector2D;
        InputScale: Vector2D;
        bPreventRecenter: boolean;
        StartupDelay: number;
        TimeUntilDeactive: number;
        TimeUntilReset: number;
        InputDir: $MulticastDelegate<(Value: Vector2D) => void>;

        static StaticClass(): Class;
    }

    export class MWJoystick extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Control: MWTouchControl;
        InputDir: $MulticastDelegate<(Value: Vector2D) => void>;

        SetControlType(NewControlType: FMWTempControlType): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWJoystick;

        static Load(InName: string): MWJoystick;
    }

    export class MWVisualStyleDesigner {
        constructor();
        constructor(Normal: SlateBrush, Touch: SlateBrush, Disable: SlateBrush);

        Normal: SlateBrush;
        Touch: SlateBrush;
        Disable: SlateBrush;

        static StaticClass(): Class;
    }

    export class MWTouchControlDesigner {
        constructor();
        constructor(CenterImage: MWVisualStyleDesigner, BackgroundImage: MWVisualStyleDesigner, EnableJoystick: boolean, Center: Vector2D, VisualSize: Vector2D, ThumbSize: Vector2D, InteractionSize: Vector2D, InputScale: Vector2D, bPreventRecenter: boolean, StartupDelay: number, TimeUntilDeactive: number, TimeUntilReset: number, InputDir: $MulticastDelegate<(Value: Vector2D) => void>);

        CenterImage: MWVisualStyleDesigner;
        BackgroundImage: MWVisualStyleDesigner;
        EnableJoystick: boolean;
        Center: Vector2D;
        VisualSize: Vector2D;
        ThumbSize: Vector2D;
        InteractionSize: Vector2D;
        InputScale: Vector2D;
        bPreventRecenter: boolean;
        StartupDelay: number;
        TimeUntilDeactive: number;
        TimeUntilReset: number;
        InputDir: $MulticastDelegate<(Value: Vector2D) => void>;

        static StaticClass(): Class;
    }

    export class MWJoystickDesigner extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Control: MWTouchControlDesigner;
        InputDir: $MulticastDelegate<(Value: Vector2D) => void>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWJoystickDesigner;

        static Load(InName: string): MWJoystickDesigner;
    }

    export class MWJoystickPanelSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LayoutData: AnchorData;
        bAutoSize: boolean;
        ZOrder: number;

        GetAlignment(): Vector2D;

        GetAnchors(): Anchors;

        GetAutoSize(): boolean;

        GetLayout(): AnchorData;

        GetOffsets(): Margin;

        GetPosition(): Vector2D;

        GetSize(): Vector2D;

        GetZOrder(): number;

        SetAlignment(InAlignment: Vector2D): void;

        SetAnchors(InAnchors: Anchors): void;

        SetAutoSize(InbAutoSize: boolean): void;

        SetLayout(InLayoutData: AnchorData): void;

        SetMaximum(InMaximumAnchors: Vector2D): void;

        SetMinimum(InMinimumAnchors: Vector2D): void;

        SetOffsets(InOffset: Margin): void;

        SetPosition(InPosition: Vector2D): void;

        SetSize(InSize: Vector2D): void;

        SetZOrder(InZOrder: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWJoystickPanelSlot;

        static Load(InName: string): MWJoystickPanelSlot;
    }

    export class MWJoystickPanel extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddChildToUVirtualJoystickPanel(Content: $Nullable<Widget>): MWJoystickPanelSlot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWJoystickPanel;

        static Load(InName: string): MWJoystickPanel;
    }

    export class MWJoystickPanelSlotDesigner extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LayoutData: AnchorData;
        bAutoSize: boolean;
        ZOrder: number;

        GetAlignment(): Vector2D;

        GetAnchors(): Anchors;

        GetAutoSize(): boolean;

        GetLayout(): AnchorData;

        GetOffsets(): Margin;

        GetPosition(): Vector2D;

        GetSize(): Vector2D;

        GetZOrder(): number;

        SetAlignment(InAlignment: Vector2D): void;

        SetAnchors(InAnchors: Anchors): void;

        SetAutoSize(InbAutoSize: boolean): void;

        SetLayout(InLayoutData: AnchorData): void;

        SetMaximum(InMaximumAnchors: Vector2D): void;

        SetMinimum(InMinimumAnchors: Vector2D): void;

        SetOffsets(InOffset: Margin): void;

        SetPosition(InPosition: Vector2D): void;

        SetSize(InSize: Vector2D): void;

        SetZOrder(InZOrder: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWJoystickPanelSlotDesigner;

        static Load(InName: string): MWJoystickPanelSlotDesigner;
    }

    export class MWJoystickPanelDesigner extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddChildToUVirtualJoystickPanel(Content: $Nullable<Widget>): MWJoystickPanelSlotDesigner;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWJoystickPanelDesigner;

        static Load(InName: string): MWJoystickPanelDesigner;
    }

    export class MWJSActor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScriptAssetID: string;

        GetScriptAssetID(): string;

        GetTarget(): MWActor;

        IsActive(): boolean;

        OnRep_ScriptAssetID(): void;

        SetBind(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWJSActor;

        static Load(InName: string): MWJSActor;
    }

    export enum EMWLabelAnchorMode {
        MWbelAnchorMode_TopLeft,
        MWLabelAnchorMode_TopCenter,
        MWLabelAnchorMode_TopRight,
        MWLabelAnchorMode_CenterLeft,
        MWLabelAnchorMode_Centered,
        MWLabelAnchorMode_CenterRight,
        MWLabelAnchorMode_BottomLeft,
        MWLabelAnchorMode_BottomCenter,
        MWLabelAnchorMode_BottomRight,
        EMWLabelAnchorMode_MAX
    }

    export enum EMWPlayOnBuildMode {
        MWPlayOnBuild_Always,
        MWPlayOnBuild_Never,
        MWPlayOnBuild_Default,
        MWPlayOnBuild_IfEditorBuiltLocally,
        MWPlayOnBuild_MAX
    }

    export enum EMWPlayOnLaunchConfiguration {
        MWLaunchConfig_Default,
        MWLaunchConfig_Debug,
        MWLaunchConfig_Development,
        MWLaunchConfig_Test,
        MWLaunchConfig_Shipping,
        MWLaunchConfig_MAX
    }

    export enum EMWPlayNetMode { MWPIE_Standalone, MWPIE_ListenServer, MWPIE_Client, MWPIE_MAX }

    export enum EMWNetworkEmulationTarget { Server, Client, Any, EMWNetworkEmulationTarget_MAX }

    export class MWNetworkEmulationPacketSettings {
        constructor();
        constructor(MinLatency: number, MaxLatency: number, PacketLossPercentage: number);

        MinLatency: number;
        MaxLatency: number;
        PacketLossPercentage: number;

        static StaticClass(): Class;
    }

    export class MWLevelEditorPlayNetworkEmulationSettings {
        constructor();
        constructor(bIsNetworkEmulationEnabled: boolean, EmulationTarget: EMWNetworkEmulationTarget, CurrentProfile: string, OutPackets: MWNetworkEmulationPacketSettings, InPackets: MWNetworkEmulationPacketSettings);

        bIsNetworkEmulationEnabled: boolean;
        EmulationTarget: EMWNetworkEmulationTarget;
        CurrentProfile: string;
        OutPackets: MWNetworkEmulationPacketSettings;
        InPackets: MWNetworkEmulationPacketSettings;

        static StaticClass(): Class;
    }

    export enum EMWLaunchModeType { MWLaunchMode_OnDevice, MWLaunchMode_MAX }

    export enum EMWPlayModeLocations {
        MWPlayLocation_CurrentCameraLocation,
        MWPlayLocation_DefaultPlayerStart,
        MWPlayLocation_MAX
    }

    export enum EMWPlayModeType {
        MWPlayMode_InViewPort,
        MWPlayMode_InEditorFloating,
        MWPlayMode_InMobilePreview,
        MWPlayMode_InTargetedMobilePreview,
        MWPlayMode_InVulkanPreview,
        MWPlayMode_InNewProcess,
        MWPlayMode_InVR,
        MWPlayMode_Simulate,
        MWPlayMode_Count,
        MWPlayMode_MAX
    }

    export class MWPlayScreenResolution {
        constructor();
        constructor(Description: string, Width: number, Height: number, AspectRatio: string, bCanSwapAspectRatio: boolean, ProfileName: string, ScaleFactor: number, LogicalHeight: number, LogicalWidth: number);

        Description: string;
        Width: number;
        Height: number;
        AspectRatio: string;
        bCanSwapAspectRatio: boolean;
        ProfileName: string;
        ScaleFactor: number;
        LogicalHeight: number;
        LogicalWidth: number;

        static StaticClass(): Class;
    }

    export class MWLevelEditorPlaySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayFromHerePlayerStartClassName: string;
        GameGetsMouseControl: boolean;
        UseMouseForTouch: boolean;
        ShowMouseControlLabel: boolean;
        MouseControlLabelPosition: EMWLabelAnchorMode;
        ViewportGetsHMDControl: boolean;
        ShouldMinimizeEditorOnVRPIE: boolean;
        AutoRecompileBlueprints: boolean;
        EnableGameSound: boolean;
        EnablePIEEnterAndExitSounds: boolean;
        PlayInEditorSoundQualityLevel: number;
        bUseNonRealtimeAudioDevice: boolean;
        bOnlyLoadVisibleLevelsInPIE: boolean;
        bPreferToStreamLevelsInPIE: boolean;
        NewWindowWidth: number;
        NewWindowHeight: number;
        NewWindowPosition: IntPoint;
        CenterNewWindow: boolean;
        PIEAlwaysOnTop: boolean;
        DisableStandaloneSound: boolean;
        AdditionalLaunchParameters: string;
        AdditionalLaunchParametersForMobile: string;
        BuildGameBeforeLaunch: EMWPlayOnBuildMode;
        LaunchConfiguration: EMWPlayOnLaunchConfiguration;
        bAutoCompileBlueprintsOnLaunch: boolean;
        bLaunchSeparateServer: boolean;
        PlayNetMode: EMWPlayNetMode;
        RunUnderOneProcess: boolean;
        PlayNumberOfClients: number;
        ServerPort: number;
        ClientWindowWidth: number;
        AutoConnectToServer: boolean;
        RouteGamepadToSecondWindow: boolean;
        CreateAudioDeviceForEveryPlayer: boolean;
        ClientWindowHeight: number;
        ServerMapNameOverride: string;
        AdditionalServerGameOptions: string;
        AdditionalLaunchOptions: string;
        bShowServerDebugDrawingByDefault: boolean;
        ServerDebugDrawingColorTintStrength: number;
        ServerDebugDrawingColorTint: LinearColor;
        AdditionalServerLaunchParameters: string;
        ServerFixedFPS: number;
        ClientFixedFPS: TArray<number>;
        NetworkEmulationSettings: MWLevelEditorPlayNetworkEmulationSettings;
        LastSize: IntPoint;
        MultipleInstancePositions: TArray<IntPoint>;
        LastExecutedLaunchDevice: string;
        LastExecutedLaunchName: string;
        LastExecutedLaunchModeType: EMWLaunchModeType;
        LastExecutedPlayModeLocation: EMWPlayModeLocations;
        LastExecutedPlayModeType: EMWPlayModeType;
        LastExecutedPIEPreviewDevice: string;
        LaptopScreenResolutions: TArray<MWPlayScreenResolution>;
        MonitorScreenResolutions: TArray<MWPlayScreenResolution>;
        PhoneScreenResolutions: TArray<MWPlayScreenResolution>;
        TabletScreenResolutions: TArray<MWPlayScreenResolution>;
        TelevisionScreenResolutions: TArray<MWPlayScreenResolution>;
        DeviceToEmulate: string;
        PIESafeZoneOverride: Margin;
        CustomUnsafeZoneStarts: TArray<Vector2D>;
        CustomUnsafeZoneDimensions: TArray<Vector2D>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWLevelEditorPlaySettings;

        static Load(InName: string): MWLevelEditorPlaySettings;
    }

    export class UserInfo {
        constructor();

        static StaticClass(): Class;
    }

    export class MWSysDelegateManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnNetworkFailure_Client: $MulticastDelegate<(ErrorType: ENetworkFailure, Message: string) => void>;
        OnReconnectFailure: $MulticastDelegate<(Message: $Ref<string>) => void>;
        OnFocus: $MulticastDelegate<(bFocus: boolean) => void>;
        OnDsReceivingMsg: $MulticastDelegate<(CmdStr: string, JsonStr: string) => void>;

        SendMsgToWS(Cmd: string, Msg: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysDelegateManager;

        static Load(InName: string): MWSysDelegateManager;
    }

    export class TSGameData {
        constructor();
        constructor(GameId: string, GameVersion: string, GameType: number, ConnectTimeOut: string);

        GameId: string;
        GameVersion: string;
        GameType: number;
        ConnectTimeOut: string;

        static StaticClass(): Class;
    }

    export class MGSData {
        constructor();
        constructor(MGSRoomId: string, NickName: string, AvatarTexture: Texture2DDynamic);

        MGSRoomId: string;
        NickName: string;
        AvatarTexture: Texture2DDynamic;

        static StaticClass(): Class;
    }

    export class MWSysLocalPlayer extends LocalPlayer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        connectUrl: string;
        InputToken: string;
        InputAccount: string;
        IsPlayer: boolean;
        bIsLocalDS: boolean;

        GetAndroidLeaveErrorMessage(): string;

        GetCurrentGameData(): TSGameData;

        GetMGSData(): MGSData;

        GetNextGameData(): TSGameData;

        GetOpenId(): string;

        GetSysDelegateManager(): MWSysDelegateManager;

        GetUserInfo(): UserInfo;

        HandleCallAndroid(Message: string, Response: $Ref<string>): void;

        HandleMGSCallUE(Response: string): void;

        IsFromAndroid(): boolean;

        QuitGame(): void;

        QuitTSGame(): void;

        SetIsVertical(NewState: boolean): void;

        static GetIsVertical(): boolean;

        static GetLocalPlayer(Context: $Nullable<Object>): MWSysLocalPlayer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysLocalPlayer;

        static Load(InName: string): MWSysLocalPlayer;
    }

    export class MWLocalPlayer extends MWSysLocalPlayer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QuitGameBecauseAutoReconnectFalied(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWLocalPlayer;

        static Load(InName: string): MWLocalPlayer;
    }

    export class SceneCapture extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MeshComp: StaticMeshComponent;
        SceneComponent: SceneComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneCapture;

        static Load(InName: string): SceneCapture;
    }

    export enum ESceneCapturePrimitiveRenderMode {
        PRM_LegacySceneCapture,
        PRM_RenderScenePrimitives,
        PRM_UseShowOnlyList,
        PRM_MAX
    }

    export enum ESceneCaptureSource {
        SCS_SceneColorHDR,
        SCS_SceneColorHDRNoAlpha,
        SCS_FinalColorLDR,
        SCS_SceneColorSceneDepth,
        SCS_SceneDepth,
        SCS_DeviceDepth,
        SCS_Normal,
        SCS_BaseColor,
        SCS_FinalColorHDR,
        SCS_FinalToneCurveHDR,
        SCS_MAX
    }

    export class EngineShowFlagsSetting {
        constructor();
        constructor(ShowFlagName: string, Enabled: boolean);

        ShowFlagName: string;
        Enabled: boolean;

        static StaticClass(): Class;
    }

    export class SceneCaptureComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PrimitiveRenderMode: ESceneCapturePrimitiveRenderMode;
        CaptureSource: ESceneCaptureSource;
        bCaptureEveryFrame: boolean;
        bCaptureOnMovement: boolean;
        bAlwaysPersistRenderingState: boolean;
        HiddenComponents: TArray<TWeakObjectPtr<PrimitiveComponent>>;
        HiddenActors: TArray<Actor>;
        ShowOnlyComponents: TArray<TWeakObjectPtr<PrimitiveComponent>>;
        ShowOnlyActors: TArray<Actor>;
        LODDistanceFactor: number;
        MaxViewDistanceOverride: number;
        CaptureSortPriority: number;
        bUseRayTracingIfEnabled: boolean;
        ShowFlagSettings: TArray<EngineShowFlagsSetting>;
        ProfilingEventName: string;
        CaptureMesh: StaticMesh;

        ClearHiddenComponents(): void;

        ClearShowOnlyComponents(): void;

        HideActorComponents(InActor: $Nullable<Actor>, bIncludeFromChildActors?: boolean /* = false */): void;

        HideComponent(InComponent: $Nullable<PrimitiveComponent>): void;

        RemoveShowOnlyActorComponents(InActor: $Nullable<Actor>, bIncludeFromChildActors?: boolean /* = false */): void;

        RemoveShowOnlyComponent(InComponent: $Nullable<PrimitiveComponent>): void;

        SetCaptureSortPriority(NewCaptureSortPriority: number): void;

        ShowOnlyActorComponents(InActor: $Nullable<Actor>, bIncludeFromChildActors?: boolean /* = false */): void;

        ShowOnlyComponent(InComponent: $Nullable<PrimitiveComponent>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponent;

        static Load(InName: string): SceneCaptureComponent;
    }

    export enum ESceneCaptureCompositeMode { SCCM_Overwrite, SCCM_Additive, SCCM_Composite, SCCM_MAX }

    export class SceneCaptureComponent2D extends SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProjectionType: ECameraProjectionMode;
        FOVAngle: number;
        OrthoWidth: number;
        TextureTarget: TextureRenderTarget2D;
        CompositeMode: ESceneCaptureCompositeMode;
        PostProcessSettings: PostProcessSettings;
        PostProcessBlendWeight: number;
        bOverride_CustomNearClippingPlane: boolean;
        CustomNearClippingPlane: number;
        bUseCustomProjectionMatrix: boolean;
        CustomProjectionMatrix: Matrix;
        bEnableClipPlane: boolean;
        ClipPlaneBase: Vector;
        ClipPlaneNormal: Vector;
        bCameraCutThisFrame: boolean;
        bConsiderUnrenderedOpaquePixelAsFullyTranslucent: boolean;
        bDisableFlipCopyGLES: boolean;

        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight?: number /* = 1.000000 */): void;

        CaptureScene(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponent2D;

        static Load(InName: string): SceneCaptureComponent2D;
    }

    export class SceneCapture2D extends SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CaptureComponent2D: SceneCaptureComponent2D;

        OnInterpToggle(bEnable: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneCapture2D;

        static Load(InName: string): SceneCapture2D;
    }

    export class MWStaticMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialsID: TArray<string>;
        DefaultMaterialsID: TArray<string>;
        bDrawAsUnwrappedUVs: boolean;
        bFlattenNormals: boolean;
        SourceAssetID: string;
        ShadowComponent: StaticMeshComponent;

        GetGuid(): string;

        GetMaterialAsset(ElementIndex: number): string;

        OnRep_MaterialAssets(): void;

        OnRep_SourceAssetID(): void;

        SetDrawAsUnwrappedUVs(bEnable: boolean): void;

        SetMaterialAsset(ElementIndex: number, InAssetGuid: string): void;

        SetStaticMeshAsset(InAssetGuid: string): void;

        static RenderMWSMCsToCombinedTexture(InStaticMeshComps: TArray<MWStaticMeshComponent>, bUnlit: boolean, InOffsets: TArray<Vector2D>, InScales: TArray<Vector2D>, TargetRT: $Nullable<TextureRenderTarget2D>, InSceneCapture?: SceneCapture2D /* = None */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWStaticMeshComponent;

        static Load(InName: string): MWStaticMeshComponent;
    }

    export class MWLODActor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MWStaticMeshComponent: MWStaticMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWLODActor;

        static Load(InName: string): MWLODActor;
    }

    export class MWLowPolyActorCreator extends MWSysCharacterCreator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWLowPolyActorCreator;

        static Load(InName: string): MWLowPolyActorCreator;
    }

    export class Message {
        constructor();

        static StaticClass(): Class;
    }

    export class MWMessageChannel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TSReceiveMessageDelegate: $MulticastDelegate<(Message: string) => void>;

        static GetInstance(): MWMessageChannel;

        static GetMyClass(): Class;

        static Message4Android(InMessage: Message): void;

        static Message4MetaWorld(InMessage: Message): void;

        static Message4MGS(InMessage: Message): void;

        static Message4TS(InMessage: Message): void;

        static Message4Web(InMessage: Message): void;

        static RegisterTSAction(InAction: string): void;

        static Send(InToWho: number, InMessageStr: string): void;

        static TSOnline(): void;

        static TSSend(InMessage: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMessageChannel;

        static Load(InName: string): MWMessageChannel;
    }

    export class MWMobileEditorTouch extends CanvasPanel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileEditorTouch;

        static Load(InName: string): MWMobileEditorTouch;
    }

    export class MWSysProcedureBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _SubProcedures: TArray<MWSysProcedureBase>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProcedureBase;

        static Load(InName: string): MWSysProcedureBase;
    }

    export class MWMobileLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AdaptiveSize(TextureSize: Vector2D, World: $Nullable<Object>): Vector2D;

        static BackToLobby(World: $Nullable<World>): void;

        static ChangeUIDirection(Context: $Nullable<Object>): void;

        static CheckIsReconnectFailed(Context: $Nullable<Object>): boolean;

        static CreateCustomWidget(World: $Nullable<World>, Class: $Nullable<Class>): UserWidget;

        static GetCurrentSize(): bigint;

        static GetMWProcedure(Context: $Nullable<Object>, ProcedureName: string): MWSysProcedureBase;

        static GetMWSysDelegateManager(Context: $Nullable<Object>): MWSysDelegateManager;

        static GetNumDrawCalls(): number;

        static GetNumTriangleDrawn(): number;

        static GetStatUnitFrameTime(World: $Nullable<World>): number;

        static GetStatUnitGameThreadTime(World: $Nullable<World>): number;

        static GetStatUnitGPUTime(World: $Nullable<World>): number;

        static GetStatUnitRenderThreadTime(World: $Nullable<World>): number;

        static GetText(TextKey: string): string;

        static GetTotalSize(): bigint;

        static GetWRDownloadSpeed(Delta: number): string;

        static GetWRUpdatePercent(): number;

        static IsFromAndroid(): boolean;

        static IsInGame(Instance: $Nullable<GameInstance>): boolean;

        static LogPrint(StrContent: string): void;

        static OpenLeftUIAndCloseRight(Context: $Nullable<Object>, CloseUI: string, OpenUI: string): void;

        static SpawnActor(World: $Nullable<World>, Class: $Nullable<Class>, Transform: Transform, SpawnCollisionHandlingOverride: ESpawnActorCollisionHandlingMethod, Owner: $Nullable<Actor>, Instigator: $Nullable<Pawn>): Actor;

        static TurnToLobby(World: $Nullable<World>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileLibrary;

        static Load(InName: string): MWMobileLibrary;
    }

    export class MWRetryRMController extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Retry(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWRetryRMController;

        static Load(InName: string): MWRetryRMController;
    }

    export class FormData {
        constructor();

        static StaticClass(): Class;
    }

    export class FormData_Url extends FormData {
        constructor();
        constructor(Urls: TArray<string>);

        Urls: TArray<string>;

        static StaticClass(): Class;
    }

    export class MWMobileProcedure_ConnectRM extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bLoadUrl: number;
        ConnectUrl: string;
        RetryRMController: MWRetryRMController;

        ConnectRM(Url: string): void;

        GetUrls(): FormData_Url;

        InsertUrl(Url: string): void;

        QuitGame(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_ConnectRM;

        static Load(InName: string): MWMobileProcedure_ConnectRM;
    }

    export class MWSysPlayerControllerBase extends PlayerController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPlayerJoined: $MulticastDelegate<(PlayerController: $Nullable<MWSysPlayerControllerBase>) => void>;
        OnPlayerLeft: $MulticastDelegate<(PlayerController: $Nullable<MWSysPlayerControllerBase>) => void>;
        OnCharacterJoined: $MulticastDelegate<(Character: $Nullable<Character>) => void>;

        Client_TravelDSSucceeded(): void;

        CloseNetConnection(): void;

        GetPlayerID(): number;

        IsRunningOnClient(): boolean;

        IsRunningOnServer(): boolean;

        LeaveGame(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPlayerControllerBase;

        static Load(InName: string): MWSysPlayerControllerBase;
    }

    export class MWMobileProcedure_DS extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MWLocalPlayer: MWLocalPlayer;

        DSReconnectFalied(): void;

        OnClientTravelFailed(World: $Nullable<World>, Type: ETravelFailure, Message: string): void;

        OnClientTravelSuccess(): void;

        OnClientTravelSuccessAfter(): void;

        OnNetworkFailure(ErrorType: ENetworkFailure, Message: string): void;

        OnPlayerLeft(PlayerController: $Nullable<MWSysPlayerControllerBase>): void;

        RemoveClientTravelSuccessBind(): void;

        TurnToLobby(): void;

        TurnToReConnectDS(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_DS;

        static Load(InName: string): MWMobileProcedure_DS;
    }

    export class MWMobileProcedure_FollowRoom extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_FollowRoom;

        static Load(InName: string): MWMobileProcedure_FollowRoom;
    }

    export class MWMobileProcedure_GetState extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DSReconnectAndCloseUI(): void;

        SelectReConnectDS(bReConnect: boolean): void;

        SelectReMatch(): void;

        TurnToLobby(): void;

        TurnToMatch(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_GetState;

        static Load(InName: string): MWMobileProcedure_GetState;
    }

    export class MWMobileProcedure_IOSLogin extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_IOSLogin;

        static Load(InName: string): MWMobileProcedure_IOSLogin;
    }

    export class MWMobileProcedure_Lobby extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GameList_C: MWGameListController;

        CreateGameListUI(): void;

        GetGameList_C(): MWGameListController;

        RequestGameData(url: string, gameName: string): void;

        SelectPlayGame(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_Lobby;

        static Load(InName: string): MWMobileProcedure_Lobby;
    }

    export class MWMobileProcedure_Login extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bLogined: number;
        bReturned: number;

        Login(): void;

        LoginTimeOutBtnClick(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_Login;

        static Load(InName: string): MWMobileProcedure_Login;
    }

    export class MWMobileProcedure_LS extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPlayerLeft(PlayerController: $Nullable<MWSysPlayerControllerBase>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_LS;

        static Load(InName: string): MWMobileProcedure_LS;
    }

    export class MWMobileProcedure_Match extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CancelMatch(): void;

        MatchFailedClick(): void;

        OBRoom(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_Match;

        static Load(InName: string): MWMobileProcedure_Match;
    }

    export class MWMobileProcedure_RMLogin extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPlayerInitiativeLeave(World: $Nullable<World>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_RMLogin;

        static Load(InName: string): MWMobileProcedure_RMLogin;
    }

    export class MWMobileProcedure_TSGameEntry extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NativeStartNewGame(GameId: string, GameVersion: string, GameType: number): void;

        static StartNewGame(Context: $Nullable<Object>, GameId: string, GameVersion: string, GameType: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_TSGameEntry;

        static Load(InName: string): MWMobileProcedure_TSGameEntry;
    }

    export class MWMobileProcedure_VerifyDSVersion extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QuitGameByVerify(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_VerifyDSVersion;

        static Load(InName: string): MWMobileProcedure_VerifyDSVersion;
    }

    export class MWMobileProcedure_WRLocalLoad extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_WRLocalLoad;

        static Load(InName: string): MWMobileProcedure_WRLocalLoad;
    }

    export class MWMobileProcedure_WRUpdate extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnDownloadFailed(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_WRUpdate;

        static Load(InName: string): MWMobileProcedure_WRUpdate;
    }

    export class MWMobileProcedure_WRUpdate_LS extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QuitGameByWRUpdate_LS(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMobileProcedure_WRUpdate_LS;

        static Load(InName: string): MWMobileProcedure_WRUpdate_LS;
    }

    export class MWUIBindDataAttributes {
        constructor();

        static StaticClass(): Class;
    }

    export class MWUIWidgetBase extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FindChildByPath(InPath: string): Widget;

        GetFocusable(): boolean;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWUniqueIndex(): number;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        GetProperties(): MWUIBindDataAttributes;

        GetRootContent(): Widget;

        IsMWUIDesignerTime(): boolean;

        RemoveRootContent(): void;

        SetFocusable(InFocus: boolean): void;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        SetRootContent(Content: $Nullable<MWCanvas>): boolean;

        SetTSEventsRegister_Internal(RegisterCount?: number /* = 0 */): void;

        static TryGetAllTsEventArray(): TMap<string, number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIWidgetBase;

        static Load(InName: string): MWUIWidgetBase;
    }

    export class MWMountUIData extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UIPath: string;
        UIAsset: MWAssetRecorder;
        WidgetBase: MWUIWidgetBase;

        FixPrefabUIPathReference(BaseFinePath: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWMountUIData;

        static Load(InName: string): MWMountUIData;
    }

    export class MWNetConnection extends IpConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FinishLoad(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWNetConnection;

        static Load(InName: string): MWNetConnection;
    }

    export class MWNewLogViewSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LogTextColor: LinearColor;
        WarningTextColor: LinearColor;
        ErrorTextColor: LinearColor;
        SupportLogView: boolean;
        ThreadColumnWidth: number;
        VerbosityColumnWidth: number;
        CategoryColumnWidth: number;
        MessageColumnWidth: number;
        MaxLogCount: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWNewLogViewSettings;

        static Load(InName: string): MWNewLogViewSettings;
    }

    export class MWNiagaraComponent extends NiagaraComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetGuid(): string;

        SetNiagaraSystemAsset(InAssetGuid: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWNiagaraComponent;

        static Load(InName: string): MWNiagaraComponent;
    }

    export class MWObjectPtr extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Guid: string;
        Type: string;
        Attach: string;
        Actor: MWActor;
        Owner: MWActor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWObjectPtr;

        static Load(InName: string): MWObjectPtr;
    }

    export class MWParticleSystemComponent extends ParticleSystemComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetGuid(): string;

        SetParticleSystemAsset(InAssetGuid: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWParticleSystemComponent;

        static Load(InName: string): MWParticleSystemComponent;
    }

    export class MWPieViewportClient extends GameViewportClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScriptInputDelegate: $MulticastDelegate<(EventType: string) => void>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWPieViewportClient;

        static Load(InName: string): MWPieViewportClient;
    }

    export class MWPrefab extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssetGuid: string;

        OnRep_AssetGuid(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWPrefab;

        static Load(InName: string): MWPrefab;
    }

    export enum EProgressBarFillType {
        LeftToRight,
        RightToLeft,
        FillFromCenter,
        TopToBottom,
        BottomToTop,
        EProgressBarFillType_MAX
    }

    export class MWProgressBar extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSliderValueChange: $MulticastDelegate<(CurrentOffset: number) => void>;
        NormalThumbUIAsset: MWAssetRecorder;
        NormalBackgroundUIAsset: MWAssetRecorder;
        FillUIAsset: MWAssetRecorder;
        DisableUIAsset: MWAssetRecorder;

        GetBackgroundBrushDrawAs(): ESlateBrushDrawType;

        GetBackgroundImageColor(): LinearColor;

        GetBackgroundImageSize(): Vector2D;

        GetCurrentValue(): number;

        GetFillBrushBrushGuid(): string;

        GetFillBrushDrawAs(): ESlateBrushDrawType;

        GetFillImageColor(): LinearColor;

        GetFillImageSize(): Vector2D;

        GetFillType(): EProgressBarFillType;

        GetIsToInt(): boolean;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetNormalBackgroundBrush(): SlateBrushWithGuid;

        GetNormalBackgroundBrushGuid(): string;

        GetNormalThumbBrushGuid(): string;

        GetOriginEventName(): string;

        GetPercent(): number;

        GetSliderMaxValue(): number;

        GetSliderMinValue(): number;

        GetThumbImageColor(): LinearColor;

        GetThumbImageDrawAs(): ESlateBrushDrawType;

        GetThumbImageSize(): Vector2D;

        SetBackgroundBrushDrawAs(InDrawAs: ESlateBrushDrawType): void;

        SetBackgroundImageColor(InColor: LinearColor): void;

        SetBackgroundImageSize(InSize: Vector2D): void;

        SetCurrentValue(InValue: number): void;

        SetDisabledBarBrushByGuid(InGuid: string, bMatchSize?: boolean /* = true */): void;

        SetFillBrushBrushByGuid(InGuid: string, bMatchSize?: boolean /* = true */): void;

        SetFillBrushDrawAs(InDrawAs: ESlateBrushDrawType): void;

        SetFillImageColor(InColor: LinearColor): void;

        SetFillImageSize(InSize: Vector2D): void;

        SetFillType(InType: EProgressBarFillType): void;

        SetIsToInt(InToInt: boolean): void;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        SetNormalBackgroundBrushByGuid(InGuid: string, bMatchSize?: boolean /* = true */): void;

        SetNormalThumbBrushByGuid(InGuid: string, bMatchSize?: boolean /* = true */): void;

        SetPercent(InPercent: number): void;

        SetSliderMaxValue(InValue: number): void;

        SetSliderMinValue(InValue: number): void;

        SetThumbImageColor(InColor: LinearColor): void;

        SetThumbImageDrawAs(InDrawAs: ESlateBrushDrawType): void;

        SetThumbImageSize(InSize: Vector2D): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWProgressBar;

        static Load(InName: string): MWProgressBar;
    }

    export class RichTextBlockDecorator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RichTextBlockDecorator;

        static Load(InName: string): RichTextBlockDecorator;
    }

    export class RichTextBlock extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Text: string;
        TextStyleSet: DataTable;
        DecoratorClasses: TArray<Class>;
        bOverrideDefaultStyle: boolean;
        DefaultTextStyleOverride: TextBlockStyle;
        MinDesiredWidth: number;
        TextTransformPolicy: ETextTransformPolicy;
        DefaultTextStyle: TextBlockStyle;
        InstanceDecorators: TArray<RichTextBlockDecorator>;

        ClearAllDefaultStyleOverrides(): void;

        GetDecoratorByClass(DecoratorClass: $Nullable<Class>): RichTextBlockDecorator;

        GetText(): string;

        SetAutoWrapText(InAutoTextWrap: boolean): void;

        SetDefaultColorAndOpacity(InColorAndOpacity: SlateColor): void;

        SetDefaultFont(InFontInfo: SlateFontInfo): void;

        SetDefaultShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;

        SetDefaultShadowOffset(InShadowOffset: Vector2D): void;

        SetDefaultStrikeBrush(InStrikeBrush: $Ref<SlateBrush>): void;

        SetDefaultTextStyle(InDefaultTextStyle: TextBlockStyle): void;

        SetMinDesiredWidth(InMinDesiredWidth: number): void;

        SetText(InText: string): void;

        SetTextStyleSet(NewTextStyleSet: $Nullable<DataTable>): void;

        SetTextTransformPolicy(InTransformPolicy: ETextTransformPolicy): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RichTextBlock;

        static Load(InName: string): RichTextBlock;
    }

    export class MWRichTextBlockExtend extends RichTextBlock {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWRichTextBlockExtend;

        static Load(InName: string): MWRichTextBlockExtend;
    }

    export class ChangeHistoryRecord {
        constructor();
        constructor(TargetObject: Object, Description: string);

        TargetObject: Object;
        Description: string;

        static StaticClass(): Class;
    }

    export class ChangeHistoryTransaction {
        constructor();
        constructor(Records: TArray<ChangeHistoryRecord>, Description: string);

        Records: TArray<ChangeHistoryRecord>;
        Description: string;

        static StaticClass(): Class;
    }

    export class MWSceneHistoryManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Transactions: TArray<ChangeHistoryTransaction>;
        ActiveTransaction: ChangeHistoryTransaction;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSceneHistoryManager;

        static Load(InName: string): MWSceneHistoryManager;
    }

    export enum EMWFormType { FullScreen, Window, Tips, EMWFormType_MAX }

    export class MWUIBase extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FormId: string;
        FormType: EMWFormType;

        BPOnDestroy(): void;

        BPOnHide(): void;

        BPOnInit(): void;

        BPOnShow(): void;

        CloseSelf(): void;

        GetFormType(): EMWFormType;

        SetFormType(Type: EMWFormType): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIBase;

        static Load(InName: string): MWUIBase;
    }

    export class MWScreenUI extends MWUIBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWScreenUI;

        static Load(InName: string): MWScreenUI;
    }

    export enum EDataStorageEnv { Local, MGSDev, MGSPre, MGS, EDataStorageEnv_MAX }

    export class MWTypeScriptGame extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPlayerJoined: $MulticastDelegate<(PlayerController: $Nullable<MWSysPlayerControllerBase>) => void>;
        OnPlayerLeft: $MulticastDelegate<(PlayerController: $Nullable<MWSysPlayerControllerBase>) => void>;
        NotifyDataSave: $MulticastDelegate<(Result: boolean) => void>;
        NotifyDataGet: $MulticastDelegate<(Data: string) => void>;
        SpawnDelegateNotify: $Delegate<(bSuccess: boolean, Actor: $Nullable<Actor>, Msg: string) => void>;
        NotifyWindowActivated: $MulticastDelegate<() => void>;
        NotifyWindowDeactivated: $MulticastDelegate<() => void>;
        NotifyTravelSuccess: $MulticastDelegate<() => void>;

        DataGet(Key: string): void;

        DataSave(UserId: string, Data: string): void;

        IsRunningClient(): boolean;

        OnPlayerJoinedCalled(PlayerController: $Nullable<MWSysPlayerControllerBase>): void;

        OnPlayerLeftCalled(PlayerController: $Nullable<MWSysPlayerControllerBase>): void;

        OnTravelSuccess(): void;

        SetEvn(Env: EDataStorageEnv): void;

        static GetWindowIsActive(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTypeScriptGame;

        static Load(InName: string): MWTypeScriptGame;
    }

    export class MWSysTypeScriptProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Game: MWTypeScriptGame;
        BindJS: $Delegate<(ScriptUrl: string, InJsActor: $Nullable<Actor>) => boolean>;
        BindGameObjectPipe: $Delegate<(InGuid: string, InActor: $Nullable<Actor>) => boolean>;
        Shutdown: $Delegate<() => void>;
        LoadInit: $Delegate<() => void>;
        GmConsole: $Delegate<(Show: boolean) => void>;
        CreateActor: $Delegate<(actor: $Nullable<Actor>) => void>;
        Destroy: $Delegate<(actor: $Nullable<Actor>) => void>;
        ForceReload: $Delegate<() => void>;
        IsEditor: boolean;
        IsServer: boolean;
        IsListenServer: boolean;
        IsDebug: boolean;
        IsPie: boolean;
        ProjectDir: string;

        InitStringStack(InSize: number): void;

        InitVectorStack(InSize: number): void;

        TestGetNumber(): number;

        TestGetString(): string;

        TestGetVector(): Vector;

        TestSetNumber(InNumber: number): void;

        TestSetString(InString: string): void;

        TestSetVector(InVector: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysTypeScriptProxy;

        static Load(InName: string): MWSysTypeScriptProxy;
    }

    export class MWScriptEnv extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScriptProxy: MWSysTypeScriptProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWScriptEnv;

        static Load(InName: string): MWScriptEnv;
    }

    export enum EMWUIScrollBoxAnimationType { ElasticAnimation, NoneLimit, Limit, EMWUIScrollBoxAnimationType_MAX }

    export enum EMWDescendantScrollDestination { IntoView, TopOrLeft, Center, EMWDescendantScrollDestination_MAX }

    export class MWScrollBox extends MWPanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnUserScrolled: $MulticastDelegate<(CurrentOffset: number) => void>;

        EndInertialScrolling(): void;

        GetAlwaysShowScrollbar(): boolean;

        GetAnimationType(): EMWUIScrollBoxAnimationType;

        GetElasticMultiplier(): number;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOrientation(): EOrientation;

        GetOriginEventName(): string;

        GetScrollAxisColor(): LinearColor;

        GetScrollbarThickness(): Vector2D;

        GetScrollBarVisible(): ESlateVisibility;

        GetScrollOffset(): number;

        GetScrollOffsetOfEnd(): number;

        GetShadowVisibility(): ESlateVisibility;

        GetSupportElastic(): boolean;

        GetViewOffsetFraction(): number;

        ScrollToEnd(): void;

        ScrollToStart(): void;

        ScrollWidgetIntoView(WidgetToFind: $Nullable<Widget>, AnimateScroll?: boolean /* = true */, ScrollDestination?: EMWDescendantScrollDestination /* = IntoView */, Padding?: number /* = 0.000000 */): void;

        SetAllowOverscroll(NewAllowOverscroll: boolean): void;

        SetAlwaysShowScrollbar(NewAlwaysShowScrollbar: boolean): void;

        SetAnimateWheelScrolling(bShouldAnimateWheelScrolling: boolean): void;

        SetAnimationType(InAnimationType: EMWUIScrollBoxAnimationType): void;

        SetConsumeMouseWheel(NewConsumeMouseWheel: EConsumeMouseWheel): void;

        SetElasticMultiplier(InElasticMultiplier: number): void;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        SetOrientation(NewOrientation: EOrientation): void;

        SetScrollAxisColor(NewScrollAxisColor: LinearColor): void;

        SetScrollbarPadding(NewScrollbarPadding: Margin): void;

        SetScrollbarThickness(NewScrollbarThickness: Vector2D): void;

        SetScrollBarVisible(NewScrollBarVisibility: ESlateVisibility): void;

        SetScrollOffset(NewScrollOffset: number): void;

        SetShadowVisibility(InVisible: ESlateVisibility): void;

        SetSupportElastic(InSupportElastic: boolean): void;

        SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWScrollBox;

        static Load(InName: string): MWScrollBox;
    }

    export class ScrollBoxStyle extends SlateWidgetStyle {
        constructor();
        constructor(TopShadowBrush: SlateBrush, BottomShadowBrush: SlateBrush, LeftShadowBrush: SlateBrush, RightShadowBrush: SlateBrush);

        TopShadowBrush: SlateBrush;
        BottomShadowBrush: SlateBrush;
        LeftShadowBrush: SlateBrush;
        RightShadowBrush: SlateBrush;

        static StaticClass(): Class;
    }

    export enum EDescendantScrollDestination { IntoView, TopOrLeft, Center, EDescendantScrollDestination_MAX }

    export enum EScrollWhenFocusChanges { NoScroll, InstantScroll, AnimatedScroll, EScrollWhenFocusChanges_MAX }

    export class ScrollBox extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetStyle: ScrollBoxStyle;
        WidgetBarStyle: ScrollBarStyle;
        Style: SlateWidgetStyleAsset;
        BarStyle: SlateWidgetStyleAsset;
        Orientation: EOrientation;
        ScrollBarVisibility: ESlateVisibility;
        ConsumeMouseWheel: EConsumeMouseWheel;
        ScrollbarThickness: Vector2D;
        ScrollbarPadding: Margin;
        AlwaysShowScrollbar: boolean;
        AlwaysShowScrollbarTrack: boolean;
        AllowOverscroll: boolean;
        bAnimateWheelScrolling: boolean;
        NavigationDestination: EDescendantScrollDestination;
        NavigationScrollPadding: number;
        ScrollWhenFocusChanges: EScrollWhenFocusChanges;
        bAllowRightClickDragScrolling: boolean;
        WheelScrollMultiplier: number;
        OnUserScrolled: $MulticastDelegate<(CurrentOffset: number) => void>;

        EndInertialScrolling(): void;

        GetScrollOffset(): number;

        GetScrollOffsetOfEnd(): number;

        GetViewOffsetFraction(): number;

        ScrollToEnd(): void;

        ScrollToStart(): void;

        ScrollWidgetIntoView(WidgetToFind: $Nullable<Widget>, AnimateScroll?: boolean /* = true */, ScrollDestination?: EDescendantScrollDestination /* = IntoView */, Padding?: number /* = 0.000000 */): void;

        SetAllowOverscroll(NewAllowOverscroll: boolean): void;

        SetAlwaysShowScrollbar(NewAlwaysShowScrollbar: boolean): void;

        SetAnimateWheelScrolling(bShouldAnimateWheelScrolling: boolean): void;

        SetConsumeMouseWheel(NewConsumeMouseWheel: EConsumeMouseWheel): void;

        SetOrientation(NewOrientation: EOrientation): void;

        SetScrollbarPadding(NewScrollbarPadding: Margin): void;

        SetScrollbarThickness(NewScrollbarThickness: Vector2D): void;

        SetScrollBarVisibility(NewScrollBarVisibility: ESlateVisibility): void;

        SetScrollOffset(NewScrollOffset: number): void;

        SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScrollBox;

        static Load(InName: string): ScrollBox;
    }

    export class MWScrollBoxStyle extends ScrollBoxStyle {
        constructor();
        constructor(TopShadowBrushExtend: MWSlateBrush, BottomShadowBrushExtend: MWSlateBrush, LeftShadowBrushExtend: MWSlateBrush, RightShadowBrushExtend: MWSlateBrush);

        TopShadowBrushExtend: MWSlateBrush;
        BottomShadowBrushExtend: MWSlateBrush;
        LeftShadowBrushExtend: MWSlateBrush;
        RightShadowBrushExtend: MWSlateBrush;

        static StaticClass(): Class;
    }

    export class MWScrollBarStyle extends ScrollBarStyle {
        constructor();
        constructor(HorizontalBackgroundImageExtend: MWSlateBrush, VerticalBackgroundImageExtend: MWSlateBrush, VerticalTopSlotImageExtend: MWSlateBrush, HorizontalTopSlotImageExtend: MWSlateBrush, VerticalBottomSlotImageExtend: MWSlateBrush, HorizontalBottomSlotImageExtend: MWSlateBrush, NormalThumbImageExtend: MWSlateBrush, HoveredThumbImageExtend: MWSlateBrush, DraggedThumbImageExtend: MWSlateBrush);

        HorizontalBackgroundImageExtend: MWSlateBrush;
        VerticalBackgroundImageExtend: MWSlateBrush;
        VerticalTopSlotImageExtend: MWSlateBrush;
        HorizontalTopSlotImageExtend: MWSlateBrush;
        VerticalBottomSlotImageExtend: MWSlateBrush;
        HorizontalBottomSlotImageExtend: MWSlateBrush;
        NormalThumbImageExtend: MWSlateBrush;
        HoveredThumbImageExtend: MWSlateBrush;
        DraggedThumbImageExtend: MWSlateBrush;

        static StaticClass(): Class;
    }

    export class MWScrollBoxExtend extends ScrollBox {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetStyleExtend: MWScrollBoxStyle;
        WidgetBarStyleExtend: MWScrollBarStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWScrollBoxExtend;

        static Load(InName: string): MWScrollBoxExtend;
    }

    export class ScrollerDataS {
        constructor();
        constructor(Row: number, Col: number);

        Row: number;
        Col: number;

        static StaticClass(): Class;
    }

    export class GameInfoScrollerData extends ScrollerDataS {
        constructor();
        constructor(GameData: GameData);

        GameData: GameData;

        static StaticClass(): Class;
    }

    export class MWScrollerView_GameInfoItem extends MWScrollerView_Item {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetScrollerData(): GameInfoScrollerData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWScrollerView_GameInfoItem;

        static Load(InName: string): MWScrollerView_GameInfoItem;
    }

    export class MWSerialize extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSerialize;

        static Load(InName: string): MWSerialize;
    }

    export enum EGetSKComStrategy { Default, Pool, EGetSKComStrategy_MAX }

    export class MWSKComManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddSKComponent(Owner: $Nullable<Character>, NewSkeletalMesh: $Nullable<SkeletalMesh>, MeshMaterials: TArray<MaterialInterface>, bUseMasterPose?: boolean /* = true */, SocketName?: string /* = "None" */, DynamicAssetPath?: string /* = "None" */): SkeletalMeshComponent;

        AddSKComponentWithAssetData(Owner: $Nullable<Character>, AssetData: MWSKAssetData): SkeletalMeshComponent;

        RegisterGetSKComImpl(Strategy: EGetSKComStrategy): void;

        RemoveSKComponent(TargetComp: $Nullable<SkeletalMeshComponent>): void;

        TempLoadSk(FilePath: string): SkeletalMesh;

        static Instance(): MWSKComManager;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSKComManager;

        static Load(InName: string): MWSKComManager;
    }

    export class MWSkeletalMeshActorCreator extends MWSysActorCreator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSkeletalMeshActorCreator;

        static Load(InName: string): MWSkeletalMeshActorCreator;
    }

    export class MWSkeletalMeshComponent extends SkeletalMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddOutlineEffect(): void;

        CreateDynamicMaterial(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSkeletalMeshComponent;

        static Load(InName: string): MWSkeletalMeshComponent;
    }

    export class MWSkillCheatManager extends CheatManager {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MWSkill_AbilitySystemNextCategory(): void;

        MWSkill_ShowDebugAbilitySystem(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSkillCheatManager;

        static Load(InName: string): MWSkillCheatManager;
    }

    export class MWSKSlotsForEditor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSKSlotsForEditor;

        static Load(InName: string): MWSKSlotsForEditor;
    }

    export enum EConstraint {
        None,
        All,
        Position_X,
        Position_Y,
        Position_Z,
        Rotation_X,
        Rotation_Y,
        Rotation_Z,
        EConstraint_MAX
    }

    export class MWStaticMeshActor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StaticMeshComponent: MWStaticMeshComponent;
        bSimulatePhysics: boolean;
        bEnableMass: boolean;
        bEnableGravity: boolean;
        bIgnoreRadialImpulse: boolean;
        bIgnoreRadialForce: boolean;
        bApplyImpulseOnDamage: boolean;
        MassInKg: number;
        LinerDamping: number;
        AngularDamping: number;
        bIsEnableOutline: boolean;
        OutlineColorIndex: number;
        bUseSmoothSync: boolean;

        GetEnableOutline(): boolean;

        GetOutlineColorIndex(): number;

        GetPhysicalConstraint(InPhysicalConstraint: EConstraint): boolean;

        GetSimulatePhysics(): boolean;

        GetStaticMeshComponent(): MWStaticMeshComponent;

        HandleComponentStaticMeshChanged(): void;

        RefreshPhysics(): void;

        SetEnableOutline(bNewEnableOutline: boolean): void;

        SetOutlineAndColor(bNewEnableOutline: boolean, NewOutlineColorIndex: number): void;

        SetOutlineColorIndex(NewOutlineColorIndex: number): void;

        SetPhysicalConstraint(InPhysicalConstraint: EConstraint, InValue: boolean): void;

        SetSimulatePhysics(bInSimulatePhysics: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWStaticMeshActor;

        static Load(InName: string): MWStaticMeshActor;
    }

    export enum EMWSysAbilityCellType { None, Animation, EMWSysAbilityCellType_MAX }

    export enum EMWSysAbilityCellSyncFlag { Normal, OnlyOnServer, OnlyOnClient, EMWSysAbilityCellSyncFlag_MAX }

    export class MWSysAbilityCellData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CellType: EMWSysAbilityCellType;
        SyncFlag: EMWSysAbilityCellSyncFlag;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityCellData;

        static Load(InName: string): MWSysAbilityCellData;
    }

    export class MWSysAbilityStateData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ExecuteTime: number;
        Controllability: number;
        ServerSwitch: boolean;
        FACellDatas: TArray<MWSysAbilityCellData>;
        Duration: number;
        IsLoop: boolean;
        AnimAssetGUID: string;
        CellType: EMWSysAbilityCellType;
        SyncFlag: EMWSysAbilityCellSyncFlag;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityStateData;

        static Load(InName: string): MWSysAbilityStateData;
    }

    export class MWSysAbilityData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ServerTimerSyncFreq: number;
        ForceSyncErrorTime: number;
        FAStateDatas: TArray<MWSysAbilityStateData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityData;

        static Load(InName: string): MWSysAbilityData;
    }

    export class MWSysAbilityObj extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FAObjData: MWSysAbilityData;
        OnAbilityStateEnter: $Delegate<(StateIndex: number, AbilityState: $Nullable<MWSysAbilityState>) => void>;
        OnAbilityStateExit: $Delegate<(StateIndex: number, AbilityState: $Nullable<MWSysAbilityState>) => void>;
        OnAbilityStatePause: $Delegate<(StateIndex: number, AbilityState: $Nullable<MWSysAbilityState>) => void>;
        OnAbilityStateResume: $Delegate<(StateIndex: number, AbilityState: $Nullable<MWSysAbilityState>) => void>;
        OnAbilityStateChanged: $Delegate<(AbilityState: $Nullable<MWSysAbilityState>) => void>;
        AbilityStates: TArray<MWSysAbilityState>;
        CurAbilityState: MWSysAbilityState;
        fServerTimeStamp: number;
        bIsPause: boolean;
        bIsReady: boolean;
        bInited: boolean;
        iCurAbilityStateIndexLocal: number;
        fServerTimerSyncFreq: number;
        fForceSyncErrorTime: number;

        Activate(): void;

        AddAbilityState(): void;

        Deactivate(): void;

        GetAbilityStateByIndex(Index: number): MWSysAbilityState;

        GetCurAbilityState(): MWSysAbilityState;

        GetDuration(): number;

        IsReady(): boolean;

        NetMulticast_Deactivate(): void;

        NetMulticast_SwitchTo(StateIndex: number): void;

        OnRep_AbilityDataChanged(): void;

        OnRep_AbilityStateChanged(): void;

        OnRep_ServerFlagSync(): void;

        Pause(): void;

        Resume(): void;

        Server_Deactivate(): void;

        Server_Pause(): void;

        Server_Resume(): void;

        Server_SetAbilityData(AbilityData: $Nullable<MWSysAbilityData>): void;

        Server_SwitchTo(StateIndex: number): void;

        SwitchTo(StateIndex: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityObj;

        static Load(InName: string): MWSysAbilityObj;
    }

    export enum EMWSysAbilityStateControlType { None, CanMove, CanJump, CanTurn, EMWSysAbilityStateControlType_MAX }

    export enum EMWSysAbilityStateFlag { None, Awake, Ready, Update, End, Destroy, EMWSysAbilityStateFlag_MAX }

    export class MWSysAbilityState extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FAStateData: MWSysAbilityStateData;
        AbilityCells: TArray<MWSysAbilityCell>;
        AbilityStateOwner: MWSysAbilityObj;

        CanJump(): boolean;

        CanMove(): boolean;

        CanTurn(): boolean;

        GetAbilityCells(): TArray<MWSysAbilityCell>;

        GetAbilityStateFlag(): EMWSysAbilityStateFlag;

        GetAbilityStateOwner(): MWSysAbilityObj;

        GetAnimationGUID(): string;

        GetDuration(): number;

        GetExecuteTime(): number;

        IsLoop(): boolean;

        NetMulticast_AddControllability(ControlType: EMWSysAbilityStateControlType): void;

        NetMulticast_CancelControllability(ControlType: EMWSysAbilityStateControlType): void;

        NetMulticast_SetAnimation(AnimGuid: string): void;

        NetMulticast_SetExecuteTime(Time: number): void;

        NetMulticast_SetLoop(Loop: boolean): void;

        Server_AddControllability(ControlType: EMWSysAbilityStateControlType): void;

        Server_CancelControllability(ControlType: EMWSysAbilityStateControlType): void;

        Server_SetAnimation(AnimGuid: string): void;

        Server_SetExecuteTime(Time: number): void;

        Server_SetLoop(Loop: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityState;

        static Load(InName: string): MWSysAbilityState;
    }

    export enum EMWSysAbilityCellFlag { Awake, Begin, Update, End, Destroy, EMWSysAbilityCellFlag_MAX }

    export class MWSysAbilityCell extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AbilityCellType: EMWSysAbilityCellType;
        AbilityCellSyncFlag: EMWSysAbilityCellSyncFlag;
        AbilityCellOwner: MWSysAbilityState;
        EMCellFlag: EMWSysAbilityCellFlag;

        GetAbilityCellFlag(): EMWSysAbilityCellFlag;

        GetAbilityCellOwner(): MWSysAbilityState;

        GetAbilityCellSyncFlag(): EMWSysAbilityCellSyncFlag;

        GetAbilityCellType(): EMWSysAbilityCellType;

        GetDuration(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityCell;

        static Load(InName: string): MWSysAbilityCell;
    }

    export class MWSysAbilityAnimCell extends MWSysAbilityCell {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CharacterOwner: MWSysCharacter;
        Animation: AnimMontage;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityAnimCell;

        static Load(InName: string): MWSysAbilityAnimCell;
    }

    export class MWSysAbilityAnimCellData extends MWSysAbilityCellData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Duration: number;
        IsLoop: boolean;
        AnimAssetGUID: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityAnimCellData;

        static Load(InName: string): MWSysAbilityAnimCellData;
    }

    export class MWSysAbilityCellClassFactory extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAbilityCellClassFactory;

        static Load(InName: string): MWSysAbilityCellClassFactory;
    }

    export class MWSysActorFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NewActorClassName: string;
        NewActorClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysActorFactory;

        static Load(InName: string): MWSysActorFactory;
    }

    export class MWSysActorFactoryBoxVolume extends MWSysActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysActorFactoryBoxVolume;

        static Load(InName: string): MWSysActorFactoryBoxVolume;
    }

    export enum EMWAttenuationDistanceModel {
        Linear,
        Logarithmic,
        Inverse,
        LogReverse,
        EMWAttenuationDistanceModel_MAX
    }

    export enum EMWAttenuationShape { Sphere, Capsule, Box, EMWAttenuationShape_MAX }

    export enum EPlayState { Play, Stop, Pause, EPlayState_MAX }

    export class MWSysAmbientSound extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsDrawBoundsLine: boolean;
        bAllowSpatialization: boolean;
        VolumeMultiplier: number;
        AudioLength: number;
        RemainTime: number;
        PlayEndTime: DateTime;
        bIsUISound: boolean;
        bButtonLoopUp: boolean;
        bShouldPlay: boolean;
        Function: EMWAttenuationDistanceModel;
        Shape: EMWAttenuationShape;
        Sphere_InnerRadius: number;
        Capsule_HalfHeight: number;
        Box_ExtentsX: number;
        Box_ExtentsY: number;
        Box_ExtentsZ: number;
        MaxDistance: number;
        InnerSphere: SphereComponent;
        MaxSphereDistance: SphereComponent;
        InnerBox: BoxComponent;
        MaxBoxDistance: BoxComponent;
        InnerCapsule: CapsuleComponent;
        MaxCapsuleDistance: CapsuleComponent;
        AudioAsset: MWAssetRecorder;
        color: Color;
        lifeTime: number;
        NumSides: number;
        DepthPriority: number;
        SoundFinishDelegate: $MulticastDelegate<() => void>;
        OnSoundStartDelegate: $MulticastDelegate<() => void>;
        IconSprite: BillboardComponent;
        AudioComponent: AudioComponent;

        ButtonPlay(): void;

        ButtonStop(): void;

        DrawInnerSphereBounds(): void;

        GetAllowSpatialization(): boolean;

        GetAttenuationFunction(): EMWAttenuationDistanceModel;

        GetAttenuationShap(): EMWAttenuationShape;

        GetAudioComponent(): AudioComponent;

        GetBox_ExtentsX(): number;

        GetBox_ExtentsY(): number;

        GetBox_ExtentsZ(): number;

        GetCapsule_HalfHeight(): number;

        GetCapsule_Radius(): number;

        GetIsUISound(): boolean;

        GetMaxDistance(): number;

        GetPlayState(): boolean;

        GetSoundPlayState(): EPlayState;

        GetSphere_InnerRadius(): number;

        GetStartLoop(): boolean;

        GetVolumeMultiplier(): number;

        HiddenShowShap_Box(bShow: boolean): void;

        HiddenShowShap_Capsule(bShow: boolean): void;

        HiddenShowShap_Sphere(bShow: boolean): void;

        PlayVoice(): void;

        PlayVoice1(bButton: boolean): void;

        SetAllowSpatialization(bNewAllowSpatialization: boolean): void;

        SetAttenuationFunction(NewFunction: EMWAttenuationDistanceModel): void;

        SetAttenuationShap(NewShap: EMWAttenuationShape): void;

        SetAudioAssest_Guid(InAssetGuid: string): void;

        SetBox_ExtentsX(NewBox_ExtentsX: number): void;

        SetBox_ExtentsY(NewBox_ExtentsY: number): void;

        SetBox_ExtentsZ(NewBox_ExtentsZ: number): void;

        SetCapsule_HalfHeight(NewCapsule_HalfHeight: number): void;

        SetCapsule_Radius(NewCapsule_Radius: number): void;

        SetInnerSphereBoundsParam(): void;

        SetIsDrawInnerBounds(IsDraw: boolean): void;

        SetIsUISound(bNewIsUISound: boolean): void;

        SetMaxDistance(NewMaxDistance: number): void;

        SetSphere_InnerRadius(NewSphere_InnerRadius: number): void;

        SetStartLoop(bNewAllowSpatialization: boolean): void;

        SetVolumeMultiplier(NewVolumeMultiplier: number): void;

        ShowShapDebugDraw(Shap: EMWAttenuationShape): void;

        StartLoopPlayVoice(): void;

        StopVoice(): void;

        StopVoice1(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAmbientSound;

        static Load(InName: string): MWSysAmbientSound;
    }

    export class MWSysAnchor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAnchor;

        static Load(InName: string): MWSysAnchor;
    }

    export class MWSysAnimInstanceProxy_MultiSkeleton extends AnimInstanceProxy {
        constructor();
        constructor(bIsInAir: boolean, bIsFullBody: boolean, bIsAccelerating: boolean, bUseStance: boolean, bUseFullBody: boolean, bUseAimOffset: boolean, bUseControllerYaw: boolean, OwnerPawn: Pawn, Speed: number, Roll: number, Pitch: number, Yaw: number, LeanIntensityScaling: number, LeanInterpSpeed: number, YawDelta: number, Direction: number, Velocity: Vector, RotationLastTick: Rotator);

        bIsInAir: boolean;
        bIsFullBody: boolean;
        bIsAccelerating: boolean;
        bUseStance: boolean;
        bUseFullBody: boolean;
        bUseAimOffset: boolean;
        bUseControllerYaw: boolean;
        OwnerPawn: Pawn;
        Speed: number;
        Roll: number;
        Pitch: number;
        Yaw: number;
        LeanIntensityScaling: number;
        LeanInterpSpeed: number;
        YawDelta: number;
        Direction: number;
        Velocity: Vector;
        RotationLastTick: Rotator;

        static StaticClass(): Class;
    }

    export class MWStanceData extends TableRowBase {
        constructor();
        constructor(BeforeCast: AnimSequenceBase, StanceIdle: AnimSequenceBase, StanceBlendSpace: BlendSpace, StanceAimOffset: AimOffsetBlendSpace);

        BeforeCast: AnimSequenceBase;
        StanceIdle: AnimSequenceBase;
        StanceBlendSpace: BlendSpace;
        StanceAimOffset: AimOffsetBlendSpace;

        static StaticClass(): Class;
    }

    export class MWAnimDataRow_MultiSkeleton extends TableRowBase {
        constructor();
        constructor(Idle: AnimSequence, JogStart: AnimSequenceBase, JogStop: AnimSequenceBase, JogBlendSpace: BlendSpaceBase, JogBlendSpace_Eight: BlendSpaceBase, JumpStart: AnimSequenceBase, JumpApex: AnimSequenceBase, JumpPreLand: AnimSequenceBase, JumpRecovery: AnimSequenceBase, AimOffset: BlendSpaceBase, IKAnimInstance: Class, Stances: TArray<MWStanceData>);

        Idle: AnimSequence;
        JogStart: AnimSequenceBase;
        JogStop: AnimSequenceBase;
        JogBlendSpace: BlendSpaceBase;
        JogBlendSpace_Eight: BlendSpaceBase;
        JumpStart: AnimSequenceBase;
        JumpApex: AnimSequenceBase;
        JumpPreLand: AnimSequenceBase;
        JumpRecovery: AnimSequenceBase;
        AimOffset: BlendSpaceBase;
        IKAnimInstance: Class;
        Stances: TArray<MWStanceData>;

        static StaticClass(): Class;
    }

    export class MWSysAnimInstance_MultiSkeleton extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseStance: boolean;
        bUseFullBody: boolean;
        bUseAimOffset: boolean;
        _Proxy: MWSysAnimInstanceProxy_MultiSkeleton;
        AnimData: MWAnimDataRow_MultiSkeleton;
        CurrentStance: MWStanceData;

        ClearAnimStance(): void;

        GetProxy(): MWSysAnimInstanceProxy_MultiSkeleton;

        SetAnimStance(StanceId: number, IsUseFullBody: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysAnimInstance_MultiSkeleton;

        static Load(InName: string): MWSysAnimInstance_MultiSkeleton;
    }

    export class MWSysBlockingArea extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _Root: StaticMeshComponent;
        _BoxUp: BoxComponent;
        _BoxDown: BoxComponent;
        _BoxRight: BoxComponent;
        _BoxLeft: BoxComponent;
        _BoxForward: BoxComponent;
        _BoxBack: BoxComponent;
        IconSprite: BillboardComponent;

        SetComponentHiddenStatus(bStatus: boolean): void;

        static SetActorPassable(TargetActor: $Nullable<Actor>, CanPass: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysBlockingArea;

        static Load(InName: string): MWSysBlockingArea;
    }

    export class MWSysCollisionProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnEnter: $MulticastDelegate<(Actor: $Nullable<Actor>) => void>;
        OnLeave: $MulticastDelegate<(Actor: $Nullable<Actor>) => void>;

        InArea(InActor: $Nullable<Actor>): boolean;

        OnBeginOverlap(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult): void;

        OnEndOverlap(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCollisionProxy;

        static Load(InName: string): MWSysCollisionProxy;
    }

    export class MWSysBoxComponent extends BoxComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _CollisionProxy: MWSysCollisionProxy;

        GetCollisionProxy(): MWSysCollisionProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysBoxComponent;

        static Load(InName: string): MWSysBoxComponent;
    }

    export enum EMWSysTriggerShape { Box, Sphere, EMWSysTriggerShape_MAX }

    export class MWSysSphereComponent extends SphereComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _CollisionProxy: MWSysCollisionProxy;

        GetCollisionProxy(): MWSysCollisionProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSphereComponent;

        static Load(InName: string): MWSysSphereComponent;
    }

    export class MWSysBoxTrigger extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TriggerShape: EMWSysTriggerShape;
        BoxComponent: MWSysBoxComponent;
        MWRootComponent: SceneComponent;
        SphereComponent: MWSysSphereComponent;
        IconSprite: BillboardComponent;

        GetBoxComponent(): MWSysBoxComponent;

        GetSphereComponent(): MWSysSphereComponent;

        SetTriggerShape(InTriggerShape: EMWSysTriggerShape): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysBoxTrigger;

        static Load(InName: string): MWSysBoxTrigger;
    }

    export class MWSysBrushBuilder extends BrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysBrushBuilder;

        static Load(InName: string): MWSysBrushBuilder;
    }

    export class MWSysButton extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ButtonPlay(): void;

        ButtonStop(): void;

        GetSoundPlayState(): EPlayState;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysButton;

        static Load(InName: string): MWSysButton;
    }

    export class SpringArmComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetArmLength: number;
        SocketOffset: Vector;
        TargetOffset: Vector;
        ProbeSize: number;
        ProbeChannel: ECollisionChannel;
        bDoCollisionTest: boolean;
        bUsePawnControlRotation: boolean;
        bInheritPitch: boolean;
        bInheritYaw: boolean;
        bInheritRoll: boolean;
        bEnableCameraLag: boolean;
        bEnableCameraRotationLag: boolean;
        bUseCameraLagSubstepping: boolean;
        bDrawDebugLagMarkers: boolean;
        CameraLagSpeed: number;
        CameraRotationLagSpeed: number;
        CameraLagMaxTimeStep: number;
        CameraLagMaxDistance: number;

        GetTargetRotation(): Rotator;

        GetUnfixedCameraPosition(): Vector;

        IsCollisionFixApplied(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpringArmComponent;

        static Load(InName: string): SpringArmComponent;
    }

    export enum GameModePP { Fixed, FreeCam_Default, FreeCam, FirstPerson, ThirdPerson, GameModePP_MAX }

    export class MWSysCameraSetting extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetArmLength: number;
        bEnableCameraLag: boolean;
        CameraLagSpeed: number;
        GameModeEnum: GameModePP;
        bUsePawnControlRotation: boolean;
        bInheritPitch: boolean;
        bInheritYaw: boolean;
        bInheritRoll: boolean;
        bEnableAdjustDistance: boolean;
        MinDistance: number;
        MaxDistance: number;
        CameraOffset: Vector;
        CameraRotation: Rotator;
        SpringArmComponent: SpringArmComponent;

        GetCameraLagSpeed(): number;

        GetCameraOffset(): Vector;

        GetCameraRotation(): Rotator;

        GetEnableAdjustDistance(): boolean;

        GetEnableCameraLag(): boolean;

        GetGameModeEnum(): GameModePP;

        GetInheritPitch(): boolean;

        GetInheritRoll(): boolean;

        GetInheritYaw(): boolean;

        GetMaxDistance(): number;

        GetMinDistance(): number;

        GetTargetArmLength(): number;

        GetUsePawnControlRotation(): boolean;

        SetCameraLagSpeed(NewCameraLagSpeed: number): void;

        SetCameraOffset(NewCameraOffset: Vector): void;

        SetCameraRotation(NewCameraRotation: Rotator): void;

        SetEnableAdjustDistance(NewEnableAdjustDistance: boolean): void;

        SetEnableCameraLag(NewEnableCameraLag: boolean): void;

        SetGameModeEnum(NewGameModeEnum: GameModePP): void;

        SetInheritPitch(NewInheritPitch: boolean): void;

        SetInheritRoll(NewInheritRoll: boolean): void;

        SetInheritYaw(NewInheritYaw: boolean): void;

        SetMaxDistance(NewMaxDistance: number): void;

        SetMinDistance(NewMinDistance: number): void;

        SetSpringArmCamera(NewSpringArmComponent: $Nullable<SpringArmComponent>): void;

        SetSpringArmDistanceByDelta(Delta: number): void;

        SetTargetArmLength(NewTargetArmLength: number): void;

        SetUsePawnControlRotation(NewUsePawnControlRotation: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCameraSetting;

        static Load(InName: string): MWSysCameraSetting;
    }

    export class MWSysCameraComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpringArmComponent: SpringArmComponent;
        CameraComponent: CameraComponent;
        CameraSetting: MWSysCameraSetting;

        SetSpringArmDistanceByDelta(Delta: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCameraComponent;

        static Load(InName: string): MWSysCameraComponent;
    }

    export class MWSysCESpringArmObject extends MWSysCameraEffectBaseObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetArmLength: number;
        SocketOffset: Vector;
        TargetOffset: Vector;
        ProbeSize: number;
        ProbeChannel: ECollisionChannel;
        bDoCollisionTest: boolean;
        bEnableRaiseCamera: boolean;
        RaiseCameraHeight: number;
        bUsePawnControlRotation: boolean;
        bInheritPitch: boolean;
        bInheritYaw: boolean;
        bInheritRoll: boolean;
        bEnableCameraLag: boolean;
        bEnableCameraRotationLag: boolean;
        bUseCameraLagSubstepping: boolean;
        bDrawDebugLagMarkers: boolean;
        CameraLagSpeed: number;
        CameraRotationLagSpeed: number;
        CameraLagMaxTimeStep: number;
        CameraLagMaxDistance: number;

        GetCameraLocationLagSpeed(): number;

        GetCameraRotationLagSpeed(): number;

        GetIsDoCollisionTest(): boolean;

        GetIsEnableCameraLocationLag(): boolean;

        GetIsEnableCameraRotationLag(): boolean;

        GetIsEnableRaiseCamera(): boolean;

        GetIsUsePawnControlRotation(): boolean;

        GetRaiseCameraHeight(): number;

        GetSocketOffset(): Vector;

        GetTargetArmLength(): number;

        GetTargetOffset(): Vector;

        GetTargetRotation(): Rotator;

        GetUnfixedCameraPosition(): Vector;

        GetViewRotation(): Rotator;

        IsCollisionFixApplied(): boolean;

        ResetOverrideCameraRotation(): void;

        SetCameraLocationLagSpeed(NewCameraLocationLagSpeed: number): void;

        SetCameraRotationLagSpeed(NewCameraRotationLagSpeed: number): void;

        SetIsDoCollisionTest(bIsDoCollisionTest: boolean): void;

        SetIsEnableCameraLocationLag(bIsEnableCameraLocationLag: boolean): void;

        SetIsEnableCameraRotationLag(bIsEnableCameraRotationLag: boolean): void;

        SetIsEnableRaiseCamera(bIsEnableRaiseCamera: boolean): void;

        SetIsUsePawnControlRotation(bIsUsePawnControlRotation: boolean): void;

        SetOverrideCameraRotation(NewOverrideRotation: Rotator, bClampByCameraModeRotationLimits?: boolean /* = false */): void;

        SetRaiseCameraHeight(NewRaiseCameraHeight: number): void;

        SetSocketOffset(NewSocketOffset: Vector): void;

        SetTargetArmLength(NewTargetArmLength: number): void;

        SetTargetOffset(NewTargetOffset: Vector): void;

        SetViewRotation(Rotation: Rotator): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCESpringArmObject;

        static Load(InName: string): MWSysCESpringArmObject;
    }

    export enum ECameraSystemInterpolationType {
        SmoothInterpolation,
        ConstInterpolation,
        ECameraSystemInterpolationType_MAX
    }

    export class MWSysInterpolationSpeed {
        constructor();
        constructor(InterpSpeed: number, InterpType: ECameraSystemInterpolationType, bUseInterpSpeedToInterpolation: boolean, InterpSpeedToInterpolation: number, ResetInterpSpeedTolerance: number);

        InterpSpeed: number;
        InterpType: ECameraSystemInterpolationType;
        bUseInterpSpeedToInterpolation: boolean;
        InterpSpeedToInterpolation: number;
        ResetInterpSpeedTolerance: number;

        static StaticClass(): Class;
    }

    export class MWSysCELockTargetObject extends MWSysCameraEffectBaseObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetActor: TWeakObjectPtr<Actor>;
        CameraRotationInterpolation: MWSysInterpolationSpeed;
        LockTargetOffset: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCELockTargetObject;

        static Load(InName: string): MWSysCELockTargetObject;
    }

    export class MWSysCEFollowTargetObject extends MWSysCameraEffectBaseObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetActor: TWeakObjectPtr<Actor>;
        CameraLocationInterpolation: MWSysInterpolationSpeed;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCEFollowTargetObject;

        static Load(InName: string): MWSysCEFollowTargetObject;
    }

    export class CameraEffectFadingActorInfo {
        constructor();
        constructor(Actor: TWeakObjectPtr<Actor>, bFadeOut: boolean, FadeOutTime: number, FadeValue: number);

        Actor: TWeakObjectPtr<Actor>;
        bFadeOut: boolean;
        FadeOutTime: number;
        FadeValue: number;

        static StaticClass(): Class;
    }

    export class MWSysCEFadingObject extends MWSysCameraEffectBaseObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bFadeSelfIfCollision: boolean;
        bEnableFadeSettings: boolean;
        MaterialFadeParamNames: TArray<string>;
        FadeInTime: number;
        FadeOutTime: number;
        MaterialFadeMinValue: number;
        MaterialFadeMaxValue: number;
        SelfFadeCheckRadius: number;
        bEnableFadeEffect: boolean;
        FadeChannel: ECollisionChannel;
        bUseCustomFadeOutTimeForSelfFade: boolean;
        SelfFadeCustomFadeOutTime: number;
        bSelfFadeAttachedActors: boolean;
        bEnableDrawFadeShapeDebug: boolean;
        OnUpdateFadeMaterial: $Delegate<(FadingActorInfo: $Ref<CameraEffectFadingActorInfo>) => void>;
        OnUpdateUnFadeMaterial: $Delegate<(FadingActorInfo: $Ref<CameraEffectFadingActorInfo>) => void>;

        AddIgnoredActor(Actor: $Nullable<Actor>): void;

        AddManualFadeActor(Actor: $Nullable<Actor>, bWithCustomTime?: boolean /* = false */, CustomFadeOutTime?: number /* = 0.000000 */): void;

        ClearIgnoredActors(): void;

        ClearManualFadeActors(): void;

        GetIsEnableFadeEffect(): boolean;

        RemoveIgnoredActor(Actor: $Nullable<Actor>): void;

        RemoveManualFadeActor(Actor: $Nullable<Actor>): void;

        SetIsEnableFadeEffect(NewIsEnableFadeEffect: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCEFadingObject;

        static Load(InName: string): MWSysCEFadingObject;
    }

    export enum ECameraRotationMode { Rotation_Fixed, Rotation_Follow, Rotation_Control, Rotation_MAX }

    export enum ECameraLocationMode { Location_Fixed, Location_Follow, Location_MAX }

    export class MWSysCameraSystemComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraComponent: CameraComponent;
        LocationObjectClass: Class;
        LockTargetObjectClass: Class;
        FollowTargetObjectClass: Class;
        FadingObjectClass: Class;
        LocationObject: MWSysCESpringArmObject;
        LockTargetObject: MWSysCELockTargetObject;
        FollowTargetObject: MWSysCEFollowTargetObject;
        FadingObject: MWSysCEFadingObject;
        CameraObjList: TArray<MWSysCameraEffectBaseObject>;

        CancelFollowTarget(): void;

        CancelLockTarget(): void;

        GetCameraComponent(): CameraComponent;

        GetCameraDownLimitAngle(): number;

        GetCameraFadingObject(): MWSysCEFadingObject;

        GetCameraFollowTargetObject(): MWSysCEFollowTargetObject;

        GetCameraFOV(): number;

        GetCameraLocation(): Vector;

        GetCameraLocationLagSpeed(): number;

        GetCameraLocationMode(): ECameraLocationMode;

        GetCameraLocationObject(): MWSysCESpringArmObject;

        GetCameraLockTargetObject(): MWSysCELockTargetObject;

        GetCameraProjectionMode(): ECameraProjectionMode;

        GetCameraRelativeTransform(): Transform;

        GetCameraRotation(): Rotator;

        GetCameraRotationLagSpeed(): number;

        GetCameraRotationMode(): ECameraRotationMode;

        GetCameraUpLimitAngle(): number;

        GetCameraWorldTransform(): Transform;

        GetFollowTargetInterpolation(): number;

        GetIsEnableCameraCollision(): boolean;

        GetIsEnableCameraLocationLag(): boolean;

        GetIsEnableCameraRotationLag(): boolean;

        GetIsEnableFadeEffect(): boolean;

        GetIsEnableFollowTarget(): boolean;

        GetIsEnableLockTarget(): boolean;

        GetIsEnableRaiseCamera(): boolean;

        GetIsUsePawnControlRotation(): boolean;

        GetOrthoFarClipPlane(): number;

        GetOrthoNearClipPlane(): number;

        GetOrthoWidth(): number;

        GetOwningPawn(): Pawn;

        GetPlayerCameraManager(): PlayerCameraManager;

        GetPlayerController(): PlayerController;

        GetRaiseCameraHeight(): number;

        GetSocketOffset(): Vector;

        GetTargetArmLength(): number;

        GetTargetOffset(): Vector;

        ResetCameraLocationMode(): void;

        ResetCameraRotationMode(): void;

        ResetOverrideCameraRotation(): void;

        SetCameraDownLimitAngle(NewDownLimitAngle: number): void;

        SetCameraFOV(NewFOV: number): void;

        SetCameraLocationLagSpeed(NewCameraLocationLagSpeed: number): void;

        SetCameraLocationMode(NewCameraLocationMode: ECameraLocationMode): void;

        SetCameraProjectionMode(NewCameraProjectionMode: ECameraProjectionMode): void;

        SetCameraRelativeTransform(NewTransform: Transform): void;

        SetCameraRotationLagSpeed(NewCameraRotationLagSpeed: number): void;

        SetCameraRotationMode(NewCameraRotationMode: ECameraRotationMode): void;

        SetCameraUpLimitAngle(NewUpLimitAngle: number): void;

        SetCameraWorldTransform(NewTransform: Transform): void;

        SetFollowTarget(NewActor: $Nullable<Actor>): void;

        SetFollowTargetInterpolation(NewFollowTargetInterpolation: number): void;

        SetIsEnableCameraCollision(bEnableCameraCollision: boolean): void;

        SetIsEnableCameraLocationLag(bIsEnableCameraLocationLag: boolean): void;

        SetIsEnableCameraRotationLag(bIsEnableCameraRotationLag: boolean): void;

        SetIsEnableFadeEffect(NewIsEnableFadeEffect: boolean): void;

        SetIsEnableFollowTarget(NewIsEnableFollowTarget: boolean): void;

        SetIsEnableLockTarget(NewIsEnableLockTarget: boolean): void;

        SetIsEnableRaiseCamera(bIsEnableRaiseCamera: boolean): void;

        SetIsUsePawnControlRotation(bIsUsePawnControlRotation: boolean): void;

        SetLockTarget(NewActor: $Nullable<Actor>): void;

        SetOrthoFarClipPlane(NewOrthoWidth: number): void;

        SetOrthoNearClipPlane(NewOrthoWidth: number): void;

        SetOrthoWidth(NewOrthoWidth: number): void;

        SetOverrideCameraRotation(NewOverrideRotation: Rotator, bClampByCameraModeRotationLimits?: boolean /* = false */): void;

        SetRaiseCameraHeight(NewRaiseCameraHeight: number): void;

        SetSocketOffset(NewSocketOffset: Vector): void;

        SetTargetArmLength(NewTargetArmLength: number): void;

        SetTargetOffset(NewTargetOffset: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCameraSystemComponent;

        static Load(InName: string): MWSysCameraSystemComponent;
    }

    export class MWSysCameraEffectBaseObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwningCamera: MWSysCameraSystemComponent;

        GetOwningActor(): Actor;

        GetOwningCamera(): MWSysCameraSystemComponent;

        GetOwningPawn(): Pawn;

        GetPlayerCameraManager(): PlayerCameraManager;

        GetPlayerController(): PlayerController;

        Validate(bWithInterpolation: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCameraEffectBaseObject;

        static Load(InName: string): MWSysCameraEffectBaseObject;
    }

    export class MWSysCameraManger extends PlayerCameraManager {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerController: PlayerController;

        SetGamePlayerMode(GameModeEnum: GameModePP): void;

        SetTarget(TargetActor: $Nullable<Actor>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCameraManger;

        static Load(InName: string): MWSysCameraManger;
    }

    export class MWSysCameraTarget extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetArmLength: number;
        bEnableCameraLag: boolean;
        CameraLagSpeed: number;
        bUsePawnControlRotation: boolean;
        bInheritPitch: boolean;
        bInheritYaw: boolean;
        bInheritRoll: boolean;
        bEnableAdjustDistance: boolean;
        MinDistance: number;
        MaxDistance: number;
        CameraOffset: Vector;
        CameraRotation: Rotator;
        _RootComp: SceneComponent;
        _CameraMesh: StaticMeshComponent;

        GetCameraLagSpeed(): number;

        GetCameraOffset(): Vector;

        GetCameraRotation(): Rotator;

        GetEnableAdjustDistance(): boolean;

        GetEnableCameraLag(): boolean;

        GetInheritPitch(): boolean;

        GetInheritRoll(): boolean;

        GetInheritYaw(): boolean;

        GetMaxDistance(): number;

        GetMinDistance(): number;

        GetTargetArmLength(): number;

        GetUsePawnControlRotation(): boolean;

        SetCameraLagSpeed(Value: number): void;

        SetCameraOffset(Value: Vector): void;

        SetCameraRotation(Value: Rotator): void;

        SetEnableAdjustDistance(Value: boolean): void;

        SetEnableCameraLag(Value: boolean): void;

        SetInheritPitch(Value: boolean): void;

        SetInheritRoll(Value: boolean): void;

        SetInheritYaw(Value: boolean): void;

        SetMaxDistance(Value: number): void;

        SetMinDistance(Value: number): void;

        SetTargetArmLength(Value: number): void;

        SetUsePawnControlRotation(Value: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCameraTarget;

        static Load(InName: string): MWSysCameraTarget;
    }

    export class FadeData {
        constructor();
        constructor(FadeComponent: TWeakObjectPtr<PrimitiveComponent>, ItemId: number);

        FadeComponent: TWeakObjectPtr<PrimitiveComponent>;
        ItemId: number;

        static StaticClass(): Class;
    }

    export class MWSysFadeControlComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bOpenFade: boolean;
        FadeObjectChannel: ECollisionChannel;
        OnUpdateFadeComponents: $MulticastDelegate<(OperatedDatas: $Ref<TArray<FadeData>>) => void>;
        OnUpdateUnFadeComponents: $MulticastDelegate<(OperatedDatas: $Ref<TArray<FadeData>>) => void>;
        TargetActor: Actor;
        CurrentCameraComponent: CameraComponent;
        NeedFadeData: TArray<FadeData>;
        NeedUnFadeData: TArray<FadeData>;
        CurrentFadeData: TArray<FadeData>;
        CurrentFadeComponents: TArray<PrimitiveComponent>;

        SetCameraComponent(InCameraComponent: $Nullable<CameraComponent>): void;

        SetTargetActor(InTargetActor: $Nullable<Actor>): void;

        TraceFadeHitResults(OutHitResults: $Ref<TArray<HitResult>>): void;

        UpdateFadeData(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysFadeControlComponent;

        static Load(InName: string): MWSysFadeControlComponent;
    }

    export enum EMWCameraControlMode { E_PawnRotation, E_ControlRotaion, E_MAX }

    export class MWSysCharacterCameraComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpringArmComponent: SpringArmComponent;
        CameraComponent: CameraComponent;
        FadeControlComponent: MWSysFadeControlComponent;
        MinDistance: number;
        MaxDistance: number;
        CameraControlMode: EMWCameraControlMode;

        FixedCameraToTargetLocation(NewLocation: Vector): void;

        FixedCameraToTargetRotation(NewRotator: Rotator): void;

        GetCameraComponent(): CameraComponent;

        GetCameraLagSpeed(): number;

        GetCameraOffset(): Vector;

        GetEnableCameraLag(): boolean;

        GetEnableCameraRotationLag(): boolean;

        GetFadeControlComponent(): MWSysFadeControlComponent;

        GetMaxDistance(): number;

        GetMinDistance(): number;

        GetSpringArmComponent(): SpringArmComponent;

        GetTargetArmLength(): number;

        GetUsePawnControlRotation(): boolean;

        ResetTransform(): void;

        SetCameraControlMode(CameraCtrlMode: EMWCameraControlMode): void;

        SetCameraLagSpeed(InCameraLagSpeed: number): void;

        SetCameraOffset(InCameraOffset: Vector): void;

        SetEnableCameraLag(InEnableCameraLag: boolean): void;

        SetEnableCameraRotationLag(Enabled: boolean): void;

        SetMaxDistance(InMaxDistance: number): void;

        SetMinDistance(InMinDistance: number): void;

        SetSpringArmDistanceByDelta(Delta: number): void;

        SetTargetArmLength(InTargetArmLength: number): void;

        SetUsePawnControlRotation(InFixedCameraAngle: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCharacterCameraComponent;

        static Load(InName: string): MWSysCharacterCameraComponent;
    }

    export class MWSysClothesActor extends MWSysActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmptySk: SkeletalMesh;
        SKGuid: string;
        Mesh: SkeletalMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysClothesActor;

        static Load(InName: string): MWSysClothesActor;
    }

    export class MWSysCubeBuilder extends MWSysBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: number;
        Y: number;
        Z: number;
        WallThickness: number;
        GroupName: string;
        Hollow: boolean;
        Tessellated: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCubeBuilder;

        static Load(InName: string): MWSysCubeBuilder;
    }

    export class MWSysCylinderComponent extends ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _Radius: number;
        _Height: number;
        _CollisionProxy: MWSysCollisionProxy;

        CalcScaledCylinderBounds(OutRadius: $Ref<number>, OutHeight: $Ref<number>): void;

        GetCollisionProxy(): MWSysCollisionProxy;

        SetCylinderHeight(InHeight: number, bUpdateOverlaps?: boolean /* = true */): void;

        SetCylinderRadius(InRadius: number, bUpdateOverlaps?: boolean /* = true */): void;

        SetCylinderSize(InRadius: number, InHeight: number, bUpdateOverlaps?: boolean /* = true */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysCylinderComponent;

        static Load(InName: string): MWSysCylinderComponent;
    }

    export enum EMWEffectRangeType { Two_D, Three_D, EMWEffectRangeType_MAX }

    export enum EMWEffectRangeShape { Rectangle, Circle, Sector, Cube, Sphere, Segment, EMWEffectRangeShape_MAX }

    export class MWSysEffectLogicalObj extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EffectRangeType: EMWEffectRangeType;
        EffectRangeShape: EMWEffectRangeShape;
        CircleRadius: number;
        RectangleWidget: number;
        RectangleHight: number;
        SectorRadius: number;
        SectorAngle: number;
        SphereRadius: number;
        CubeWidget: number;
        CubeHight: number;
        CubeLength: number;
        SegmentRadius: number;
        SegmentAngle: number;
        SegmentHight: number;
        StartPlayEvent: $MulticastDelegate<() => void>;
        StopPlayEvent: $MulticastDelegate<() => void>;
        EffectObj: MWActor;

        ClientPlayEffect(Effectguid: string): void;

        ClientStopEffect(): void;

        GetInRangeAllActor(): TArray<MWActor>;

        PlayEffect(): void;

        StartPlay(): void;

        StopEffect(): void;

        StopPlay(): void;

        Update(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysEffectLogicalObj;

        static Load(InName: string): MWSysEffectLogicalObj;
    }

    export class MWSysEffectLogicalShapeComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysEffectLogicalShapeComponent;

        static Load(InName: string): MWSysEffectLogicalShapeComponent;
    }

    export enum EParticleType { CascadeParticle, NiagaraParticle, EParticleType_MAX }

    export enum EEffectAttachType {
        KeepRelativeOffset,
        KeepWorldPosition,
        SnapToTarget,
        SnapToTargetIncludingScale,
        EEffectAttachType_MAX
    }

    export class MWSysEffectObj extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IconSprite: BillboardComponent;
        bEffectLoop: boolean;
        LoopCount: number;
        bAutoActive: boolean;
        ParticleAsset: MWAssetRecorder;
        EffectColor: LinearColor;
        CascadeParticleSystemComponent: ParticleSystemComponent;
        NiagaraParticleSystemComponent: NiagaraComponent;
        ParticleType: EParticleType;
        NewSprite: BillboardComponent;
        bShouldSetColor: boolean;

        ButtonPlay(): void;

        ButtonStop(): void;

        GetEffectColor(): LinearColor;

        GetEffectLength(): number;

        GetLoop(): boolean;

        GetLoopCount(): number;

        GetSoundPlayState(): EPlayState;

        ParticlePlay(): void;

        ParticleStop(): void;

        SetEffectColor(NewColor: LinearColor): void;

        SetHue(): void;

        SetLoop(NewLoop: boolean): void;

        SetLoopCount(NewLoopCount: number): void;

        static ParticleDestroy(EffectAsset: $Nullable<ParticleSystemComponent>): void;

        static SpawnParticleAndAttachToComponent(EffectObj: $Nullable<MWSysEffectObj>, AttachToActor: $Nullable<Actor>, AttachSocketName: string, Location: Vector, Rotation: Rotator, Scale: Vector, LocationType: EEffectAttachType, bAutoDestroy: boolean, bAutoActivateSystem: boolean): ParticleSystemComponent;

        static SpawnParticleAtLocation(EffectObj: $Nullable<MWSysEffectObj>, SpawnLocation: Vector, SpawnRotation: Rotator, SpawnScale: Vector, bAutoDestroy: boolean, bAutoActivateSystem: boolean): ParticleSystemComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysEffectObj;

        static Load(InName: string): MWSysEffectObj;
    }

    export class MWSysEquipmentBase extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EquipType: string;
        EquipName: string;
        bHoldEquipAnim: boolean;
        bHideEquip: boolean;
        HoldEquipAnimString: string;
        SocketNameString: string;
        _RootComp: SceneComponent;
        IconSprite: BillboardComponent;

        GetEquipName(): string;

        GetEquipType(): string;

        GetHoldEquipAnimString(): string;

        GetIsHideEquip(): boolean;

        GetIsPlayHoldEquipAnim(): boolean;

        GetSocketNameString(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysEquipmentBase;

        static Load(InName: string): MWSysEquipmentBase;
    }

    export class MWSysFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AngleHitCheck(Angle: number, OriginLoc: Vector, OriginForward: Vector, TargetLoc: Vector): boolean;

        static BoxOverlap(WorldContextObject: $Nullable<Object>, OriginLoc: Vector, TargetLoc: Vector, BoxWidth: number, BoxHeight: number, bDebug: boolean): TArray<Actor>;

        static CylinderOverlap(WorldContextObject: $Nullable<Object>, OriginLoc: Vector, Radius: number, Height: number, bDebug: boolean): TArray<Actor>;

        static SphereOverlap(WorldContextObject: $Nullable<Object>, OriginLoc: Vector, SphereRadius: number, bDebug: boolean): TArray<Actor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysFunctionLibrary;

        static Load(InName: string): MWSysFunctionLibrary;
    }

    export class MWSysGameInstance extends MWGameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _Instances: TArray<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysGameInstance;

        static Load(InName: string): MWSysGameInstance;
    }

    export class MWSysGameMode extends GameMode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _PawnClasses: TArray<Class>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysGameMode;

        static Load(InName: string): MWSysGameMode;
    }

    export class MWSysGameSession extends GameSession {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysGameSession;

        static Load(InName: string): MWSysGameSession;
    }

    export class MWSysGameState extends GameState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysGameState;

        static Load(InName: string): MWSysGameState;
    }

    export class MWSysHeroPackageActor extends MWSysCharacterActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHeroPackageActor;

        static Load(InName: string): MWSysHeroPackageActor;
    }

    export class MWSysHeroPackageData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimSequenceData: DataTable;
        AnimMontageData: DataTable;
        HeroName: string;
        SubAnimationBlueprint: Class;
        SkinSkeletalMeshes: TArray<SkeletalMesh>;

        GetAnimMontageById(MontageId: number): AnimMontage;

        GetAnimMontageCount(): number;

        GetAnimSequenceById(SequenceId: number): AnimSequence;

        GetDefaultSkeletalMesh(): SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHeroPackageData;

        static Load(InName: string): MWSysHeroPackageData;
    }

    export class MWSysHotWeaponActionComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimationGuid: string;

        HadAnimationGuid(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHotWeaponActionComponent;

        static Load(InName: string): MWSysHotWeaponActionComponent;
    }

    export enum EMWSysHotWeaponFireMode {
        SingleFire,
        ContinuousFire,
        FullAutomationFire,
        Max,
        EMWSysHotWeaponFireMode_MAX
    }

    export class MWSysHotWeaponFireComponentConfigData {
        constructor();
        constructor(FireMode: EMWSysHotWeaponFireMode, FireCount: number, FireInterval: number, ClipSize: number, MultipleShot: number, IsFireOnScreenCenter: boolean, OffsetOfFireOnScreenCenter: Vector);

        FireMode: EMWSysHotWeaponFireMode;
        FireCount: number;
        FireInterval: number;
        ClipSize: number;
        MultipleShot: number;
        IsFireOnScreenCenter: boolean;
        OffsetOfFireOnScreenCenter: Vector;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponFireComponentRunTimeData {
        constructor();
        constructor(FireMode: EMWSysHotWeaponFireMode, FireCount: number, FireInterval: number, ClipSize: number, MultipleShot: number, IsFireOnScreenCenter: boolean, OffsetOfFireOnScreenCenter: Vector, bFiring: boolean, bIsInFullAuto: boolean, BulletSize: number);

        FireMode: EMWSysHotWeaponFireMode;
        FireCount: number;
        FireInterval: number;
        ClipSize: number;
        MultipleShot: number;
        IsFireOnScreenCenter: boolean;
        OffsetOfFireOnScreenCenter: Vector;
        bFiring: boolean;
        bIsInFullAuto: boolean;
        BulletSize: number;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponFireComponent extends MWSysHotWeaponActionComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelegateStartFireOnServer: $MulticastDelegate<() => void>;
        DelegateStartFireOnClient: $MulticastDelegate<() => void>;
        DelegateEndFireOnServer: $MulticastDelegate<() => void>;
        DelegateEndContinuousFireOnServer: $MulticastDelegate<() => void>;
        DelegateEndFireOnClient: $MulticastDelegate<() => void>;
        ConfigData: MWSysHotWeaponFireComponentConfigData;
        RunTimeData: MWSysHotWeaponFireComponentRunTimeData;

        GetCurrentFireModel(): EMWSysHotWeaponFireMode;

        NetMultiCastEndFire(): void;

        NetMultiCastStartFire(): void;

        SetCurrentAutomaticFireCount(Size: number): void;

        SetCurrentbIsInFullAuto(NewIsFullAutoFiring: boolean): void;

        SetCurrentClipSize(Size: number): void;

        SetCurrentFireInterval(Interval: number): void;

        SetCurrentFireModel(FireMode: EMWSysHotWeaponFireMode): void;

        SetCurrentMultipleShot(Value: number): void;

        SetCurrentOffsetOfFireOnScreenCenter(Value: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHotWeaponFireComponent;

        static Load(InName: string): MWSysHotWeaponFireComponent;
    }

    export class MWSysHotWeaponAccuracyOfFireSetting {
        constructor();
        constructor(DispersionHalfAngleDefault: number, DispersionHalfAngleMax: number, DispersionHalfAngleMin: number, DispersionHalfAngleDecreaseSpeed: number, DispersionHalfAngleIncreaseSpeed: number, DispersionHalfAngleIncreasePerShot: number);

        DispersionHalfAngleDefault: number;
        DispersionHalfAngleMax: number;
        DispersionHalfAngleMin: number;
        DispersionHalfAngleDecreaseSpeed: number;
        DispersionHalfAngleIncreaseSpeed: number;
        DispersionHalfAngleIncreasePerShot: number;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponAccuracyOfFireComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RunTimeData: MWSysHotWeaponAccuracyOfFireSetting;
        ConfigData: MWSysHotWeaponAccuracyOfFireSetting;
        CurrentDispersionHalfAngle: number;
        TargetDispersionHalfAngle: number;
        DelegateCurrentDispersionChangedOnClient: $MulticastDelegate<() => void>;

        GetCurrentDispersionHalfAngle(): number;

        GetDispersionHalfAngleDecreaseSpeed(): number;

        GetDispersionHalfAngleDefault(): number;

        GetDispersionHalfAngleIncreasePerShot(): number;

        GetDispersionHalfAngleIncreaseSpeed(): number;

        GetDispersionHalfAngleMax(): number;

        GetDispersionHalfAngleMin(): number;

        GetRandomDispersionDir(ShootDir: Vector): Vector;

        GetTargetDispersionHalfAngle(): number;

        OnRep_CurrentDispersionChanged(): void;

        ScreenPointToWorldLocAndRot(PlayerControllerParam: $Nullable<PlayerController>, InScreenPointXY: Vector2D, OutWorldPos: $Ref<Vector>, OutWorldForwardDir: $Ref<Vector>): boolean;

        SetDispersionHalfAngleDecreaseSpeed(NewValue: number): void;

        SetDispersionHalfAngleDefault(NewValue: number): void;

        SetDispersionHalfAngleIncreasePerShot(NewValue: number): void;

        SetDispersionHalfAngleIncreaseSpeed(NewValue: number): void;

        SetDispersionHalfAngleMax(NewValue: number): void;

        SetDispersionHalfAngleMin(NewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHotWeaponAccuracyOfFireComponent;

        static Load(InName: string): MWSysHotWeaponAccuracyOfFireComponent;
    }

    export enum EMWSysHotWeaponAimMode { First_Person, Third_Person, Max, EMWSysHotWeaponAimMode_MAX }

    export enum EMWSysHotWeaponCrossHairType {
        None,
        ThirdPersonCrossHair,
        ThirdPersonDot,
        FirstPersonCrossHair,
        Max,
        EMWSysHotWeaponCrossHairType_MAX
    }

    export class MWSysHotWeaponAimSetting {
        constructor();
        constructor(AimMode: EMWSysHotWeaponAimMode, ScopeTypeIndex: EMWSysHotWeaponCrossHairType, AimmingZoom: number, CameraOffsetDistanceInThirdPersonMode: number);

        AimMode: EMWSysHotWeaponAimMode;
        ScopeTypeIndex: EMWSysHotWeaponCrossHairType;
        AimmingZoom: number;
        CameraOffsetDistanceInThirdPersonMode: number;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponAimComponent extends MWSysHotWeaponActionComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultSpringArmLengthInThirdPerson: number;
        RunTimeData: MWSysHotWeaponAimSetting;
        ConfigData: MWSysHotWeaponAimSetting;
        DelegateStartAimOnServer: $MulticastDelegate<() => void>;
        DelegateStartAimOnClient: $MulticastDelegate<() => void>;
        DelegateEndAimOnServer: $MulticastDelegate<() => void>;
        DelegateEndAimOnClient: $MulticastDelegate<() => void>;

        GetAimmingZoom(): number;

        GetAimMode(): EMWSysHotWeaponAimMode;

        GetCameraOffsetDistanceInThirdPersonMode(): number;

        GetDefaultCameraSpringArmLength(): number;

        GetScopeTypeIndex(): EMWSysHotWeaponCrossHairType;

        SetAimming(NewAimState: boolean): void;

        SetAimmingClient(NewAimState: boolean): void;

        SetAimmingServer(NewAimState: boolean): void;

        SetAimmingZoom(NewAimmingZoom: number): void;

        SetAimMode(NewAimMode: EMWSysHotWeaponAimMode): void;

        SetCameraOffsetDistanceInThirdPersonMode(NewCameraOffsetDistance: number): void;

        SetDefaultCameraSpringArmLength(NewSpringArmLength: number): void;

        SetScopeTypeIndex(NewScopeTypeIndex: EMWSysHotWeaponCrossHairType): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHotWeaponAimComponent;

        static Load(InName: string): MWSysHotWeaponAimComponent;
    }

    export class MWSysHotWeaponLoadComponentConfigData {
        constructor();
        constructor(LoadTime: number, bLoadAfterFire: boolean);

        LoadTime: number;
        bLoadAfterFire: boolean;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponLoadComponentRunTimeData {
        constructor();
        constructor(LoadTime: number, bLoadSuccess: boolean, bLoadAfterFire: boolean);

        LoadTime: number;
        bLoadSuccess: boolean;
        bLoadAfterFire: boolean;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponLoadComponent extends MWSysHotWeaponActionComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConfigData: MWSysHotWeaponLoadComponentConfigData;
        RunTimeData: MWSysHotWeaponLoadComponentRunTimeData;
        DelegateStartLoadOnServer: $MulticastDelegate<() => void>;
        DelegateStartLoadOnClient: $MulticastDelegate<() => void>;
        DelegateEndLoadOnServer: $MulticastDelegate<() => void>;
        DelegateEndLoadOnClient: $MulticastDelegate<() => void>;

        BreakLoad(): void;

        GetLoadAfterFire(): boolean;

        GetLoadTime(): number;

        NetMultiCastEndLoad(bIsSuccess: boolean): void;

        NetMultiCastStartLoad(): void;

        SetLoadAfterFire(bOpen: boolean): void;

        SetLoadTime(Time: number): void;

        StartLoad(bHasEnoughBullet: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHotWeaponLoadComponent;

        static Load(InName: string): MWSysHotWeaponLoadComponent;
    }

    export class MWSysHotWeaponReloadComponentConfigData {
        constructor();
        constructor(ReloadTime: number);

        ReloadTime: number;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponReloadComponentRunTimeData {
        constructor();
        constructor(ReloadTime: number);

        ReloadTime: number;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponReloadComponent extends MWSysHotWeaponActionComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConfigData: MWSysHotWeaponReloadComponentConfigData;
        RunTimeData: MWSysHotWeaponReloadComponentRunTimeData;
        DelegateStartReloadOnServer: $MulticastDelegate<() => void>;
        DelegateStartReloadOnClient: $MulticastDelegate<() => void>;
        DelegateEndReloadOnServer: $MulticastDelegate<() => void>;
        DelegateEndReloadOnClient: $MulticastDelegate<() => void>;

        BreakReload(): void;

        EndReload(): void;

        GetReloadTime(): number;

        NetMultiCastEndReload(): void;

        NetMultiCastStartReload(): void;

        SetReloadTime(Time: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHotWeaponReloadComponent;

        static Load(InName: string): MWSysHotWeaponReloadComponent;
    }

    export class MWSysHotWeaponRecoilForceComponentRunTimeData {
        constructor();
        constructor(HorizontalOffsetMin: number, HorizontalOffsetMax: number, VerticalOffsetMin: number, VerticalOffsetMax: number, HorizontalJitterMin: number, HorizontalJitterMax: number, VerticalJitterMin: number, VerticalJitterMax: number, DeepJitterMin: number, DeepJitterMax: number, HorizontalJitterRate: number, VerticalJitterRate: number, DeepJitterRate: number);

        HorizontalOffsetMin: number;
        HorizontalOffsetMax: number;
        VerticalOffsetMin: number;
        VerticalOffsetMax: number;
        HorizontalJitterMin: number;
        HorizontalJitterMax: number;
        VerticalJitterMin: number;
        VerticalJitterMax: number;
        DeepJitterMin: number;
        DeepJitterMax: number;
        HorizontalJitterRate: number;
        VerticalJitterRate: number;
        DeepJitterRate: number;

        static StaticClass(): Class;
    }

    export class MWSysHotWeaponRecoilForceComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelegateStartRecoilForceOnServer: $MulticastDelegate<() => void>;
        DelegateStartRecoilForceOnClient: $MulticastDelegate<() => void>;
        RunTimeData: MWSysHotWeaponRecoilForceComponentRunTimeData;

        GetDeepJitter(): number;

        GetHorizontalJitter(): number;

        GetHorizontalOffset(): number;

        GetVerticalJitter(): number;

        GetVerticalOffset(): number;

        NetMultiCastStartRecoilForce(): void;

        SetHorizontalJitterMax(Value: number): void;

        SetHorizontalJitterMin(Value: number): void;

        SetHorizontalOffsetMax(Value: number): void;

        SetHorizontalOffsetMin(Value: number): void;

        SetVerticalJitterMax(Value: number): void;

        SetVerticalJitterMin(Value: number): void;

        SetVerticalOffsetMax(Value: number): void;

        SetVerticalOffsetMin(Value: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHotWeaponRecoilForceComponent;

        static Load(InName: string): MWSysHotWeaponRecoilForceComponent;
    }

    export enum EMWSysHotWeaponState { Idle, Reloading, Loading, Firing, Max, EMWSysHotWeaponState_MAX }

    export class MWSysHotWeapon extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelegateEquipOnServer: $MulticastDelegate<(EquipOwner: $Nullable<MWActor>) => void>;
        DelegateEquipOnClient: $MulticastDelegate<() => void>;
        DelegateUnEquipOnServer: $MulticastDelegate<() => void>;
        DelegateUnEquipOnClient: $MulticastDelegate<() => void>;
        DelegateOnRepOwner: $MulticastDelegate<() => void>;
        EquipActionComponent: MWSysHotWeaponActionComponent;
        IdleActionComponent: MWSysHotWeaponActionComponent;
        FireComponent: MWSysHotWeaponFireComponent;
        AccuracyOfFireComponent: MWSysHotWeaponAccuracyOfFireComponent;
        AimComponent: MWSysHotWeaponAimComponent;
        LoadComponent: MWSysHotWeaponLoadComponent;
        ReloadComponent: MWSysHotWeaponReloadComponent;
        RecoilForceComponent: MWSysHotWeaponRecoilForceComponent;
        bOpenAccuracyOfFireComponent: boolean;
        bOpenAimComponent: boolean;
        bOpenLoadComponent: boolean;
        bOpenReloadComponent: boolean;
        bOpenRecoilForceComponent: boolean;
        CurrentState: EMWSysHotWeaponState;
        IconSprite: BillboardComponent;

        BreakLoad(): void;

        BreakLoadOnServer(): void;

        BreakReload(): void;

        BreakReloadOnServer(): void;

        CurrentState_Rep(): void;

        Equipment(NetOwner: $Nullable<MWActor>, AttachedComponent: $Nullable<SceneComponent>, SocketName: string): void;

        EquipOnServer(NetOwner: $Nullable<MWActor>, AttachedComponent: $Nullable<SceneComponent>, SocketName: string): void;

        GetCurrentState(): EMWSysHotWeaponState;

        GetOpenAccuracyOfFireComponent(): boolean;

        GetOpenAimComponent(): boolean;

        GetOpenLoadComponent(): boolean;

        GetOpenRecoilForceComponent(): boolean;

        GetOpenReloadComponent(): boolean;

        Load(): void;

        NetMultiCastOnEquip(NetOwner: $Nullable<MWActor>): void;

        NetMultiCastOnUnEquip(): void;

        OnDelegateFireStartDispersionIncrease(): void;

        Reload(BulletSize: number): void;

        SetCurrentFireModel(FireMode: EMWSysHotWeaponFireMode): void;

        SetOpenAccuracyOfFireComponent(bOpen: boolean): void;

        SetOpenAimComponent(bOpen: boolean): void;

        SetOpenLoadComponent(bOpen: boolean): void;

        SetOpenRecoilForceComponent(bOpen: boolean): void;

        SetOpenReloadComponent(bOpen: boolean): void;

        StartFire(): void;

        StartFireOnServer(): void;

        StartLoadOnServer(): void;

        StartReloadOnServer(BulletSize: number): void;

        StopFire(): void;

        StopFireOnServer(): void;

        UnEquipment(): void;

        UnEquipOnServer(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysHotWeapon;

        static Load(InName: string): MWSysHotWeapon;
    }

    export class MWSysImpulse extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysImpulse;

        static Load(InName: string): MWSysImpulse;
    }

    export class MWSysInputComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _bUseGamepadHw: boolean;
        TouchDragRotationScaleX: number;
        TouchDragRotationScaleY: number;

        SetEnableControlCamera(InEnable: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysInputComponent;

        static Load(InName: string): MWSysInputComponent;
    }

    export class MWSysInteractiveObj extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetName: string;
        SkillAnimationStanceType: string;
        BindSocket: string;
        TargetObj: Actor;
        IsInteractive: boolean;
        _Root: StaticMeshComponent;
        IconSprite: BillboardComponent;

        GetMWGuid(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysInteractiveObj;

        static Load(InName: string): MWSysInteractiveObj;
    }

    export class MWSysInteractiveObject extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysInteractiveObject;

        static Load(InName: string): MWSysInteractiveObject;
    }

    export class MWSysInterpolationLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static InterpFloat(Current: number, Target: number, DeltaTime: number, InterpSpeed: $Ref<MWSysInterpolationSpeed>, bResetSpeedIfResultEqualToTarget?: boolean /* = true */): number;

        static InterpolationSpeed_GetCurrentInterpolationSpeed(InterpSpeed: MWSysInterpolationSpeed): number;

        static InterpolationSpeed_InterpolateSpeed(InterpSpeed: $Ref<MWSysInterpolationSpeed>, DeltaTime: number): void;

        static InterpolationSpeed_ResetSpeed(InterpSpeed: $Ref<MWSysInterpolationSpeed>): void;

        static InterpRotator(Current: Rotator, Target: Rotator, DeltaTime: number, InterpSpeed: $Ref<MWSysInterpolationSpeed>, bResetSpeedIfResultEqualToTarget?: boolean /* = true */): Rotator;

        static InterpVector(Current: Vector, Target: Vector, DeltaTime: number, InterpSpeed: $Ref<MWSysInterpolationSpeed>, bResetSpeedIfResultEqualToTarget?: boolean /* = true */): Vector;

        static ReplaceSpringArmToCameraSystemComponent(Actor: $Nullable<Actor>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysInterpolationLibrary;

        static Load(InName: string): MWSysInterpolationLibrary;
    }

    export class MWSysLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AnimProxy_ConditionSetJumpState(InCondition: boolean, InAnimInstance: $Nullable<MWSysAnimInstance_Ground>, InSetJumpState: EMWAnim_JumpState): boolean;

        static AsyncEnterProcedureByName(Context: $Nullable<Object>, ProcedureName: string): void;

        static CreateAndSetMaterialInstanceDynamic(PrimitiveComponent: $Nullable<PrimitiveComponent>, ElementIndex: number): MaterialInstanceDynamic;

        static FalseValue(): boolean;

        static GetMWCharacterAssetsManager(Context: $Nullable<Object>): MWCharacterAssetsManager;

        static LoadFileByGuid(Guid: string): string;

        static LoadFileByPath(Path: string): string;

        static LoadSKMeshByGuid(Guid: string): boolean;

        static NotifyCharacterEditorRefresh(InGuid: string): void;

        static QuitApplication(): void;

        static TrueValue(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysLibrary;

        static Load(InName: string): MWSysLibrary;
    }

    export class NavAreaBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavAreaBase;

        static Load(InName: string): NavAreaBase;
    }

    export class NavArea extends NavAreaBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultCost: number;
        FixedAreaEnteringCost: number;
        DrawColor: Color;
        SupportedAgents: NavAgentSelector;
        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavArea;

        static Load(InName: string): NavArea;
    }

    export class MWSysNavArea extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysNavArea;

        static Load(InName: string): MWSysNavArea;
    }

    export class MWSysNavProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<() => void>;
        OnFail: $MulticastDelegate<() => void>;
        PFollowComp: PathFollowingComponent;
        NavActor: Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysNavProxy;

        static Load(InName: string): MWSysNavProxy;
    }

    export class MWSysNavHelper extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AIMoveTo(InPawn: $Nullable<Pawn>, Destination: Vector, Radius: number): AIAsyncTaskBlueprintProxy;

        static ClearMoveTo(InPawn: $Nullable<Pawn>): void;

        static PlayerMoveTo(InPawn: $Nullable<Pawn>, Destination: Vector, Radius: number): MWSysNavProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysNavHelper;

        static Load(InName: string): MWSysNavHelper;
    }

    export class NavMeshBoundsVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SupportedAgents: NavAgentSelector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavMeshBoundsVolume;

        static Load(InName: string): NavMeshBoundsVolume;
    }

    export class MWSysNavMeshVolume extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NavMeshBounds: BoxComponent;
        _Root: StaticMeshComponent;
        IconSprite: BillboardComponent;
        NavVolume: NavMeshBoundsVolume;

        BuildNav(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysNavMeshVolume;

        static Load(InName: string): MWSysNavMeshVolume;
    }

    export class NavModifierVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AreaClass: Class;
        bMaskFillCollisionUnderneathForNavmesh: boolean;

        SetAreaClass(NewAreaClass?: Class /* = None */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavModifierVolume;

        static Load(InName: string): NavModifierVolume;
    }

    export enum AreaClass { Null, Default, LowHeight, ObStacle, AreaClass_MAX }

    export class MWSysNavModifierVolume extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NavMeshBounds: BoxComponent;
        _Root: StaticMeshComponent;
        IconSprite: BillboardComponent;
        ModifierVolume: NavModifierVolume;

        GetModifierVolumeAreaClass(): AreaClass;

        SetModifierVolumeAreaClass(AreaType: AreaClass): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysNavModifierVolume;

        static Load(InName: string): MWSysNavModifierVolume;
    }

    export class MWSysOnlineSession extends OnlineSession {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysOnlineSession;

        static Load(InName: string): MWSysOnlineSession;
    }

    export class ConstrainComponentPropName {
        constructor();
        constructor(ComponentName: string);

        ComponentName: string;

        static StaticClass(): Class;
    }

    export enum EConstraintFrame { Frame1, Frame2, EConstraintFrame_MAX }

    export class PhysicsConstraintComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstraintActor1: Actor;
        ComponentName1: ConstrainComponentPropName;
        ConstraintActor2: Actor;
        ComponentName2: ConstrainComponentPropName;
        ConstraintSetup: PhysicsConstraintTemplate;
        OnConstraintBroken: $MulticastDelegate<(ConstraintIndex: number) => void>;
        ConstraintInstance: ConstraintInstance;

        BreakConstraint(): void;

        GetConstraintForce(OutLinearForce: $Ref<Vector>, OutAngularForce: $Ref<Vector>): void;

        GetCurrentSwing1(): number;

        GetCurrentSwing2(): number;

        GetCurrentTwist(): number;

        IsBroken(): boolean;

        SetAngularBreakable(bAngularBreakable: boolean, AngularBreakThreshold: number): void;

        SetAngularDriveMode(DriveMode: EAngularDriveMode): void;

        SetAngularDriveParams(PositionStrength: number, VelocityStrength: number, InForceLimit: number): void;

        SetAngularOrientationDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean): void;

        SetAngularOrientationTarget(InPosTarget: Rotator): void;

        SetAngularSwing1Limit(MotionType: EAngularConstraintMotion, Swing1LimitAngle: number): void;

        SetAngularSwing2Limit(MotionType: EAngularConstraintMotion, Swing2LimitAngle: number): void;

        SetAngularTwistLimit(ConstraintType: EAngularConstraintMotion, TwistLimitAngle: number): void;

        SetAngularVelocityDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean): void;

        SetAngularVelocityDriveSLERP(bEnableSLERP: boolean): void;

        SetAngularVelocityDriveTwistAndSwing(bEnableTwistDrive: boolean, bEnableSwingDrive: boolean): void;

        SetAngularVelocityTarget(InVelTarget: Vector): void;

        SetConstrainedComponents(Component1: $Nullable<PrimitiveComponent>, BoneName1: string, Component2: $Nullable<PrimitiveComponent>, BoneName2: string): void;

        SetConstraintReferenceFrame(Frame: EConstraintFrame, RefFrame: Transform): void;

        SetConstraintReferenceOrientation(Frame: EConstraintFrame, PriAxis: Vector, SecAxis: Vector): void;

        SetConstraintReferencePosition(Frame: EConstraintFrame, RefPosition: Vector): void;

        SetDisableCollision(bDisableCollision: boolean): void;

        SetLinearBreakable(bLinearBreakable: boolean, LinearBreakThreshold: number): void;

        SetLinearDriveParams(PositionStrength: number, VelocityStrength: number, InForceLimit: number): void;

        SetLinearPositionDrive(bEnableDriveX: boolean, bEnableDriveY: boolean, bEnableDriveZ: boolean): void;

        SetLinearPositionTarget(InPosTarget: Vector): void;

        SetLinearVelocityDrive(bEnableDriveX: boolean, bEnableDriveY: boolean, bEnableDriveZ: boolean): void;

        SetLinearVelocityTarget(InVelTarget: Vector): void;

        SetLinearXLimit(ConstraintType: ELinearConstraintMotion, LimitSize: number): void;

        SetLinearYLimit(ConstraintType: ELinearConstraintMotion, LimitSize: number): void;

        SetLinearZLimit(ConstraintType: ELinearConstraintMotion, LimitSize: number): void;

        SetOrientationDriveSLERP(bEnableSLERP: boolean): void;

        SetOrientationDriveTwistAndSwing(bEnableTwistDrive: boolean, bEnableSwingDrive: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintComponent;

        static Load(InName: string): PhysicsConstraintComponent;
    }

    export class MWSysPhysicsConstraintBase extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstraintComp: PhysicsConstraintComponent;
        ConstraintActor1: Actor;
        bConstraintActor1SimulatePhysic: boolean;
        ConstraintActor1Ptr: MWObjectPtr;
        ConstraintActor2: Actor;
        bConstraintActor2SimulatePhysic: boolean;
        ConstraintActor2Ptr: MWObjectPtr;
        ConstraintActorName1: string;
        ConstraintActorName2: string;
        bDisableCollision: boolean;
        CurrentDistance: number;
        IconSprite: BillboardComponent;
        Trans: Transform;
        Actor1Trans: Transform;
        Actor2Trans: Transform;

        FindConstraintActors(): void;

        GetCenterOfActor1Box(): Vector;

        GetCenterOfActor2Box(): Vector;

        GetConstraintActor1(): Actor;

        GetConstraintActor2(): Actor;

        GetConstraintActorName(ConstraintActor: $Nullable<Actor>): string;

        GetConstraintComp(): PhysicsConstraintComponent;

        HandleConstraintActor1PhyReadied(InTarget: $Nullable<MWStaticMeshActor>): void;

        HandleConstraintActor2PhyReadied(InTarget: $Nullable<MWStaticMeshActor>): void;

        OnBehaviorRegisterToWorld(InBehavior: $Nullable<MWActor>): void;

        OnDestroyedActor(DesActor: $Nullable<Actor>): void;

        OnRep_ConstraintActorName1(): void;

        OnRep_ConstraintActorName2(): void;

        SetActor1ByCheckParent(Actor: $Nullable<MWActor>): void;

        SetConstrain(): void;

        SetConstraintActor1(Actor: $Nullable<Actor>): void;

        SetConstraintActor2(Actor: $Nullable<Actor>): void;

        SetConstraintActorInitTransform(): void;

        SetConstraintActorName1(value: string): void;

        SetConstraintActorName2(value: string): void;

        UpdateConstraintActorsGatherCurrentMovement(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintBase;

        static Load(InName: string): MWSysPhysicsConstraintBase;
    }

    export class MWSysPhysicsConstraintAngularMotor extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bEnable: boolean;
        Torque: Vector;
        TorqueStrength: number;

        GetActivate(): boolean;

        GetTorque(): Vector;

        GetTorqueStrength(): number;

        OnRep_Update_Enable(): void;

        OnRep_Update_Torque(): void;

        OnRep_Update_TorqueStrength(): void;

        SetActivate(activate: boolean): void;

        SetTorque(TorqueValue: Vector): void;

        SetTorqueStrength(Strength: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintAngularMotor;

        static Load(InName: string): MWSysPhysicsConstraintAngularMotor;
    }

    export class MWSysPhysicsConstraintCable extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LimitDistance: number;
        IsDisableCollision: boolean;
        DelayInitDataTimerHandle: TimerHandle;

        GetConstraintDistance(): number;

        GetConstraintLimitDistance(): number;

        GetDisableCollision(): boolean;

        OnRep_Set(): void;

        SetConstraintLimitDistance(Dis: number): void;

        SetDisableCollision(bValue: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintCable;

        static Load(InName: string): MWSysPhysicsConstraintCable;
    }

    export enum EPhysicsConstraintType { Free, Limited, Locked, EPhysicsConstraintType_MAX }

    export class MWSysPhysicsConstraintCylinder extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsActivate: boolean;
        LinearLimitDistance: number;
        LinearLimitSpeed: Vector;
        LinearAcceleration: number;
        ReboundForce: number;
        LinearTypes: FixSizeArray<EPhysicsConstraintType>;
        AngularLimitDegress: Vector;
        AngularTargetSpeed: Vector;
        AngularAcceleration: number;
        AngularTypes: FixSizeArray<EPhysicsConstraintType>;

        GetActivate(): boolean;

        GetAngularAcceleration(): number;

        GetAngularLimit(): Vector;

        GetAngularTargetSpeed(): Vector;

        GetAngularType(Index: number): EPhysicsConstraintType;

        GetLinearAcceleration(): number;

        GetLinearLimitDistance(): number;

        GetLinearMaxSpeed(): Vector;

        GetLinearType(Index: number): EPhysicsConstraintType;

        GetReboundForce(): number;

        OnRep_UpDateConstraint(): void;

        SetActivate(NewActivate: boolean): void;

        SetAngularAcceleration(InAngularRate: number): void;

        SetAngularLimit(InAngularLimit: Vector): void;

        SetAngularTargetSpeed(InAngularLimitSpeed: Vector): void;

        SetAngularType(Index: number, Type: EPhysicsConstraintType): void;

        SetLinearAcceleration(Value: number): void;

        SetLinearLimitDistance(Value: number): void;

        SetLinearMaxSpeed(Value: Vector): void;

        SetLinearType(Index: number, Type: EPhysicsConstraintType): void;

        SetReboundForce(Value: number): void;

        UpdateActivate(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintCylinder;

        static Load(InName: string): MWSysPhysicsConstraintCylinder;
    }

    export class MWSysPhysicsConstraintFulcrum extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsActivate: boolean;
        LimitAngle: Vector;

        GetActivate(): boolean;

        GetLimitAngle(): Vector;

        OnRep_Set(): void;

        SetActivate(IsActivateValue: boolean): void;

        SetLimitAngle(LimitAngleValue: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintFulcrum;

        static Load(InName: string): MWSysPhysicsConstraintFulcrum;
    }

    export class MWSysPhysicsConstraintLinear extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ArrowComponent: ArrowComponent;
        Activate: boolean;
        MaxSpeed: Vector;
        Acceleration: number;

        GetAcceleration(): number;

        GetActivate(): boolean;

        GetMaxSpeed(): Vector;

        OnRep_Acceleration(): void;

        OnRep_Activate(): void;

        OnRep_MaxSpeed(): void;

        SetAcceleration(NewAcceleration: number): void;

        SetActivate(NewActivate: boolean): void;

        SetMaxSpeed(NewMaxSpeed: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintLinear;

        static Load(InName: string): MWSysPhysicsConstraintLinear;
    }

    export class MWSysPhysicsConstraintPrism extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsActivate: boolean;
        DelayInitDataTimerHandle: TimerHandle;
        LinearDirectionX: EPhysicsConstraintType;
        LinearDirectionY: EPhysicsConstraintType;
        LinearDirectionZ: EPhysicsConstraintType;
        LinearLimit: number;
        LinearVelocity: Vector;
        LinearStrength: number;
        Restitution: number;

        GetIsIsActivate(): boolean;

        GetLinearDirectionX(): EPhysicsConstraintType;

        GetLinearDirectionY(): EPhysicsConstraintType;

        GetLinearDirectionZ(): EPhysicsConstraintType;

        GetLinearLimit(): number;

        GetLinearStrength(): number;

        GetLinearVelocity(): Vector;

        GetRestitution(): number;

        SetIsActivate(Value: boolean): void;

        SetLinearDirectionX(Value: EPhysicsConstraintType): void;

        SetLinearDirectionY(Value: EPhysicsConstraintType): void;

        SetLinearDirectionZ(Value: EPhysicsConstraintType): void;

        SetLinearLimit(Value: number): void;

        SetLinearStrength(Value: number): void;

        SetLinearVelocity(Value: Vector): void;

        SetRestitution(Value: number): void;

        SetUp(): void;

        UpdateActivate(): void;

        UpdateLinear(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintPrism;

        static Load(InName: string): MWSysPhysicsConstraintPrism;
    }

    export class MWSysPhysicsConstraintRotation extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsActivate: boolean;
        RotatorDirectionX: EPhysicsConstraintType;
        RotatorDirectionY: EPhysicsConstraintType;
        RotatorDirectionZ: EPhysicsConstraintType;
        AngularLimitX: number;
        AngularLimitY: number;
        AngularLimitZ: number;
        AngularVelocity: Vector;
        AngularStrength: number;

        Activate(): void;

        GetAngularLimitX(): number;

        GetAngularLimitY(): number;

        GetAngularLimitZ(): number;

        GetAngularStrength(): number;

        GetAngularVelocity(): Vector;

        GetIsActivate(): boolean;

        GetRotatorDirectionX(): EPhysicsConstraintType;

        GetRotatorDirectionY(): EPhysicsConstraintType;

        GetRotatorDirectionZ(): EPhysicsConstraintType;

        SetAngularLimitX(Value: number): void;

        SetAngularLimitY(Value: number): void;

        SetAngularLimitZ(Value: number): void;

        SetAngularStrength(Value: number): void;

        SetAngularVelocity(Value: Vector): void;

        SetIsActivate(Value: boolean): void;

        SetRotatorDirectionX(Value: EPhysicsConstraintType): void;

        SetRotatorDirectionY(Value: EPhysicsConstraintType): void;

        SetRotatorDirectionZ(Value: EPhysicsConstraintType): void;

        UpdateAngular(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintRotation;

        static Load(InName: string): MWSysPhysicsConstraintRotation;
    }

    export class MWSysPhysicsConstraintSpring extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsActivated: boolean;
        DefaultSpringLength: number;
        CurrentSpringLength: number;
        IsLimitedLength: boolean;
        MaxStretchLength: number;
        SpringStiffness: number;
        SpringDamping: number;
        DelayInitDataTimerHandle: TimerHandle;
        IsFinishedBind: boolean;

        ConstructSpring(): void;

        GetActivateState(): boolean;

        GetCurrentSpringLength(): number;

        GetIsLimitedLength(): boolean;

        GetMaxStretchLength(): number;

        GetSpringDamping(): number;

        GetSpringDefaultLength(): number;

        GetSpringStiffness(): number;

        OnRep_Set(): void;

        SetActivateState(InIsActivated: boolean): void;

        SetIsLimitedLength(InIsLimitedLength: boolean): void;

        SetMaxStretchLength(StretchLength: number): void;

        SetSpringDamping(InSpringDamping: number): void;

        SetSpringDefaultLength(SpringLength: number): void;

        SetSpringStiffness(InSpringStiffness: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintSpring;

        static Load(InName: string): MWSysPhysicsConstraintSpring;
    }

    export class MWSysPhysicsConstraintStick extends MWSysPhysicsConstraintBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetConstraintDistance(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysicsConstraintStick;

        static Load(InName: string): MWSysPhysicsConstraintStick;
    }

    export class MWSysPhysVolume extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicsVolumePtr: PhysicsVolume;
        MWTerminalVelocity: number;
        MWPriority: number;
        MWFluidFriction: number;
        bMWWaterVolume: boolean;
        IsDrawBoundsLines: boolean;
        VolumeBounds: BoxComponent;
        UnitSideLength: number;
        IsDisplayIcon: boolean;
        IconSprite: BillboardComponent;

        AttachPhysVolumeToSelf(): void;

        GetFluidFriction(): number;

        GetIsDisplayIcon(): boolean;

        GetIsDrawBoundsLines(): boolean;

        GetVolumeBounds(): BoxComponent;

        InitPhysicsVolume(): void;

        SetFluidFriction(NewFluidFriction: number): void;

        SetIsDisplayIcon(IsDisplay: boolean): void;

        SetIsDrawBoundsLines(IsDraw: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPhysVolume;

        static Load(InName: string): MWSysPhysVolume;
    }

    export class MWSysPlayerCameraManager extends PlayerCameraManager {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerController: PlayerController;

        SetTarget(TargetActor: $Nullable<Actor>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPlayerCameraManager;

        static Load(InName: string): MWSysPlayerCameraManager;
    }

    export class MWSysPlayerController extends MWSysPlayerControllerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultUI: UserWidget;
        OnRpcCall: $Delegate<(RPCInfo: string) => void>;

        CallRpc(Info: string, Multicast: boolean, ToServer: boolean): void;

        Client_Invoke(Info: string): void;

        Client_MulticastInvoke(Info: string): void;

        IsRunningClient(): boolean;

        ScriptObjectReady(): void;

        Server_Invoke(Info: string): void;

        static GetPlayerList(): TMap<number, MWSysPlayerCharacter>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPlayerController;

        static Load(InName: string): MWSysPlayerController;
    }

    export class MWSysPlayerCharacter extends MWSysCharacter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _SysInputComponent: MWSysInputComponent;
        PreJump: boolean;
        _CameraSystemComponent: MWSysCameraSystemComponent;
        bFirstPersonCamera: boolean;
        OnSkill1Trigger: $MulticastDelegate<() => void>;
        OnSkill2Trigger: $MulticastDelegate<() => void>;
        OnSkill3Trigger: $MulticastDelegate<() => void>;
        OnSkill4Trigger: $MulticastDelegate<() => void>;
        OnSkill5Trigger: $MulticastDelegate<() => void>;
        OnSkill1TriggerRelease: $MulticastDelegate<() => void>;
        OnSkill2TriggerRelease: $MulticastDelegate<() => void>;
        OnSkill3TriggerRelease: $MulticastDelegate<() => void>;
        OnSkill4TriggerRelease: $MulticastDelegate<() => void>;
        OnSkill5TriggerRelease: $MulticastDelegate<() => void>;

        GetHeadLocation(): Vector;

        GetPlayerController(): MWSysPlayerController;

        GetThirdPersonCamera(): MWSysCameraSystemComponent;

        InitInputComponent(): void;

        IsFirstCamera(): boolean;

        OnRep_CameraMode(): void;

        OnRep_PreJump(): void;

        Server_Jump(): void;

        Server_SetCameraMode(bFirstPerson: boolean): void;

        SetCameraMode(bFirstPerson: boolean): void;

        StartInitiativeJump(): void;

        static GetCurrentCharacter(ContextObject: $Nullable<Object>): MWSysPlayerCharacter;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPlayerCharacter;

        static Load(InName: string): MWSysPlayerCharacter;
    }

    export class PlayerStart extends NavigationObjectBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerStartTag: string;
        ArrowComponent: ArrowComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlayerStart;

        static Load(InName: string): PlayerStart;
    }

    export class MWSysPlayerStart extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NewArrowComponent: ArrowComponent;
        NewSprite: BillboardComponent;
        ChildActorComponent: ChildActorComponent;
        PlayerStart: PlayerStart;
        Capsule: CapsuleComponent;
        triggerBeginTexture: Texture2D;
        triggerEndTexture: Texture2D;

        ComponentSetActive(bVisibility: boolean): void;

        OnOverlapBegin(OverlappedComp: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult): void;

        OnOverlapEnd(OverlappedComp: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPlayerStart;

        static Load(InName: string): MWSysPlayerStart;
    }

    export class MWPlayerData {
        constructor();
        constructor(PlayerID: string, Token: string, ThemeClothing: string, UserData: string);

        PlayerID: string;
        Token: string;
        ThemeClothing: string;
        UserData: string;

        static StaticClass(): Class;
    }

    export class MWPlayerRuntimeData {
        constructor();
        constructor(PlayerData: MWPlayerData);

        PlayerData: MWPlayerData;

        static StaticClass(): Class;
    }

    export class MWSysPlayerState extends PlayerState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _PlayerRuntimeData: MWPlayerRuntimeData;

        GetPlayerID(): string;

        GetUserData(): string;

        OnRep_PlayerRuntimeData(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPlayerState;

        static Load(InName: string): MWSysPlayerState;
    }

    export class MWSysPointLight extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsDrawBoundsLine: boolean;
        LightComponent: PointLightComponent;
        IconSprite: BillboardComponent;
        color: Color;
        lifeTime: number;
        NumSides: number;
        DepthPriority: number;

        DrawSphereBounds(): void;

        SetIsDrawBoundsLine(IsDraw: boolean): void;

        SetSphereBoundsParam(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPointLight;

        static Load(InName: string): MWSysPointLight;
    }

    export class PostProcessVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: PostProcessSettings;
        Priority: number;
        BlendRadius: number;
        BlendWeight: number;
        bEnabled: boolean;
        bUnbound: boolean;

        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight?: number /* = 1.000000 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PostProcessVolume;

        static Load(InName: string): PostProcessVolume;
    }

    export class MWSysPostProcess extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BloomIntensity: number;
        AutoExposureBias: number;
        AutoExposureMinBrightness: number;
        AutoExposureMaxBrightness: number;
        Saturation: Vector4;
        Contrast: Vector4;
        Gamma: Vector4;
        Gain: Vector4;
        ChildActorComponent: ChildActorComponent;
        PostProcessVolume: PostProcessVolume;

        Flush(): void;

        GetAutoExposureBias(): number;

        GetBloomIntensity(): number;

        GetContrast(): Vector4;

        GetGain(): Vector4;

        GetGamma(): Vector4;

        GetMaxBrightness(): number;

        GetMinBrightness(): number;

        GetSaturation(): Vector4;

        SetAutoExposureBias(NewAutoExposureBias: number): void;

        SetBloomIntensity(NewBloomIntensity: number): void;

        SetContrast(NewContrast: Vector4): void;

        SetGain(NewGain: Vector4): void;

        SetGamma(NewGamma: Vector4): void;

        SetMaxBrightness(NewMaxBrightness: number): void;

        SetMinBrightness(NewMinBrightness: number): void;

        SetSaturation(NewSaturation: Vector4): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPostProcess;

        static Load(InName: string): MWSysPostProcess;
    }

    export class PostProcessComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: PostProcessSettings;
        Priority: number;
        BlendRadius: number;
        BlendWeight: number;
        bEnabled: boolean;
        bUnbound: boolean;

        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight?: number /* = 1.000000 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PostProcessComponent;

        static Load(InName: string): PostProcessComponent;
    }

    export class MWSysPostProcessAdvance extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PostProcessComponent: PostProcessComponent;
        bAutoEnableTeamColor: boolean;
        DefaultSilhouetteColorArray: TArray<Color>;
        DefaultSilhouetteColor: Color;
        OutlineWidth: number;
        OccluderBlend: number;
        PPMIC: MaterialInstanceConstant;
        TeamColorData: Texture2D;
        PPMID: MaterialInstanceDynamic;
        ToneCurveAmount: number;
        BloomIntensity: number;
        GlobalSaturation: number;
        GlobalContrast: number;
        GlobalGamma: number;
        LDRSaturation: number;
        LDRContrast: number;
        LDRGamma: number;
        HDRSaturation: number;
        HDRContrast: number;
        HDRGamma: number;
        LUTBlend: number;
        LUTTexture: Texture2D;
        AmbientOcclusionIntensity: number;
        AmbientOcclusionRadius: number;
        MotionBlur: number;
        LDR2HDRThreshold: number;
        ToneSlope: number;
        ToneToe: number;
        ToneShoulder: number;
        ToneBlackClip: number;
        ToneWhiteClip: number;
        AutoExposureBias: number;
        AutoExposureMinBrightness: number;
        AutoExposureMaxBrightness: number;

        DisableTeamColor(): void;

        EnableTeamColor(): void;

        ExportTeamColorDataAsPNG(): void;

        GetAmbientOcclusionIntensity(): number;

        GetAmbientOcclusionRadius(): number;

        GetAutoExposureBias(): number;

        GetAutoExposureMaxBrightness(): number;

        GetAutoExposureMinBrightness(): number;

        GetBloomIntensity(): number;

        GetGlobalContrast(): number;

        GetGlobalGamma(): number;

        GetGlobalSaturation(): number;

        GetHDRContrast(): number;

        GetHDRGamma(): number;

        GetHDRSaturation(): number;

        GetLDR2HDRThreshold(): number;

        GetLDRContrast(): number;

        GetLDRGamma(): number;

        GetLDRSaturation(): number;

        GetLUTBlend(): number;

        GetLUTTexture(): Texture2D;

        GetLUTTextureAssetByGuid(): string;

        GetMotionBlur(): number;

        GetOccluderBlend(): number;

        GetOutlineWidth(): number;

        GetTeamColor(bSuccess: $Ref<boolean>, OutTeamColor: $Ref<Color>, InTeamID?: number /* = 1 */): void;

        GetToneBlackClip(): number;

        GetToneCurveAmount(): number;

        GetToneShoulder(): number;

        GetToneSlope(): number;

        GetToneToe(): number;

        GetToneWhiteClip(): number;

        InitTeamColorData(bSuccess: $Ref<boolean>, WorldContextObject: $Nullable<Object>): void;

        ManualUpdateTeamColorOutlline(): void;

        SetAmbientOcclusionIntensity(InAmbientOcclusionIntensity: number): void;

        SetAmbientOcclusionRadius(InAmbientOcclusionRadius: number): void;

        SetAutoExposureBias(InAutoExposureBias: number): void;

        SetAutoExposureMaxBrightness(InAutoExposureMaxBrightness: number): void;

        SetAutoExposureMinBrightness(InAutoExposureMinBrightness: number): void;

        SetBloomIntensity(InBloomIntensity: number): void;

        SetGlobalContrast(InGlobalContrast: number): void;

        SetGlobalGamma(InGlobalGamma: number): void;

        SetGlobalSaturation(InGlobalSaturation: number): void;

        SetHDRContrast(InHDRContrast: number): void;

        SetHDRGamma(InHDRGamma: number): void;

        SetHDRSaturation(InHDRSaturation: number): void;

        SetLDR2HDRThreshold(InLDR2HDRThreshold: number): void;

        SetLDRContrast(InLDRContrast: number): void;

        SetLDRGamma(InLDRGamma: number): void;

        SetLDRSaturation(InLDRSaturation: number): void;

        SetLUTBlend(InLUTBlend: number): void;

        SetLUTTexture(InLUTTexture: $Nullable<Texture2D>): void;

        SetLUTTextureAssetByGuid(Value: string): void;

        SetMotionBlur(InMotionBlur: number): void;

        SetOccluderBlend(InOccluderBlend: number): void;

        SetOutlineWidth(InOutlineWidth: number): void;

        SetTeamColor(bSuccess: $Ref<boolean>, InTeamID?: number /* = 1 */, InTeamColor?: Color /* = (R=255,G=127,B=63,A=127) */): void;

        SetToneBlackClip(InToneBlackClip: number): void;

        SetToneCurveAmount(InToneCurveAmount: number): void;

        SetToneShoulder(InToneShoulder: number): void;

        SetToneSlope(InToneSlope: number): void;

        SetToneToe(InToneToe: number): void;

        SetToneWhiteClip(InToneWhiteClip: number): void;

        static GetObjectTeamID(bSuccess: $Ref<boolean>, OutTeamID: $Ref<number>, InObject?: Object /* = None */): void;

        static GetPrimitiveTeamID(bSuccess: $Ref<boolean>, OutTeamID: $Ref<number>, InPrimitive?: PrimitiveComponent /* = None */): void;

        static SetObjectTeamID(bSuccess: $Ref<boolean>, InObject?: Object /* = None */, InTeamID?: number /* = 1 */): void;

        static SetPrimitiveTeamID(bSuccess: $Ref<boolean>, InPrimitive?: PrimitiveComponent /* = None */, InTeamID?: number /* = 1 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysPostProcessAdvance;

        static Load(InName: string): MWSysPostProcessAdvance;
    }

    export class MWSysProcedure_DS extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProcedure_DS;

        static Load(InName: string): MWSysProcedure_DS;
    }

    export class MWSysProcedure_FakeUpdate extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestClick(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProcedure_FakeUpdate;

        static Load(InName: string): MWSysProcedure_FakeUpdate;
    }

    export class MWSysProcedure_Lobby extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProcedure_Lobby;

        static Load(InName: string): MWSysProcedure_Lobby;
    }

    export class MWSysProcedure_Login extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProcedure_Login;

        static Load(InName: string): MWSysProcedure_Login;
    }

    export class MWSysProcedure_Update extends MWSysProcedureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProcedure_Update;

        static Load(InName: string): MWSysProcedure_Update;
    }

    export class MWSysProcedureManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _Procedures: TMap<string, MWSysProcedureBase>;
        _CurrentProcedure: MWSysProcedureBase;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProcedureManager;

        static Load(InName: string): MWSysProcedureManager;
    }

    export class MWSysProjectileEntityStruct {
        constructor();
        constructor(MeshAsset: MWAssetRecorder, ParticleAsset: MWAssetRecorder, InitailSpeed: number, Range: number, bSimulatePhysics: boolean, GravityScale: number, MaxBounces: number, CollisionCapsuleRadius: number, CollisionCapsuleLength: number, bCollisionIgnorePawn: boolean);

        MeshAsset: MWAssetRecorder;
        ParticleAsset: MWAssetRecorder;
        InitailSpeed: number;
        Range: number;
        bSimulatePhysics: boolean;
        GravityScale: number;
        MaxBounces: number;
        CollisionCapsuleRadius: number;
        CollisionCapsuleLength: number;
        bCollisionIgnorePawn: boolean;

        static StaticClass(): Class;
    }

    export class ProjectileMovementComponent extends MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialSpeed: number;
        MaxSpeed: number;
        bRotationFollowsVelocity: boolean;
        bRotationRemainsVertical: boolean;
        bShouldBounce: boolean;
        bInitialVelocityInLocalSpace: boolean;
        bForceSubStepping: boolean;
        bSimulationEnabled: boolean;
        bSweepCollision: boolean;
        bIsHomingProjectile: boolean;
        bBounceAngleAffectsFriction: boolean;
        bIsSliding: boolean;
        bInterpMovement: boolean;
        bInterpRotation: boolean;
        PreviousHitTime: number;
        PreviousHitNormal: Vector;
        ProjectileGravityScale: number;
        Buoyancy: number;
        Bounciness: number;
        Friction: number;
        BounceVelocityStopSimulatingThreshold: number;
        MinFrictionFraction: number;
        OnProjectileBounce: $MulticastDelegate<(ImpactResult: HitResult, ImpactVelocity: Vector) => void>;
        OnProjectileStop: $MulticastDelegate<(ImpactResult: HitResult) => void>;
        HomingAccelerationMagnitude: number;
        HomingTargetComponent: TWeakObjectPtr<SceneComponent>;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        BounceAdditionalIterations: number;
        InterpLocationTime: number;
        InterpRotationTime: number;
        InterpLocationMaxLagDistance: number;
        InterpLocationSnapToTargetDistance: number;

        IsInterpolationComplete(): boolean;

        IsVelocityUnderSimulationThreshold(): boolean;

        LimitVelocity(NewVelocity: Vector): Vector;

        MoveInterpolationTarget(NewLocation: Vector, NewRotation: Rotator): void;

        OnProjectileBounceDelegate__DelegateSignature(ImpactResult: HitResult, ImpactVelocity: Vector): void;

        OnProjectileStopDelegate__DelegateSignature(ImpactResult: HitResult): void;

        ResetInterpolation(): void;

        SetInterpolatedComponent(Component: $Nullable<SceneComponent>): void;

        SetVelocityInLocalSpace(NewVelocity: Vector): void;

        StopSimulating(HitResult: HitResult): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProjectileMovementComponent;

        static Load(InName: string): ProjectileMovementComponent;
    }

    export class MWSysProjectileEntity extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProjectileData: MWSysProjectileEntityStruct;
        ProjectileHitEvent: $MulticastDelegate<(HitComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, NormalImpulse: Vector, Hit: HitResult) => void>;
        ProjectileBeginOverlapEvent: $MulticastDelegate<(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
        ProjectileEndOverlapEvent: $MulticastDelegate<(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number) => void>;
        ProjectileBounceEvent: $MulticastDelegate<(ImpactResult: HitResult, ImpactVelocity: Vector, BounceNum: number) => void>;
        ProjectileInterruptEvent: $MulticastDelegate<() => void>;
        OnRepOwnerSucceessed: $MulticastDelegate<() => void>;
        MeshComp: StaticMeshComponent;
        ParticleComp: ParticleSystemComponent;
        ArrowComp: ArrowComponent;
        CollisionComp: CapsuleComponent;
        MovementComp: ProjectileMovementComponent;
        IsDrawBoundsLine: boolean;
        bOverDistance: boolean;
        bOverMaxBounce: boolean;

        AddDynamicEvent(): void;

        Launch(): void;

        NetMulticastLaunch(SpawnTransform: Transform): void;

        OnUEComponentBeginOverlap(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult): void;

        OnUEComponentBounce(ImpactResult: HitResult, ImpactVelocity: Vector): void;

        OnUEComponentEndOverlap(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number): void;

        OnUEComponentHit(HitComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, NormalImpulse: Vector, Hit: HitResult): void;

        OnUEProjectileStop(ImpactResult: HitResult): void;

        Pause(): void;

        Resume(): void;

        ServerLaunch(): void;

        SetInitialSpeed(Speed: number): void;

        SetupUEComponent(Simulated: boolean): void;

        SpawnMeshAndParticle(): void;

        UpdateProjectileVelocity(Rotation: Rotator): void;

        static HitActorCheck(ActorCheck: $Nullable<Actor>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProjectileEntity;

        static Load(InName: string): MWSysProjectileEntity;
    }

    export class MWSysProjectileLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ObjectsLineTrace(WorldContextObject: $Nullable<Object>, Start: Vector, End: Vector, MultiTrace: boolean, OutHits: $Ref<TArray<HitResult>>, bDebug: boolean): boolean;

        static ObjectsParabolicTrace(WorldContextObject: $Nullable<Object>, StartPos: Vector, Direction: Vector, InitSpeed: number, EffectiveRange: number, ProjectileRadius: number, IgnoreObjectTypes: TArray<EObjectTypeQuery>, OutHit: $Ref<HitResult>, EndPos: $Ref<Vector>, bDebug: boolean): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProjectileLibrary;

        static Load(InName: string): MWSysProjectileLibrary;
    }

    export enum EMWSysSkillHitTargetType { Overlap, Hit, Bounce, EMWSysSkillHitTargetType_MAX }

    export enum EMWSysSkillProjectileBehaveType { Instant, AttachToTarget, EMWSysSkillProjectileBehaveType_MAX }

    export class MWSysSkillProjectileSetting {
        constructor();
        constructor(ProjectilePrefabClass: Class, SpawnLocation: Vector, SpawnDirection: Vector, ProjectileScale: Vector, InitailSpeed: number, Range: number, bSimulatePhysics: boolean, GravityScale: number, MaxBounces: number, MaxPierces: number, ContactBehaviorType: EMWSysSkillProjectileBehaveType, CollisionCapsuleRadius: number, CollisionCapsuleLength: number, InfluenceRangeValue: number, TraceTarget: Actor, bCollisionIgnorePawn: boolean);

        ProjectilePrefabClass: Class;
        SpawnLocation: Vector;
        SpawnDirection: Vector;
        ProjectileScale: Vector;
        InitailSpeed: number;
        Range: number;
        bSimulatePhysics: boolean;
        GravityScale: number;
        MaxBounces: number;
        MaxPierces: number;
        ContactBehaviorType: EMWSysSkillProjectileBehaveType;
        CollisionCapsuleRadius: number;
        CollisionCapsuleLength: number;
        InfluenceRangeValue: number;
        TraceTarget: Actor;
        bCollisionIgnorePawn: boolean;

        static StaticClass(): Class;
    }

    export class MWSysSKillProjectileBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ContactTargetEvent: $MulticastDelegate<(ContactInfo: HitResult, OtherActor: $Nullable<Actor>, ContactType: EMWSysSkillHitTargetType) => void>;
        InterruptEvent: $MulticastDelegate<() => void>;
        ProjectileSettings: MWSysSkillProjectileSetting;
        MeshComp: StaticMeshComponent;
        ParticleComp: ParticleSystemComponent;
        ArrowComp: ArrowComponent;
        CollisionComp: CapsuleComponent;
        MovementComp: ProjectileMovementComponent;
        ProjectileMesh: StaticMesh;
        SpawnParticle: ParticleSystem;
        BehaviorType: EMWSysSkillProjectileBehaveType;
        EffectRangeValue: number;

        FollowTheTrail(StartLocation: Vector, TargetLocation: Vector, Speed: number): void;

        HitActorCheck(ActorCheck: $Nullable<Actor>): boolean;

        LoadMeshByString(PathName: string): StaticMesh;

        LoadParticleByString(PathName: string): ParticleSystem;

        OnBeginOverlap(OverlappedComp: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult): void;

        OnComponentBounce(ImpactResult: HitResult, ImpactVelocity: Vector): void;

        OnComponentHit(HitComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, NormalImpulse: Vector, Hit: HitResult): void;

        OnComponentOverlap(OverlappedComponent: $Nullable<PrimitiveComponent>, OtherActor: $Nullable<Actor>, OtherComp: $Nullable<PrimitiveComponent>, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult): void;

        OnInterrupt(): void;

        OnRep_Mesh(): void;

        OnRep_Particle(): void;

        OnRep_ProjectileSetting(): void;

        SetEffectRange(DamageRange: number): void;

        SetInfluenceRange(InfluenceRange: number): void;

        SetInitialSpeed(Speed: number): void;

        SetMesh(Mesh: $Nullable<StaticMesh>): void;

        SetParticle(Particle: $Nullable<ParticleSystem>): void;

        SetTraceTarget(Target: $Nullable<Actor>): void;

        Setup(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSKillProjectileBase;

        static Load(InName: string): MWSysSKillProjectileBase;
    }

    export enum EMWSysSkillProjectileType { LineTrace, ParabolicTrace, Entity, EMWSysSkillProjectileType_MAX }

    export class MWSysProjectileStruct {
        constructor();
        constructor(ProjectileType: EMWSysSkillProjectileType, MeshAsset: MWAssetRecorder, ParticleAsset: MWAssetRecorder, ProjectileSetting: MWSysSkillProjectileSetting, ProjectileStaticMeshPath: string, ProjectileEmitterPath: string, ProjectileHitEmitterPath: string);

        ProjectileType: EMWSysSkillProjectileType;
        MeshAsset: MWAssetRecorder;
        ParticleAsset: MWAssetRecorder;
        ProjectileSetting: MWSysSkillProjectileSetting;
        ProjectileStaticMeshPath: string;
        ProjectileEmitterPath: string;
        ProjectileHitEmitterPath: string;

        static StaticClass(): Class;
    }

    export class MWSysProjectileObj extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Root: SceneComponent;
        Projectile: MWSysSKillProjectileBase;
        GProjectileData: MWSysProjectileStruct;
        ProjectileTargetEvent: $MulticastDelegate<(ContactInfo: HitResult, OtherActor: $Nullable<Actor>, ContactType: EMWSysSkillHitTargetType) => void>;
        ProjectileChangeEvent: $MulticastDelegate<(OtherActor: $Nullable<Actor>) => void>;
        TestMesh: StaticMesh;

        OnProjectileHit(ContactInfo: HitResult, OtherActor: $Nullable<Actor>, ContactType: EMWSysSkillHitTargetType): void;

        OnRep_ProjectileChange(): void;

        ServerSpawnProjectile(SpawnTransform: Transform): void;

        SpawnProjectile(OutHits: $Ref<TArray<HitResult>>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysProjectileObj;

        static Load(InName: string): MWSysProjectileObj;
    }

    export enum ERecastPartitioning { Monotone, Watershed, ChunkyMonotone, ERecastPartitioning_MAX }

    export class RecastNavMesh extends NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDrawTriangleEdges: boolean;
        bDrawPolyEdges: boolean;
        bDrawFilledPolys: boolean;
        bDrawNavMeshEdges: boolean;
        bDrawTileBounds: boolean;
        bDrawPathCollidingGeometry: boolean;
        bDrawTileLabels: boolean;
        bDrawPolygonLabels: boolean;
        bDrawDefaultPolygonCost: boolean;
        bDrawLabelsOnPathNodes: boolean;
        bDrawNavLinks: boolean;
        bDrawFailedNavLinks: boolean;
        bDrawClusters: boolean;
        bDrawOctree: boolean;
        bDrawOctreeDetails: boolean;
        bDrawMarkedForbiddenPolys: boolean;
        bDistinctlyDrawTilesBeingBuilt: boolean;
        DrawOffset: number;
        bFixedTilePoolSize: boolean;
        TilePoolSize: number;
        TileSizeUU: number;
        CellSize: number;
        CellHeight: number;
        AgentRadius: number;
        AgentHeight: number;
        AgentMaxSlope: number;
        AgentMaxStepHeight: number;
        MinRegionArea: number;
        MergeRegionSize: number;
        MaxSimplificationError: number;
        MaxSimultaneousTileGenerationJobsCount: number;
        TileNumberHardLimit: number;
        PolyRefTileBits: number;
        PolyRefNavPolyBits: number;
        PolyRefSaltBits: number;
        NavMeshOriginOffset: Vector;
        DefaultDrawDistance: number;
        DefaultMaxSearchNodes: number;
        DefaultMaxHierarchicalSearchNodes: number;
        RegionPartitioning: ERecastPartitioning;
        LayerPartitioning: ERecastPartitioning;
        RegionChunkSplits: number;
        LayerChunkSplits: number;
        bSortNavigationAreasByCost: boolean;
        bPerformVoxelFiltering: boolean;
        bMarkLowHeightAreas: boolean;
        bUseExtraTopCellWhenMarkingAreas: boolean;
        bFilterLowSpanSequences: boolean;
        bFilterLowSpanFromTileCache: boolean;
        bDoFullyAsyncNavDataGathering: boolean;
        bUseBetterOffsetsFromCorners: boolean;
        bStoreEmptyTileLayers: boolean;
        bUseVirtualFilters: boolean;
        bAllowNavLinkAsPathEnd: boolean;
        bUseVoxelCache: boolean;
        TileSetUpdateInterval: number;
        HeuristicScale: number;
        VerticalDeviationFromGroundCompensation: number;

        K2_ReplaceAreaInTileBounds(Bounds: Box, OldArea: $Nullable<Class>, NewArea: $Nullable<Class>, ReplaceLinks?: boolean /* = true */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RecastNavMesh;

        static Load(InName: string): RecastNavMesh;
    }

    export class MWSysRecastNavMesh extends RecastNavMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysRecastNavMesh;

        static Load(InName: string): MWSysRecastNavMesh;
    }

    export class RectLightComponent extends LocalLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceWidth: number;
        SourceHeight: number;
        BarnDoorAngle: number;
        BarnDoorLength: number;
        SourceTexture: Texture;

        SetBarnDoorAngle(NewValue: number): void;

        SetBarnDoorLength(NewValue: number): void;

        SetSourceHeight(NewValue: number): void;

        SetSourceTexture(bNewValue: $Nullable<Texture>): void;

        SetSourceWidth(bNewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RectLightComponent;

        static Load(InName: string): RectLightComponent;
    }

    export class MWSysRectLight extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsDrawBoundsLine: boolean;
        RectLightComponent: RectLightComponent;
        IconSprite: BillboardComponent;
        SourceWidth: number;
        SourceHeight: number;
        BarnDoorAngle: number;
        BarnDoorLength: number;
        RectColor: Color;
        LifeTime: number;
        DepthPriority: number;

        SetIsDrawBoundsLine(IsDraw: boolean): void;

        SetRectBoundsParam(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysRectLight;

        static Load(InName: string): MWSysRectLight;
    }

    export enum EMWSysRotatorState { Start, End, ToStart, ToEnd, EMWSysRotatorState_MAX }

    export class MWSysRotator extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpinningTime: number;
        NeedRotationAngle: Rotator;
        OnRotatorStartClient: $MulticastDelegate<() => void>;
        OnRotatorEndClient: $MulticastDelegate<() => void>;
        OnRotatorStartServer: $MulticastDelegate<() => void>;
        OnRotatorEndServer: $MulticastDelegate<() => void>;
        _RootComp: SceneComponent;
        IconSprite: BillboardComponent;
        _CurrentProgress: number;
        ECurrentState: EMWSysRotatorState;
        InitRotation: Rotator;
        EndRotation: Rotator;
        ConstraintActor: Actor;

        BreakSpinning(): void;

        ClientRotatorEnd(State: EMWSysRotatorState): void;

        ClientRotatorProgress(CurrentProgress: number, State: EMWSysRotatorState): void;

        ClientRotatorStart(State: EMWSysRotatorState): void;

        GetConstraintActor(): Actor;

        GetCurrentState(): EMWSysRotatorState;

        OnReverse(): void;

        OnRun(): void;

        ServerRotatorEnd(State: EMWSysRotatorState): void;

        ServerRotatorProgress(CurrentProgress: number, State: EMWSysRotatorState): void;

        ServerRotatorStart(State: EMWSysRotatorState): void;

        SetConstraintActor(value: string): void;

        SpinningToClose(DeltaTime: number): void;

        SpinningToOpen(DeltaTime: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysRotator;

        static Load(InName: string): MWSysRotator;
    }

    export enum EMWSysRotatorDirection { X, Y, Z, EMWSysRotatorDirection_MAX }

    export enum EMWSysRotator2State { Stop, Running, EMWSysRotator2State_MAX }

    export class MWSysRotator2 extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootComp: SceneComponent;
        ConstraintComp: PhysicsConstraintComponent;
        IconSprite: BillboardComponent;
        OnRotationRun: $MulticastDelegate<() => void>;
        OnRotationStop: $MulticastDelegate<() => void>;
        bIsPhysicsMode: boolean;
        Phy_ConstraintActor: Actor;
        Phy_ConstraintAngular: number;
        Phy_RecoveryStrength: number;
        ERotationDirection: EMWSysRotatorDirection;
        ERotationState: EMWSysRotator2State;
        bIsConstraintAngle: boolean;
        RotatedAngle: number;
        MaxRotationalAngle: number;
        RotationalAngularVelocity: number;
        MaxRotationalAngularVelocity: number;
        RotationalAngularAcceleration: number;
        Reverse: boolean;
        DelayInitDataTimerHandle: TimerHandle;
        DelayFindActorTimerHandle: TimerHandle;

        CalculateTheRotationAngle(DeltaTime: number): Rotator;

        CheckState(): EMWSysRotator2State;

        GetConstraintActor(): Actor;

        GetConstraintActorGUID(): string;

        GetIsConstraintAngle(): boolean;

        GetIsPhysicsMode(): boolean;

        GetMaxRotationalAngle(): number;

        GetMaxRotationalAngularVelocity(): number;

        GetRotationalAngularAcceleration(): number;

        GetRotationalAngularVelocity(): number;

        GetRotationalDirection(): EMWSysRotatorDirection;

        GetRotationState(): EMWSysRotator2State;

        MulticastRotationToRun(): void;

        MulticastRotationToStop(): void;

        OnEnd(): void;

        OnReverse(): void;

        OnRunning(): void;

        Phy_SetUp(): void;

        ServerRotationToReverse(): void;

        ServerRotationToRun(): void;

        ServerRotationToStop(): void;

        SetConstraintActor(Value: string): void;

        SetIsConstraintAngle(Value: boolean): void;

        SetIsPhysicsMode(Value: boolean): void;

        SetMaxRotationalAngle(Value: number): void;

        SetMaxRotationalAngularVelocity(Value: number): void;

        SetRotationalAngularAcceleration(Value: number): void;

        SetRotationalAngularVelocity(Value: number): void;

        SetRotationalDirection(Value: EMWSysRotatorDirection): void;

        UpdateRotator(): void;

        UpdateRotatorAngle(Value: Rotator): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysRotator2;

        static Load(InName: string): MWSysRotator2;
    }

    export class MWSysSkeletalMeshActor extends MWSysActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SKGuid: string;
        Mesh: MWSkeletalMeshComponent;

        GetSkeletalMeshComponent(): MWSkeletalMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkeletalMeshActor;

        static Load(InName: string): MWSysSkeletalMeshActor;
    }

    export class MWSysSkillASC extends AbilitySystemComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillASC;

        static Load(InName: string): MWSysSkillASC;
    }

    export enum EMWSysSkillStage { Pre, Cast, Post, EMWSysSkillStage_MAX }

    export enum EMWSysSkillTargetType { SELF, FRIENDS, ENEMY, EMWSysSkillTargetType_MAX }

    export enum EMWSysSkillTargetSelectType {
        None,
        SectorRange,
        RectangularRange,
        GroundSphereTrace,
        EMWSysSkillTargetSelectType_MAX
    }

    export class MWSysSkillTargetSelectParameters {
        constructor();
        constructor(MaxRadius: number, InfluenceRadius: number, WideSide: number, HeightSide: number, Angle: number, AutoSpawn: boolean);

        MaxRadius: number;
        InfluenceRadius: number;
        WideSide: number;
        HeightSide: number;
        Angle: number;
        AutoSpawn: boolean;

        static StaticClass(): Class;
    }

    export enum EMWSysSkillTargetFilter { All, OnlySelf, OnlyPawn, Enemy, EMWSysSkillTargetFilter_MAX }

    export class MWSysSkillTargetFilter {
        constructor();
        constructor(TargetFilterEnum: EMWSysSkillTargetFilter, bReverseFilter: boolean);

        TargetFilterEnum: EMWSysSkillTargetFilter;
        bReverseFilter: boolean;

        static StaticClass(): Class;
    }

    export class MWSysSkillMotionControlStruct {
        constructor();
        constructor(MoveSpeed: number, TurnSpeed: number, JumpFlag: boolean, MoveFlag: boolean, FaceTargetFlag: boolean, InterruptOnMoveFlag: boolean, Socket: string, Offset: Transform, MontagePath: string, StageDuration: number);

        MoveSpeed: number;
        TurnSpeed: number;
        JumpFlag: boolean;
        MoveFlag: boolean;
        FaceTargetFlag: boolean;
        InterruptOnMoveFlag: boolean;
        Socket: string;
        Offset: Transform;
        MontagePath: string;
        StageDuration: number;

        static StaticClass(): Class;
    }

    export class MWSysSkillDataTableBaseStruct extends TableRowBase {
        constructor();
        constructor(SkillName: string, SkillLevel: number, TargetType: EMWSysSkillTargetType, bActivateOnGranted: boolean, bRequireTarget: boolean, TargetSelectType: EMWSysSkillTargetSelectType, TargetParam: MWSysSkillTargetSelectParameters, TargetFilter: MWSysSkillTargetFilter, PlacementActor: Class, AbilityDamageClass: Class, SelfCooldownDuration: number, CommonCooldownDuration: number, PreMontageInfo: MWSysSkillMotionControlStruct, CastMontageInfo: MWSysSkillMotionControlStruct, PostMontageInfo: MWSysSkillMotionControlStruct, bHasProjectile: boolean, ProjectileData: MWSysProjectileStruct);

        SkillName: string;
        SkillLevel: number;
        TargetType: EMWSysSkillTargetType;
        bActivateOnGranted: boolean;
        bRequireTarget: boolean;
        TargetSelectType: EMWSysSkillTargetSelectType;
        TargetParam: MWSysSkillTargetSelectParameters;
        TargetFilter: MWSysSkillTargetFilter;
        PlacementActor: Class;
        AbilityDamageClass: Class;
        SelfCooldownDuration: number;
        CommonCooldownDuration: number;
        PreMontageInfo: MWSysSkillMotionControlStruct;
        CastMontageInfo: MWSysSkillMotionControlStruct;
        PostMontageInfo: MWSysSkillMotionControlStruct;
        bHasProjectile: boolean;
        ProjectileData: MWSysProjectileStruct;

        static StaticClass(): Class;
    }

    export class MWSysSkillTask_WaitCharacterMove extends AbilityTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnCharacterMove: $MulticastDelegate<() => void>;
        CachedMovementComponent: MovementComponent;

        static CreateWaitCharacterMove(OwningAbility: $Nullable<GameplayAbility>, MaximumMagnitude: number): MWSysSkillTask_WaitCharacterMove;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillTask_WaitCharacterMove;

        static Load(InName: string): MWSysSkillTask_WaitCharacterMove;
    }

    export class MWSysSkillBase extends GameplayAbility {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPreStageStart: $MulticastDelegate<() => void>;
        OnPreStageEnd: $MulticastDelegate<() => void>;
        OnCastStageStart: $MulticastDelegate<() => void>;
        OnCastStageEnd: $MulticastDelegate<() => void>;
        OnPostStageStart: $MulticastDelegate<() => void>;
        OnPostStageEnd: $MulticastDelegate<() => void>;
        OnFailed: $MulticastDelegate<() => void>;
        OnInterrupted: $MulticastDelegate<() => void>;
        OnNormalEnd: $MulticastDelegate<() => void>;
        OnTargetConfirmDelegate: $MulticastDelegate<(TargetActor: TArray<Actor>, HitLocation: Vector) => void>;
        OnTargetContact: $MulticastDelegate<(ContactInfo: HitResult, OtherActor: $Nullable<Actor>, Owner: $Nullable<Actor>, ContactType: EMWSysSkillHitTargetType) => void>;
        OnSkillProjectileChanged: $MulticastDelegate<(OtherActor: $Nullable<Actor>) => void>;
        SelfCooldownDuration: number;
        CommonCooldownDuration: number;
        ProjectileObj: MWSysProjectileObj;
        TempCooldownTags: GameplayTagContainer;
        Stage: EMWSysSkillStage;
        FilterHandle: GameplayTargetDataFilterHandle;
        SpawnActor: GameplayAbilityTargetActor;
        SkillData: MWSysSkillDataTableBaseStruct;
        Targets: TArray<Actor>;
        CastCenterLocation: Vector;
        TestMesh: StaticMesh;
        DelayTask_Pre: AbilityTask_WaitDelay;
        DelayTask_Cast: AbilityTask_WaitDelay;
        DelayTask_Post: AbilityTask_WaitDelay;
        Task_CharMove: MWSysSkillTask_WaitCharacterMove;
        GlobalWaitTargetData: AbilityTask_WaitTargetData;

        EndSkill(bInterrupted: boolean): void;

        GetProjectile(): MWSysSKillProjectileBase;

        GetSelf(): MWSysSkillBase;

        GetSkillData(OutSkillData: $Ref<MWSysSkillDataTableBaseStruct>): void;

        OnCharacterMove(): void;

        OnDelayFinished(): void;

        OnProjectileChange(Projectile: $Nullable<Actor>): void;

        OnProjectileHit(ContactInfo: HitResult, OtherActor: $Nullable<Actor>, ContactType: EMWSysSkillHitTargetType): void;

        OnRep_ParticleObj(): void;

        OnRep_SkillData(): void;

        OnSkillCastStageEnd(): void;

        OnSkillCastStageStart(): void;

        OnSkillFailed(): void;

        OnSkillInterrupted(): void;

        OnSkillNormalEnd(): void;

        OnSkillPostStageEnd(): void;

        OnSkillPostStageStart(): void;

        OnSkillPreStageEnd(): void;

        OnSkillPreStageStart(): void;

        OnSkillTargetConfirm(TargetHitActors: TArray<Actor>, HitLocation: Vector): void;

        OnTargetCancel(Data: GameplayAbilityTargetDataHandle): void;

        OnTargetValid(Data: GameplayAbilityTargetDataHandle): void;

        ServerEndSkill(bInterrupted: boolean): void;

        ServerSetDynamicData(NewTargets: TArray<Actor>, NewCastCenterLocation: Vector): void;

        ServerSetSkillData(NewSkillData: MWSysSkillDataTableBaseStruct): void;

        SetProjectileSpawnInfo(SpawnLocation: Vector, SpawnDirection: Vector, ProjectileScale: Vector, Target: $Nullable<Actor>): void;

        SetTargetSelect(Distance: number, RelRotation: number): void;

        SkillSpawnProjectile(): void;

        TSSetupSkill(NewSkillData: MWSysSkillDataTableBaseStruct): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillBase;

        static Load(InName: string): MWSysSkillBase;
    }

    export class MWSysSkillDataTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _SkillDataTable: DataTable;

        CheckSkillTable(): void;

        LoadSkillCSV(): boolean;

        LoadSkillTable(SkillID: string): MWSysSkillDataTableBaseStruct;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillDataTable;

        static Load(InName: string): MWSysSkillDataTable;
    }

    export class MWSysSkillEffectCooldown extends GameplayEffect {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetDurationTag(): GameplayTag;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillEffectCooldown;

        static Load(InName: string): MWSysSkillEffectCooldown;
    }

    export class MWSysSkillGISubsystem extends GameInstanceSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillGISubsystem;

        static Load(InName: string): MWSysSkillGISubsystem;
    }

    export class MWSysSkillInterface_SetTarState extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetTargetActorState(Rotation: number, Distance: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillInterface_SetTarState;

        static Load(InName: string): MWSysSkillInterface_SetTarState;
    }

    export class MWSysSkillManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static ActiveSkillWithName(TargetActor: $Nullable<Actor>, AbilityName: string): boolean;

        static ActorSkillTargetCancel(TargetActor: $Nullable<Actor>): void;

        static ActorSkillTargetConfirm(TargetActor: $Nullable<Actor>): void;

        static AddSkillToTarget(TargetActor: $Nullable<Actor>, SkillData: MWSysSkillDataTableBaseStruct): void;

        static ApplyEffectToTarget(TargetActor: $Nullable<Actor>, Effect: $Nullable<Class>): void;

        static CancelSkillWithName(TargetActor: $Nullable<Actor>, AbilityName: string): void;

        static GetCooldownRemainingTimeWithName(TargetActor: $Nullable<Actor>, AbilityName: string, TimeRemaining: $Ref<number>, CooldownDuration: $Ref<number>, CommonTimeRemaining: $Ref<number>, CommonCooldownDuration: $Ref<number>): boolean;

        static GetSkillByName(TargetActor: $Nullable<Actor>, SkillName: string): MWSysSkillBase;

        static SetSkillTargetDistanceAndRotation(TargetActor: $Nullable<Actor>, Distance: number, RelativeRotation: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillManager;

        static Load(InName: string): MWSysSkillManager;
    }

    export class MWSkillHandleData {
        constructor();
        constructor(SkillName: string, SkillHandle: GameplayAbilitySpecHandle);

        SkillName: string;
        SkillHandle: GameplayAbilitySpecHandle;

        static StaticClass(): Class;
    }

    export class MWSysSkillObject extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MWAbilitySystemComponent: MWSysSkillASC;
        RootComp: SceneComponent;
        OwningActor: Actor;
        SkillHandles: TArray<MWSkillHandleData>;
        LocalSkillData: MWSysSkillDataTableBaseStruct;
        IconSprite: BillboardComponent;
        SkillDataBase: MWSysSkillDataTableBaseStruct;

        ActivateAbilitiesWithTags(AbilityTags: GameplayTagContainer, bAllowRemoteActivation?: boolean /* = true */): boolean;

        ActivateAbilityWithName(SkillName: string): boolean;

        ActivateAbilityWithParams(SkillName: string, Targets: TArray<Actor>, CastCenterLocation: Vector, ErrorMsg: $Ref<string>): boolean;

        AddAbilityWithName(NewSkillClass: $Nullable<Class>, SkillName: string): void;

        AddSkill(Actor: $Nullable<Actor>): void;

        CanActivateAbility(SkillName: string): boolean;

        EndAbilityWithName(SkillName: string): void;

        GetActiveAbilitiesWithTags(AbilityTags: GameplayTagContainer, ActiveAbilities: $Ref<TArray<MWSysSkillBase>>): void;

        GetCooldownRemainingForTag(CooldownTags: GameplayTagContainer, TimeRemaining: $Ref<number>, CooldownDuration: $Ref<number>): boolean;

        GetSkillData(): MWSysSkillDataTableBaseStruct;

        GetSkillHandleWithName(SkillName: string): GameplayAbilitySpecHandle;

        GetSKillInstanceByName(SkillName: string): MWSysSkillBase;

        InitSkillWithDataStruct(SkillData: MWSysSkillDataTableBaseStruct): void;

        RemoveAbilityWithName(SkillName: string): void;

        ServerActivateWithName(SkillName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillObject;

        static Load(InName: string): MWSysSkillObject;
    }

    export class MWSysSkillTagManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        _MWSysGameplayTagDataTable: DataTable;

        GetAllTag(): TArray<GameplayTag>;

        InitTag(): void;

        static AddOneSkillTag(TagName: string, DataTable: $Nullable<DataTable>): boolean;

        static AddTag(TagName: string): void;

        static DeleteOneSkillTag(TagName: string, DataTable: $Nullable<DataTable>): boolean;

        static DeleteTag(TagName: string): void;

        static GetTag(TagName: string): GameplayTag;

        static HasTagInManager(TagName: string): boolean;

        static RefreshTagTree(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillTagManager;

        static Load(InName: string): MWSysSkillTagManager;
    }

    export class MWSysSkillTarget_GetRangeActors extends GameplayAbilityTargetActor_GroundTrace {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Root: SceneComponent;
        MaxRangeRadius: DecalComponent;
        ActualInfluenceRadius: DecalComponent;
        MaxRangeRadiusValue: number;
        ActualInfluenceRadiusValue: number;
        UserCustomRotation_Degree: number;
        UserCustomDistance: number;

        SetTargetActorState(Rotation: number, Distance: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillTarget_GetRangeActors;

        static Load(InName: string): MWSysSkillTarget_GetRangeActors;
    }

    export class MWSysTarget_PlacementReticle extends GameplayAbilityWorldReticle {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CollisionComponent: CapsuleComponent;
        DefaultAnimSequence: AnimSequence;
        VisualizationComponents: TArray<ActorComponent>;

        AddSkeletalComponent(): SkeletalMeshComponent;

        SetTargetActor(SourceActor: $Nullable<Actor>): void;

        static GetComponentRelativeTranstorm(MeshComponent: $Nullable<SceneComponent>, Root: $Nullable<SceneComponent>): Transform;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysTarget_PlacementReticle;

        static Load(InName: string): MWSysTarget_PlacementReticle;
    }

    export class MWSysSkillTarget_PlacementActor extends GameplayAbilityTargetActor_GroundTrace {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlacedActorClass: Class;
        AutoSpawn: boolean;
        MaxRangeRadiusValue: number;
        PlacedActorMaterial: MaterialInterface;
        UserCustomRotation_Degree: number;
        UserCustomDistance: number;
        ConfirmTrans: Transform;

        GetPlacementReticle(): MWSysTarget_PlacementReticle;

        SetTargetActorState(Rotation: number, Distance: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillTarget_PlacementActor;

        static Load(InName: string): MWSysSkillTarget_PlacementActor;
    }

    export class MWSysSkillTarget_Rectangle extends GameplayAbilityTargetActor_Radius {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AttachComponent: SceneComponent;
        ArrowComponent: ArrowComponent;
        MaxRangeRadius: DecalComponent;
        RectangleDecal: DecalComponent;
        RectangleWidth: ScalableFloat;
        RectangleHeight: number;
        ExternalRange: number;
        UserCustomRotation: number;

        SetTargetActorState(Rotation: number, Distance: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillTarget_Rectangle;

        static Load(InName: string): MWSysSkillTarget_Rectangle;
    }

    export class MWSysSkillTarget_Sector extends GameplayAbilityTargetActor_Radius {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AttachComponent: SceneComponent;
        ArrowComponent: ArrowComponent;
        ExternalRadius: DecalComponent;
        InternalSector: DecalComponent;
        SectorAngle: ScalableFloat;
        ExternalRange: number;
        DetermineHalfHeight: number;
        InternalSectorMaterial: MaterialInstanceDynamic;
        UserCustomRotation: number;

        SetTargetActorState(Rotation: number, Distance: number): void;

        static AngleHitCheck(Angle: number, OriginLoc: Vector, OriginForward: Vector, TargetLoc: Vector): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkillTarget_Sector;

        static Load(InName: string): MWSysSkillTarget_Sector;
    }

    export class MWSysSkyBoxMaterial extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SunHeight: number;
        HorizonFalloff: number;
        ZenithColor: LinearColor;
        HorizonColor: LinearColor;
        CloudColor: LinearColor;
        OverallColor: LinearColor;
        ColorsDeterminedBySunPosition: boolean;
        SunBrightness: number;
        CloudSpeed: number;
        CloudOpacity: number;
        SkyBrightness: number;
        StarsBrightness: number;
        HorizonColorCurve: CurveLinearColor;
        ZenithColorCurve: CurveLinearColor;
        CloudColorCurve: CurveLinearColor;

        GetCloudColor(): LinearColor;

        GetCloudColorCurve(): CurveLinearColor;

        GetCloudOpacity(): number;

        GetCloudSpeed(): number;

        GetColorsDeterminedBySunPosition(): boolean;

        GetHorizonColor(): LinearColor;

        GetHorizonColorCurve(): CurveLinearColor;

        GetHorizonFalloff(): number;

        GetOverallColor(): LinearColor;

        GetSkyBrightness(): number;

        GetStarsBrightness(): number;

        GetSunBrightness(): number;

        GetSunHeight(): number;

        GetZenithColor(): LinearColor;

        GetZenithColorCurve(): CurveLinearColor;

        OnRep_Refresh(): void;

        RefreshMaterial_Imp(): void;

        SetCloudColor(NewCloudColor: LinearColor): void;

        SetCloudColorCurve(NewCloudColorCurve: $Nullable<CurveLinearColor>): void;

        SetCloudOpacity(NewCloudOpacity: number): void;

        SetCloudSpeed(NewCloudSpeed: number): void;

        SetColorsDeterminedBySunPosition(NewColorsDeterminedBySunPosition: boolean): void;

        SetHorizonColor(NewHorizonColor: LinearColor): void;

        SetHorizonColorCurve(NewHorizonColorCurve: $Nullable<CurveLinearColor>): void;

        SetHorizonFalloff(NewHorizonFalloff: number): void;

        SetMaterial(): void;

        SetOverallColor(NewOverallColor: LinearColor): void;

        SetSkyBrightness(NewSkyBrightness: number): void;

        SetStarsBrightness(NewStarsBrightness: number): void;

        SetSunBrightness(NewSunBrightness: number): void;

        SetSunHeight(NewSunHeight: number): void;

        SetZenithColor(NewZenithColor: LinearColor): void;

        SetZenithColorCurve(NewZenithColorCurve: $Nullable<CurveLinearColor>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkyBoxMaterial;

        static Load(InName: string): MWSysSkyBoxMaterial;
    }

    export enum EMWSysSkyPreset {
        Morning_2D,
        Noon_2D,
        Dusk_2D,
        Night_2D,
        Morning_LowPoly,
        Noon_LowPoly,
        Dusk_LowPoly,
        Night_LowPoly,
        EMWSysSkyPreset_MAX
    }

    export class MWSysSkyBoxMaterial2 extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SkyPreset: EMWSysSkyPreset;
        SkyDomeTexture: Texture2D;
        SkyDomeTextureAssetID: string;
        SkyDomeIntensity: number;
        SkyDomeTint: LinearColor;
        bEnableSkyDomeGradient: boolean;
        SkyDomeTopTint: LinearColor;
        SkyDomeHorizontalTint: LinearColor;
        SkyDomeBotTint: LinearColor;
        SkyDomeHorizontalFallOff: number;
        bEnableStar: boolean;
        StarTexture: Texture2D;
        StarTextureAssetID: string;
        StarIntensity: number;
        StarTiling: number;
        bEnableSun: boolean;
        SunTexture: Texture2D;
        SunTextureAssetID: string;
        SunIntensity: number;
        SunTint: LinearColor;
        SunSize: number;
        bEnableMoon: boolean;
        MoonTexture: Texture2D;
        MoonTextureAssetID: string;
        MoonIntensity: number;
        MoonTint: LinearColor;
        MoonSize: number;
        bEnableCloud: boolean;
        CloudTexture: Texture2D;
        CloudTextureAssetID: string;
        CloudOpacity: number;
        CloudTint: LinearColor;
        CloudDensity: number;
        CloudSpeed: number;
        SkyPresetParameters: DataTable;

        GetCloudDensity(): number;

        GetCloudOpacity(): number;

        GetCloudSpeed(): number;

        GetCloudTextureAssetID(): string;

        GetCloudTint(): LinearColor;

        GetIsEnableCloud(): boolean;

        GetIsEnableMoon(): boolean;

        GetIsEnableSkyDomeGradient(): boolean;

        GetIsEnableStar(): boolean;

        GetIsEnableSun(): boolean;

        GetMoonIntensity(): number;

        GetMoonSize(): number;

        GetMoonTextureAssetID(): string;

        GetMoonTint(): LinearColor;

        GetSkyBoxMaterialInstanceConstant(SkyBoxInstanceBasePath?: string /* = "MaterialInstanceConstant'/MWSysGamePlayObjects/MWSysSkyBox/Preset/MI_MW_Sky_Preset_.MI_MW_Sky_Preset_'" */): MaterialInstanceConstant;

        GetSkyDomeBotTint(): LinearColor;

        GetSkyDomeHorizontalFallOff(): number;

        GetSkyDomeHorizontalTint(): LinearColor;

        GetSkyDomeIntensity(): number;

        GetSkyDomeTextureAssetID(): string;

        GetSkyDomeTint(): LinearColor;

        GetSkyDomeTopTint(): LinearColor;

        GetSkyPreset(): EMWSysSkyPreset;

        GetStarIntensity(): number;

        GetStarTextureAssetID(): string;

        GetStarTiling(): number;

        GetSunIntensity(): number;

        GetSunSize(): number;

        GetSunTextureAssetID(): string;

        GetSunTint(): LinearColor;

        OnBehaviorRegisterToWorld(InBehavior: $Nullable<MWActor>): void;

        OnRep_Refresh(): void;

        RefreshMaterial_Imp(): void;

        ResetSkyBoxParams(): void;

        SetCloudDensity(Value: number): void;

        SetCloudOpacity(Value: number): void;

        SetCloudSpeed(Value: number): void;

        SetCloudTextureAssetByID(Value: string): void;

        SetCloudTint(Value: LinearColor): void;

        SetIsEnableCloud(Value: boolean): void;

        SetIsEnableMoon(Value: boolean): void;

        SetIsEnableSkyDomeGradient(Value: boolean): void;

        SetIsEnableStar(Value: boolean): void;

        SetIsEnableSun(Value: boolean): void;

        SetMoonIntensity(Value: number): void;

        SetMoonSize(Value: number): void;

        SetMoonTextureAssetByID(Value: string): void;

        SetMoonTint(Value: LinearColor): void;

        SetPreSetByIndex(InIndex: number): void;

        SetPreSetByName(InName: string): void;

        SetSkyDomeBotTint(Value: LinearColor): void;

        SetSkyDomeHorizontalFallOff(Value: number): void;

        SetSkyDomeHorizontalTint(Value: LinearColor): void;

        SetSkyDomeIntensity(Value: number): void;

        SetSkyDomeTextureAssetByID(Value: string): void;

        SetSkyDomeTint(Value: LinearColor): void;

        SetSkyDomeTopTint(Value: LinearColor): void;

        SetSkyPreset(Preset: EMWSysSkyPreset): void;

        SetStarIntensity(Value: number): void;

        SetStarTextureAssetByID(Value: string): void;

        SetStarTiling(Value: number): void;

        SetSunIntensity(Value: number): void;

        SetSunSize(Value: number): void;

        SetSunTextureAssetByID(Value: string): void;

        SetSunTint(Value: LinearColor): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSkyBoxMaterial2;

        static Load(InName: string): MWSysSkyBoxMaterial2;
    }

    export enum ExtrapolationMode { UNLIMITED, LIMITED, NONE, ExtrapolationMode_MAX }

    export enum SyncMode { XYZ, XY, XZ, YZ, X, Y, Z, NONE, SyncMode_MAX }

    export class SmoothSync extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        interpolationBackTime: number;
        extrapolationMode: ExtrapolationMode;
        useExtrapolationTimeLimit: boolean;
        extrapolationTimeLimit: number;
        useExtrapolationDistanceLimit: boolean;
        extrapolationDistanceLimit: number;
        sendPositionThreshold: number;
        sendRotationThreshold: number;
        sendScaleThreshold: number;
        sendVelocityThreshold: number;
        sendAngularVelocityThreshold: number;
        receivedPositionThreshold: number;
        receivedRotationThreshold: number;
        positionSnapThreshold: number;
        rotationSnapThreshold: number;
        scaleSnapThreshold: number;
        timeSmoothing: number;
        positionLerpSpeed: number;
        rotationLerpSpeed: number;
        scaleLerpSpeed: number;
        syncPosition: SyncMode;
        syncRotation: SyncMode;
        syncScale: SyncMode;
        syncVelocity: SyncMode;
        syncAngularVelocity: SyncMode;
        syncMovementMode: boolean;
        isPositionCompressed: boolean;
        isRotationCompressed: boolean;
        isScaleCompressed: boolean;
        isVelocityCompressed: boolean;
        isAngularVelocityCompressed: boolean;
        sendRate: number;
        isUsingOriginRebasing: boolean;
        alwaysSendOrigin: boolean;
        syncOwnershipChange: boolean;
        realComponentToSync: SceneComponent;
        interpolationTime: number;
        atRestPositionThreshold: number;
        atRestRotationThreshold: number;

        clearBuffer(): void;

        ClientSendsTransformToServer(value: TArray<number>): void;

        enableSmoothSync(enable: boolean): void;

        forceStateSendNextFrame(): void;

        ServerSendsTransformToEveryone(value: TArray<number>): void;

        setSceneComponentToSync(theComponent: $Nullable<SceneComponent>): void;

        SmoothSyncEnableClientToServer(enable: boolean): void;

        SmoothSyncEnableServerToClients(enable: boolean): void;

        SmoothSyncTeleportClientToServer(position: Vector, rotation: Vector, scale: Vector, tempOwnerTime: number): void;

        SmoothSyncTeleportServerToClients(position: Vector, rotation: Vector, scale: Vector, tempOwnerTime: number): void;

        teleport(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SmoothSync;

        static Load(InName: string): SmoothSync;
    }

    export class MWSysSmoothSync extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SmoothSync: SmoothSync;

        GetExtrapolationTimeLint(): number;

        GetIsSyncPosition(): boolean;

        GetIsSyncRotation(): boolean;

        GetIsSyncScale(): boolean;

        GetPositionSnapThreshold(): number;

        GetRotationSnapThreshold(): number;

        GetScaleSnapThreshold(): number;

        GetSendRate(): number;

        GetTimeSmoothing(): number;

        SetExtrapolationTimeLint(value: number): void;

        SetIsSyncPosition(value: boolean): void;

        SetIsSyncRotation(value: boolean): void;

        SetIsSyncScale(value: boolean): void;

        SetPositionSnapThreshold(value: number): void;

        SetRotationSnapThreshold(value: number): void;

        SetScaleSnapThreshold(value: number): void;

        SetSendRate(value: number): void;

        SetTimeSmoothing(value: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSmoothSync;

        static Load(InName: string): MWSysSmoothSync;
    }

    export class MWSysSpaceEarthSwitchActor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSwitchToTargetState: $MulticastDelegate<(TargetState: number) => void>;

        BroadcastOnSwitchToTargetState(Value: $Ref<number>): void;

        GetAnimationTargetState(): boolean;

        GetCurrentState(): boolean;

        GetHasFinishAnimation(): boolean;

        SpaceEarthSwitch_GetAnimationTargetState(): number;

        SpaceEarthSwitch_GetCurrentState(): number;

        SpaceEarthSwitch_HasFinishAnimation(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSpaceEarthSwitchActor;

        static Load(InName: string): MWSysSpaceEarthSwitchActor;
    }

    export class MWSysSpectatorPawn extends SpectatorPawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseGamepadHw: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSpectatorPawn;

        static Load(InName: string): MWSysSpectatorPawn;
    }

    export class MWSysSpectatorPlayerControllerBase extends MWSysPlayerControllerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayersID: TArray<string>;

        OnRep_PlayersIDChanged(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSpectatorPlayerControllerBase;

        static Load(InName: string): MWSysSpectatorPlayerControllerBase;
    }

    export class MWSysSpectatorPlayerController extends MWSysSpectatorPlayerControllerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpectatorUI: UserWidget;
        CurrentPawn: MWSysSpectatorPawn;

        Client_SpectatorPlayer(WatchLocation: Vector, WatchRotation: Rotator): void;

        Server_SpectatorPlayer(PlayerId: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSpectatorPlayerController;

        static Load(InName: string): MWSysSpectatorPlayerController;
    }

    export class MWSysSphereTrigger extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SphereComponent: MWSysSphereComponent;
        MWRootComponent: SceneComponent;
        IconSprite: BillboardComponent;

        GetSphereComponent(): MWSysSphereComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSphereTrigger;

        static Load(InName: string): MWSysSphereTrigger;
    }

    export class MWSysSpotLight extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsDrawBoundsLine: boolean;
        ArrowComponent: ArrowComponent;
        SpotLightComponent: SpotLightComponent;
        IconSprite: BillboardComponent;
        OuterAngle: number;
        InnerAngle: number;
        OuterColor: Color;
        InnerColor: Color;
        LifeTime: number;
        CircleSidesNum: number;
        ArcSidesNum: number;
        DepthPriority: number;

        DrawSpotBounds(CircleNumSides: number, ArcNumSides: number, ConeAngle: number, color: $Ref<Color>, DrawLinelifetime: number, depth: number): void;

        SetInnerConeAngle(Angle: number): void;

        SetIsDrawBoundsLine(isDraw: boolean): void;

        SetOuterConeAngle(Angle: number): void;

        SetSpotBoundsParam(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSpotLight;

        static Load(InName: string): MWSysSpotLight;
    }

    export class MWSysSpringComponent extends SpringArmComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bInfluenceVisibility: boolean;
        bOverlapTop: boolean;
        bDoOverlapTest: boolean;
        OverlapProbeSize: number;
        ActorsToIgnore: TArray<Actor>;
        OverlapProbeChannel: ECollisionChannel;
        ComponentClassFilter: Class;
        OnGetTargetTopLoc: $Delegate<() => Vector>;
        BlockingOffsetDisUnScaled: number;
        SweepTopStartOffsetUnScaled: Vector;
        SweepTopEndOffsetUnScaled: Vector;
        DesiredLocation: Vector;
        bUseDesiredLoc: boolean;
        bUseDesiredX: boolean;
        bUseDesiredY: boolean;
        bUseDesiredZ: boolean;
        FollowTarget: Actor;

        CheckOverlapOwner(ProbeLocation: $Ref<Vector>): boolean;

        CheckTargetTopBlocking(): boolean;

        GetBlockingOffsetDis(): number;

        GetFollowTarget(): Actor;

        GetRelativeSocketLocation(): Vector;

        GetRelativeSocketRotation(): Quat;

        GetSweepTopEndOffset(): Vector;

        GetSweepTopStartOffset(): Vector;

        MWSysGetLocation__DelegateSignature(): Vector;

        SetBlockingOffsetDisUnscaled(OffsetDis: number): void;

        SetDesiredRotation(InDesiredRot: Rotator): void;

        SetFollowTarget(Target: $Nullable<Actor>): void;

        SetSweepTopEndOffsetUnScaled(EndOffsetUnScaled: Vector): void;

        SetSweepTopStartOffsetUnScaled(StartOffsetUnScaled: Vector): void;

        UpdateDesiredLoc(InDesiredLoc: $Ref<Vector>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysSpringComponent;

        static Load(InName: string): MWSysSpringComponent;
    }

    export enum EImageCopyMethod { COPY_ADD, COPY_REPLACE, COPY_MAX }

    export class MWSysTextureProcessLib extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CopyImageToTargetTexture2D(Texture2DTarget: $Nullable<Texture2D>, Texture2DSource: $Nullable<Texture2D>, x?: number /* = 0 */, y?: number /* = 0 */, CopyMethod?: EImageCopyMethod /* = COPY_ADD */): boolean;

        static CopyTexture2D(TargetTexture2D: $Nullable<Texture2D>, SourceTexture2D: $Nullable<Texture2D>): void;

        static GetPixelTexture2D(Color: $Ref<Color>, Texture2DImage: $Nullable<Texture2D>, x?: number /* = 0 */, y?: number /* = 0 */): boolean;

        static GetSizeOfTexture2D(width: $Ref<number>, height: $Ref<number>, Texture2DImage: $Nullable<Texture2D>): boolean;

        static MakeTexture2D(Texture2DImage: $Ref<Texture2D>, width: number, height: number, DefaultColor?: Color /* = (R=255,G=255,B=255,A=0) */): boolean;

        static new_RenderTarget(WorldContextObject: $Nullable<Object>, width?: number /* = 512 */, height?: number /* = 512 */, ClearColor?: Color /* = (R=255,G=255,B=255,A=0) */, bLinearToGamma?: boolean /* = false */): TextureRenderTarget2D;

        static RenderMaterialToTexture(WorldContextObject: $Nullable<Object>, RT: $Ref<TextureRenderTarget2D>, MaterialInterface?: MaterialInterface /* = None */, width?: number /* = 512 */, height?: number /* = 512 */, ClearColor?: Color /* = (R=255,G=255,B=255,A=0) */, bLinearToGamma?: boolean /* = false */): boolean;

        static RenderMaterialToTexture2D(WorldContextObject: $Nullable<Object>, Texture2DImage: $Ref<Texture2D>, MaterialInterface?: MaterialInterface /* = None */, width?: number /* = 512 */, height?: number /* = 512 */, ClearColor?: Color /* = (R=255,G=255,B=255,A=0) */, bLinearToGamma?: boolean /* = false */): boolean;

        static RenderTargetToImageFile(WorldContextObject: $Nullable<Object>, width: $Ref<number>, height: $Ref<number>, filePath: string, RT: $Nullable<TextureRenderTarget2D>, bLinearToGamma?: boolean /* = false */, ForceAlphaValue?: number /* = -1 */): boolean;

        static RenderTargetToTexture2D(WorldContextObject: $Nullable<Object>, Texture2DImage: $Ref<Texture2D>, width: $Ref<number>, height: $Ref<number>, RT: $Nullable<TextureRenderTarget2D>, bLinearToGamma?: boolean /* = false */, ForceAlphaValue?: number /* = -1 */): boolean;

        static ScreenShotAsImageFile(filePath?: string /* = "D:/ExampleFolder/ExampleImage.png" */, bInShowUI?: boolean /* = false */, bAddUniqueSuffix?: boolean /* = false */): boolean;

        static ScreenShotAsTexture2D(Texture2DImage: $Ref<Texture2D>, ImageWidth: $Ref<number>, ImageHeight: $Ref<number>, WorldContextObject: $Nullable<Object>): boolean;

        static SetPixelTexture2D(Texture2DImage: $Nullable<Texture2D>, Color?: Color /* = (R=0,G=0,B=255,A=255) */, x?: number /* = 0 */, y?: number /* = 0 */, bUpdateSource?: boolean /* = true */): boolean;

        static SetSizeOfTexture2D(width: number, height: number, Texture2DImage: $Nullable<Texture2D>, DefaultColor?: Color /* = (R=255,G=255,B=255,A=0) */): boolean;

        static Texture2DAsImageFile(ImageWidth: $Ref<number>, ImageHeight: $Ref<number>, Texture2DImage: $Nullable<Texture2D>, filePath?: string /* = "D:/ExampleFolder/ExampleImage.png" */, bCompress?: boolean /* = true */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysTextureProcessLib;

        static Load(InName: string): MWSysTextureProcessLib;
    }

    export class PhysicsThrusterComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ThrustStrength: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsThrusterComponent;

        static Load(InName: string): PhysicsThrusterComponent;
    }

    export class MWSysThruster extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Activate: boolean;
        ThrustStrength: number;
        ParentActorGuid: string;
        DelayFindParentActorHandle: TimerHandle;
        IconSprite: BillboardComponent;
        ThrusterComponent: PhysicsThrusterComponent;
        ArrowComponent: ArrowComponent;

        GetActivate(): boolean;

        GetParentActorGuid(): string;

        GetThrustStrength(): number;

        Server_SetActivate(NewActivate: boolean): void;

        Server_SetThrustStrength(NewStrength: number): void;

        SetActivate(NewActivate: boolean): void;

        SetParentActorGuid(NewParentActorGuid: string): void;

        SetThrustStrength(NewStrength: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysThruster;

        static Load(InName: string): MWSysThruster;
    }

    export enum TouchType { TouchBegin, TouchMove, TouchEnd, TouchType_MAX }

    export class MWSysTouchInput extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Touches: TArray<Vector>;
        TouchMulDele: $MulticastDelegate<(InFingerIndedx: number, Inlocation: Vector2D, TypeState: TouchType) => void>;
        TouchBeginMulDele: $MulticastDelegate<(InFingerIndedx: number, Inlocation: Vector2D, TypeState: TouchType) => void>;
        TouchMoveMulDele: $MulticastDelegate<(InFingerIndedx: number, Inlocation: Vector2D, TypeState: TouchType) => void>;
        TouchEndMulDele: $MulticastDelegate<(InFingerIndedx: number, Inlocation: Vector2D, TypeState: TouchType) => void>;

        OnPlayerJoin(PlayerController: $Nullable<MWSysPlayerControllerBase>): void;

        OnPlayerLeft(PlayerController: $Nullable<MWSysPlayerControllerBase>): void;

        SetPlayerController(InplayerController: $Nullable<PlayerController>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysTouchInput;

        static Load(InName: string): MWSysTouchInput;
    }

    export enum EWidgetSpace { World, Screen, EWidgetSpace_MAX }

    export enum EWidgetTimingPolicy { RealTime, GameTime, EWidgetTimingPolicy_MAX }

    export enum EWindowVisibility { Visible, SelfHitTestInvisible, EWindowVisibility_MAX }

    export enum EWidgetBlendMode { Opaque, Masked, Transparent, EWidgetBlendMode_MAX }

    export enum EWidgetGeometryMode { Plane, Cylinder, EWidgetGeometryMode_MAX }

    export enum ETickMode { Disabled, Enabled, Automatic, ETickMode_MAX }

    export class WidgetComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Space: EWidgetSpace;
        TimingPolicy: EWidgetTimingPolicy;
        WidgetClass: Class;
        DrawSize: IntPoint;
        bManuallyRedraw: boolean;
        bRedrawRequested: boolean;
        RedrawTime: number;
        CurrentDrawSize: IntPoint;
        bDrawAtDesiredSize: boolean;
        Pivot: Vector2D;
        bReceiveHardwareInput: boolean;
        bWindowFocusable: boolean;
        WindowVisibility: EWindowVisibility;
        bApplyGammaCorrection: boolean;
        OwnerPlayer: LocalPlayer;
        BackgroundColor: LinearColor;
        TintColorAndOpacity: LinearColor;
        OpacityFromTexture: number;
        BlendMode: EWidgetBlendMode;
        bIsTwoSided: boolean;
        TickWhenOffscreen: boolean;
        BodySetup: BodySetup;
        TranslucentMaterial: MaterialInterface;
        TranslucentMaterial_OneSided: MaterialInterface;
        OpaqueMaterial: MaterialInterface;
        OpaqueMaterial_OneSided: MaterialInterface;
        MaskedMaterial: MaterialInterface;
        MaskedMaterial_OneSided: MaterialInterface;
        RenderTarget: TextureRenderTarget2D;
        MaterialInstance: MaterialInstanceDynamic;
        bAddedToScreen: boolean;
        bEditTimeUsable: boolean;
        SharedLayerName: string;
        LayerZOrder: number;
        GeometryMode: EWidgetGeometryMode;
        CylinderArcAngle: number;
        TickMode: ETickMode;
        Widget: UserWidget;

        GetCurrentDrawSize(): Vector2D;

        GetCylinderArcAngle(): number;

        GetDrawAtDesiredSize(): boolean;

        GetDrawSize(): Vector2D;

        GetGeometryMode(): EWidgetGeometryMode;

        GetManuallyRedraw(): boolean;

        GetMaterialInstance(): MaterialInstanceDynamic;

        GetOwnerPlayer(): LocalPlayer;

        GetPivot(): Vector2D;

        GetRedrawTime(): number;

        GetRenderTarget(): TextureRenderTarget2D;

        GetTickWhenOffscreen(): boolean;

        GetTwoSided(): boolean;

        GetUserWidgetObject(): UserWidget;

        GetWidget(): UserWidget;

        GetWidgetSpace(): EWidgetSpace;

        GetWindowFocusable(): boolean;

        GetWindowVisiblility(): EWindowVisibility;

        IsWidgetVisible(): boolean;

        RequestRedraw(): void;

        SetBackgroundColor(NewBackgroundColor: LinearColor): void;

        SetCylinderArcAngle(InCylinderArcAngle: number): void;

        SetDrawAtDesiredSize(bInDrawAtDesiredSize: boolean): void;

        SetDrawSize(Size: Vector2D): void;

        SetGeometryMode(InGeometryMode: EWidgetGeometryMode): void;

        SetManuallyRedraw(bUseManualRedraw: boolean): void;

        SetOwnerPlayer(LocalPlayer: $Nullable<LocalPlayer>): void;

        SetPivot(InPivot: Vector2D): void;

        SetRedrawTime(InRedrawTime: number): void;

        SetTickMode(InTickMode: ETickMode): void;

        SetTickWhenOffscreen(bWantTickWhenOffscreen: boolean): void;

        SetTintColorAndOpacity(NewTintColorAndOpacity: LinearColor): void;

        SetTwoSided(bWantTwoSided: boolean): void;

        SetWidget(Widget: $Nullable<UserWidget>): void;

        SetWidgetSpace(NewSpace: EWidgetSpace): void;

        SetWindowFocusable(bInWindowFocusable: boolean): void;

        SetWindowVisibility(InVisibility: EWindowVisibility): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetComponent;

        static Load(InName: string): WidgetComponent;
    }

    export enum EMWWidgetSpace { World, Screen, OverheadUI, EMWWidgetSpace_MAX }

    export class MWSysWidgetComponent extends WidgetComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentSpace: EMWWidgetSpace;
        TimerHandle: TimerHandle;
        MaxVisibleDistance: number;
        bAsHeadUI: boolean;
        bOcclusion: boolean;
        bScaledByDistance: boolean;
        bHideByDistance: boolean;
        bAsEnemy: boolean;
        bOccluedByItself: boolean;

        GetDistanceScaleFactor(): number;

        GetHeadUIMaxVisibleDistance(): number;

        GetIfAsEnemy(): boolean;

        GetIfHideByDistance(): boolean;

        GetIfOcclusion(): boolean;

        GetIfScaledByDistance(): boolean;

        GetOccluedByItself(): boolean;

        SetDistanceScaleFactor(Value: number): void;

        SetHeadUIMaxVisibleDistance(Value: number): void;

        SetIfAsEnemy(Value: boolean): void;

        SetIfHideByDistance(Value: boolean): void;

        SetIfOcclusion(Value: boolean): void;

        SetIfScaledByDistance(Value: boolean): void;

        SetOccluedByItself(Value: boolean): void;

        SetUISpace(NewSpace: EMWWidgetSpace): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysWidgetComponent;

        static Load(InName: string): MWSysWidgetComponent;
    }

    export class MWSysUIWidget extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetComponent: MWSysWidgetComponent;
        UIAsset: MWAssetRecorder;
        CurrentUI: UserWidget;

        GetCylinderArcAngle(): number;

        GetDistanceScaleFactor(): number;

        GetDrawSize(): Vector2D;

        GetGeometryMode(): EWidgetGeometryMode;

        GetHeadUIMaxVisibleDistance(): number;

        GetIfAsEnemy(): boolean;

        GetIfHideByDistance(): boolean;

        GetIfOcclusion(): boolean;

        GetIfScaledByDistance(): boolean;

        GetOccluedByItself(): boolean;

        GetPivot(): Vector2D;

        GetUI(): UserWidget;

        GetWidgetSpace(): EMWWidgetSpace;

        OnUIDelete(Message: string): void;

        OnUIUpdate(Message: string): void;

        RequestRedraw(): void;

        SetCylinderArcAngle(InCylinderArcAngle: number): void;

        SetDistanceScaleFactor(Value: number): void;

        SetDrawSize(Size: Vector2D): void;

        SetGeometryMode(InGeometryMode: EWidgetGeometryMode): void;

        SetHeadUIMaxVisibleDistance(Value: number): void;

        SetIfAsEnemy(Value: boolean): void;

        SetIfHideByDistance(Value: boolean): void;

        SetIfOcclusion(Value: boolean): void;

        SetIfScaledByDistance(Value: boolean): void;

        SetOccluedByItself(Value: boolean): void;

        SetPivot(Position: Vector2D): void;

        SetUI(UIGuid: string): void;

        SetWidget(Widget: $Nullable<UserWidget>): void;

        SetWidgetSpace(NewSpace: EMWWidgetSpace): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysUIWidget;

        static Load(InName: string): MWSysUIWidget;
    }

    export class MWSysVehicleCameraSetting extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraMesh: StaticMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysVehicleCameraSetting;

        static Load(InName: string): MWSysVehicleCameraSetting;
    }

    export class MWSysVehicleWheelFront extends VehicleWheel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysVehicleWheelFront;

        static Load(InName: string): MWSysVehicleWheelFront;
    }

    export class MWSysVehicleWheelRear extends VehicleWheel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysVehicleWheelRear;

        static Load(InName: string): MWSysVehicleWheelRear;
    }

    export enum EMWSysWeaponFireState {
        None,
        PrimaryShooting,
        SecondaryShooting,
        Reloading,
        Loading,
        Cooldown,
        Max,
        EMWSysWeaponFireState_MAX
    }

    export enum EMWSysWeaponFireMode { Semi_Auto, Full_Auto, Burst, Max, EMWSysWeaponFireMode_MAX }

    export enum EMWSysWeaponLoadType { None, On_Reload, On_Fire_Reload, Max, EMWSysWeaponLoadType_MAX }

    export class MWSysWeaponBasicSetting {
        constructor();
        constructor(IsHitScan: boolean, Rof: number, BurstCount: number, Range: number, LoadTime: number, LoadType: EMWSysWeaponLoadType);

        IsHitScan: boolean;
        Rof: number;
        BurstCount: number;
        Range: number;
        LoadTime: number;
        LoadType: EMWSysWeaponLoadType;

        static StaticClass(): Class;
    }

    export class MWSysWeaponClipSetting {
        constructor();
        constructor(MaxClipAmmo: number, AmmoCostPerShot: number, AmmoPerReload: number, bInfiniteAmmo: boolean, bAutoReload: boolean, bReloadToFull: boolean, ReloadTime: number);

        MaxClipAmmo: number;
        AmmoCostPerShot: number;
        AmmoPerReload: number;
        bInfiniteAmmo: boolean;
        bAutoReload: boolean;
        bReloadToFull: boolean;
        ReloadTime: number;

        static StaticClass(): Class;
    }

    export enum EMWSysWeaponShootLocationType { ScreenCenter, PreDefined, Max, EMWSysWeaponShootLocationType_MAX }

    export class MWSysWeaponGameObjConfigData {
        constructor();
        constructor(MultiShoot: number, TriggerIndex: number, EquipSlotName: string, AnimationCollectionIndex: number, SkillIndex: number, ShootLocationType: EMWSysWeaponShootLocationType, SpreadHalfAngleDefault: number, SpreadHalfAngleMax: number, SpreadHalfAngleMin: number, SpreadDecreaseSpeed: number, SpreadIncreaseSpeed: number, SpreadIncPerShot: number, bApplyRecoil: boolean, AimOffsetPerShootHorizontal: number, AimOffsetPerShootVertical: number, RecoilOffsetHorizontal: number, RecoilOffsetVertical: number, CrossHairTypeIndex: number, bEnableAiming: boolean, bRealisticAiming: boolean, ScopeTypeIndex: number, AimingZoom: number);

        MultiShoot: number;
        TriggerIndex: number;
        EquipSlotName: string;
        AnimationCollectionIndex: number;
        SkillIndex: number;
        ShootLocationType: EMWSysWeaponShootLocationType;
        SpreadHalfAngleDefault: number;
        SpreadHalfAngleMax: number;
        SpreadHalfAngleMin: number;
        SpreadDecreaseSpeed: number;
        SpreadIncreaseSpeed: number;
        SpreadIncPerShot: number;
        bApplyRecoil: boolean;
        AimOffsetPerShootHorizontal: number;
        AimOffsetPerShootVertical: number;
        RecoilOffsetHorizontal: number;
        RecoilOffsetVertical: number;
        CrossHairTypeIndex: number;
        bEnableAiming: boolean;
        bRealisticAiming: boolean;
        ScopeTypeIndex: number;
        AimingZoom: number;

        static StaticClass(): Class;
    }

    export class MWSysWeaponConfigData {
        constructor();
        constructor(BasicSettings: MWSysWeaponBasicSetting, ClipSettings: MWSysWeaponClipSetting, GameObjConfigData: MWSysWeaponGameObjConfigData);

        BasicSettings: MWSysWeaponBasicSetting;
        ClipSettings: MWSysWeaponClipSetting;
        GameObjConfigData: MWSysWeaponGameObjConfigData;

        static StaticClass(): Class;
    }

    export class MWSysWeaponBase extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnPrimaryShootServer: $MulticastDelegate<() => void>;
        OnPrimaryShootClient: $MulticastDelegate<() => void>;
        OnPrimaryShootEndServer: $MulticastDelegate<() => void>;
        OnPrimaryShootEndClient: $MulticastDelegate<() => void>;
        OnSecondaryShootServer: $MulticastDelegate<() => void>;
        OnSecondaryShootClient: $MulticastDelegate<() => void>;
        OnReloadStartServer: $MulticastDelegate<() => void>;
        OnReloadStartClient: $MulticastDelegate<() => void>;
        OnReloadSuccessServer: $MulticastDelegate<() => void>;
        OnReloadSuccessClient: $MulticastDelegate<() => void>;
        OnLoadStartServer: $MulticastDelegate<() => void>;
        OnLoadStartClient: $MulticastDelegate<() => void>;
        OnLoadSuccessServer: $MulticastDelegate<() => void>;
        OnLoadSuccessClient: $MulticastDelegate<() => void>;
        OnEquipServer: $MulticastDelegate<(EquipOwner: $Nullable<Actor>) => void>;
        OnEquipClient: $MulticastDelegate<(EquipOwner: $Nullable<Actor>) => void>;
        OnUnEquipServer: $MulticastDelegate<() => void>;
        OnUnEquipClient: $MulticastDelegate<() => void>;
        OnTargetsHit: $MulticastDelegate<(HitResults: TArray<HitResult>) => void>;
        CurrentClipAmmo: number;
        RemainingAmmo: number;
        CurrentFireState: EMWSysWeaponFireState;
        CurrentFireMode: EMWSysWeaponFireMode;
        ConfigData: MWSysWeaponConfigData;
        EquipOwner: TWeakObjectPtr<Actor>;
        bLoaded: boolean;
        bEnableReload: boolean;
        bLoadOnFire: boolean;
        RootComp: SceneComponent;
        IconSprite: BillboardComponent;

        BreakLoad(): void;

        BreakReload(): void;

        CanShoot(): boolean;

        ClientPrimaryShoot(): void;

        ClientSecondaryShoot(): void;

        Equipment(NetOwner: $Nullable<Actor>): void;

        GetFireMode(): EMWSysWeaponFireMode;

        OnEquip(NetOwner: $Nullable<Actor>): void;

        OnLoadStart(): void;

        OnLoadSuccess(): void;

        OnPrimaryShootEnd(): void;

        OnReloadStart(): void;

        OnReloadSuccess(): void;

        OnUnEquip(): void;

        Reload(): void;

        SecondaryShoot(): void;

        ServerBreakLoad(): void;

        ServerBreakReload(): void;

        ServerEquip(NetOwner: $Nullable<Actor>): void;

        ServerLoad(): void;

        ServerPrimaryShoot(): void;

        ServerReload(): void;

        ServerSecondaryShoot(): void;

        ServerStartPrimaryShoot(): void;

        ServerStopPrimaryShoot(): void;

        ServerSwitchFireMode(NewFireMode: EMWSysWeaponFireMode): void;

        ServerUnEquip(): void;

        StartPrimaryShoot(): void;

        StopPrimaryShoot(): void;

        SwitchFireMode(NewFireMode: EMWSysWeaponFireMode): void;

        UnEquipment(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysWeaponBase;

        static Load(InName: string): MWSysWeaponBase;
    }

    export enum EMWSysWeaponSlotType { Common, Scope, Buttstock, Clip, Grip, Muzzle, EMWSysWeaponSlotType_MAX }

    export class MWSysWeaponSlot extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SlotType: EMWSysWeaponSlotType;
        bIsEquipAccessory: boolean;
        EquipOwner: TWeakObjectPtr<Actor>;
        AccessoryGUID: string;
        EquipedAccessory: Actor;
        OnAddWeaponSlotServer: $MulticastDelegate<(OwnerWeapon: $Nullable<Actor>) => void>;
        OnAddWeaponSlotClient: $MulticastDelegate<(OwnerWeapon: $Nullable<Actor>) => void>;
        OnEquipAccessoryServer: $MulticastDelegate<(OwnerWeapon: $Nullable<Actor>) => void>;
        OnEquipAccessoryClient: $MulticastDelegate<(OwnerWeapon: $Nullable<Actor>) => void>;
        OnUnEquipAccessoryServer: $MulticastDelegate<() => void>;
        OnUnEquipAccessoryClient: $MulticastDelegate<() => void>;

        AddWeaponSlot(NetOwner: $Nullable<Actor>): boolean;

        EquipAccessory(Accessory: $Nullable<Actor>): void;

        EquipAccessoryMulti(Accessory: $Nullable<Actor>): void;

        EquipAccessoryServer(Accessory: $Nullable<Actor>): void;

        GetAccessoryGUID(): string;

        GetIsEquipAccessory(): boolean;

        GetSlotType(): EMWSysWeaponSlotType;

        SetAccessoryGUID(NewGUID: string): void;

        SetIsEquipAccessory(IsEquipAccessory: boolean): void;

        SetSlotType(NewSlotType: EMWSysWeaponSlotType): void;

        UnEquipAccessory(): void;

        UnEquipAccessoryMulti(): void;

        UnEquipAccessoryServer(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysWeaponSlot;

        static Load(InName: string): MWSysWeaponSlot;
    }

    export enum WorldSettingEnum { PeaceMode, FreedomMode, CampMode, MAX }

    export class MWSysWorldSetting extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Gravity: number;
        SkillCountDown: number;
        CampCount: number;
        CampPlayerCount: number;
        MaximumPlayerCount: number;
        PlayerRelation: WorldSettingEnum;
        bJoinInHalfWay: boolean;
        CullDistances: TArray<Vector2D>;

        GetCampCount(): number;

        GetCampPlayerCount(): number;

        GetGravity(): number;

        GetJoinInHalfWay(): boolean;

        GetMaxMumPlayerCount(): number;

        GetMaxPlayerCount(): number;

        GetPlayerRelation(): WorldSettingEnum;

        GetSkillCountDown(): number;

        SetCampCount(NewCampCount: number): void;

        SetCampPlayerCount(PlayerCount: number): void;

        SetGravity(NewGravity: number): void;

        SetJoinInHalfWay(NewJoinInHalfWay: boolean): void;

        SetMaxMumPlayerCount(NewPlayerCount: number): void;

        SetPlayerRelation(NewPlayerRelation: WorldSettingEnum): void;

        SetSkillCountDown(NewSkillCountDown: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWSysWorldSetting;

        static Load(InName: string): MWSysWorldSetting;
    }

    export class MWJoystickStyle {
        constructor();
        constructor(Normal: SlateBrush, Touch: SlateBrush, Disable: SlateBrush);

        Normal: SlateBrush;
        Touch: SlateBrush;
        Disable: SlateBrush;

        static StaticClass(): Class;
    }

    export enum FMWControlType { MWControlType_None, MoveType, CameraType, FMWControlType_MAX }

    export class MWTouchInputControl {
        constructor();
        constructor(JoystickName: string, CenterImage: MWJoystickStyle, BackgroundImage: MWJoystickStyle, EnableJoystick: boolean, ControlType: FMWControlType, Center: Vector2D, VisualSize: Vector2D, ThumbSize: Vector2D, InteractionSize: Vector2D, InputScale: Vector2D, bPreventRecenter: boolean, StartupDelay: number, TimeUntilDeactive: number, TimeUntilReset: number);

        JoystickName: string;
        CenterImage: MWJoystickStyle;
        BackgroundImage: MWJoystickStyle;
        EnableJoystick: boolean;
        ControlType: FMWControlType;
        Center: Vector2D;
        VisualSize: Vector2D;
        ThumbSize: Vector2D;
        InteractionSize: Vector2D;
        InputScale: Vector2D;
        bPreventRecenter: boolean;
        StartupDelay: number;
        TimeUntilDeactive: number;
        TimeUntilReset: number;

        static StaticClass(): Class;
    }

    export class MWTempVirtualJoystickPanel extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Controls: TArray<MWTouchInputControl>;
        InputDir: $MulticastDelegate<(JoystickName: string, Value: Vector2D) => void>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTempVirtualJoystickPanel;

        static Load(InName: string): MWTempVirtualJoystickPanel;
    }

    export class MWTextBlock extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSimpleTextMode: boolean;
        ShadowColorAndOpacityDelegate: $Delegate<() => LinearColor>;

        GetbStrikeline(): boolean;

        GetbUnderline(): boolean;

        GetFontColor(): LinearColor;

        GetFontInfo(): MWUIFontInfo;

        GetFontLitterSpace(): number;

        GetFontOutLineColor(): LinearColor;

        GetFontOutLineSize(): number;

        GetFontSize(): number;

        GetGlyph(): EMWUIFontGlyph;

        GetLineHeightPercentage(): number;

        GetMWGuid(): Guid;

        GetMWJustification(): EMWTextJustify;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        GetShadowColorAndOpacity(): LinearColor;

        GetShadowOffset(): Vector2D;

        GetTextByString(): string;

        GetTextHorizontalLayout(): EMWUITextHorizontalLayout;

        GetTextJustification(): ETextJustify;

        GetTextVerticalJustify(): ETextVerticalJustify;

        SetbStrikeline(InbStrikeline: boolean): void;

        SetbUnderline(InbUnderline: boolean): void;

        SetFontColor(InColorAndOpacity: LinearColor): void;

        SetFontInfo(InFontInfo: MWUIFontInfo): void;

        SetFontLetterSpace(InLetterSpace: number): void;

        SetFontOutLineColor(OutlineColor: LinearColor): void;

        SetFontOutLineSize(InOutLineSize: number): void;

        SetFontSize(InSize: number): void;

        SetGlyph(InGlyph: EMWUIFontGlyph): void;

        SetLineHeightPercentage(InLineHeightPercentage: number): void;

        SetMWName(InName: string): void;

        SetMWTextJustification(InTextJustification: EMWTextJustify): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        SetShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;

        SetShadowOffset(InShadowOffset: Vector2D): void;

        SetTextByString(InText: string): void;

        SetTextHorizontalLayout(InTextHorizontalLayout: EMWUITextHorizontalLayout): void;

        SetTextJustification(InTextJustification: ETextJustify): void;

        SetTextVerticalJustify(InTextJustification: ETextVerticalJustify): void;

        SetWrapTextAt(InWrapAt: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTextBlock;

        static Load(InName: string): MWTextBlock;
    }

    export class MWTextBlockExtend extends TextBlock {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StrikeBrushExtend: MWSlateBrush;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTextBlockExtend;

        static Load(InName: string): MWTextBlockExtend;
    }

    export class MWTime extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetGameExecuteTime(): number;

        static GetGameTime(): number;

        static GetTime(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTime;

        static Load(InName: string): MWTime;
    }

    export class MWTipUI extends MWUIBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTipUI;

        static Load(InName: string): MWTipUI;
    }

    export class MWTipUI_Generic extends MWTipUI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UpdateTipText(TipText: string, BtnText: string, TipBGText: string): void;

        UpdateTipTextWithDoubleBtn(TipText: string, BtnLeftText: string, BtnRightText: string, TipBGText: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTipUI_Generic;

        static Load(InName: string): MWTipUI_Generic;
    }

    export class MWTipUI_DoubleContent extends MWTipUI_Generic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UpdateDoubleTipText(LeftTipText: string, RightTipText: string): void;

        UpdateRightTipText(RightTipText: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTipUI_DoubleContent;

        static Load(InName: string): MWTipUI_DoubleContent;
    }

    export class MWTipUI_Download extends MWTipUI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetProgress(): number;

        GetSpeed(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTipUI_Download;

        static Load(InName: string): MWTipUI_Download;
    }

    export class MWTipUI_Tick extends MWTipUI_Generic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReconnectionInterval: number;

        UpdateTipPerTickInBP(TipText: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTipUI_Tick;

        static Load(InName: string): MWTipUI_Tick;
    }

    export class MWTipUI_WithBtn extends MWTipUI_Generic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EnsureButton: Button;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTipUI_WithBtn;

        static Load(InName: string): MWTipUI_WithBtn;
    }

    export class MWTipUI_WithDoubleBtn extends MWTipUI_Generic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LeftButton: Button;
        RightButton: Button;

        CancelClick(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTipUI_WithDoubleBtn;

        static Load(InName: string): MWTipUI_WithDoubleBtn;
    }

    export class MWTokenSettings extends MWSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RequestAuth: string;

        OnAuthChanged(InValue: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTokenSettings;

        static Load(InName: string): MWTokenSettings;
    }

    export class MWTouchPad extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnDrag: $MulticastDelegate<(Value: Vector2D, InDelta: Vector2D) => void>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTouchPad;

        static Load(InName: string): MWTouchPad;
    }

    export class MWTouchPadDesigner extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnDrag: $MulticastDelegate<(Value: Vector2D, InDelta: Vector2D) => void>;

        GetInputScale(): Vector2D;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        SetInputScale(Scale: Vector2D): void;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTouchPadDesigner;

        static Load(InName: string): MWTouchPadDesigner;
    }

    export class MWTsHttp extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetUrlParameter(Url: string, ParameterName: string): string;

        static UrlDecode(String: string): string;

        static UrlEncode(String: string): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTsHttp;

        static Load(InName: string): MWTsHttp;
    }

    export class MWTsStat extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static DecDwordStat(L: string): number;

        static DecDwordStatBy(L: string): number;

        static DecFloatStatBy(L: string): number;

        static DefineAccumulatorFloatStat(L: string): number;

        static DefineAccumulatorStat(L: string): number;

        static DefineCounterStat(L: string): number;

        static DefineCycleStat(L: string): number;

        static DefineFloatStat(L: string): number;

        static IncDwordStat(L: string): number;

        static IncDwordStatBy(L: string): number;

        static IncFloatStatBy(L: string): number;

        static StartCycleCounter(L: string): number;

        static StartDynamicCycleCounter(L: string): number;

        static StopAllCycleCounters(): void;

        static StopCycleCounter(L: string): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWTsStat;

        static Load(InName: string): MWTsStat;
    }

    export class MWUIDragDropOperation extends DragDropOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetMWUIDragDropPayLoadGuid(): string;

        OnDragEnd(PointerEvent: $Nullable<DragDropOperation>): void;

        static NewMWUIDragDropOperation(InDefaultDragVisual: $Nullable<Widget>, InTag: string, InPivot: EDragPivot, InOffset: Vector2D, InPayLoadGuid: string): MWUIDragDropOperation;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIDragDropOperation;

        static Load(InName: string): MWUIDragDropOperation;
    }

    export class MWUIWidgetDelegateInParam {
        constructor();
        constructor(InWidget: Widget, ParamEvents: TArray<string>, InDragDropOperation: MWUIDragDropOperation, InFloatTime: number, InText: string, InGemotry: Geometry, InFocusEvent: FocusEvent, InCharacterEvent: CharacterEvent, InKeyEvent: KeyEvent, InAnalogInputEvent: AnalogInputEvent, InPointerEvent: PointerEvent);

        InWidget: Widget;
        ParamEvents: TArray<string>;
        InDragDropOperation: MWUIDragDropOperation;
        InFloatTime: number;
        InText: string;
        InGemotry: Geometry;
        InFocusEvent: FocusEvent;
        InCharacterEvent: CharacterEvent;
        InKeyEvent: KeyEvent;
        InAnalogInputEvent: AnalogInputEvent;
        InPointerEvent: PointerEvent;

        static StaticClass(): Class;
    }

    export class MWUIWidgetDelegateRetVal {
        constructor();
        constructor(IsValid: boolean, OutBool: boolean, OutEventReply: EventReply, OutDragDropOperation: MWUIDragDropOperation);

        IsValid: boolean;
        OutBool: boolean;
        OutEventReply: EventReply;
        OutDragDropOperation: MWUIDragDropOperation;

        static StaticClass(): Class;
    }

    export class MWUITSEventBind {
        constructor();
        constructor(EventDelegate: string, BindEvents: string);

        EventDelegate: string;
        BindEvents: string;

        static StaticClass(): Class;
    }

    export class ScriptFunctionInfo {
        constructor();
        constructor(FunctionName: string);

        FunctionName: string;

        static StaticClass(): Class;
    }

    export class MWUIDelegate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnMWUIWidgetCreate: $Delegate<(Object: $Nullable<Object>, BindJsFile: string) => void>;
        OnMWUIWidgetOnDestroy: $Delegate<(Name: string) => void>;
        OnMWUIEventDelegate: $Delegate<(EventParam: MWUIWidgetDelegateInParam) => MWUIWidgetDelegateRetVal>;
        OnMWUIReadyBindTSEvent: $Delegate<(Obj: $Nullable<Widget>, BindData: TArray<MWUITSEventBind>, BindObj: $Nullable<Widget>) => void>;
        OnDragDropDestroy: $Delegate<(PayLoadGuid: string) => void>;
        OnMWUIEditorFresh: $Delegate<(Name: string, Obj: $Nullable<Widget>) => TArray<ScriptFunctionInfo>>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIDelegate;

        static Load(InName: string): MWUIDelegate;
    }

    export class MWUIWidgetPrefab extends MWUIWidgetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIWidgetPrefab;

        static Load(InName: string): MWUIWidgetPrefab;
    }

    export class MWUIBlueprintFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static BeginShowUI(): void;

        static CreateMWUIWidgetBase(Outer: $Nullable<Widget>): MWUIWidgetBase;

        static CreateMWUIWidgetWithName(Outer: $Nullable<Object>, InClassTypeName: string, Name?: string /* = "None" */): Widget;

        static CreateUI(InPath: string): MWUIWidgetBase;

        static CreateUIAndAddToViewport(InPath: string): MWUIWidgetBase;

        static CreateUIByName(name: string): MWUIWidgetBase;

        static CreateUIPrefabByName(name: string): MWUIWidgetPrefab;

        static DestroyWidget(InWidget: $Nullable<Widget>): void;

        static GetAbsolutePosition(Geometry: Geometry): Vector2D;

        static GetAbsolutePositionAtCoordinates(Geometry: Geometry, Coordinate: Vector2D): Vector2D;

        static GetAbsoluteSize(Geometry: Geometry): Vector2D;

        static GetCurrentMousePosition(): Vector2D;

        static GetGameInstance(): Object;

        static GetLastMousePosition(): Vector2D;

        static GetLocalPositionAtCoordinates(Geometry: Geometry, Coordinate: Vector2D): Vector2D;

        static GetLocalSize(Geometry: Geometry): Vector2D;

        static GetMWUIDelegate(): MWUIDelegate;

        static GetWidgetFullPath(InWidget: $Nullable<Widget>): string;

        static IsUnderLocation(Geometry: Geometry, AbsoluteCoordinate: Vector2D): boolean;

        static UserAddGameCoin(CallBack: $Delegate<(Content: string) => void>, GameId: string, Token: string, UserAccount: string, CoinNum: number, Note?: string /* = "" */, TimeOut?: number /* = -1 */): void;

        static UserDecreaseGameCoin(CallBack: $Delegate<(Content: string) => void>, GameId: string, Token: string, UserAccount: string, CoinNum: number, Note?: string /* = "" */, TimeOut?: number /* = -1 */): void;

        static UserQueryGameCoin(CallBack: $Delegate<(Content: string) => void>, Account: string, GameId: string, TimeOut?: number /* = -1 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIBlueprintFunctionLibrary;

        static Load(InName: string): MWUIBlueprintFunctionLibrary;
    }

    export class MWUIDragTool extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChildCanvas: MWCanvas;

        OnBeginTextEdit(NewText: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIDragTool;

        static Load(InName: string): MWUIDragTool;
    }

    export class MWUIInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetNodePath(): string;

        GetProperties(): MWUIBindDataAttributes;

        IsMWUIDesignerTime(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIInterface;

        static Load(InName: string): MWUIInterface;
    }

    export class MWUIUtility extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateUI(UIPath: string, ZOrder?: number /* = 0 */): UserWidget;

        static DestroyUI(UI: $Nullable<MWUIBase>): void;

        static HideUI(UI: $Nullable<MWUIBase>): void;

        static ShowUI(UI: $Nullable<MWUIBase>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUIUtility;

        static Load(InName: string): MWUIUtility;
    }

    export class MWUnionActor extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUnionActor;

        static Load(InName: string): MWUnionActor;
    }

    export class MWUtilityLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetCPUUsage(): number;

        static GetCPUUsageRelative(): number;

        static GetNumDrawCalls(): number;

        static GetNumTriangleDrawn(): number;

        static GetProcessMemory(): number;

        static GetStatUnitFrameTime(World: $Nullable<World>): number;

        static GetStatUnitGameThreadTime(World: $Nullable<World>): number;

        static GetStatUnitGPUTime(World: $Nullable<World>): number;

        static GetStatUnitRenderThreadTime(World: $Nullable<World>): number;

        static OutputPerfDataToLog(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUtilityLibrary;

        static Load(InName: string): MWUtilityLibrary;
    }

    export class MWUUserWidgetExtensionMethods extends ExtensionMethods {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetWidgetFromName(UserWidget: $Nullable<UserWidget>, Name: string): Widget;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUUserWidgetExtensionMethods;

        static Load(InName: string): MWUUserWidgetExtensionMethods;
    }

    export class MWUWorldExtensionMethods extends ExtensionMethods {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetFirstPlayerController(World: $Nullable<World>): PlayerController;

        static GetGameViewportSize(World: $Nullable<World>): Vector2D;

        static GetMousePosition(World: $Nullable<World>): Vector2D;

        static SpawnActor(World: $Nullable<World>, Class: $Nullable<Class>, Transform: Transform, SpawnCollisionHandlingOverride: ESpawnActorCollisionHandlingMethod, Owner: $Nullable<Actor>, Instigator: $Nullable<Pawn>): Actor;

        static SpawnActorAndAttach(World: $Nullable<World>, Class: $Nullable<Class>, Owner: $Nullable<Actor>): Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWUWorldExtensionMethods;

        static Load(InName: string): MWUWorldExtensionMethods;
    }

    export class MWJoystickStyleExtend extends MWJoystickStyle {
        constructor();
        constructor(NormalExtend: MWSlateBrush, TouchExtend: MWSlateBrush, DisableExtend: MWSlateBrush);

        NormalExtend: MWSlateBrush;
        TouchExtend: MWSlateBrush;
        DisableExtend: MWSlateBrush;

        static StaticClass(): Class;
    }

    export class MWTouchInputControlExtend extends MWTouchInputControl {
        constructor();
        constructor(CenterImageExtend: MWJoystickStyleExtend, BackgroundImageExtend: MWJoystickStyleExtend);

        CenterImageExtend: MWJoystickStyleExtend;
        BackgroundImageExtend: MWJoystickStyleExtend;

        static StaticClass(): Class;
    }

    export class MWVirtualJoystickPanel extends MWTempVirtualJoystickPanel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ControlsExtend: TArray<MWTouchInputControlExtend>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWVirtualJoystickPanel;

        static Load(InName: string): MWVirtualJoystickPanel;
    }

    export class MWJoystickStyleDesigner {
        constructor();
        constructor(Normal: SlateBrushWithGuid, Touch: SlateBrushWithGuid, Disable: SlateBrushWithGuid);

        Normal: SlateBrushWithGuid;
        Touch: SlateBrushWithGuid;
        Disable: SlateBrushWithGuid;

        static StaticClass(): Class;
    }

    export enum EMWControlType { MWControlType_None, MoveType, CameraType, EMWControlType_MAX }

    export class MWTouchInputControlDesigner {
        constructor();
        constructor(CenterImage: MWJoystickStyleDesigner, BackgroundImage: MWJoystickStyleDesigner, ControlType: EMWControlType, Center: Vector2D, VisualSize: Vector2D, ThumbSize: Vector2D, InteractionSize: Vector2D, InputScale: Vector2D, bPreventRecenter: boolean, StartupDelay: number, TimeUntilDeactive: number, TimeUntilReset: number, ActiveOpacity: number, DeactivateOpacity: number);

        CenterImage: MWJoystickStyleDesigner;
        BackgroundImage: MWJoystickStyleDesigner;
        ControlType: EMWControlType;
        Center: Vector2D;
        VisualSize: Vector2D;
        ThumbSize: Vector2D;
        InteractionSize: Vector2D;
        InputScale: Vector2D;
        bPreventRecenter: boolean;
        StartupDelay: number;
        TimeUntilDeactive: number;
        TimeUntilReset: number;
        ActiveOpacity: number;
        DeactivateOpacity: number;

        static StaticClass(): Class;
    }

    export class MWVirtualJoystickPanelDesigner extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Controls: TArray<MWTouchInputControlDesigner>;
        m_Control: MWTouchInputControlDesigner;
        InputDir: $MulticastDelegate<(JoystickName: string, Value: Vector2D) => void>;
        InputDir_Designer: $MulticastDelegate<(JoystickName: string, Value: Vector2D) => void>;

        GetActiveOpacity(): number;

        GetBackgroundImage(): MWJoystickStyleDesigner;

        GetBackgroundImageDisable(): string;

        GetBackgroundImageNormal(): string;

        GetBackgroundImageTouch(): string;

        GetCenter(): Vector2D;

        GetCenterImage(): MWJoystickStyleDesigner;

        GetCenterImageDisable(): string;

        GetCenterImageNormal(): string;

        GetCenterImageTouch(): string;

        GetControl(): MWTouchInputControlDesigner;

        GetControlType(): EMWControlType;

        GetDeactiveOpacity(): number;

        GetInputScale(): Vector2D;

        GetInteractionSize(): Vector2D;

        GetIsPreventRecenter(): boolean;

        GetMWGuid(): Guid;

        GetMWName(): string;

        GetMWVisibility(): ESlateVisibility;

        GetOriginEventName(): string;

        GetStartupDelay(): number;

        GetThumbSize(): Vector2D;

        GetTimeUntilDeactive(): number;

        GetTimeUntilReset(): number;

        GetVisualSize(): Vector2D;

        NotifyOtherEvent(str: string, Vec: Vector2D): void;

        SetActiveOpacity(NewTimeUntilDeactive: number): void;

        SetBackgroundImage(CenterImage: MWJoystickStyleDesigner): void;

        SetBackgroundImageDisable(Guid: string, bMatchSize?: boolean /* = true */): void;

        SetBackgroundImageNormal(Guid: string, bMatchSize?: boolean /* = true */): void;

        SetBackgroundImageTouch(Guid: string, bMatchSize?: boolean /* = true */): void;

        SetCenter(NewCenter: Vector2D): void;

        SetCenterImage(CenterImage: MWJoystickStyleDesigner): void;

        SetCenterImageDisable(Guid: string, bMatchSize?: boolean /* = true */): void;

        SetCenterImageNormal(Guid: string, bMatchSize?: boolean /* = true */): void;

        SetCenterImageTouch(Guid: string, bMatchSize?: boolean /* = true */): void;

        SetControlType(NewContrlType: EMWControlType): void;

        SetDeactiveOpacity(NewTimeUntilDeactive: number): void;

        SetInputScale(NewInputScale: Vector2D): void;

        SetInteractionSize(NewInteractionSize: Vector2D): void;

        SetIsPreventRecenter(bIsPreventRecenter: boolean): void;

        SetMWName(InName: string): void;

        SetMWVisibility(InVisibility: ESlateVisibility): void;

        SetStartupDelay(NewStartUpDelay: number): void;

        SetThumbSize(NewThumbSize: Vector2D): void;

        SetTimeUntilDeactive(NewTimeUntilDeactive: number): void;

        SetTimeUntilReset(NewTimeUntilReset: number): void;

        SetVisualSize(NewVisualSize: Vector2D): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWVirtualJoystickPanelDesigner;

        static Load(InName: string): MWVirtualJoystickPanelDesigner;
    }

    export class MWWebSocketSettings extends MWSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Url: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWebSocketSettings;

        static Load(InName: string): MWWebSocketSettings;
    }

    export class MWVehicleGearData {
        constructor();
        constructor(Ratio: number, DownRatio: number, UpRatio: number);

        Ratio: number;
        DownRatio: number;
        UpRatio: number;

        static StaticClass(): Class;
    }

    export enum EMWWheelPosition { FrontWheel, RearWheel, EMWWheelPosition_MAX }

    export class MWVehicleWheelData {
        constructor();
        constructor(Position: EMWWheelPosition, ShapeRadius: number, SteerAngle: number, WheelIndex: number);

        Position: EMWWheelPosition;
        ShapeRadius: number;
        SteerAngle: number;
        WheelIndex: number;

        static StaticClass(): Class;
    }

    export enum EMWDriveMode { FourDrive, FrontDrive, RearDrive, EMWDriveMode_MAX }

    export class MWWheeledVehicle4W extends MWAdvancedVehicleBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GearSettings: TArray<MWVehicleGearData>;
        FixedWheelSettings: TArray<MWVehicleWheelData>;
        Mass: number;
        FrictionScale: number;
        DriveMode: EMWDriveMode;
        MaxEngineRPM: number;
        bMultiGears: boolean;
        bAutoGear: boolean;
        MaxBrakeTorque: number;
        CameraSettingActor: MWActor;
        CameraSettingPtr: MWObjectPtr;

        GetCameraSettingActor(): MWActor;

        OnParentActorEndPlay(Actor: $Nullable<Actor>, EndPlayReason: EEndPlayReason): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWheeledVehicle4W;

        static Load(InName: string): MWWheeledVehicle4W;
    }

    export class MWWidgetManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AllForms: TMap<string, MWUIBase>;
        RegisteredForms: TMap<string, string>;
        ShowingForms: TArray<MWUIBase>;
        WindowForms: TArray<MWUIBase>;

        CloseForm(Form: string): boolean;

        GetForm(Form: string): MWUIBase;

        GetIsVisible(Form: string): boolean;

        LoadForm(Form: string): MWUIBase;

        OpenForm(Form: string): boolean;

        RegisterUIForm(Form: string, LoadPath: string): MWWidgetManager;

        RemoveAll(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWidgetManager;

        static Load(InName: string): MWWidgetManager;
    }

    export class MWWidgetTreePanel extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWidgetTreePanel;

        static Load(InName: string): MWWidgetTreePanel;
    }

    export class MWWindowUI extends MWUIBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWindowUI;

        static Load(InName: string): MWWindowUI;
    }

    export class MWWorldRunEvents extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWorldRunEvents;

        static Load(InName: string): MWWorldRunEvents;
    }

    export class MWWRActor extends MWSerialize {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWRActor;

        static Load(InName: string): MWWRActor;
    }

    export class MWWRCharacter extends Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWRCharacter;

        static Load(InName: string): MWWRCharacter;
    }

    export class MWWRDebugSettings extends MWSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PrintDownloadSwitch: boolean;

        SetPrintDownloadInfo(InValue: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MWWRDebugSettings;

        static Load(InName: string): MWWRDebugSettings;
    }

    export enum ETestEnum { R3840x2160, R2160x1440, R1920x1080, R1280x720, ETestEnum_MAX }

    export class MyClass extends MWEdToolBarSettingsBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TestSpeed: number;
        Age: number;
        NameString: string;
        Name: string;
        Orientation: ETestEnum;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): MyClass;

        static Load(InName: string): MyClass;
    }

    export class NamedInterface {
        constructor();
        constructor(InterfaceName: string, InterfaceObject: Object);

        InterfaceName: string;
        InterfaceObject: Object;

        static StaticClass(): Class;
    }

    export class NamedInterfaceDef {
        constructor();
        constructor(InterfaceName: string, InterfaceClassName: string);

        InterfaceName: string;
        InterfaceClassName: string;

        static StaticClass(): Class;
    }

    export class NamedInterfaces extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NamedInterfaces: TArray<NamedInterface>;
        NamedInterfaceDefs: TArray<NamedInterfaceDef>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NamedInterfaces;

        static Load(InName: string): NamedInterfaces;
    }

    export class NamedSlot extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NamedSlot;

        static Load(InName: string): NamedSlot;
    }

    export class NamedSlotInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NamedSlotInterface;

        static Load(InName: string): NamedSlotInterface;
    }

    export class NameProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NameProperty;

        static Load(InName: string): NameProperty;
    }

    export class NativeCodeGenCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NativeCodeGenCommandlet;

        static Load(InName: string): NativeCodeGenCommandlet;
    }

    export class NativeWidgetHost extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NativeWidgetHost;

        static Load(InName: string): NativeWidgetHost;
    }

    export class NavAgentInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavAgentInterface;

        static Load(InName: string): NavAgentInterface;
    }

    export class NavArea_Default extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavArea_Default;

        static Load(InName: string): NavArea_Default;
    }

    export class NavArea_LowHeight extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavArea_LowHeight;

        static Load(InName: string): NavArea_LowHeight;
    }

    export class NavArea_Null extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavArea_Null;

        static Load(InName: string): NavArea_Null;
    }

    export class NavArea_Obstacle extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavArea_Obstacle;

        static Load(InName: string): NavArea_Obstacle;
    }

    export class NavAreaMeta extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavAreaMeta;

        static Load(InName: string): NavAreaMeta;
    }

    export class NavAreaMeta_SwitchByAgent extends NavAreaMeta {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Agent0Area: Class;
        Agent1Area: Class;
        Agent2Area: Class;
        Agent3Area: Class;
        Agent4Area: Class;
        Agent5Area: Class;
        Agent6Area: Class;
        Agent7Area: Class;
        Agent8Area: Class;
        Agent9Area: Class;
        Agent10Area: Class;
        Agent11Area: Class;
        Agent12Area: Class;
        Agent13Area: Class;
        Agent14Area: Class;
        Agent15Area: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavAreaMeta_SwitchByAgent;

        static Load(InName: string): NavAreaMeta_SwitchByAgent;
    }

    export class NavCollisionCylinder {
        constructor();
        constructor(Offset: Vector, Radius: number, Height: number);

        Offset: Vector;
        Radius: number;
        Height: number;

        static StaticClass(): Class;
    }

    export class NavCollisionBox {
        constructor();
        constructor(Offset: Vector, Extent: Vector);

        Offset: Vector;
        Extent: Vector;

        static StaticClass(): Class;
    }

    export class NavCollision extends NavCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CylinderCollision: TArray<NavCollisionCylinder>;
        BoxCollision: TArray<NavCollisionBox>;
        AreaClass: Class;
        bGatherConvexGeometry: boolean;
        bCreateOnClient: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavCollision;

        static Load(InName: string): NavCollision;
    }

    export class NavEdgeProviderInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavEdgeProviderInterface;

        static Load(InName: string): NavEdgeProviderInterface;
    }

    export class NavigationFilterArea {
        constructor();
        constructor(AreaClass: Class, TravelCostOverride: number, EnteringCostOverride: number, bIsExcluded: boolean, bOverrideTravelCost: boolean, bOverrideEnteringCost: boolean);

        AreaClass: Class;
        TravelCostOverride: number;
        EnteringCostOverride: number;
        bIsExcluded: boolean;
        bOverrideTravelCost: boolean;
        bOverrideEnteringCost: boolean;

        static StaticClass(): Class;
    }

    export class NavigationFilterFlags {
        constructor();
        constructor(bNavFlag0: boolean, bNavFlag1: boolean, bNavFlag2: boolean, bNavFlag3: boolean, bNavFlag4: boolean, bNavFlag5: boolean, bNavFlag6: boolean, bNavFlag7: boolean, bNavFlag8: boolean, bNavFlag9: boolean, bNavFlag10: boolean, bNavFlag11: boolean, bNavFlag12: boolean, bNavFlag13: boolean, bNavFlag14: boolean, bNavFlag15: boolean);

        bNavFlag0: boolean;
        bNavFlag1: boolean;
        bNavFlag2: boolean;
        bNavFlag3: boolean;
        bNavFlag4: boolean;
        bNavFlag5: boolean;
        bNavFlag6: boolean;
        bNavFlag7: boolean;
        bNavFlag8: boolean;
        bNavFlag9: boolean;
        bNavFlag10: boolean;
        bNavFlag11: boolean;
        bNavFlag12: boolean;
        bNavFlag13: boolean;
        bNavFlag14: boolean;
        bNavFlag15: boolean;

        static StaticClass(): Class;
    }

    export class NavigationQueryFilter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Areas: TArray<NavigationFilterArea>;
        IncludeFlags: NavigationFilterFlags;
        ExcludeFlags: NavigationFilterFlags;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationQueryFilter;

        static Load(InName: string): NavigationQueryFilter;
    }

    export class NavFilter_AIControllerDefault extends NavigationQueryFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavFilter_AIControllerDefault;

        static Load(InName: string): NavFilter_AIControllerDefault;
    }

    export class NavigationDataInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationDataInterface;

        static Load(InName: string): NavigationDataInterface;
    }

    export class NavigationGraph extends NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationGraph;

        static Load(InName: string): NavigationGraph;
    }

    export class NavigationGraphNode extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationGraphNode;

        static Load(InName: string): NavigationGraphNode;
    }

    export class NavGraphNode {
        constructor();
        constructor(Owner: Object);

        Owner: Object;

        static StaticClass(): Class;
    }

    export class NavigationGraphNodeComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Node: NavGraphNode;
        NextNodeComponent: NavigationGraphNodeComponent;
        PrevNodeComponent: NavigationGraphNodeComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationGraphNodeComponent;

        static Load(InName: string): NavigationGraphNodeComponent;
    }

    export class NavigationInvokerComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TileGenerationRadius: number;
        TileRemovalRadius: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationInvokerComponent;

        static Load(InName: string): NavigationInvokerComponent;
    }

    export class NavigationPathGenerator extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationPathGenerator;

        static Load(InName: string): NavigationPathGenerator;
    }

    export class NavigationSystemModuleConfig extends NavigationSystemConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bStrictlyStatic: boolean;
        bCreateOnClient: boolean;
        bAutoSpawnMissingNavData: boolean;
        bSpawnNavDataInNavBoundsLevel: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationSystemModuleConfig;

        static Load(InName: string): NavigationSystemModuleConfig;
    }

    export enum ENavDataGatheringModeConfig { Invalid, Instant, Lazy, ENavDataGatheringModeConfig_MAX }

    export enum FNavigationSystemRunMode {
        InvalidMode,
        GameMode,
        EditorMode,
        SimulationMode,
        PIEMode,
        InferFromWorldMode,
        FNavigationSystemRunMode_MAX
    }

    export enum ENavigationQueryResult { Invalid, Error, Fail, Success, ENavigationQueryResult_MAX }

    export class NavigationSystemV1 extends NavigationSystemBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MainNavData: NavigationData;
        AbstractNavData: NavigationData;
        DefaultAgentName: string;
        CrowdManagerClass: TSoftClassPtr<CrowdManagerBase>;
        bAutoCreateNavigationData: boolean;
        bSpawnNavDataInNavBoundsLevel: boolean;
        bAllowClientSideNavigation: boolean;
        bShouldDiscardSubLevelNavData: boolean;
        bTickWhilePaused: boolean;
        bSupportRebuilding: boolean;
        bInitialBuildingLocked: boolean;
        bSkipAgentHeightCheckWhenPickingNavData: boolean;
        bGenerateNavigationOnlyAroundNavigationInvokers: boolean;
        ActiveTilesUpdateInterval: number;
        DataGatheringMode: ENavDataGatheringModeConfig;
        DirtyAreaWarningSizeThreshold: number;
        SupportedAgents: TArray<NavDataConfig>;
        SupportedAgentsMask: NavAgentSelector;
        NavDataSet: TArray<NavigationData>;
        NavDataRegistrationQueue: TArray<NavigationData>;
        OnNavDataRegisteredEvent: $MulticastDelegate<(NavData: $Nullable<NavigationData>) => void>;
        OnNavigationGenerationFinishedDelegate: $MulticastDelegate<(NavData: $Nullable<NavigationData>) => void>;
        OperationMode: FNavigationSystemRunMode;
        DirtyAreasUpdateFreq: number;

        K2_ReplaceAreaInOctreeData(Object: $Nullable<Object>, OldArea: $Nullable<Class>, NewArea: $Nullable<Class>): boolean;

        OnNavigationBoundsUpdated(NavVolume: $Nullable<NavMeshBoundsVolume>): void;

        RegisterNavigationInvoker(Invoker: $Nullable<Actor>, TileGenerationRadius?: number /* = 3000.000000 */, TileRemovalRadius?: number /* = 5000.000000 */): void;

        ResetMaxSimultaneousTileGenerationJobsCount(): void;

        SetGeometryGatheringMode(NewMode: ENavDataGatheringModeConfig): void;

        SetMaxSimultaneousTileGenerationJobsCount(MaxNumberOfJobs: number): void;

        UnregisterNavigationInvoker(Invoker: $Nullable<Actor>): void;

        static FindPathToActorSynchronously(WorldContextObject: $Nullable<Object>, PathStart: Vector, GoalActor: $Nullable<Actor>, TetherDistance?: number /* = 50.000000 */, PathfindingContext?: Actor /* = None */, FilterClass?: Class /* = None */): NavigationPath;

        static FindPathToLocationSynchronously(WorldContextObject: $Nullable<Object>, PathStart: Vector, PathEnd: Vector, PathfindingContext?: Actor /* = None */, FilterClass?: Class /* = None */): NavigationPath;

        static GetNavigationSystem(WorldContextObject: $Nullable<Object>): NavigationSystemV1;

        static GetPathCost(WorldContextObject: $Nullable<Object>, PathStart: Vector, PathEnd: Vector, PathCost: $Ref<number>, NavData?: NavigationData /* = None */, FilterClass?: Class /* = None */): ENavigationQueryResult;

        static GetPathLength(WorldContextObject: $Nullable<Object>, PathStart: Vector, PathEnd: Vector, PathLength: $Ref<number>, NavData?: NavigationData /* = None */, FilterClass?: Class /* = None */): ENavigationQueryResult;

        static GetRandomPointInNavigableRadius(WorldContextObject: $Nullable<Object>, Origin: Vector, Radius: number, NavData?: NavigationData /* = None */, FilterClass?: Class /* = None */): Vector;

        static GetRandomReachablePointInRadius(WorldContextObject: $Nullable<Object>, Origin: Vector, Radius: number, NavData?: NavigationData /* = None */, FilterClass?: Class /* = None */): Vector;

        static IsNavigationBeingBuilt(WorldContextObject: $Nullable<Object>): boolean;

        static IsNavigationBeingBuiltOrLocked(WorldContextObject: $Nullable<Object>): boolean;

        static K2_GetRandomLocationInNavigableRadius(WorldContextObject: $Nullable<Object>, Origin: Vector, RandomLocation: $Ref<Vector>, Radius: number, NavData?: NavigationData /* = None */, FilterClass?: Class /* = None */): boolean;

        static K2_GetRandomPointInNavigableRadius(WorldContextObject: $Nullable<Object>, Origin: Vector, RandomLocation: $Ref<Vector>, Radius: number, NavData?: NavigationData /* = None */, FilterClass?: Class /* = None */): boolean;

        static K2_GetRandomReachablePointInRadius(WorldContextObject: $Nullable<Object>, Origin: Vector, RandomLocation: $Ref<Vector>, Radius: number, NavData?: NavigationData /* = None */, FilterClass?: Class /* = None */): boolean;

        static K2_ProjectPointToNavigation(WorldContextObject: $Nullable<Object>, Point: Vector, ProjectedLocation: $Ref<Vector>, NavData: $Nullable<NavigationData>, FilterClass: $Nullable<Class>, QueryExtent?: Vector /* =  */): boolean;

        static NavigationRaycast(WorldContextObject: $Nullable<Object>, RayStart: Vector, RayEnd: Vector, HitLocation: $Ref<Vector>, FilterClass?: Class /* = None */, Querier?: Controller /* = None */): boolean;

        static ProjectPointToNavigation(WorldContextObject: $Nullable<Object>, Point: Vector, NavData?: NavigationData /* = None */, FilterClass?: Class /* = None */, QueryExtent?: Vector /* =  */): Vector;

        static SimpleMoveToActor(Controller: $Nullable<Controller>, Goal: $Nullable<Actor>): void;

        static SimpleMoveToLocation(Controller: $Nullable<Controller>, Goal: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationSystemV1;

        static Load(InName: string): NavigationSystemV1;
    }

    export class NavTestRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavTestRenderingComponent;

        static Load(InName: string): NavTestRenderingComponent;
    }

    export enum ENavCostDisplay { TotalCost, HeuristicOnly, RealCostOnly, ENavCostDisplay_MAX }

    export class NavigationTestingActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CapsuleComponent: CapsuleComponent;
        EdRenderComp: NavTestRenderingComponent;
        InvokerComponent: NavigationInvokerComponent;
        bActAsNavigationInvoker: boolean;
        NavAgentProps: NavAgentProperties;
        QueryingExtent: Vector;
        MyNavData: NavigationData;
        ProjectedLocation: Vector;
        bProjectedLocationValid: boolean;
        bSearchStart: boolean;
        CostLimitFactor: number;
        MinimumCostLimit: number;
        bBacktracking: boolean;
        bUseHierarchicalPathfinding: boolean;
        bGatherDetailedInfo: boolean;
        bDrawDistanceToWall: boolean;
        bShowNodePool: boolean;
        bShowBestPath: boolean;
        bShowDiffWithPreviousStep: boolean;
        bShouldBeVisibleInGame: boolean;
        CostDisplayMode: ENavCostDisplay;
        TextCanvasOffset: Vector2D;
        bPathExist: boolean;
        bPathIsPartial: boolean;
        bPathSearchOutOfNodes: boolean;
        PathfindingTime: number;
        PathCost: number;
        PathfindingSteps: number;
        OtherActor: NavigationTestingActor;
        FilterClass: Class;
        ShowStepIndex: number;
        OffsetFromCornersDistance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavigationTestingActor;

        static Load(InName: string): NavigationTestingActor;
    }

    export enum ENavLinkDirection { BothWays, LeftToRight, RightToLeft, ENavLinkDirection_MAX }

    export class NavigationLinkBase {
        constructor();
        constructor(LeftProjectHeight: number, MaxFallDownLength: number, SnapRadius: number, SnapHeight: number, SupportedAgents: NavAgentSelector, bSupportsAgent0: boolean, bSupportsAgent1: boolean, bSupportsAgent2: boolean, bSupportsAgent3: boolean, bSupportsAgent4: boolean, bSupportsAgent5: boolean, bSupportsAgent6: boolean, bSupportsAgent7: boolean, bSupportsAgent8: boolean, bSupportsAgent9: boolean, bSupportsAgent10: boolean, bSupportsAgent11: boolean, bSupportsAgent12: boolean, bSupportsAgent13: boolean, bSupportsAgent14: boolean, bSupportsAgent15: boolean, Description: string, Direction: ENavLinkDirection, bUseSnapHeight: boolean, bSnapToCheapestArea: boolean, bCustomFlag0: boolean, bCustomFlag1: boolean, bCustomFlag2: boolean, bCustomFlag3: boolean, bCustomFlag4: boolean, bCustomFlag5: boolean, bCustomFlag6: boolean, bCustomFlag7: boolean, AreaClass: Class);

        LeftProjectHeight: number;
        MaxFallDownLength: number;
        SnapRadius: number;
        SnapHeight: number;
        SupportedAgents: NavAgentSelector;
        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;
        Description: string;
        Direction: ENavLinkDirection;
        bUseSnapHeight: boolean;
        bSnapToCheapestArea: boolean;
        bCustomFlag0: boolean;
        bCustomFlag1: boolean;
        bCustomFlag2: boolean;
        bCustomFlag3: boolean;
        bCustomFlag4: boolean;
        bCustomFlag5: boolean;
        bCustomFlag6: boolean;
        bCustomFlag7: boolean;
        AreaClass: Class;

        static StaticClass(): Class;
    }

    export class NavigationLink extends NavigationLinkBase {
        constructor();
        constructor(Left: Vector, Right: Vector);

        Left: Vector;
        Right: Vector;

        static StaticClass(): Class;
    }

    export class NavLinkComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Links: TArray<NavigationLink>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLinkComponent;

        static Load(InName: string): NavLinkComponent;
    }

    export class NavRelevantComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAttachToOwnersRoot: boolean;
        CachedNavParent: Object;

        SetNavigationRelevancy(bRelevant: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavRelevantComponent;

        static Load(InName: string): NavRelevantComponent;
    }

    export class NavLinkCustomComponent extends NavRelevantComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NavLinkUserId: number;
        EnabledAreaClass: Class;
        DisabledAreaClass: Class;
        SupportedAgents: NavAgentSelector;
        LinkRelativeStart: Vector;
        LinkRelativeEnd: Vector;
        LinkDirection: ENavLinkDirection;
        bLinkEnabled: boolean;
        bNotifyWhenEnabled: boolean;
        bNotifyWhenDisabled: boolean;
        bCreateBoxObstacle: boolean;
        ObstacleOffset: Vector;
        ObstacleExtent: Vector;
        ObstacleAreaClass: Class;
        BroadcastRadius: number;
        BroadcastInterval: number;
        BroadcastChannel: ECollisionChannel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLinkCustomComponent;

        static Load(InName: string): NavLinkCustomComponent;
    }

    export class NavLinkCustomInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLinkCustomInterface;

        static Load(InName: string): NavLinkCustomInterface;
    }

    export class NavigationSegmentLink extends NavigationLinkBase {
        constructor();
        constructor(LeftStart: Vector, LeftEnd: Vector, RightStart: Vector, RightEnd: Vector);

        LeftStart: Vector;
        LeftEnd: Vector;
        RightStart: Vector;
        RightEnd: Vector;

        static StaticClass(): Class;
    }

    export class NavLinkDefinition extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Links: TArray<NavigationLink>;
        SegmentLinks: TArray<NavigationSegmentLink>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLinkDefinition;

        static Load(InName: string): NavLinkDefinition;
    }

    export class NavLinkHostInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLinkHostInterface;

        static Load(InName: string): NavLinkHostInterface;
    }

    export class NavLinkRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLinkRenderingComponent;

        static Load(InName: string): NavLinkRenderingComponent;
    }

    export class NavLinkProxy extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PointLinks: TArray<NavigationLink>;
        SegmentLinks: TArray<NavigationSegmentLink>;
        SmartLinkComp: NavLinkCustomComponent;
        bSmartLinkIsRelevant: boolean;
        EdRenderComp: NavLinkRenderingComponent;
        SpriteComponent: BillboardComponent;
        OnSmartLinkReached: $MulticastDelegate<(MovingActor: $Nullable<Actor>, DestinationPoint: Vector) => void>;

        CopyEndPointsFromSimpleLinkToSmartLink(): void;

        HasMovingAgents(): boolean;

        IsSmartLinkEnabled(): boolean;

        ReceiveSmartLinkReached(Agent: $Nullable<Actor>, Destination: Vector): void;

        ResumePathFollowing(Agent: $Nullable<Actor>): void;

        SetSmartLinkEnabled(bEnabled: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLinkProxy;

        static Load(InName: string): NavLinkProxy;
    }

    export class NavLinkTrivial extends NavLinkDefinition {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavLinkTrivial;

        static Load(InName: string): NavLinkTrivial;
    }

    export class NavMeshRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavMeshRenderingComponent;

        static Load(InName: string): NavMeshRenderingComponent;
    }

    export class NavModifierComponent extends NavRelevantComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AreaClass: Class;
        FailsafeExtent: Vector;
        bIncludeAgentHeight: boolean;

        SetAreaClass(NewAreaClass: $Nullable<Class>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavModifierComponent;

        static Load(InName: string): NavModifierComponent;
    }

    export class NavNodeInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavNodeInterface;

        static Load(InName: string): NavNodeInterface;
    }

    export class NavPathObserverInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavPathObserverInterface;

        static Load(InName: string): NavPathObserverInterface;
    }

    export class NavRelevantInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavRelevantInterface;

        static Load(InName: string): NavRelevantInterface;
    }

    export enum ENavSystemOverridePolicy { Override, Append, Skip, ENavSystemOverridePolicy_MAX }

    export class NavSystemConfigOverride extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpriteComponent: BillboardComponent;
        NavigationSystemConfig: NavigationSystemConfig;
        OverridePolicy: ENavSystemOverridePolicy;
        bLoadOnClient: boolean;

        ApplyChanges(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NavSystemConfigOverride;

        static Load(InName: string): NavSystemConfigOverride;
    }

    export class NetAnalyticsDataConfig {
        constructor();
        constructor(DataName: string, bEnabled: boolean);

        DataName: string;
        bEnabled: boolean;

        static StaticClass(): Class;
    }

    export class NetAnalyticsAggregatorConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NetAnalyticsData: TArray<NetAnalyticsDataConfig>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NetAnalyticsAggregatorConfig;

        static Load(InName: string): NetAnalyticsAggregatorConfig;
    }

    export class NetImage extends Image {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureUrl: string;
        Size: Vector2D;
        DyTexture2D: Texture2DDynamic;

        RequestNetImage(Url: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NetImage;

        static Load(InName: string): NetImage;
    }

    export class NetPushModelHelpers extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static MarkPropertyDirty(Object: $Nullable<Object>, PropertyName: string): void;

        static MarkPropertyDirtyFromRepIndex(Object: $Nullable<Object>, RepIndex: number, PropertyName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NetPushModelHelpers;

        static Load(InName: string): NetPushModelHelpers;
    }

    export class NetworkPredictionInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NetworkPredictionInterface;

        static Load(InName: string): NetworkPredictionInterface;
    }

    export class NetworkEmulationProfileDescription {
        constructor();
        constructor(ProfileName: string, ToolTip: string);

        ProfileName: string;
        ToolTip: string;

        static StaticClass(): Class;
    }

    export class NetworkSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bVerifyPeer: boolean;
        bEnableMultiplayerWorldOriginRebasing: boolean;
        MaxRepArraySize: number;
        MaxRepArrayMemory: number;
        NetworkEmulationProfiles: TArray<NetworkEmulationProfileDescription>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NetworkSettings;

        static Load(InName: string): NetworkSettings;
    }

    export class NewPluginDescriptorData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CreatedBy: string;
        CreatedByURL: string;
        Description: string;
        bIsBetaVersion: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NewPluginDescriptorData;

        static Load(InName: string): NewPluginDescriptorData;
    }

    export class NiagaraActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NiagaraComponent: NiagaraComponent;
        SpriteComponent: BillboardComponent;
        ArrowComponent: ArrowComponent;
        bDestroyOnSystemFinish: boolean;

        OnNiagaraSystemFinished(FinishedComponent: $Nullable<NiagaraComponent>): void;

        SetDestroyOnSystemFinish(bShouldDestroyOnSystemFinish: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraActor;

        static Load(InName: string): NiagaraActor;
    }

    export enum ENiagaraClipboardFunctionScriptMode { ScriptAsset, Assignment, ENiagaraClipboardFunctionScriptMode_MAX }

    export enum ENiagaraClipboardFunctionInputValueMode {
        Local,
        Linked,
        Data,
        Expression,
        Dynamic,
        ENiagaraClipboardFunctionInputValueMode_MAX
    }

    export class NiagaraClipboardFunctionInput extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputName: string;
        InputType: NiagaraTypeDefinition;
        bHasEditCondition: boolean;
        bEditConditionValue: boolean;
        ValueMode: ENiagaraClipboardFunctionInputValueMode;
        Local: TArray<number>;
        Linked: string;
        Data: NiagaraDataInterface;
        Expression: string;
        Dynamic: NiagaraClipboardFunction;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraClipboardFunctionInput;

        static Load(InName: string): NiagaraClipboardFunctionInput;
    }

    export class NiagaraNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChangeId: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNode;

        static Load(InName: string): NiagaraNode;
    }

    export class NiagaraNodeWithDynamicPins extends NiagaraNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeWithDynamicPins;

        static Load(InName: string): NiagaraNodeWithDynamicPins;
    }

    export class NiagaraPropagatedVariable {
        constructor();
        constructor(SwitchParameter: NiagaraVariable, PropagatedName: string);

        SwitchParameter: NiagaraVariable;
        PropagatedName: string;

        static StaticClass(): Class;
    }

    export class NiagaraMessageData extends NiagaraMessageDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraMessageData;

        static Load(InName: string): NiagaraMessageData;
    }

    export class NiagaraNodeFunctionCall extends NiagaraNodeWithDynamicPins {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FunctionScript: NiagaraScript;
        FunctionScriptAssetObjectPath: string;
        Signature: NiagaraFunctionSignature;
        FunctionSpecifiers: TMap<string, string>;
        PropagatedStaticSwitchParameters: TArray<NiagaraPropagatedVariable>;
        CachedChangeId: Guid;
        FunctionDisplayName: string;
        MessageKeyToMessageMap: TMap<Guid, NiagaraMessageData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeFunctionCall;

        static Load(InName: string): NiagaraNodeFunctionCall;
    }

    export class NiagaraClipboardFunction extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FunctionName: string;
        DisplayName: string;
        ScriptMode: ENiagaraClipboardFunctionScriptMode;
        Script: TSoftObjectPtr<NiagaraScript>;
        AssignmentTargets: TArray<NiagaraVariable>;
        AssignmentDefaults: TArray<string>;
        Inputs: TArray<NiagaraClipboardFunctionInput>;
        OnPastedFunctionCallNodeDelegate: $Delegate<(PastedFunctionCall: $Nullable<NiagaraNodeFunctionCall>) => void>;

        OnPastedFunctionCallNode__DelegateSignature(PastedFunctionCall: $Nullable<NiagaraNodeFunctionCall>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraClipboardFunction;

        static Load(InName: string): NiagaraClipboardFunction;
    }

    export enum ENiagaraDefaultMode { Value, Binding, Custom, ENiagaraDefaultMode_MAX }

    export class NiagaraScriptVariableBinding {
        constructor();
        constructor(Name: string);

        Name: string;

        static StaticClass(): Class;
    }

    export class NiagaraInputConditionMetadata {
        constructor();
        constructor(InputName: string, TargetValues: TArray<string>);

        InputName: string;
        TargetValues: TArray<string>;

        static StaticClass(): Class;
    }

    export enum ENiagaraScriptParameterUsage {
        Input,
        Output,
        Local,
        InputOutput,
        InitialValueInput,
        None,
        Num,
        ENiagaraScriptParameterUsage_MAX
    }

    export class NiagaraVariableMetaData {
        constructor();
        constructor(Description: string, CategoryName: string, bAdvancedDisplay: boolean, EditorSortPriority: number, bInlineEditConditionToggle: boolean, EditCondition: NiagaraInputConditionMetadata, VisibleCondition: NiagaraInputConditionMetadata, PropertyMetaData: TMap<string, string>, ParentAttribute: string, ScopeName: string, Usage: ENiagaraScriptParameterUsage, bIsStaticSwitch: boolean, StaticSwitchDefaultValue: number, bAddedToNodeGraphDeepCopy: boolean, bOutputIsPersistent: boolean, CachedNamespacelessVariableName: string, bCreatedInSystemEditor: boolean, bUseLegacyNameString: boolean);

        Description: string;
        CategoryName: string;
        bAdvancedDisplay: boolean;
        EditorSortPriority: number;
        bInlineEditConditionToggle: boolean;
        EditCondition: NiagaraInputConditionMetadata;
        VisibleCondition: NiagaraInputConditionMetadata;
        PropertyMetaData: TMap<string, string>;
        ParentAttribute: string;
        ScopeName: string;
        Usage: ENiagaraScriptParameterUsage;
        bIsStaticSwitch: boolean;
        StaticSwitchDefaultValue: number;
        bAddedToNodeGraphDeepCopy: boolean;
        bOutputIsPersistent: boolean;
        CachedNamespacelessVariableName: string;
        bCreatedInSystemEditor: boolean;
        bUseLegacyNameString: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraScriptVariable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultMode: ENiagaraDefaultMode;
        DefaultBinding: NiagaraScriptVariableBinding;
        Variable: NiagaraVariable;
        Metadata: NiagaraVariableMetaData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraScriptVariable;

        static Load(InName: string): NiagaraScriptVariable;
    }

    export class NiagaraClipboardContent extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Functions: TArray<NiagaraClipboardFunction>;
        FunctionInputs: TArray<NiagaraClipboardFunctionInput>;
        Renderers: TArray<NiagaraRendererProperties>;
        Scripts: TArray<NiagaraScript>;
        ScriptVariables: TArray<NiagaraScriptVariable>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraClipboardContent;

        static Load(InName: string): NiagaraClipboardContent;
    }

    export class UserDefinedEnum extends Enum {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UniqueNameIndex: number;
        enumDescription: string;
        DisplayNameMap: TMap<string, string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserDefinedEnum;

        static Load(InName: string): UserDefinedEnum;
    }

    export class NiagaraClipboardEditorScriptingUtilities extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateBoolLocalValueInput(InOuter: $Nullable<Object>, InInputName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InBoolValue: boolean): NiagaraClipboardFunctionInput;

        static CreateDataValueInput(InOuter: $Nullable<Object>, InInputName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InDataValue: $Nullable<NiagaraDataInterface>): NiagaraClipboardFunctionInput;

        static CreateDynamicValueInput(InOuter: $Nullable<Object>, InInputName: string, InInputTypeName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InDynamicValueName: string, InDynamicValue: $Nullable<NiagaraScript>): NiagaraClipboardFunctionInput;

        static CreateEnumLocalValueInput(InOuter: $Nullable<Object>, InInputName: string, bInHasEditCondition: boolean, bInEditCoditionValue: boolean, InEnumType: $Nullable<UserDefinedEnum>, InEnumValue: number): NiagaraClipboardFunctionInput;

        static CreateExpressionValueInput(InOuter: $Nullable<Object>, InInputName: string, InInputTypeName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InExpressionValue: string): NiagaraClipboardFunctionInput;

        static CreateFloatLocalValueInput(InOuter: $Nullable<Object>, InInputName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InLocalValue: number): NiagaraClipboardFunctionInput;

        static CreateIntLocalValueInput(InOuter: $Nullable<Object>, InInputName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InLocalValue: number): NiagaraClipboardFunctionInput;

        static CreateLinkedValueInput(InOuter: $Nullable<Object>, InInputName: string, InInputTypeName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InLinkedValue: string): NiagaraClipboardFunctionInput;

        static CreateStructLocalValueInput(InOuter: $Nullable<Object>, InInputName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InStructValue: $Nullable<UserDefinedStruct>): NiagaraClipboardFunctionInput;

        static CreateVec2LocalValueInput(InOuter: $Nullable<Object>, InInputName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InVec2Value: Vector2D): NiagaraClipboardFunctionInput;

        static CreateVec3LocalValueInput(InOuter: $Nullable<Object>, InInputName: string, bInHasEditCondition: boolean, bInEditConditionValue: boolean, InVec3Value: Vector): NiagaraClipboardFunctionInput;

        static GetTypeName(InInput: $Nullable<NiagaraClipboardFunctionInput>): string;

        static TryGetInputByName(InInputs: TArray<NiagaraClipboardFunctionInput>, InInputName: string, bOutSucceeded: $Ref<boolean>, OutInput: $Ref<NiagaraClipboardFunctionInput>): void;

        static TryGetLocalValueAsFloat(InInput: $Nullable<NiagaraClipboardFunctionInput>, bOutSucceeded: $Ref<boolean>, OutValue: $Ref<number>): void;

        static TryGetLocalValueAsInt(InInput: $Nullable<NiagaraClipboardFunctionInput>, bOutSucceeded: $Ref<boolean>, OutValue: $Ref<number>): void;

        static TrySetLocalValueAsInt(InInput: $Nullable<NiagaraClipboardFunctionInput>, bOutSucceeded: $Ref<boolean>, InValue: number, bLooseTyping?: boolean /* = true */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraClipboardEditorScriptingUtilities;

        static Load(InName: string): NiagaraClipboardEditorScriptingUtilities;
    }

    export class NCPoolElement {
        constructor();
        constructor(Component: NiagaraComponent);

        Component: NiagaraComponent;

        static StaticClass(): Class;
    }

    export class NCPool {
        constructor();
        constructor(FreeElements: TArray<NCPoolElement>, InUseComponents_Auto: TArray<NiagaraComponent>, InUseComponents_Manual: TArray<NiagaraComponent>);

        FreeElements: TArray<NCPoolElement>;
        InUseComponents_Auto: TArray<NiagaraComponent>;
        InUseComponents_Manual: TArray<NiagaraComponent>;

        static StaticClass(): Class;
    }

    export class NiagaraComponentPool extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WorldParticleSystemPools: TMap<NiagaraSystem, NCPool>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraComponentPool;

        static Load(InName: string): NiagaraComponentPool;
    }

    export enum ENiagaraBindingSource {
        ImplicitFromSource,
        ExplicitParticles,
        ExplicitEmitter,
        ExplicitSystem,
        ExplicitUser,
        MaxBindingSource,
        ENiagaraBindingSource_MAX
    }

    export class NiagaraVariableAttributeBinding {
        constructor();
        constructor(ParamMapVariable: NiagaraVariableBase, DataSetVariable: NiagaraVariable, RootVariable: NiagaraVariable, BoundVariable: NiagaraVariable, CachedDisplayName: string, BindingSourceMode: ENiagaraBindingSource, bBindingExistsOnSource: boolean, bIsCachedParticleValue: boolean);

        ParamMapVariable: NiagaraVariableBase;
        DataSetVariable: NiagaraVariable;
        RootVariable: NiagaraVariable;
        BoundVariable: NiagaraVariable;
        CachedDisplayName: string;
        BindingSourceMode: ENiagaraBindingSource;
        bBindingExistsOnSource: boolean;
        bIsCachedParticleValue: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraComponentPropertyBinding {
        constructor();
        constructor(AttributeBinding: NiagaraVariableAttributeBinding, PropertyName: string, PropertyType: NiagaraTypeDefinition, MetadataSetterName: string, WritableValue: NiagaraVariable);

        AttributeBinding: NiagaraVariableAttributeBinding;
        PropertyName: string;
        PropertyType: NiagaraTypeDefinition;
        MetadataSetterName: string;
        WritableValue: NiagaraVariable;

        static StaticClass(): Class;
    }

    export class NiagaraComponentRendererProperties extends NiagaraRendererProperties {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ComponentType: Class;
        ComponentCountLimit: number;
        EnabledBinding: NiagaraVariableAttributeBinding;
        bAssignComponentsOnParticleID: boolean;
        bOnlyCreateComponentsOnParticleSpawn: boolean;
        bVisualizeComponents: boolean;
        TemplateComponent: SceneComponent;
        PropertyBindings: TArray<NiagaraComponentPropertyBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraComponentRendererProperties;

        static Load(InName: string): NiagaraComponentRendererProperties;
    }

    export class NiagaraEmitterNameSettingsRef {
        constructor();
        constructor(SystemName: string, EmitterName: string);

        SystemName: string;
        EmitterName: string;

        static StaticClass(): Class;
    }

    export class NiagaraComponentSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SuppressActivationList: TSet<string>;
        ForceAutoPooolingList: TSet<string>;
        SuppressEmitterList: TSet<NiagaraEmitterNameSettingsRef>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraComponentSettings;

        static Load(InName: string): NiagaraComponentSettings;
    }

    export class NiagaraConvertInPlaceUtilityBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraConvertInPlaceUtilityBase;

        static Load(InName: string): NiagaraConvertInPlaceUtilityBase;
    }

    export class NiagaraConvertInPlaceEmitterAndSystemState extends NiagaraConvertInPlaceUtilityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraConvertInPlaceEmitterAndSystemState;

        static Load(InName: string): NiagaraConvertInPlaceEmitterAndSystemState;
    }

    export class Texture2DArray extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddressX: TextureAddress;
        AddressY: TextureAddress;
        AddressZ: TextureAddress;
        SourceTextures: TArray<Texture2D>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Texture2DArray;

        static Load(InName: string): Texture2DArray;
    }

    export class NiagaraDataInterface2DArrayTexture extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Texture: Texture2DArray;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterface2DArrayTexture;

        static Load(InName: string): NiagaraDataInterface2DArrayTexture;
    }

    export class NiagaraDataInterfaceArray extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxElements: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArray;

        static Load(InName: string): NiagaraDataInterfaceArray;
    }

    export class NiagaraDataInterfaceArrayBool extends NiagaraDataInterfaceArray {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoolData: TArray<boolean>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayBool;

        static Load(InName: string): NiagaraDataInterfaceArrayBool;
    }

    export class NiagaraDataInterfaceArrayColor extends NiagaraDataInterfaceArray {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ColorData: TArray<LinearColor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayColor;

        static Load(InName: string): NiagaraDataInterfaceArrayColor;
    }

    export class NiagaraDataInterfaceArrayFloat extends NiagaraDataInterfaceArray {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatData: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayFloat;

        static Load(InName: string): NiagaraDataInterfaceArrayFloat;
    }

    export class NiagaraDataInterfaceArrayFloat2 extends NiagaraDataInterfaceArray {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatData: TArray<Vector2D>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayFloat2;

        static Load(InName: string): NiagaraDataInterfaceArrayFloat2;
    }

    export class NiagaraDataInterfaceArrayFloat3 extends NiagaraDataInterfaceArray {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatData: TArray<Vector>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayFloat3;

        static Load(InName: string): NiagaraDataInterfaceArrayFloat3;
    }

    export class NiagaraDataInterfaceArrayFloat4 extends NiagaraDataInterfaceArray {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatData: TArray<Vector4>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayFloat4;

        static Load(InName: string): NiagaraDataInterfaceArrayFloat4;
    }

    export class NiagaraDataInterfaceArrayFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetNiagaraArrayBool(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string): TArray<boolean>;

        static GetNiagaraArrayColor(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string): TArray<LinearColor>;

        static GetNiagaraArrayFloat(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string): TArray<number>;

        static GetNiagaraArrayInt32(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string): TArray<number>;

        static GetNiagaraArrayQuat(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string): TArray<Quat>;

        static GetNiagaraArrayVector(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string): TArray<Vector>;

        static GetNiagaraArrayVector2D(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string): TArray<Vector2D>;

        static GetNiagaraArrayVector4(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string): TArray<Vector4>;

        static SetNiagaraArrayBool(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, ArrayData: TArray<boolean>): void;

        static SetNiagaraArrayColor(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, ArrayData: TArray<LinearColor>): void;

        static SetNiagaraArrayFloat(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, ArrayData: TArray<number>): void;

        static SetNiagaraArrayInt32(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, ArrayData: TArray<number>): void;

        static SetNiagaraArrayQuat(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, ArrayData: TArray<Quat>): void;

        static SetNiagaraArrayVector(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, ArrayData: TArray<Vector>): void;

        static SetNiagaraArrayVector2D(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, ArrayData: TArray<Vector2D>): void;

        static SetNiagaraArrayVector4(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, ArrayData: TArray<Vector4>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayFunctionLibrary;

        static Load(InName: string): NiagaraDataInterfaceArrayFunctionLibrary;
    }

    export class NiagaraDataInterfaceArrayInt32 extends NiagaraDataInterfaceArray {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IntData: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayInt32;

        static Load(InName: string): NiagaraDataInterfaceArrayInt32;
    }

    export class NiagaraDataInterfaceArrayQuat extends NiagaraDataInterfaceArray {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        QuatData: TArray<Quat>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceArrayQuat;

        static Load(InName: string): NiagaraDataInterfaceArrayQuat;
    }

    export class NiagaraDataInterfaceAudioOscilloscope extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Submix: SoundSubmix;
        Resolution: number;
        ScopeInMilliseconds: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceAudioOscilloscope;

        static Load(InName: string): NiagaraDataInterfaceAudioOscilloscope;
    }

    export class NiagaraDataInterfaceAudioPlayer extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundToPlay: SoundBase;
        Attenuation: SoundAttenuation;
        Concurrency: SoundConcurrency;
        ParameterNames: TArray<string>;
        bLimitPlaysPerTick: boolean;
        MaxPlaysPerTick: number;
        bStopWhenComponentIsDestroyed: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceAudioPlayer;

        static Load(InName: string): NiagaraDataInterfaceAudioPlayer;
    }

    export class NiagaraDataInterfaceAudioSubmix extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Submix: SoundSubmix;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceAudioSubmix;

        static Load(InName: string): NiagaraDataInterfaceAudioSubmix;
    }

    export class NiagaraDataInterfaceAudioSpectrum extends NiagaraDataInterfaceAudioSubmix {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Resolution: number;
        MinimumFrequency: number;
        MaximumFrequency: number;
        NoiseFloorDb: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceAudioSpectrum;

        static Load(InName: string): NiagaraDataInterfaceAudioSpectrum;
    }

    export class NiagaraDataInterfaceCamera extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlayerControllerIndex: number;
        bRequireCurrentFrameData: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceCamera;

        static Load(InName: string): NiagaraDataInterfaceCamera;
    }

    export class NiagaraDataInterfaceCollisionQuery extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceCollisionQuery;

        static Load(InName: string): NiagaraDataInterfaceCollisionQuery;
    }

    export class NiagaraDataInterfaceCurveBase extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShaderLUT: TArray<number>;
        LUTMinTime: number;
        LUTMaxTime: number;
        LUTInvTimeRange: number;
        LUTNumSamplesMinusOne: number;
        bUseLUT: boolean;
        bExposeCurve: boolean;
        bOptimizeLUT: boolean;
        bOverrideOptimizeThreshold: boolean;
        ShowInCurveEditor: boolean;
        HasEditorData: boolean;
        OptimizeThreshold: number;
        ExposedName: string;
        ExposedTexture: Texture2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceCurveBase;

        static Load(InName: string): NiagaraDataInterfaceCurveBase;
    }

    export class NiagaraDataInterfaceColorCurve extends NiagaraDataInterfaceCurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RedCurve: RichCurve;
        GreenCurve: RichCurve;
        BlueCurve: RichCurve;
        AlphaCurve: RichCurve;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceColorCurve;

        static Load(InName: string): NiagaraDataInterfaceColorCurve;
    }

    export class NiagaraDataInterfaceCurlNoise extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Seed: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceCurlNoise;

        static Load(InName: string): NiagaraDataInterfaceCurlNoise;
    }

    export class NiagaraDataInterfaceCurve extends NiagaraDataInterfaceCurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Curve: RichCurve;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceCurve;

        static Load(InName: string): NiagaraDataInterfaceCurve;
    }

    export class NiagaraUserParameterBinding {
        constructor();
        constructor(Parameter: NiagaraVariable);

        Parameter: NiagaraVariable;

        static StaticClass(): Class;
    }

    export enum ENDIExport_GPUAllocationMode { FixedSize, PerParticle, ENDIExport_MAX }

    export class NiagaraDataInterfaceExport extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CallbackHandlerParameter: NiagaraUserParameterBinding;
        GPUAllocationMode: ENDIExport_GPUAllocationMode;
        GPUAllocationFixedSize: number;
        GPUAllocationPerParticleSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceExport;

        static Load(InName: string): NiagaraDataInterfaceExport;
    }

    export class NiagaraDataInterfaceGBuffer extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceGBuffer;

        static Load(InName: string): NiagaraDataInterfaceGBuffer;
    }

    export class NiagaraDataInterfaceRWBase extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OutputShaderStages: TSet<number>;
        IterationShaderStages: TSet<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceRWBase;

        static Load(InName: string): NiagaraDataInterfaceRWBase;
    }

    export class NiagaraDataInterfaceGrid2D extends NiagaraDataInterfaceRWBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumCellsX: number;
        NumCellsY: number;
        NumCellsMaxAxis: number;
        NumAttributes: number;
        SetGridFromMaxAxis: boolean;
        WorldBBoxSize: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceGrid2D;

        static Load(InName: string): NiagaraDataInterfaceGrid2D;
    }

    export enum ENiagaraGpuBufferFormat { Float, HalfFloat, UnsignedNormalizedByte, Max, ENiagaraGpuBufferFormat_MAX }

    export class NiagaraDataInterfaceGrid2DCollection extends NiagaraDataInterfaceGrid2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RenderTargetUserParameter: NiagaraUserParameterBinding;
        OverrideBufferFormat: ENiagaraGpuBufferFormat;
        bOverrideFormat: boolean;
        bPreviewGrid: boolean;
        PreviewAttribute: string;
        ManagedRenderTargets: TMap<bigint, TextureRenderTarget2DArray>;

        FillRawTexture2D(Component: $Nullable<NiagaraComponent>, Dest: $Nullable<TextureRenderTarget2D>, TilesX: $Ref<number>, TilesY: $Ref<number>): boolean;

        FillTexture2D(Component: $Nullable<NiagaraComponent>, dest: $Nullable<TextureRenderTarget2D>, AttributeIndex: number): boolean;

        GetRawTextureSize(Component: $Nullable<NiagaraComponent>, SizeX: $Ref<number>, SizeY: $Ref<number>): void;

        GetTextureSize(Component: $Nullable<NiagaraComponent>, SizeX: $Ref<number>, SizeY: $Ref<number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceGrid2DCollection;

        static Load(InName: string): NiagaraDataInterfaceGrid2DCollection;
    }

    export class NiagaraDataInterfaceGrid2DCollectionReader extends NiagaraDataInterfaceGrid2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterName: string;
        DIName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceGrid2DCollectionReader;

        static Load(InName: string): NiagaraDataInterfaceGrid2DCollectionReader;
    }

    export enum ESetResolutionMethod { Independent, MaxAxis, CellSize, ESetResolutionMethod_MAX }

    export class NiagaraDataInterfaceGrid3D extends NiagaraDataInterfaceRWBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumCells: IntVector;
        CellSize: number;
        NumCellsMaxAxis: number;
        SetResolutionMethod: ESetResolutionMethod;
        WorldBBoxSize: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceGrid3D;

        static Load(InName: string): NiagaraDataInterfaceGrid3D;
    }

    export class NiagaraDataInterfaceGrid3DCollection extends NiagaraDataInterfaceGrid3D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumAttributes: number;
        RenderTargetUserParameter: NiagaraUserParameterBinding;
        BufferFormat: ENiagaraGpuBufferFormat;

        FillRawVolumeTexture(Component: $Nullable<NiagaraComponent>, Dest: $Nullable<VolumeTexture>, TilesX: $Ref<number>, TilesY: $Ref<number>, TileZ: $Ref<number>): boolean;

        FillVolumeTexture(Component: $Nullable<NiagaraComponent>, dest: $Nullable<VolumeTexture>, AttributeIndex: number): boolean;

        GetRawTextureSize(Component: $Nullable<NiagaraComponent>, SizeX: $Ref<number>, SizeY: $Ref<number>, SizeZ: $Ref<number>): void;

        GetTextureSize(Component: $Nullable<NiagaraComponent>, SizeX: $Ref<number>, SizeY: $Ref<number>, SizeZ: $Ref<number>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceGrid3DCollection;

        static Load(InName: string): NiagaraDataInterfaceGrid3DCollection;
    }

    export class NiagaraDataInterfaceLandscape extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceLandscape: Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceLandscape;

        static Load(InName: string): NiagaraDataInterfaceLandscape;
    }

    export class NiagaraDataInterfaceNeighborGrid3D extends NiagaraDataInterfaceGrid3D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxNeighborsPerCell: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceNeighborGrid3D;

        static Load(InName: string): NiagaraDataInterfaceNeighborGrid3D;
    }

    export class NiagaraDataInterfaceOcclusion extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceOcclusion;

        static Load(InName: string): NiagaraDataInterfaceOcclusion;
    }

    export class NiagaraDataInterfaceParticleRead extends NiagaraDataInterfaceRWBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceParticleRead;

        static Load(InName: string): NiagaraDataInterfaceParticleRead;
    }

    export class NiagaraDataInterfacePlatformSet extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Platforms: NiagaraPlatformSet;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfacePlatformSet;

        static Load(InName: string): NiagaraDataInterfacePlatformSet;
    }

    export class NiagaraDataInterfaceRenderTarget2D extends NiagaraDataInterfaceRWBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Size: IntPoint;
        OverrideRenderTargetFormat: ETextureRenderTargetFormat;
        bOverrideFormat: boolean;
        bPreviewRenderTarget: boolean;
        RenderTargetUserParameter: NiagaraUserParameterBinding;
        ManagedRenderTargets: TMap<bigint, TextureRenderTarget2D>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceRenderTarget2D;

        static Load(InName: string): NiagaraDataInterfaceRenderTarget2D;
    }

    export class NiagaraDataInterfaceRenderTarget2DArray extends NiagaraDataInterfaceRWBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Size: IntVector;
        OverrideRenderTargetFormat: ETextureRenderTargetFormat;
        bOverrideFormat: boolean;
        bPreviewRenderTarget: boolean;
        RenderTargetUserParameter: NiagaraUserParameterBinding;
        ManagedRenderTargets: TMap<bigint, TextureRenderTarget2DArray>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceRenderTarget2DArray;

        static Load(InName: string): NiagaraDataInterfaceRenderTarget2DArray;
    }

    export class NiagaraDataInterfaceRenderTargetVolume extends NiagaraDataInterfaceRWBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Size: IntVector;
        OverrideRenderTargetFormat: ETextureRenderTargetFormat;
        bOverrideFormat: boolean;
        bPreviewRenderTarget: boolean;
        RenderTargetUserParameter: NiagaraUserParameterBinding;
        ManagedRenderTargets: TMap<bigint, TextureRenderTargetVolume>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceRenderTargetVolume;

        static Load(InName: string): NiagaraDataInterfaceRenderTargetVolume;
    }

    export class NiagaraDataInterfaceSimpleCounter extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceSimpleCounter;

        static Load(InName: string): NiagaraDataInterfaceSimpleCounter;
    }

    export enum ENDISkeletalMesh_SourceMode { Default, Source, AttachParent, ENDISkeletalMesh_MAX }

    export enum ENDISkeletalMesh_SkinningMode { Invalid, None, SkinOnTheFly, PreSkin, ENDISkeletalMesh_MAX }

    export class NiagaraDataInterfaceSkeletalMesh extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceMode: ENDISkeletalMesh_SourceMode;
        PreviewMesh: SkeletalMesh;
        Source: Actor;
        MeshUserParameter: NiagaraUserParameterBinding;
        SourceComponent: SkeletalMeshComponent;
        SkinningMode: ENDISkeletalMesh_SkinningMode;
        SamplingRegions: TArray<string>;
        WholeMeshLOD: number;
        FilteredBones: TArray<string>;
        FilteredSockets: TArray<string>;
        ExcludeBoneName: string;
        bExcludeBone: boolean;
        bRequireCurrentFrameData: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceSkeletalMesh;

        static Load(InName: string): NiagaraDataInterfaceSkeletalMesh;
    }

    export class NiagaraDataInterfaceSpline extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Source: Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceSpline;

        static Load(InName: string): NiagaraDataInterfaceSpline;
    }

    export enum ENDIStaticMesh_SourceMode { Default, Source, AttachParent, DefaultMeshOnly, ENDIStaticMesh_MAX }

    export class NDIStaticMeshSectionFilter {
        constructor();
        constructor(AllowedMaterialSlots: TArray<number>);

        AllowedMaterialSlots: TArray<number>;

        static StaticClass(): Class;
    }

    export class NiagaraDataInterfaceStaticMesh extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceMode: ENDIStaticMesh_SourceMode;
        PreviewMesh: StaticMesh;
        DefaultMesh: StaticMesh;
        Source: Actor;
        SourceComponent: StaticMeshComponent;
        SectionFilter: NDIStaticMeshSectionFilter;
        bUsePhysicsBodyVelocity: boolean;
        FilteredSockets: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceStaticMesh;

        static Load(InName: string): NiagaraDataInterfaceStaticMesh;
    }

    export class NiagaraDataInterfaceTexture extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Texture: Texture;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceTexture;

        static Load(InName: string): NiagaraDataInterfaceTexture;
    }

    export class NiagaraDataInterfaceVector2DCurve extends NiagaraDataInterfaceCurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        XCurve: RichCurve;
        YCurve: RichCurve;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceVector2DCurve;

        static Load(InName: string): NiagaraDataInterfaceVector2DCurve;
    }

    export class NiagaraDataInterfaceVector4Curve extends NiagaraDataInterfaceCurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        XCurve: RichCurve;
        YCurve: RichCurve;
        ZCurve: RichCurve;
        WCurve: RichCurve;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceVector4Curve;

        static Load(InName: string): NiagaraDataInterfaceVector4Curve;
    }

    export class NiagaraDataInterfaceVectorCurve extends NiagaraDataInterfaceCurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        XCurve: RichCurve;
        YCurve: RichCurve;
        ZCurve: RichCurve;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceVectorCurve;

        static Load(InName: string): NiagaraDataInterfaceVectorCurve;
    }

    export class VectorField extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Bounds: Box;
        Intensity: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VectorField;

        static Load(InName: string): VectorField;
    }

    export class NiagaraDataInterfaceVectorField extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Field: VectorField;
        bTileX: boolean;
        bTileY: boolean;
        bTileZ: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceVectorField;

        static Load(InName: string): NiagaraDataInterfaceVectorField;
    }

    export class NiagaraDataInterfaceVolumeTexture extends NiagaraDataInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Texture: VolumeTexture;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDataInterfaceVolumeTexture;

        static Load(InName: string): NiagaraDataInterfaceVolumeTexture;
    }

    export class NiagaraScriptFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraScriptFactoryNew;

        static Load(InName: string): NiagaraScriptFactoryNew;
    }

    export class NiagaraDynamicInputScriptFactory extends NiagaraScriptFactoryNew {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraDynamicInputScriptFactory;

        static Load(InName: string): NiagaraDynamicInputScriptFactory;
    }

    export class NiagaraSpawnShortcut {
        constructor();
        constructor(Name: string, Input: InputChord);

        Name: string;
        Input: InputChord;

        static StaticClass(): Class;
    }

    export class NiagaraNewAssetDialogConfig {
        constructor();
        constructor(SelectedOptionIndex: number, WindowSize: Vector2D);

        SelectedOptionIndex: number;
        WindowSize: Vector2D;

        static StaticClass(): Class;
    }

    export enum ENiagaraNamespaceMetadataOptions {
        HideInScript,
        HideInSystem,
        AdvancedInScript,
        AdvancedInSystem,
        PreventEditingNamespace,
        PreventEditingNamespaceModifier,
        PreventEditingName,
        PreventCreatingInSystemEditor,
        ENiagaraNamespaceMetadataOptions_MAX
    }

    export class NiagaraNamespaceMetadata {
        constructor();
        constructor(Namespaces: TArray<string>, RequiredNamespaceModifier: string, DisplayName: string, DisplayNameLong: string, Description: string, BackgroundColor: LinearColor, ForegroundStyle: string, SortId: number, OptionalNamespaceModifiers: TArray<string>, Options: TArray<ENiagaraNamespaceMetadataOptions>);

        Namespaces: TArray<string>;
        RequiredNamespaceModifier: string;
        DisplayName: string;
        DisplayNameLong: string;
        Description: string;
        BackgroundColor: LinearColor;
        ForegroundStyle: string;
        SortId: number;
        OptionalNamespaceModifiers: TArray<string>;
        Options: TArray<ENiagaraNamespaceMetadataOptions>;

        static StaticClass(): Class;
    }

    export class NiagaraEditorSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultScript: SoftObjectPath;
        DefaultDynamicInputScript: SoftObjectPath;
        DefaultFunctionScript: SoftObjectPath;
        DefaultModuleScript: SoftObjectPath;
        RequiredSystemUpdateScript: SoftObjectPath;
        GraphCreationShortcuts: TArray<NiagaraSpawnShortcut>;
        bAutoCompile: boolean;
        bAutoPlay: boolean;
        bResetSimulationOnChange: boolean;
        bResimulateOnChangeWhilePaused: boolean;
        bResetDependentSystemsWhenEditingEmitters: boolean;
        bDisplayAdvancedParameterPanelCategories: boolean;
        NewAssetDialogConfigMap: TMap<string, NiagaraNewAssetDialogConfig>;
        HLSLKeywordReplacements: TMap<string, string>;
        NamespaceMetadata: TArray<NiagaraNamespaceMetadata>;
        NamespaceModifierMetadata: TArray<NiagaraNamespaceMetadata>;
        DefaultNamespaceMetadata: NiagaraNamespaceMetadata;
        DefaultNamespaceModifierMetadata: NiagaraNamespaceMetadata;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEditorSettings;

        static Load(InName: string): NiagaraEditorSettings;
    }

    export class NiagaraEffectTypeFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEffectTypeFactoryNew;

        static Load(InName: string): NiagaraEffectTypeFactoryNew;
    }

    export class NiagaraStackEditorData extends NiagaraEditorDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StackEntryKeyToDisplayName: TMap<string, string>;
        DismissedStackIssueIds: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackEditorData;

        static Load(InName: string): NiagaraStackEditorData;
    }

    export class NiagaraEmitterEditorData extends NiagaraEditorDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StackEditorData: NiagaraStackEditorData;
        PlaybackRangeMin: number;
        PlaybackRangeMax: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEmitterEditorData;

        static Load(InName: string): NiagaraEmitterEditorData;
    }

    export class NiagaraEmitterFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEmitterFactoryNew;

        static Load(InName: string): NiagaraEmitterFactoryNew;
    }

    export class NiagaraThumbnailRendererBase extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraThumbnailRendererBase;

        static Load(InName: string): NiagaraThumbnailRendererBase;
    }

    export class NiagaraEmitterThumbnailRenderer extends NiagaraThumbnailRendererBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEmitterThumbnailRenderer;

        static Load(InName: string): NiagaraEmitterThumbnailRenderer;
    }

    export class NiagaraEventReceiverEmitterAction extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEventReceiverEmitterAction;

        static Load(InName: string): NiagaraEventReceiverEmitterAction;
    }

    export class NiagaraEventReceiverEmitterAction_SpawnParticles extends NiagaraEventReceiverEmitterAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumParticles: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraEventReceiverEmitterAction_SpawnParticles;

        static Load(InName: string): NiagaraEventReceiverEmitterAction_SpawnParticles;
    }

    export enum ENCPoolMethod {
        None,
        AutoRelease,
        ManualRelease,
        ManualRelease_OnComplete,
        FreeInPool,
        ENCPoolMethod_MAX
    }

    export class NiagaraFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetNiagaraParameterCollection(WorldContextObject: $Nullable<Object>, Collection: $Nullable<NiagaraParameterCollection>): NiagaraParameterCollectionInstance;

        static OverrideSystemUserVariableSkeletalMeshComponent(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, SkeletalMeshComponent: $Nullable<SkeletalMeshComponent>): void;

        static OverrideSystemUserVariableStaticMesh(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, StaticMesh: $Nullable<StaticMesh>): void;

        static OverrideSystemUserVariableStaticMeshComponent(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, StaticMeshComponent: $Nullable<StaticMeshComponent>): void;

        static SetSkeletalMeshDataInterfaceSamplingRegions(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, SamplingRegions: TArray<string>): void;

        static SetTextureObject(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, Texture: $Nullable<Texture>): void;

        static SetVolumeTextureObject(NiagaraSystem: $Nullable<NiagaraComponent>, OverrideName: string, Texture: $Nullable<VolumeTexture>): void;

        static SpawnSystemAtLocation(WorldContextObject: $Nullable<Object>, SystemTemplate: $Nullable<NiagaraSystem>, Location: Vector, Rotation?: Rotator /* =  */, Scale?: Vector /* = 1.000000,1.000000,1.000000 */, bAutoDestroy?: boolean /* = true */, bAutoActivate?: boolean /* = true */, PoolingMethod?: ENCPoolMethod /* = None */, bPreCullCheck?: boolean /* = true */): NiagaraComponent;

        static SpawnSystemAttached(SystemTemplate: $Nullable<NiagaraSystem>, AttachToComponent: $Nullable<SceneComponent>, AttachPointName: string, Location: Vector, Rotation: Rotator, LocationType: EAttachLocation, bAutoDestroy: boolean, bAutoActivate?: boolean /* = true */, PoolingMethod?: ENCPoolMethod /* = None */, bPreCullCheck?: boolean /* = true */): NiagaraComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraFunctionLibrary;

        static Load(InName: string): NiagaraFunctionLibrary;
    }

    export class NiagaraFunctionScriptFactory extends NiagaraScriptFactoryNew {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraFunctionScriptFactory;

        static Load(InName: string): NiagaraFunctionScriptFactory;
    }

    export class NiagaraCompileHashVisitorDebugInfo {
        constructor();
        constructor(Object: string, PropertyKeys: TArray<string>, PropertyValues: TArray<string>);

        Object: string;
        PropertyKeys: TArray<string>;
        PropertyValues: TArray<string>;

        static StaticClass(): Class;
    }

    export class NiagaraGraphScriptUsageInfo {
        constructor();
        constructor(BaseId: Guid, UsageType: ENiagaraScriptUsage, UsageId: Guid, CompileHash: NiagaraCompileHash, CompileHashFromGraph: NiagaraCompileHash, CompileLastObjects: TArray<NiagaraCompileHashVisitorDebugInfo>, Traversal: TArray<NiagaraNode>, DataHash: TArray<number>, GeneratedCompileId: Guid);

        BaseId: Guid;
        UsageType: ENiagaraScriptUsage;
        UsageId: Guid;
        CompileHash: NiagaraCompileHash;
        CompileHashFromGraph: NiagaraCompileHash;
        CompileLastObjects: TArray<NiagaraCompileHashVisitorDebugInfo>;
        Traversal: TArray<NiagaraNode>;
        DataHash: TArray<number>;
        GeneratedCompileId: Guid;

        static StaticClass(): Class;
    }

    export class NiagaraGraphParameterReference {
        constructor();
        constructor(Key: Guid, Value: TWeakObjectPtr<Object>);

        Key: Guid;
        Value: TWeakObjectPtr<Object>;

        static StaticClass(): Class;
    }

    export class NiagaraGraphParameterReferenceCollection {
        constructor();
        constructor(ParameterReferences: TArray<NiagaraGraphParameterReference>, Graph: NiagaraGraph, bCreated: boolean);

        ParameterReferences: TArray<NiagaraGraphParameterReference>;
        Graph: NiagaraGraph;
        bCreated: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ChangeId: Guid;
        ForceRebuildId: Guid;
        LastBuiltTraversalDataChangeId: Guid;
        CachedUsageInfo: TArray<NiagaraGraphScriptUsageInfo>;
        VariableToMetaData: TMap<NiagaraVariable, NiagaraVariableMetaData>;
        VariableToScriptVariable: TMap<NiagaraVariable, NiagaraScriptVariable>;
        ParameterToReferencesMap: TMap<NiagaraVariable, NiagaraGraphParameterReferenceCollection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraGraph;

        static Load(InName: string): NiagaraGraph;
    }

    export class NiagaraLightRendererProperties extends NiagaraRendererProperties {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseInverseSquaredFalloff: boolean;
        bAffectsTranslucency: boolean;
        RadiusScale: number;
        ColorAdd: Vector;
        LightRenderingEnabledBinding: NiagaraVariableAttributeBinding;
        LightExponentBinding: NiagaraVariableAttributeBinding;
        PositionBinding: NiagaraVariableAttributeBinding;
        ColorBinding: NiagaraVariableAttributeBinding;
        RadiusBinding: NiagaraVariableAttributeBinding;
        VolumetricScatteringBinding: NiagaraVariableAttributeBinding;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraLightRendererProperties;

        static Load(InName: string): NiagaraLightRendererProperties;
    }

    export enum ENiagaraSortMode {
        None,
        ViewDepth,
        ViewDistance,
        CustomAscending,
        CustomDecending,
        ENiagaraSortMode_MAX
    }

    export class NiagaraMeshMaterialOverride {
        constructor();
        constructor(ExplicitMat: MaterialInterface, UserParamBinding: NiagaraUserParameterBinding);

        ExplicitMat: MaterialInterface;
        UserParamBinding: NiagaraUserParameterBinding;

        static StaticClass(): Class;
    }

    export enum ENiagaraMeshFacingMode { Default, Velocity, CameraPosition, CameraPlane, ENiagaraMeshFacingMode_MAX }

    export enum ENiagaraMeshLockedAxisSpace { Simulation, World, Local, ENiagaraMeshLockedAxisSpace_MAX }

    export enum ENiagaraMeshPivotOffsetSpace { Mesh, Simulation, World, Local, ENiagaraMeshPivotOffsetSpace_MAX }

    export class NiagaraMeshRendererProperties extends NiagaraRendererProperties {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParticleMesh: StaticMesh;
        SortMode: ENiagaraSortMode;
        bOverrideMaterials: boolean;
        bSortOnlyWhenTranslucent: boolean;
        OverrideMaterials: TArray<NiagaraMeshMaterialOverride>;
        SubImageSize: Vector2D;
        bSubImageBlend: boolean;
        FacingMode: ENiagaraMeshFacingMode;
        bLockedAxisEnable: boolean;
        LockedAxis: Vector;
        LockedAxisSpace: ENiagaraMeshLockedAxisSpace;
        PivotOffset: Vector;
        PivotOffsetSpace: ENiagaraMeshPivotOffsetSpace;
        bEnableFrustumCulling: boolean;
        bEnableCameraDistanceCulling: boolean;
        MinCameraDistance: number;
        MaxCameraDistance: number;
        RendererVisibility: number;
        PositionBinding: NiagaraVariableAttributeBinding;
        ColorBinding: NiagaraVariableAttributeBinding;
        VelocityBinding: NiagaraVariableAttributeBinding;
        MeshOrientationBinding: NiagaraVariableAttributeBinding;
        ScaleBinding: NiagaraVariableAttributeBinding;
        SubImageIndexBinding: NiagaraVariableAttributeBinding;
        DynamicMaterialBinding: NiagaraVariableAttributeBinding;
        DynamicMaterial1Binding: NiagaraVariableAttributeBinding;
        DynamicMaterial2Binding: NiagaraVariableAttributeBinding;
        DynamicMaterial3Binding: NiagaraVariableAttributeBinding;
        MaterialRandomBinding: NiagaraVariableAttributeBinding;
        CustomSortingBinding: NiagaraVariableAttributeBinding;
        NormalizedAgeBinding: NiagaraVariableAttributeBinding;
        CameraOffsetBinding: NiagaraVariableAttributeBinding;
        RendererVisibilityTagBinding: NiagaraVariableAttributeBinding;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraMeshRendererProperties;

        static Load(InName: string): NiagaraMeshRendererProperties;
    }

    export enum ENiagaraMessageSeverity {
        CriticalError,
        Error,
        PerformanceWarning,
        Warning,
        Info,
        ENiagaraMessageSeverity_MAX
    }

    export class NiagaraMessageDataText extends NiagaraMessageData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MessageText: string;
        MessageSeverity: ENiagaraMessageSeverity;
        TopicName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraMessageDataText;

        static Load(InName: string): NiagaraMessageDataText;
    }

    export class NiagaraModuleScriptFactory extends NiagaraScriptFactoryNew {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraModuleScriptFactory;

        static Load(InName: string): NiagaraModuleScriptFactory;
    }

    export class NiagaraNodeAssignment extends NiagaraNodeFunctionCall {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssignmentTarget: NiagaraVariable;
        AssignmentDefaultValue: string;
        AssignmentTargets: TArray<NiagaraVariable>;
        AssignmentDefaultValues: TArray<string>;
        OldFunctionCallName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeAssignment;

        static Load(InName: string): NiagaraNodeAssignment;
    }

    export class NiagaraConvertConnection {
        constructor();
        constructor(SourcePinId: Guid, SourcePath: TArray<string>, DestinationPinId: Guid, DestinationPath: TArray<string>);

        SourcePinId: Guid;
        SourcePath: TArray<string>;
        DestinationPinId: Guid;
        DestinationPath: TArray<string>;

        static StaticClass(): Class;
    }

    export class NiagaraConvertPinRecord {
        constructor();
        constructor(PinId: Guid, Path: TArray<string>);

        PinId: Guid;
        Path: TArray<string>;

        static StaticClass(): Class;
    }

    export class NiagaraNodeConvert extends NiagaraNodeWithDynamicPins {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AutowireSwizzle: string;
        AutowireMakeType: NiagaraTypeDefinition;
        AutowireBreakType: NiagaraTypeDefinition;
        Connections: TArray<NiagaraConvertConnection>;
        bIsWiringShown: boolean;
        ExpandedItems: TArray<NiagaraConvertPinRecord>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeConvert;

        static Load(InName: string): NiagaraNodeConvert;
    }

    export class NiagaraNodeCustomHlsl extends NiagaraNodeFunctionCall {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScriptUsage: ENiagaraScriptUsage;
        CustomHlsl: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeCustomHlsl;

        static Load(InName: string): NiagaraNodeCustomHlsl;
    }

    export class NiagaraNodeDataSetBase extends NiagaraNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DataSet: NiagaraDataSetID;
        Variables: TArray<NiagaraVariable>;
        VariableFriendlyNames: TArray<string>;
        ExternalStructAsset: Struct;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeDataSetBase;

        static Load(InName: string): NiagaraNodeDataSetBase;
    }

    export class NiagaraNodeEmitter extends NiagaraNodeWithDynamicPins {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwnerSystem: NiagaraSystem;
        EmitterHandleId: Guid;
        DisplayName: string;
        ScriptType: ENiagaraScriptUsage;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeEmitter;

        static Load(InName: string): NiagaraNodeEmitter;
    }

    export class PinGuidsForPath {
        constructor();
        constructor(OutputPinGuid: Guid, InputAPinGuid: Guid, InputBPinGuid: Guid);

        OutputPinGuid: Guid;
        InputAPinGuid: Guid;
        InputBPinGuid: Guid;

        static StaticClass(): Class;
    }

    export class NiagaraNodeIf extends NiagaraNodeWithDynamicPins {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OutputVars: TArray<NiagaraVariable>;
        PathAssociatedPinGuids: TArray<PinGuidsForPath>;
        ConditionPinGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeIf;

        static Load(InName: string): NiagaraNodeIf;
    }

    export enum ENiagaraInputNodeUsage {
        Undefined,
        Parameter,
        Attribute,
        SystemConstant,
        TranslatorConstant,
        RapidIterationParameter,
        ENiagaraInputNodeUsage_MAX
    }

    export class NiagaraInputExposureOptions {
        constructor();
        constructor(bExposed: boolean, bRequired: boolean, bCanAutoBind: boolean, bHidden: boolean);

        bExposed: boolean;
        bRequired: boolean;
        bCanAutoBind: boolean;
        bHidden: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraNodeInput extends NiagaraNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Input: NiagaraVariable;
        Usage: ENiagaraInputNodeUsage;
        CallSortPriority: number;
        ExposureOptions: NiagaraInputExposureOptions;
        DataInterface: NiagaraDataInterface;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeInput;

        static Load(InName: string): NiagaraNodeInput;
    }

    export class AddedPinData {
        constructor();
        constructor(PinType: EdGraphPinType, PinName: string);

        PinType: EdGraphPinType;
        PinName: string;

        static StaticClass(): Class;
    }

    export class NiagaraNodeOp extends NiagaraNodeWithDynamicPins {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OpName: string;
        AddedPins: TArray<AddedPinData>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeOp;

        static Load(InName: string): NiagaraNodeOp;
    }

    export class NiagaraNodeOutput extends NiagaraNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Outputs: TArray<NiagaraVariable>;
        ScriptType: ENiagaraScriptUsage;
        ScriptTypeId: Guid;
        ScriptTypeIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeOutput;

        static Load(InName: string): NiagaraNodeOutput;
    }

    export class NiagaraNodeParameterMapBase extends NiagaraNodeWithDynamicPins {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeParameterMapBase;

        static Load(InName: string): NiagaraNodeParameterMapBase;
    }

    export class NiagaraNodeParameterMapSet extends NiagaraNodeParameterMapBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeParameterMapSet;

        static Load(InName: string): NiagaraNodeParameterMapSet;
    }

    export class NiagaraNodeParameterMapFor extends NiagaraNodeParameterMapSet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeParameterMapFor;

        static Load(InName: string): NiagaraNodeParameterMapFor;
    }

    export class NiagaraNodeParameterMapGet extends NiagaraNodeParameterMapBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PinOutputToPinDefaultPersistentId: TMap<Guid, Guid>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeParameterMapGet;

        static Load(InName: string): NiagaraNodeParameterMapGet;
    }

    export class NiagaraNodeReadDataSet extends NiagaraNodeDataSetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeReadDataSet;

        static Load(InName: string): NiagaraNodeReadDataSet;
    }

    export class NiagaraNodeReroute extends NiagaraNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeReroute;

        static Load(InName: string): NiagaraNodeReroute;
    }

    export class NiagaraNodeUsageSelector extends NiagaraNodeWithDynamicPins {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OutputVars: TArray<NiagaraVariable>;
        OutputVarGuids: TArray<Guid>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeUsageSelector;

        static Load(InName: string): NiagaraNodeUsageSelector;
    }

    export class NiagaraNodeSimTargetSelector extends NiagaraNodeUsageSelector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeSimTargetSelector;

        static Load(InName: string): NiagaraNodeSimTargetSelector;
    }

    export enum ENiagaraStaticSwitchType { Bool, Integer, Enum, ENiagaraStaticSwitchType_MAX }

    export class StaticSwitchTypeData {
        constructor();
        constructor(SwitchType: ENiagaraStaticSwitchType, MaxIntCount: number, Enum: Enum, SwitchConstant: string);

        SwitchType: ENiagaraStaticSwitchType;
        MaxIntCount: number;

        SwitchConstant: string;

        static StaticClass(): Class;
    }

    export class NiagaraNodeStaticSwitch extends NiagaraNodeUsageSelector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputParameterName: string;
        SwitchTypeData: StaticSwitchTypeData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeStaticSwitch;

        static Load(InName: string): NiagaraNodeStaticSwitch;
    }

    export class NiagaraNodeWriteDataSet extends NiagaraNodeDataSetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraNodeWriteDataSet;

        static Load(InName: string): NiagaraNodeWriteDataSet;
    }

    export class NiagaraOverviewNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OwningSystem: NiagaraSystem;
        EmitterHandleGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraOverviewNode;

        static Load(InName: string): NiagaraOverviewNode;
    }

    export class NiagaraParameterCollectionFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraParameterCollectionFactoryNew;

        static Load(InName: string): NiagaraParameterCollectionFactoryNew;
    }

    export class NiagaraParameterCollectionInstanceFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraParameterCollectionInstanceFactoryNew;

        static Load(InName: string): NiagaraParameterCollectionInstanceFactoryNew;
    }

    export class BasicParticleData {
        constructor();
        constructor(Position: Vector, Size: number, Velocity: Vector);

        Position: Vector;
        Size: number;
        Velocity: Vector;

        static StaticClass(): Class;
    }

    export class NiagaraParticleCallbackHandler extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReceiveParticleData(Data: TArray<BasicParticleData>, NiagaraSystem: $Nullable<NiagaraSystem>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraParticleCallbackHandler;

        static Load(InName: string): NiagaraParticleCallbackHandler;
    }

    export class NiagaraPrecompileContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Scripts: TArray<NiagaraScript>;
        System: NiagaraSystem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPrecompileContainer;

        static Load(InName: string): NiagaraPrecompileContainer;
    }

    export class NiagaraPreviewAxis extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ApplyToPreview(PreviewComponent: $Nullable<NiagaraComponent>, PreviewIndex: number, bIsXAxis: boolean, OutLabelText: $Ref<string>): void;

        Num(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewAxis;

        static Load(InName: string): NiagaraPreviewAxis;
    }

    export class NiagaraPreviewAxis_InterpParamBase extends NiagaraPreviewAxis {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Param: string;
        Count: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewAxis_InterpParamBase;

        static Load(InName: string): NiagaraPreviewAxis_InterpParamBase;
    }

    export class NiagaraPreviewAxis_InterpParamFloat extends NiagaraPreviewAxis_InterpParamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: number;
        Max: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewAxis_InterpParamFloat;

        static Load(InName: string): NiagaraPreviewAxis_InterpParamFloat;
    }

    export class NiagaraPreviewAxis_InterpParamInt32 extends NiagaraPreviewAxis_InterpParamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: number;
        Max: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewAxis_InterpParamInt32;

        static Load(InName: string): NiagaraPreviewAxis_InterpParamInt32;
    }

    export class NiagaraPreviewAxis_InterpParamLinearColor extends NiagaraPreviewAxis_InterpParamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: LinearColor;
        Max: LinearColor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewAxis_InterpParamLinearColor;

        static Load(InName: string): NiagaraPreviewAxis_InterpParamLinearColor;
    }

    export class NiagaraPreviewAxis_InterpParamVector extends NiagaraPreviewAxis_InterpParamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: Vector;
        Max: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewAxis_InterpParamVector;

        static Load(InName: string): NiagaraPreviewAxis_InterpParamVector;
    }

    export class NiagaraPreviewAxis_InterpParamVector2D extends NiagaraPreviewAxis_InterpParamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: Vector2D;
        Max: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewAxis_InterpParamVector2D;

        static Load(InName: string): NiagaraPreviewAxis_InterpParamVector2D;
    }

    export class NiagaraPreviewAxis_InterpParamVector4 extends NiagaraPreviewAxis_InterpParamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Min: Vector4;
        Max: Vector4;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewAxis_InterpParamVector4;

        static Load(InName: string): NiagaraPreviewAxis_InterpParamVector4;
    }

    export class NiagaraPreviewBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetLabelText(InXAxisText: string, InYAxisText: string): void;

        SetSystem(InSystem: $Nullable<NiagaraSystem>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewBase;

        static Load(InName: string): NiagaraPreviewBase;
    }

    export enum ENiagaraPreviewGridResetMode { Never, Individual, All, ENiagaraPreviewGridResetMode_MAX }

    export class NiagaraPreviewGrid extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        System: NiagaraSystem;
        ResetMode: ENiagaraPreviewGridResetMode;
        PreviewAxisX: NiagaraPreviewAxis;
        PreviewAxisY: NiagaraPreviewAxis;
        PreviewClass: Class;
        SpacingX: number;
        SpacingY: number;
        NumX: number;
        NumY: number;
        PreviewComponents: TArray<ChildActorComponent>;
        SpriteComponent: BillboardComponent;
        ArrowComponent: ArrowComponent;

        ActivatePreviews(bReset: boolean): void;

        DeactivatePreviews(): void;

        GetPreviews(OutPreviews: $Ref<TArray<NiagaraComponent>>): void;

        SetPaused(bPaused: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraPreviewGrid;

        static Load(InName: string): NiagaraPreviewGrid;
    }

    export enum ENiagaraRibbonFacingMode { Screen, Custom, CustomSideVector, ENiagaraRibbonFacingMode_MAX }

    export enum ENiagaraRibbonUVEdgeMode { SmoothTransition, Locked, ENiagaraRibbonUVEdgeMode_MAX }

    export enum ENiagaraRibbonUVDistributionMode {
        ScaledUniformly,
        ScaledUsingRibbonSegmentLength,
        TiledOverRibbonLength,
        ENiagaraRibbonUVDistributionMode_MAX
    }

    export class NiagaraRibbonUVSettings {
        constructor();
        constructor(LeadingEdgeMode: ENiagaraRibbonUVEdgeMode, TrailingEdgeMode: ENiagaraRibbonUVEdgeMode, DistributionMode: ENiagaraRibbonUVDistributionMode, TilingLength: number, Offset: Vector2D, Scale: Vector2D, bEnablePerParticleUOverride: boolean, bEnablePerParticleVRangeOverride: boolean);

        LeadingEdgeMode: ENiagaraRibbonUVEdgeMode;
        TrailingEdgeMode: ENiagaraRibbonUVEdgeMode;
        DistributionMode: ENiagaraRibbonUVDistributionMode;
        TilingLength: number;
        Offset: Vector2D;
        Scale: Vector2D;
        bEnablePerParticleUOverride: boolean;
        bEnablePerParticleVRangeOverride: boolean;

        static StaticClass(): Class;
    }

    export enum ENiagaraRibbonAgeOffsetMode { Scale, Clip, ENiagaraRibbonAgeOffsetMode_MAX }

    export enum ENiagaraRibbonDrawDirection { FrontToBack, BackToFront, ENiagaraRibbonDrawDirection_MAX }

    export enum ENiagaraRibbonTessellationMode { Automatic, Custom, Disabled, ENiagaraRibbonTessellationMode_MAX }

    export class NiagaraRibbonRendererProperties extends NiagaraRendererProperties {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Material: MaterialInterface;
        MaterialUserParamBinding: NiagaraUserParameterBinding;
        FacingMode: ENiagaraRibbonFacingMode;
        UV0Settings: NiagaraRibbonUVSettings;
        UV1Settings: NiagaraRibbonUVSettings;
        UV0TilingDistance: number;
        UV0Scale: Vector2D;
        UV0Offset: Vector2D;
        UV0AgeOffsetMode: ENiagaraRibbonAgeOffsetMode;
        UV1TilingDistance: number;
        UV1Scale: Vector2D;
        UV1Offset: Vector2D;
        UV1AgeOffsetMode: ENiagaraRibbonAgeOffsetMode;
        DrawDirection: ENiagaraRibbonDrawDirection;
        CurveTension: number;
        TessellationMode: ENiagaraRibbonTessellationMode;
        TessellationFactor: number;
        bUseConstantFactor: boolean;
        TessellationAngle: number;
        bScreenSpaceTessellation: boolean;
        PositionBinding: NiagaraVariableAttributeBinding;
        ColorBinding: NiagaraVariableAttributeBinding;
        VelocityBinding: NiagaraVariableAttributeBinding;
        NormalizedAgeBinding: NiagaraVariableAttributeBinding;
        RibbonTwistBinding: NiagaraVariableAttributeBinding;
        RibbonWidthBinding: NiagaraVariableAttributeBinding;
        RibbonFacingBinding: NiagaraVariableAttributeBinding;
        RibbonIdBinding: NiagaraVariableAttributeBinding;
        RibbonLinkOrderBinding: NiagaraVariableAttributeBinding;
        MaterialRandomBinding: NiagaraVariableAttributeBinding;
        DynamicMaterialBinding: NiagaraVariableAttributeBinding;
        DynamicMaterial1Binding: NiagaraVariableAttributeBinding;
        DynamicMaterial2Binding: NiagaraVariableAttributeBinding;
        DynamicMaterial3Binding: NiagaraVariableAttributeBinding;
        U0OverrideBinding: NiagaraVariableAttributeBinding;
        V0RangeOverrideBinding: NiagaraVariableAttributeBinding;
        U1OverrideBinding: NiagaraVariableAttributeBinding;
        V1RangeOverrideBinding: NiagaraVariableAttributeBinding;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraRibbonRendererProperties;

        static Load(InName: string): NiagaraRibbonRendererProperties;
    }

    export class NiagaraScratchPadViewModel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraScratchPadViewModel;

        static Load(InName: string): NiagaraScratchPadViewModel;
    }

    export class NiagaraScriptSource extends NiagaraScriptSourceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NodeGraph: NiagaraGraph;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraScriptSource;

        static Load(InName: string): NiagaraScriptSource;
    }

    export class NiagaraSequence extends MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MovieScene: MovieScene;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSequence;

        static Load(InName: string): NiagaraSequence;
    }

    export class SequencerTrackFilterExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequencerTrackFilterExtension;

        static Load(InName: string): SequencerTrackFilterExtension;
    }

    export class NiagaraSequencerTrackFilter extends SequencerTrackFilterExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSequencerTrackFilter;

        static Load(InName: string): NiagaraSequencerTrackFilter;
    }

    export class NiagaraSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AdditionalParameterTypes: TArray<SoftObjectPath>;
        AdditionalPayloadTypes: TArray<SoftObjectPath>;
        AdditionalParameterEnums: TArray<SoftObjectPath>;
        DefaultEffectType: SoftObjectPath;
        QualityLevels: TArray<string>;
        ComponentRendererWarningsPerClass: TMap<string, string>;
        DefaultRenderTargetFormat: ETextureRenderTargetFormat;
        DefaultGridFormat: ENiagaraGpuBufferFormat;
        DefaultEffectTypePtr: NiagaraEffectType;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSettings;

        static Load(InName: string): NiagaraSettings;
    }

    export class NiagaraSignificanceHandlerAge extends NiagaraSignificanceHandler {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSignificanceHandlerAge;

        static Load(InName: string): NiagaraSignificanceHandlerAge;
    }

    export class NiagaraSignificanceHandlerDistance extends NiagaraSignificanceHandler {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSignificanceHandlerDistance;

        static Load(InName: string): NiagaraSignificanceHandlerDistance;
    }

    export enum ENiagaraIterationSource { Particles, DataInterface, ENiagaraIterationSource_MAX }

    export class NiagaraVariableDataInterfaceBinding {
        constructor();
        constructor(BoundVariable: NiagaraVariable);

        BoundVariable: NiagaraVariable;

        static StaticClass(): Class;
    }

    export class NiagaraSimulationStageGeneric extends NiagaraSimulationStageBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IterationSource: ENiagaraIterationSource;
        Iterations: number;
        bSpawnOnly: boolean;
        bDisablePartialParticleUpdate: boolean;
        DataInterface: NiagaraVariableDataInterfaceBinding;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSimulationStageGeneric;

        static Load(InName: string): NiagaraSimulationStageGeneric;
    }

    export enum ENiagaraRendererSourceDataMode { Particles, Emitter, ENiagaraRendererSourceDataMode_MAX }

    export enum ENiagaraSpriteAlignment { Unaligned, VelocityAligned, CustomAlignment, ENiagaraSpriteAlignment_MAX }

    export enum ENiagaraSpriteFacingMode {
        FaceCamera,
        FaceCameraPlane,
        CustomFacingVector,
        FaceCameraPosition,
        FaceCameraDistanceBlend,
        ENiagaraSpriteFacingMode_MAX
    }

    export class NiagaraMaterialAttributeBinding {
        constructor();
        constructor(MaterialParameterName: string, NiagaraVariable: NiagaraVariableBase, ResolvedNiagaraVariable: NiagaraVariableBase, NiagaraChildVariable: NiagaraVariableBase);

        MaterialParameterName: string;
        NiagaraVariable: NiagaraVariableBase;
        ResolvedNiagaraVariable: NiagaraVariableBase;
        NiagaraChildVariable: NiagaraVariableBase;

        static StaticClass(): Class;
    }

    export class NiagaraSpriteRendererProperties extends NiagaraRendererProperties {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Material: MaterialInterface;
        SourceMode: ENiagaraRendererSourceDataMode;
        MaterialUserParamBinding: NiagaraUserParameterBinding;
        Alignment: ENiagaraSpriteAlignment;
        FacingMode: ENiagaraSpriteFacingMode;
        PivotInUVSpace: Vector2D;
        SortMode: ENiagaraSortMode;
        SubImageSize: Vector2D;
        bSubImageBlend: boolean;
        bRemoveHMDRollInVR: boolean;
        bSortOnlyWhenTranslucent: boolean;
        bGpuLowLatencyTranslucency: boolean;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
        bEnableCameraDistanceCulling: boolean;
        MinCameraDistance: number;
        MaxCameraDistance: number;
        RendererVisibility: number;
        PositionBinding: NiagaraVariableAttributeBinding;
        ColorBinding: NiagaraVariableAttributeBinding;
        VelocityBinding: NiagaraVariableAttributeBinding;
        SpriteRotationBinding: NiagaraVariableAttributeBinding;
        SpriteSizeBinding: NiagaraVariableAttributeBinding;
        SpriteFacingBinding: NiagaraVariableAttributeBinding;
        SpriteAlignmentBinding: NiagaraVariableAttributeBinding;
        SubImageIndexBinding: NiagaraVariableAttributeBinding;
        DynamicMaterialBinding: NiagaraVariableAttributeBinding;
        DynamicMaterial1Binding: NiagaraVariableAttributeBinding;
        DynamicMaterial2Binding: NiagaraVariableAttributeBinding;
        DynamicMaterial3Binding: NiagaraVariableAttributeBinding;
        CameraOffsetBinding: NiagaraVariableAttributeBinding;
        UVScaleBinding: NiagaraVariableAttributeBinding;
        MaterialRandomBinding: NiagaraVariableAttributeBinding;
        CustomSortingBinding: NiagaraVariableAttributeBinding;
        NormalizedAgeBinding: NiagaraVariableAttributeBinding;
        RendererVisibilityTagBinding: NiagaraVariableAttributeBinding;
        MaterialParameterBindings: TArray<NiagaraMaterialAttributeBinding>;
        bUseMaterialCutoutTexture: boolean;
        CutoutTexture: Texture2D;
        BoundingMode: ESubUVBoundingVertexCount;
        OpacitySourceMode: EOpacitySourceMode;
        AlphaThreshold: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSpriteRendererProperties;

        static Load(InName: string): NiagaraSpriteRendererProperties;
    }

    export class NiagaraStackErrorItem extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackErrorItem;

        static Load(InName: string): NiagaraStackErrorItem;
    }

    export class NiagaraStackEntry extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Children: TArray<NiagaraStackEntry>;
        ErrorChildren: TArray<NiagaraStackErrorItem>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackEntry;

        static Load(InName: string): NiagaraStackEntry;
    }

    export class NiagaraStackItemFooter extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackItemFooter;

        static Load(InName: string): NiagaraStackItemFooter;
    }

    export class NiagaraStackItem extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ItemFooter: NiagaraStackItemFooter;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackItem;

        static Load(InName: string): NiagaraStackItem;
    }

    export class NiagaraStackItemContent extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackItemContent;

        static Load(InName: string): NiagaraStackItemContent;
    }

    export class NiagaraStackObject extends NiagaraStackItemContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackObject;

        static Load(InName: string): NiagaraStackObject;
    }

    export class NiagaraStackEmitterPropertiesItem extends NiagaraStackItem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterObject: NiagaraStackObject;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackEmitterPropertiesItem;

        static Load(InName: string): NiagaraStackEmitterPropertiesItem;
    }

    export class NiagaraStackItemGroupFooter extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackItemGroupFooter;

        static Load(InName: string): NiagaraStackItemGroupFooter;
    }

    export class NiagaraStackItemGroup extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GroupFooter: NiagaraStackItemGroupFooter;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackItemGroup;

        static Load(InName: string): NiagaraStackItemGroup;
    }

    export class NiagaraStackEmitterSettingsGroup extends NiagaraStackItemGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PropertiesItem: NiagaraStackEmitterPropertiesItem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackEmitterSettingsGroup;

        static Load(InName: string): NiagaraStackEmitterSettingsGroup;
    }

    export class NiagaraStackErrorItemFix extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackErrorItemFix;

        static Load(InName: string): NiagaraStackErrorItemFix;
    }

    export class NiagaraStackErrorItemDismiss extends NiagaraStackErrorItemFix {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackErrorItemDismiss;

        static Load(InName: string): NiagaraStackErrorItemDismiss;
    }

    export class NiagaraStackErrorItemLongDescription extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackErrorItemLongDescription;

        static Load(InName: string): NiagaraStackErrorItemLongDescription;
    }

    export class NiagaraStackEventHandlerGroup extends NiagaraStackItemGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackEventHandlerGroup;

        static Load(InName: string): NiagaraStackEventHandlerGroup;
    }

    export class NiagaraStackEventHandlerPropertiesItem extends NiagaraStackItem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterObject: NiagaraStackObject;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackEventHandlerPropertiesItem;

        static Load(InName: string): NiagaraStackEventHandlerPropertiesItem;
    }

    export class NiagaraStackScriptItemGroup extends NiagaraStackItemGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackScriptItemGroup;

        static Load(InName: string): NiagaraStackScriptItemGroup;
    }

    export class NiagaraStackEventScriptItemGroup extends NiagaraStackScriptItemGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EventHandlerProperties: NiagaraStackEventHandlerPropertiesItem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackEventScriptItemGroup;

        static Load(InName: string): NiagaraStackEventScriptItemGroup;
    }

    export class NiagaraStackFunctionInput extends NiagaraStackItemContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackFunctionInput;

        static Load(InName: string): NiagaraStackFunctionInput;
    }

    export class NiagaraStackFunctionInputCollection extends NiagaraStackItemContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackFunctionInputCollection;

        static Load(InName: string): NiagaraStackFunctionInputCollection;
    }

    export class NiagaraStackInputCategory extends NiagaraStackItemContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackInputCategory;

        static Load(InName: string): NiagaraStackInputCategory;
    }

    export class NiagaraStackItemTextContent extends NiagaraStackItemContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackItemTextContent;

        static Load(InName: string): NiagaraStackItemTextContent;
    }

    export class NiagaraStackModuleItemLinkedInputCollection extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackModuleItemLinkedInputCollection;

        static Load(InName: string): NiagaraStackModuleItemLinkedInputCollection;
    }

    export class NiagaraStackModuleItemOutputCollection extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackModuleItemOutputCollection;

        static Load(InName: string): NiagaraStackModuleItemOutputCollection;
    }

    export class NiagaraStackModuleItem extends NiagaraStackItem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LinkedInputCollection: NiagaraStackModuleItemLinkedInputCollection;
        InputCollection: NiagaraStackFunctionInputCollection;
        OutputCollection: NiagaraStackModuleItemOutputCollection;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackModuleItem;

        static Load(InName: string): NiagaraStackModuleItem;
    }

    export class NiagaraStackModuleItemOutput extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackModuleItemOutput;

        static Load(InName: string): NiagaraStackModuleItemOutput;
    }

    export class NiagaraStackParameterStoreEntry extends NiagaraStackItemContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ValueObjectEntry: NiagaraStackObject;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackParameterStoreEntry;

        static Load(InName: string): NiagaraStackParameterStoreEntry;
    }

    export class NiagaraStackParameterStoreItem extends NiagaraStackItem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackParameterStoreItem;

        static Load(InName: string): NiagaraStackParameterStoreItem;
    }

    export class NiagaraStackPropertyRow extends NiagaraStackItemContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackPropertyRow;

        static Load(InName: string): NiagaraStackPropertyRow;
    }

    export class NiagaraStackRendererItem extends NiagaraStackItem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RendererObject: NiagaraStackObject;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackRendererItem;

        static Load(InName: string): NiagaraStackRendererItem;
    }

    export class NiagaraStackRenderItemGroup extends NiagaraStackItemGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackRenderItemGroup;

        static Load(InName: string): NiagaraStackRenderItemGroup;
    }

    export class NiagaraStackSystemSettingsGroup extends NiagaraStackItemGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackSystemSettingsGroup;

        static Load(InName: string): NiagaraStackSystemSettingsGroup;
    }

    export class NiagaraStackSimulationStagesGroup extends NiagaraStackItemGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackSimulationStagesGroup;

        static Load(InName: string): NiagaraStackSimulationStagesGroup;
    }

    export class NiagaraStackRoot extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SystemSettingsGroup: NiagaraStackSystemSettingsGroup;
        SystemSpawnGroup: NiagaraStackScriptItemGroup;
        SystemUpdateGroup: NiagaraStackScriptItemGroup;
        EmitterSettingsGroup: NiagaraStackEmitterSettingsGroup;
        EmitterSpawnGroup: NiagaraStackScriptItemGroup;
        EmitterUpdateGroup: NiagaraStackScriptItemGroup;
        ParticleSpawnGroup: NiagaraStackScriptItemGroup;
        ParticleUpdateGroup: NiagaraStackScriptItemGroup;
        AddEventHandlerGroup: NiagaraStackEventHandlerGroup;
        AddSimulationStageGroup: NiagaraStackSimulationStagesGroup;
        RenderGroup: NiagaraStackRenderItemGroup;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackRoot;

        static Load(InName: string): NiagaraStackRoot;
    }

    export class NiagaraStackSelection extends NiagaraStackEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackSelection;

        static Load(InName: string): NiagaraStackSelection;
    }

    export class NiagaraStackSimulationStagePropertiesItem extends NiagaraStackItem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SimulationStageObject: NiagaraStackObject;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackSimulationStagePropertiesItem;

        static Load(InName: string): NiagaraStackSimulationStagePropertiesItem;
    }

    export class NiagaraStackSimulationStageGroup extends NiagaraStackScriptItemGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SimulationStageProperties: NiagaraStackSimulationStagePropertiesItem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackSimulationStageGroup;

        static Load(InName: string): NiagaraStackSimulationStageGroup;
    }

    export class NiagaraStackSystemPropertiesItem extends NiagaraStackItem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SystemObject: NiagaraStackObject;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackSystemPropertiesItem;

        static Load(InName: string): NiagaraStackSystemPropertiesItem;
    }

    export class NiagaraStackViewModel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootEntry: NiagaraStackEntry;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraStackViewModel;

        static Load(InName: string): NiagaraStackViewModel;
    }

    export class NiagaraSystemAuditCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSystemAuditCommandlet;

        static Load(InName: string): NiagaraSystemAuditCommandlet;
    }

    export class NiagaraSystemEditorFolder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FolderName: string;
        ChildFolders: TArray<NiagaraSystemEditorFolder>;
        ChildEmitterHandleIds: TArray<Guid>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSystemEditorFolder;

        static Load(InName: string): NiagaraSystemEditorFolder;
    }

    export class NiagaraGraphViewSettings {
        constructor();
        constructor(Location: Vector2D, Zoom: number, bIsValid: boolean);

        Location: Vector2D;
        Zoom: number;
        bIsValid: boolean;

        static StaticClass(): Class;
    }

    export class NiagaraSystemEditorData extends NiagaraEditorDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootFolder: NiagaraSystemEditorFolder;
        StackEditorData: NiagaraStackEditorData;
        OwnerTransform: Transform;
        PlaybackRangeMin: number;
        PlaybackRangeMax: number;
        SystemOverviewGraph: EdGraph;
        OverviewGraphViewSettings: NiagaraGraphViewSettings;
        bSystemIsPlaceholder: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSystemEditorData;

        static Load(InName: string): NiagaraSystemEditorData;
    }

    export class NiagaraSystemFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSystemFactoryNew;

        static Load(InName: string): NiagaraSystemFactoryNew;
    }

    export class NiagaraSystemSelectionViewModel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StackSelection: NiagaraStackSelection;
        SelectionStackViewModel: NiagaraStackViewModel;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSystemSelectionViewModel;

        static Load(InName: string): NiagaraSystemSelectionViewModel;
    }

    export class NiagaraSystemThumbnailRenderer extends NiagaraThumbnailRendererBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NiagaraSystemThumbnailRenderer;

        static Load(InName: string): NiagaraSystemThumbnailRenderer;
    }

    export class NodeAndChannelMappings extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NodeAndChannelMappings;

        static Load(InName: string): NodeAndChannelMappings;
    }

    export class NodeDependingOnEnumInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NodeDependingOnEnumInterface;

        static Load(InName: string): NodeDependingOnEnumInterface;
    }

    export class NodeMappingProviderInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NodeMappingProviderInterface;

        static Load(InName: string): NodeMappingProviderInterface;
    }

    export class NoiseField extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MinRange: number;
        MaxRange: number;
        Transform: Transform;

        SetNoiseField(MinRange: number, MaxRange: number, Transform: Transform): NoiseField;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NoiseField;

        static Load(InName: string): NoiseField;
    }

    export class Note extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Text: string;
        SpriteComponent: BillboardComponent;
        ArrowComponent: ArrowComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Note;

        static Load(InName: string): Note;
    }

    export class NullAudioCaptureProtocol extends MovieSceneAudioCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NullAudioCaptureProtocol;

        static Load(InName: string): NullAudioCaptureProtocol;
    }

    export class NullNavSysConfig extends NavigationSystemConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): NullNavSysConfig;

        static Load(InName: string): NullNavSysConfig;
    }

    export class ObjectExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ObjectExporterT3D;

        static Load(InName: string): ObjectExporterT3D;
    }

    export class ObjectLibraryFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ObjectLibraryFactory;

        static Load(InName: string): ObjectLibraryFactory;
    }

    export class ObjectRedirector extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ObjectRedirector;

        static Load(InName: string): ObjectRedirector;
    }

    export class ObjectReferencer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ReferencedObjects: TArray<Object>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ObjectReferencer;

        static Load(InName: string): ObjectReferencer;
    }

    export class ObjectTraceWorldSubsystem extends WorldSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ObjectTraceWorldSubsystem;

        static Load(InName: string): ObjectTraceWorldSubsystem;
    }

    export class OnlineBeacon extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BeaconConnectionInitialTimeout: number;
        BeaconConnectionTimeout: number;
        NetDriver: NetDriver;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineBeacon;

        static Load(InName: string): OnlineBeacon;
    }

    export class OnlineBeaconHostObject extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BeaconTypeName: string;
        ClientBeaconActorClass: Class;
        ClientActors: TArray<OnlineBeaconClient>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineBeaconHostObject;

        static Load(InName: string): OnlineBeaconHostObject;
    }

    export enum EBeaconConnectionState { Invalid, Closed, Pending, Open, EBeaconConnectionState_MAX }

    export class OnlineBeaconClient extends OnlineBeacon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BeaconOwner: OnlineBeaconHostObject;
        BeaconConnection: NetConnection;
        ConnectionState: EBeaconConnectionState;

        ClientOnConnected(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineBeaconClient;

        static Load(InName: string): OnlineBeaconClient;
    }

    export class OnlineBeaconHost extends OnlineBeacon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ListenPort: number;
        ClientActors: TArray<OnlineBeaconClient>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineBeaconHost;

        static Load(InName: string): OnlineBeaconHost;
    }

    export class OnlineEngineInterface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineEngineInterface;

        static Load(InName: string): OnlineEngineInterface;
    }

    export class OnlineEngineInterfaceImpl extends OnlineEngineInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VoiceSubsystemNameOverride: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineEngineInterfaceImpl;

        static Load(InName: string): OnlineEngineInterfaceImpl;
    }

    export class PIELoginSettingsInternal {
        constructor();
        constructor(Id: string, Token: string, Type: string, TokenBytes: TArray<number>);

        Id: string;
        Token: string;
        Type: string;
        TokenBytes: TArray<number>;

        static StaticClass(): Class;
    }

    export class OnlinePIESettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bOnlinePIEEnabled: boolean;
        Logins: TArray<PIELoginSettingsInternal>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlinePIESettings;

        static Load(InName: string): OnlinePIESettings;
    }

    export class OnlineSessionClient extends OnlineSession {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsFromInvite: boolean;
        bHandlingDisconnect: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OnlineSessionClient;

        static Load(InName: string): OnlineSessionClient;
    }

    export enum EFieldOperationType { Field_Multiply, Field_Divide, Field_Add, Field_Substract, Field_Operation_Max }

    export class OperatorField extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;
        RightField: FieldNodeBase;
        LeftField: FieldNodeBase;
        Operation: EFieldOperationType;

        SetOperatorField(Magnitude: number, RightField: $Nullable<FieldNodeBase>, LeftField: $Nullable<FieldNodeBase>, Operation: EFieldOperationType): OperatorField;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OperatorField;

        static Load(InName: string): OperatorField;
    }

    export class ORPHANED_DATA_ONLY_DmgTypeBP_Environmental_C_0 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ORPHANED_DATA_ONLY_DmgTypeBP_Environmental_C_0;

        static Load(InName: string): ORPHANED_DATA_ONLY_DmgTypeBP_Environmental_C_0;
    }

    export class OverlaySlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): OverlaySlot;

        static Load(InName: string): OverlaySlot;
    }

    export class Overlay extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddChildToOverlay(Content: $Nullable<Widget>): OverlaySlot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Overlay;

        static Load(InName: string): Overlay;
    }

    export class PackageFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PackageFactory;

        static Load(InName: string): PackageFactory;
    }

    export class PackageMapClient extends PackageMap {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PackageMapClient;

        static Load(InName: string): PackageMapClient;
    }

    export class PackageTools extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static SanitizePackageName(InPackageName: string): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PackageTools;

        static Load(InName: string): PackageTools;
    }

    export class PacketHandlerProfileConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Components: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PacketHandlerProfileConfig;

        static Load(InName: string): PacketHandlerProfileConfig;
    }

    export class PackFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PackFactory;

        static Load(InName: string): PackFactory;
    }

    export class PainCausingVolume extends PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bPainCausing: boolean;
        DamagePerSec: number;
        DamageType: Class;
        PainInterval: number;
        bEntryPain: boolean;
        BACKUP_bPainCausing: boolean;
        DamageInstigator: Controller;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PainCausingVolume;

        static Load(InName: string): PainCausingVolume;
    }

    export enum EMeshPaintColorViewMode { Normal, RGB, Alpha, Red, Green, Blue, EMeshPaintColorViewMode_MAX }

    export class PaintBrushSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BrushRadius: number;
        BrushStrength: number;
        BrushFalloffAmount: number;
        bEnableFlow: boolean;
        bOnlyFrontFacingTriangles: boolean;
        ColorViewMode: EMeshPaintColorViewMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PaintBrushSettings;

        static Load(InName: string): PaintBrushSettings;
    }

    export enum EPaintMode { Vertices, Textures, EPaintMode_MAX }

    export enum EMeshPaintMode { PaintColors, PaintWeights, EMeshPaintMode_MAX }

    export enum ETextureWeightTypes { AlphaLerp, RGB, ARGB, OneMinusARGB, ETextureWeightTypes_MAX }

    export enum ETexturePaintIndex {
        TextureOne,
        TextureTwo,
        TextureThree,
        TextureFour,
        TextureFive,
        ETexturePaintIndex_MAX
    }

    export class VertexPaintSettings {
        constructor();
        constructor(MeshPaintMode: EMeshPaintMode, PaintColor: LinearColor, EraseColor: LinearColor, bWriteRed: boolean, bWriteGreen: boolean, bWriteBlue: boolean, bWriteAlpha: boolean, TextureWeightType: ETextureWeightTypes, PaintTextureWeightIndex: ETexturePaintIndex, EraseTextureWeightIndex: ETexturePaintIndex, bPaintOnSpecificLOD: boolean, LODIndex: number);

        MeshPaintMode: EMeshPaintMode;
        PaintColor: LinearColor;
        EraseColor: LinearColor;
        bWriteRed: boolean;
        bWriteGreen: boolean;
        bWriteBlue: boolean;
        bWriteAlpha: boolean;
        TextureWeightType: ETextureWeightTypes;
        PaintTextureWeightIndex: ETexturePaintIndex;
        EraseTextureWeightIndex: ETexturePaintIndex;
        bPaintOnSpecificLOD: boolean;
        LODIndex: number;

        static StaticClass(): Class;
    }

    export class TexturePaintSettings {
        constructor();
        constructor(PaintColor: LinearColor, EraseColor: LinearColor, bWriteRed: boolean, bWriteGreen: boolean, bWriteBlue: boolean, bWriteAlpha: boolean, UVChannel: number, bEnableSeamPainting: boolean, PaintTexture: Texture2D);

        PaintColor: LinearColor;
        EraseColor: LinearColor;
        bWriteRed: boolean;
        bWriteGreen: boolean;
        bWriteBlue: boolean;
        bWriteAlpha: boolean;
        UVChannel: number;
        bEnableSeamPainting: boolean;
        PaintTexture: Texture2D;

        static StaticClass(): Class;
    }

    export class PaintModeSettings extends MeshPaintSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PaintMode: EPaintMode;
        VertexPaintSettings: VertexPaintSettings;
        TexturePaintSettings: TexturePaintSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PaintModeSettings;

        static Load(InName: string): PaintModeSettings;
    }

    export class PanelExtensionSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PanelExtensionSubsystem;

        static Load(InName: string): PanelExtensionSubsystem;
    }

    export class ParticleModuleAccelerationBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAlwaysInWorldSpace: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationBase;

        static Load(InName: string): ParticleModuleAccelerationBase;
    }

    export class ParticleModuleAcceleration extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Acceleration: RawDistributionVector;
        bApplyOwnerScale: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAcceleration;

        static Load(InName: string): ParticleModuleAcceleration;
    }

    export class ParticleModuleAccelerationConstant extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Acceleration: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationConstant;

        static Load(InName: string): ParticleModuleAccelerationConstant;
    }

    export class ParticleModuleAccelerationDrag extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DragCoefficient: DistributionFloat;
        DragCoefficientRaw: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationDrag;

        static Load(InName: string): ParticleModuleAccelerationDrag;
    }

    export class ParticleModuleAccelerationDragScaleOverLife extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DragScale: DistributionFloat;
        DragScaleRaw: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationDragScaleOverLife;

        static Load(InName: string): ParticleModuleAccelerationDragScaleOverLife;
    }

    export class ParticleModuleAccelerationOverLifetime extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AccelOverLife: RawDistributionVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationOverLifetime;

        static Load(InName: string): ParticleModuleAccelerationOverLifetime;
    }

    export class ParticleModuleAttractorBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorBase;

        static Load(InName: string): ParticleModuleAttractorBase;
    }

    export class ParticleModuleAttractorLine extends ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EndPoint0: Vector;
        EndPoint1: Vector;
        Range: RawDistributionFloat;
        Strength: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorLine;

        static Load(InName: string): ParticleModuleAttractorLine;
    }

    export enum EAttractorParticleSelectionMethod { EAPSM_Random, EAPSM_Sequential, EAPSM_MAX }

    export class ParticleModuleAttractorParticle extends ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterName: string;
        Range: RawDistributionFloat;
        bStrengthByDistance: boolean;
        Strength: RawDistributionFloat;
        bAffectBaseVelocity: boolean;
        SelectionMethod: EAttractorParticleSelectionMethod;
        bRenewSource: boolean;
        bInheritSourceVel: boolean;
        LastSelIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorParticle;

        static Load(InName: string): ParticleModuleAttractorParticle;
    }

    export class ParticleModuleAttractorPoint extends ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Position: RawDistributionVector;
        Range: RawDistributionFloat;
        Strength: RawDistributionFloat;
        StrengthByDistance: boolean;
        bAffectBaseVelocity: boolean;
        bOverrideVelocity: boolean;
        bUseWorldSpacePosition: boolean;
        Positive_X: boolean;
        Positive_Y: boolean;
        Positive_Z: boolean;
        Negative_X: boolean;
        Negative_Y: boolean;
        Negative_Z: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorPoint;

        static Load(InName: string): ParticleModuleAttractorPoint;
    }

    export class ParticleModuleAttractorPointGravity extends ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Position: Vector;
        Radius: number;
        Strength: DistributionFloat;
        StrengthRaw: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorPointGravity;

        static Load(InName: string): ParticleModuleAttractorPointGravity;
    }

    export class ParticleModuleBeamBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamBase;

        static Load(InName: string): ParticleModuleBeamBase;
    }

    export enum BeamModifierType { PEB2MT_Source, PEB2MT_Target, PEB2MT_MAX }

    export class BeamModifierOptions {
        constructor();
        constructor(bModify: boolean, bScale: boolean, bLock: boolean);

        bModify: boolean;
        bScale: boolean;
        bLock: boolean;

        static StaticClass(): Class;
    }

    export class ParticleModuleBeamModifier extends ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ModifierType: BeamModifierType;
        PositionOptions: BeamModifierOptions;
        Position: RawDistributionVector;
        TangentOptions: BeamModifierOptions;
        Tangent: RawDistributionVector;
        bAbsoluteTangent: boolean;
        StrengthOptions: BeamModifierOptions;
        Strength: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamModifier;

        static Load(InName: string): ParticleModuleBeamModifier;
    }

    export class ParticleModuleBeamNoise extends ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bLowFreq_Enabled: boolean;
        Frequency: number;
        Frequency_LowRange: number;
        NoiseRange: RawDistributionVector;
        NoiseRangeScale: RawDistributionFloat;
        bNRScaleEmitterTime: boolean;
        NoiseSpeed: RawDistributionVector;
        bSmooth: boolean;
        NoiseLockRadius: number;
        bNoiseLock: boolean;
        bOscillate: boolean;
        NoiseLockTime: number;
        NoiseTension: number;
        bUseNoiseTangents: boolean;
        NoiseTangentStrength: RawDistributionFloat;
        NoiseTessellation: number;
        bTargetNoise: boolean;
        FrequencyDistance: number;
        bApplyNoiseScale: boolean;
        NoiseScale: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamNoise;

        static Load(InName: string): ParticleModuleBeamNoise;
    }

    export enum Beam2SourceTargetMethod {
        PEB2STM_Default,
        PEB2STM_UserSet,
        PEB2STM_Emitter,
        PEB2STM_Particle,
        PEB2STM_Actor,
        PEB2STM_MAX
    }

    export enum Beam2SourceTargetTangentMethod {
        PEB2STTM_Direct,
        PEB2STTM_UserSet,
        PEB2STTM_Distribution,
        PEB2STTM_Emitter,
        PEB2STTM_MAX
    }

    export class ParticleModuleBeamSource extends ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceMethod: Beam2SourceTargetMethod;
        SourceName: string;
        bSourceAbsolute: boolean;
        Source: RawDistributionVector;
        bLockSource: boolean;
        SourceTangentMethod: Beam2SourceTargetTangentMethod;
        SourceTangent: RawDistributionVector;
        bLockSourceTangent: boolean;
        SourceStrength: RawDistributionFloat;
        bLockSourceStength: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamSource;

        static Load(InName: string): ParticleModuleBeamSource;
    }

    export class ParticleModuleBeamTarget extends ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetMethod: Beam2SourceTargetMethod;
        TargetName: string;
        Target: RawDistributionVector;
        bTargetAbsolute: boolean;
        bLockTarget: boolean;
        TargetTangentMethod: Beam2SourceTargetTangentMethod;
        TargetTangent: RawDistributionVector;
        bLockTargetTangent: boolean;
        TargetStrength: RawDistributionFloat;
        bLockTargetStength: boolean;
        LockRadius: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamTarget;

        static Load(InName: string): ParticleModuleBeamTarget;
    }

    export class ParticleModuleCameraBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleCameraBase;

        static Load(InName: string): ParticleModuleCameraBase;
    }

    export enum EParticleCameraOffsetUpdateMethod { EPCOUM_DirectSet, EPCOUM_Additive, EPCOUM_Scalar, EPCOUM_MAX }

    export class ParticleModuleCameraOffset extends ParticleModuleCameraBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraOffset: RawDistributionFloat;
        bSpawnTimeOnly: boolean;
        UpdateMethod: EParticleCameraOffsetUpdateMethod;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleCameraOffset;

        static Load(InName: string): ParticleModuleCameraOffset;
    }

    export class ParticleModuleCollisionBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollisionBase;

        static Load(InName: string): ParticleModuleCollisionBase;
    }

    export enum EParticleCollisionComplete {
        EPCC_Kill,
        EPCC_Freeze,
        EPCC_HaltCollisions,
        EPCC_FreezeTranslation,
        EPCC_FreezeRotation,
        EPCC_FreezeMovement,
        EPCC_MAX
    }

    export class ParticleModuleCollision extends ParticleModuleCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DampingFactor: RawDistributionVector;
        DampingFactorRotation: RawDistributionVector;
        MaxCollisions: RawDistributionFloat;
        CollisionCompletionOption: EParticleCollisionComplete;
        CollisionTypes: TArray<EObjectTypeQuery>;
        bApplyPhysics: boolean;
        bIgnoreTriggerVolumes: boolean;
        ParticleMass: RawDistributionFloat;
        DirScalar: number;
        bPawnsDoNotDecrementCount: boolean;
        bOnlyVerticalNormalsDecrementCount: boolean;
        VerticalFudgeFactor: number;
        DelayAmount: RawDistributionFloat;
        bDropDetail: boolean;
        bCollideOnlyIfVisible: boolean;
        bIgnoreSourceActor: boolean;
        MaxCollisionDistance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollision;

        static Load(InName: string): ParticleModuleCollision;
    }

    export enum EParticleCollisionResponse { Bounce, Stop, Kill, EParticleCollisionResponse_MAX }

    export enum EParticleCollisionMode { SceneDepth, DistanceField, EParticleCollisionMode_MAX }

    export class ParticleModuleCollisionGPU extends ParticleModuleCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Resilience: RawDistributionFloat;
        ResilienceScaleOverLife: RawDistributionFloat;
        Friction: number;
        RandomSpread: number;
        RandomDistribution: number;
        RadiusScale: number;
        RadiusBias: number;
        Response: EParticleCollisionResponse;
        CollisionMode: EParticleCollisionMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollisionGPU;

        static Load(InName: string): ParticleModuleCollisionGPU;
    }

    export class ParticleModuleColorBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorBase;

        static Load(InName: string): ParticleModuleColorBase;
    }

    export class ParticleModuleColor extends ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartColor: RawDistributionVector;
        StartAlpha: RawDistributionFloat;
        bClampAlpha: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleColor;

        static Load(InName: string): ParticleModuleColor;
    }

    export class ParticleRandomSeedInfo {
        constructor();
        constructor(ParameterName: string, bGetSeedFromInstance: boolean, bInstanceSeedIsIndex: boolean, bResetSeedOnEmitterLooping: boolean, bRandomlySelectSeedArray: boolean, RandomSeeds: TArray<number>);

        ParameterName: string;
        bGetSeedFromInstance: boolean;
        bInstanceSeedIsIndex: boolean;
        bResetSeedOnEmitterLooping: boolean;
        bRandomlySelectSeedArray: boolean;
        RandomSeeds: TArray<number>;

        static StaticClass(): Class;
    }

    export class ParticleModuleColor_Seeded extends ParticleModuleColor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleColor_Seeded;

        static Load(InName: string): ParticleModuleColor_Seeded;
    }

    export class ParticleModuleColorOverLife extends ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ColorOverLife: RawDistributionVector;
        AlphaOverLife: RawDistributionFloat;
        bClampAlpha: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorOverLife;

        static Load(InName: string): ParticleModuleColorOverLife;
    }

    export class ParticleModuleColorScaleOverLife extends ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ColorScaleOverLife: RawDistributionVector;
        AlphaScaleOverLife: RawDistributionFloat;
        bEmitterTime: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorScaleOverLife;

        static Load(InName: string): ParticleModuleColorScaleOverLife;
    }

    export class ParticleModuleEventReceiverKillParticles extends ParticleModuleEventReceiverBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bStopSpawning: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverKillParticles;

        static Load(InName: string): ParticleModuleEventReceiverKillParticles;
    }

    export class ParticleModuleEventReceiverSpawn extends ParticleModuleEventReceiverBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpawnCount: RawDistributionFloat;
        bUseParticleTime: boolean;
        bUsePSysLocation: boolean;
        bInheritVelocity: boolean;
        InheritVelocityScale: RawDistributionVector;
        PhysicalMaterials: TArray<PhysicalMaterial>;
        bBanPhysicalMaterials: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverSpawn;

        static Load(InName: string): ParticleModuleEventReceiverSpawn;
    }

    export class ParticleModuleKillBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillBase;

        static Load(InName: string): ParticleModuleKillBase;
    }

    export class ParticleModuleKillBox extends ParticleModuleKillBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LowerLeftCorner: RawDistributionVector;
        UpperRightCorner: RawDistributionVector;
        bAbsolute: boolean;
        bKillInside: boolean;
        bAxisAlignedAndFixedSize: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillBox;

        static Load(InName: string): ParticleModuleKillBox;
    }

    export class ParticleModuleKillHeight extends ParticleModuleKillBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Height: RawDistributionFloat;
        bAbsolute: boolean;
        bFloor: boolean;
        bApplyPSysScale: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillHeight;

        static Load(InName: string): ParticleModuleKillHeight;
    }

    export class ParticleModuleLifetimeBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetimeBase;

        static Load(InName: string): ParticleModuleLifetimeBase;
    }

    export class ParticleModuleLifetime extends ParticleModuleLifetimeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Lifetime: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetime;

        static Load(InName: string): ParticleModuleLifetime;
    }

    export class ParticleModuleLifetime_Seeded extends ParticleModuleLifetime {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetime_Seeded;

        static Load(InName: string): ParticleModuleLifetime_Seeded;
    }

    export class ParticleModuleLightBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLightBase;

        static Load(InName: string): ParticleModuleLightBase;
    }

    export class ParticleModuleLight extends ParticleModuleLightBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseInverseSquaredFalloff: boolean;
        bAffectsTranslucency: boolean;
        bPreviewLightRadius: boolean;
        SpawnFraction: number;
        ColorScaleOverLife: RawDistributionVector;
        BrightnessOverLife: RawDistributionFloat;
        RadiusScale: RawDistributionFloat;
        LightExponent: RawDistributionFloat;
        LightingChannels: LightingChannels;
        VolumetricScatteringIntensity: number;
        bHighQualityLights: boolean;
        bShadowCastingLights: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLight;

        static Load(InName: string): ParticleModuleLight;
    }

    export class ParticleModuleLight_Seeded extends ParticleModuleLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLight_Seeded;

        static Load(InName: string): ParticleModuleLight_Seeded;
    }

    export class ParticleModuleLocationBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationBase;

        static Load(InName: string): ParticleModuleLocationBase;
    }

    export class ParticleModuleLocation extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartLocation: RawDistributionVector;
        DistributeOverNPoints: number;
        DistributeThreshold: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocation;

        static Load(InName: string): ParticleModuleLocation;
    }

    export class ParticleModuleLocation_Seeded extends ParticleModuleLocation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocation_Seeded;

        static Load(InName: string): ParticleModuleLocation_Seeded;
    }

    export enum ELocationBoneSocketSource { BONESOCKETSOURCE_Bones, BONESOCKETSOURCE_Sockets, BONESOCKETSOURCE_MAX }

    export class LocationBoneSocketInfo {
        constructor();
        constructor(BoneSocketName: string, Offset: Vector);

        BoneSocketName: string;
        Offset: Vector;

        static StaticClass(): Class;
    }

    export enum ELocationBoneSocketSelectionMethod { BONESOCKETSEL_Sequential, BONESOCKETSEL_Random, BONESOCKETSEL_MAX }

    export class ParticleModuleLocationBoneSocket extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceType: ELocationBoneSocketSource;
        UniversalOffset: Vector;
        SourceLocations: TArray<LocationBoneSocketInfo>;
        SelectionMethod: ELocationBoneSocketSelectionMethod;
        bUpdatePositionEachFrame: boolean;
        bOrientMeshEmitters: boolean;
        bInheritBoneVelocity: boolean;
        InheritVelocityScale: number;
        SkelMeshActorParamName: string;
        NumPreSelectedIndices: number;
        EditorSkelMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationBoneSocket;

        static Load(InName: string): ParticleModuleLocationBoneSocket;
    }

    export class ParticleModuleLocationDirect extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Location: RawDistributionVector;
        LocationOffset: RawDistributionVector;
        ScaleFactor: RawDistributionVector;
        Direction: RawDistributionVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationDirect;

        static Load(InName: string): ParticleModuleLocationDirect;
    }

    export enum ELocationEmitterSelectionMethod { ELESM_Random, ELESM_Sequential, ELESM_MAX }

    export class ParticleModuleLocationEmitter extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterName: string;
        SelectionMethod: ELocationEmitterSelectionMethod;
        InheritSourceVelocity: boolean;
        InheritSourceVelocityScale: number;
        bInheritSourceRotation: boolean;
        InheritSourceRotationScale: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationEmitter;

        static Load(InName: string): ParticleModuleLocationEmitter;
    }

    export class ParticleModuleLocationEmitterDirect extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationEmitterDirect;

        static Load(InName: string): ParticleModuleLocationEmitterDirect;
    }

    export class ParticleModuleLocationPrimitiveBase extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Positive_X: boolean;
        Positive_Y: boolean;
        Positive_Z: boolean;
        Negative_X: boolean;
        Negative_Y: boolean;
        Negative_Z: boolean;
        SurfaceOnly: boolean;
        Velocity: boolean;
        VelocityScale: RawDistributionFloat;
        StartLocation: RawDistributionVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveBase;

        static Load(InName: string): ParticleModuleLocationPrimitiveBase;
    }

    export enum CylinderHeightAxis { PMLPC_HEIGHTAXIS_X, PMLPC_HEIGHTAXIS_Y, PMLPC_HEIGHTAXIS_Z, PMLPC_HEIGHTAXIS_MAX }

    export class ParticleModuleLocationPrimitiveCylinder extends ParticleModuleLocationPrimitiveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RadialVelocity: boolean;
        StartRadius: RawDistributionFloat;
        StartHeight: RawDistributionFloat;
        HeightAxis: CylinderHeightAxis;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveCylinder;

        static Load(InName: string): ParticleModuleLocationPrimitiveCylinder;
    }

    export class ParticleModuleLocationPrimitiveCylinder_Seeded extends ParticleModuleLocationPrimitiveCylinder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveCylinder_Seeded;

        static Load(InName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
    }

    export class ParticleModuleLocationPrimitiveSphere extends ParticleModuleLocationPrimitiveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartRadius: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveSphere;

        static Load(InName: string): ParticleModuleLocationPrimitiveSphere;
    }

    export class ParticleModuleLocationPrimitiveSphere_Seeded extends ParticleModuleLocationPrimitiveSphere {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveSphere_Seeded;

        static Load(InName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
    }

    export class ParticleModuleLocationPrimitiveTriangle extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartOffset: RawDistributionVector;
        Height: RawDistributionFloat;
        Angle: RawDistributionFloat;
        Thickness: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveTriangle;

        static Load(InName: string): ParticleModuleLocationPrimitiveTriangle;
    }

    export enum ELocationSkelVertSurfaceSource {
        VERTSURFACESOURCE_Vert,
        VERTSURFACESOURCE_Surface,
        VERTSURFACESOURCE_MAX
    }

    export class ParticleModuleLocationSkelVertSurface extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceType: ELocationSkelVertSurfaceSource;
        UniversalOffset: Vector;
        bUpdatePositionEachFrame: boolean;
        bOrientMeshEmitters: boolean;
        bInheritBoneVelocity: boolean;
        InheritVelocityScale: number;
        SkelMeshActorParamName: string;
        EditorSkelMesh: SkeletalMesh;
        ValidAssociatedBones: TArray<string>;
        bEnforceNormalCheck: boolean;
        NormalToCompare: Vector;
        NormalCheckToleranceDegrees: number;
        NormalCheckTolerance: number;
        ValidMaterialIndices: TArray<number>;
        bInheritVertexColor: boolean;
        bInheritUV: boolean;
        InheritUVChannel: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationSkelVertSurface;

        static Load(InName: string): ParticleModuleLocationSkelVertSurface;
    }

    export class ParticleModuleLocationWorldOffset extends ParticleModuleLocation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationWorldOffset;

        static Load(InName: string): ParticleModuleLocationWorldOffset;
    }

    export class ParticleModuleLocationWorldOffset_Seeded extends ParticleModuleLocationWorldOffset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationWorldOffset_Seeded;

        static Load(InName: string): ParticleModuleLocationWorldOffset_Seeded;
    }

    export class ParticleModuleMaterialBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleMaterialBase;

        static Load(InName: string): ParticleModuleMaterialBase;
    }

    export class ParticleModuleMeshMaterial extends ParticleModuleMaterialBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MeshMaterials: TArray<MaterialInterface>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshMaterial;

        static Load(InName: string): ParticleModuleMeshMaterial;
    }

    export class ParticleModuleRotationBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationBase;

        static Load(InName: string): ParticleModuleRotationBase;
    }

    export class ParticleModuleMeshRotation extends ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartRotation: RawDistributionVector;
        bInheritParent: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotation;

        static Load(InName: string): ParticleModuleMeshRotation;
    }

    export class ParticleModuleMeshRotation_Seeded extends ParticleModuleMeshRotation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotation_Seeded;

        static Load(InName: string): ParticleModuleMeshRotation_Seeded;
    }

    export class ParticleModuleRotationRateBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRateBase;

        static Load(InName: string): ParticleModuleRotationRateBase;
    }

    export class ParticleModuleMeshRotationRate extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartRotationRate: RawDistributionVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRate;

        static Load(InName: string): ParticleModuleMeshRotationRate;
    }

    export class ParticleModuleMeshRotationRate_Seeded extends ParticleModuleMeshRotationRate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRate_Seeded;

        static Load(InName: string): ParticleModuleMeshRotationRate_Seeded;
    }

    export class ParticleModuleMeshRotationRateMultiplyLife extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LifeMultiplier: RawDistributionVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRateMultiplyLife;

        static Load(InName: string): ParticleModuleMeshRotationRateMultiplyLife;
    }

    export class ParticleModuleMeshRotationRateOverLife extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RotRate: RawDistributionVector;
        bScaleRotRate: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRateOverLife;

        static Load(InName: string): ParticleModuleMeshRotationRateOverLife;
    }

    export class ParticleModuleOrientationBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrientationBase;

        static Load(InName: string): ParticleModuleOrientationBase;
    }

    export enum EParticleAxisLock {
        EPAL_NONE,
        EPAL_X,
        EPAL_Y,
        EPAL_Z,
        EPAL_NEGATIVE_X,
        EPAL_NEGATIVE_Y,
        EPAL_NEGATIVE_Z,
        EPAL_ROTATE_X,
        EPAL_ROTATE_Y,
        EPAL_ROTATE_Z,
        EPAL_MAX
    }

    export class ParticleModuleOrientationAxisLock extends ParticleModuleOrientationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LockAxisFlags: EParticleAxisLock;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrientationAxisLock;

        static Load(InName: string): ParticleModuleOrientationAxisLock;
    }

    export class ParticleModuleParameterBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterBase;

        static Load(InName: string): ParticleModuleParameterBase;
    }

    export enum EEmitterDynamicParameterValue {
        EDPV_UserSet,
        EDPV_AutoSet,
        EDPV_VelocityX,
        EDPV_VelocityY,
        EDPV_VelocityZ,
        EDPV_VelocityMag,
        EDPV_MAX
    }

    export class EmitterDynamicParameter {
        constructor();
        constructor(ParamName: string, bUseEmitterTime: boolean, bSpawnTimeOnly: boolean, ValueMethod: EEmitterDynamicParameterValue, bScaleVelocityByParamValue: boolean, ParamValue: RawDistributionFloat);

        ParamName: string;
        bUseEmitterTime: boolean;
        bSpawnTimeOnly: boolean;
        ValueMethod: EEmitterDynamicParameterValue;
        bScaleVelocityByParamValue: boolean;
        ParamValue: RawDistributionFloat;

        static StaticClass(): Class;
    }

    export class ParticleModuleParameterDynamic extends ParticleModuleParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DynamicParams: TArray<EmitterDynamicParameter>;
        UpdateFlags: number;
        bUsesVelocity: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterDynamic;

        static Load(InName: string): ParticleModuleParameterDynamic;
    }

    export class ParticleModuleParameterDynamic_Seeded extends ParticleModuleParameterDynamic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterDynamic_Seeded;

        static Load(InName: string): ParticleModuleParameterDynamic_Seeded;
    }

    export class ParticleModulePivotOffset extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PivotOffset: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModulePivotOffset;

        static Load(InName: string): ParticleModulePivotOffset;
    }

    export class ParticleModuleRotation extends ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartRotation: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotation;

        static Load(InName: string): ParticleModuleRotation;
    }

    export class ParticleModuleRotation_Seeded extends ParticleModuleRotation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotation_Seeded;

        static Load(InName: string): ParticleModuleRotation_Seeded;
    }

    export class ParticleModuleRotationOverLifetime extends ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RotationOverLife: RawDistributionFloat;
        Scale: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationOverLifetime;

        static Load(InName: string): ParticleModuleRotationOverLifetime;
    }

    export class ParticleModuleRotationRate extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartRotationRate: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRate;

        static Load(InName: string): ParticleModuleRotationRate;
    }

    export class ParticleModuleRotationRate_Seeded extends ParticleModuleRotationRate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRate_Seeded;

        static Load(InName: string): ParticleModuleRotationRate_Seeded;
    }

    export class ParticleModuleRotationRateMultiplyLife extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LifeMultiplier: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRateMultiplyLife;

        static Load(InName: string): ParticleModuleRotationRateMultiplyLife;
    }

    export class ParticleModuleSizeBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeBase;

        static Load(InName: string): ParticleModuleSizeBase;
    }

    export class ParticleModuleSize extends ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartSize: RawDistributionVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSize;

        static Load(InName: string): ParticleModuleSize;
    }

    export class ParticleModuleSize_Seeded extends ParticleModuleSize {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSize_Seeded;

        static Load(InName: string): ParticleModuleSize_Seeded;
    }

    export class ParticleModuleSizeMultiplyLife extends ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LifeMultiplier: RawDistributionVector;
        MultiplyX: boolean;
        MultiplyY: boolean;
        MultiplyZ: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeMultiplyLife;

        static Load(InName: string): ParticleModuleSizeMultiplyLife;
    }

    export class ParticleModuleSizeScale extends ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SizeScale: RawDistributionVector;
        EnableX: boolean;
        EnableY: boolean;
        EnableZ: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeScale;

        static Load(InName: string): ParticleModuleSizeScale;
    }

    export class ParticleModuleSizeScaleBySpeed extends ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpeedScale: Vector2D;
        MaxScale: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeScaleBySpeed;

        static Load(InName: string): ParticleModuleSizeScaleBySpeed;
    }

    export class ParticleModuleSourceMovement extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceMovementScale: RawDistributionVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSourceMovement;

        static Load(InName: string): ParticleModuleSourceMovement;
    }

    export class ParticleModuleSpawnPerUnit extends ParticleModuleSpawnBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UnitScalar: number;
        MovementTolerance: number;
        SpawnPerUnit: RawDistributionFloat;
        MaxFrameDistance: number;
        bIgnoreSpawnRateWhenMoving: boolean;
        bIgnoreMovementAlongX: boolean;
        bIgnoreMovementAlongY: boolean;
        bIgnoreMovementAlongZ: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawnPerUnit;

        static Load(InName: string): ParticleModuleSpawnPerUnit;
    }

    export class ParticleModuleSubUVBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUVBase;

        static Load(InName: string): ParticleModuleSubUVBase;
    }

    export class SubUVAnimation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SubUVTexture: Texture2D;
        SubImages_Horizontal: number;
        SubImages_Vertical: number;
        BoundingMode: ESubUVBoundingVertexCount;
        OpacitySourceMode: EOpacitySourceMode;
        AlphaThreshold: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubUVAnimation;

        static Load(InName: string): SubUVAnimation;
    }

    export class ParticleModuleSubUV extends ParticleModuleSubUVBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Animation: SubUVAnimation;
        SubImageIndex: RawDistributionFloat;
        bUseRealTime: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUV;

        static Load(InName: string): ParticleModuleSubUV;
    }

    export class ParticleModuleSubUVMovie extends ParticleModuleSubUV {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseEmitterTime: boolean;
        FrameRate: RawDistributionFloat;
        StartingFrame: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUVMovie;

        static Load(InName: string): ParticleModuleSubUVMovie;
    }

    export class ParticleModuleTrailBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleTrailBase;

        static Load(InName: string): ParticleModuleTrailBase;
    }

    export enum ETrail2SourceMethod { PET2SRCM_Default, PET2SRCM_Particle, PET2SRCM_Actor, PET2SRCM_MAX }

    export enum EParticleSourceSelectionMethod { EPSSM_Random, EPSSM_Sequential, EPSSM_MAX }

    export class ParticleModuleTrailSource extends ParticleModuleTrailBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceMethod: ETrail2SourceMethod;
        SourceName: string;
        SourceStrength: RawDistributionFloat;
        bLockSourceStength: boolean;
        SourceOffsetCount: number;
        SourceOffsetDefaults: TArray<Vector>;
        SelectionMethod: EParticleSourceSelectionMethod;
        bInheritRotation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleTrailSource;

        static Load(InName: string): ParticleModuleTrailSource;
    }

    export class ParticleModuleTypeDataAnimTrail extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bDeadTrailsOnDeactivate: boolean;
        bEnablePreviousTangentRecalculation: boolean;
        bTangentRecalculationEveryFrame: boolean;
        TilingDistance: number;
        DistanceTessellationStepSize: number;
        TangentTessellationStepSize: number;
        WidthTessellationStepSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataAnimTrail;

        static Load(InName: string): ParticleModuleTypeDataAnimTrail;
    }

    export enum EBeam2Method { PEB2M_Distance, PEB2M_Target, PEB2M_Branch, PEB2M_MAX }

    export enum EBeamTaperMethod { PEBTM_None, PEBTM_Full, PEBTM_Partial, PEBTM_MAX }

    export class ParticleModuleTypeDataBeam2 extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BeamMethod: EBeam2Method;
        TextureTile: number;
        TextureTileDistance: number;
        Sheets: number;
        MaxBeamCount: number;
        Speed: number;
        InterpolationPoints: number;
        bAlwaysOn: boolean;
        UpVectorStepSize: number;
        BranchParentName: string;
        Distance: RawDistributionFloat;
        TaperMethod: EBeamTaperMethod;
        TaperFactor: RawDistributionFloat;
        TaperScale: RawDistributionFloat;
        RenderGeometry: boolean;
        RenderDirectLine: boolean;
        RenderLines: boolean;
        RenderTessellation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataBeam2;

        static Load(InName: string): ParticleModuleTypeDataBeam2;
    }

    export class GPUSpriteLocalVectorFieldInfo {
        constructor();
        constructor(Field: VectorField, Transform: Transform, MinInitialRotation: Rotator, MaxInitialRotation: Rotator, RotationRate: Rotator, Intensity: number, Tightness: number, bIgnoreComponentTransform: boolean, bTileX: boolean, bTileY: boolean, bTileZ: boolean, bUseFixDT: boolean);

        Field: VectorField;
        Transform: Transform;
        MinInitialRotation: Rotator;
        MaxInitialRotation: Rotator;
        RotationRate: Rotator;
        Intensity: number;
        Tightness: number;
        bIgnoreComponentTransform: boolean;
        bTileX: boolean;
        bTileY: boolean;
        bTileZ: boolean;
        bUseFixDT: boolean;

        static StaticClass(): Class;
    }

    export class FloatDistribution {
        constructor();
        constructor(Table: DistributionLookupTable);

        Table: DistributionLookupTable;

        static StaticClass(): Class;
    }

    export class GPUSpriteEmitterInfo {
        constructor();
        constructor(RequiredModule: ParticleModuleRequired, SpawnModule: ParticleModuleSpawn, SpawnPerUnitModule: ParticleModuleSpawnPerUnit, SpawnModules: TArray<ParticleModule>, LocalVectorField: GPUSpriteLocalVectorFieldInfo, VectorFieldScale: FloatDistribution, DragCoefficient: FloatDistribution, PointAttractorStrength: FloatDistribution, Resilience: FloatDistribution, ConstantAcceleration: Vector, PointAttractorPosition: Vector, PointAttractorRadiusSq: number, OrbitOffsetBase: Vector, OrbitOffsetRange: Vector, InvMaxSize: Vector2D, InvRotationRateScale: number, MaxLifetime: number, MaxParticleCount: number, ScreenAlignment: EParticleScreenAlignment, LockAxisFlag: EParticleAxisLock, bEnableCollision: boolean, CollisionMode: EParticleCollisionMode, bRemoveHMDRoll: boolean, MinFacingCameraBlendDistance: number, MaxFacingCameraBlendDistance: number, DynamicColor: RawDistributionVector, DynamicAlpha: RawDistributionFloat, DynamicColorScale: RawDistributionVector, DynamicAlphaScale: RawDistributionFloat);

        RequiredModule: ParticleModuleRequired;
        SpawnModule: ParticleModuleSpawn;
        SpawnPerUnitModule: ParticleModuleSpawnPerUnit;
        SpawnModules: TArray<ParticleModule>;
        LocalVectorField: GPUSpriteLocalVectorFieldInfo;
        VectorFieldScale: FloatDistribution;
        DragCoefficient: FloatDistribution;
        PointAttractorStrength: FloatDistribution;
        Resilience: FloatDistribution;
        ConstantAcceleration: Vector;
        PointAttractorPosition: Vector;
        PointAttractorRadiusSq: number;
        OrbitOffsetBase: Vector;
        OrbitOffsetRange: Vector;
        InvMaxSize: Vector2D;
        InvRotationRateScale: number;
        MaxLifetime: number;
        MaxParticleCount: number;
        ScreenAlignment: EParticleScreenAlignment;
        LockAxisFlag: EParticleAxisLock;
        bEnableCollision: boolean;
        CollisionMode: EParticleCollisionMode;
        bRemoveHMDRoll: boolean;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
        DynamicColor: RawDistributionVector;
        DynamicAlpha: RawDistributionFloat;
        DynamicColorScale: RawDistributionVector;
        DynamicAlphaScale: RawDistributionFloat;

        static StaticClass(): Class;
    }

    export class GPUSpriteResourceData {
        constructor();
        constructor(QuantizedColorSamples: TArray<Color>, QuantizedMiscSamples: TArray<Color>, QuantizedSimulationAttrSamples: TArray<Color>, ColorScale: Vector4, ColorBias: Vector4, MiscScale: Vector4, MiscBias: Vector4, SimulationAttrCurveScale: Vector4, SimulationAttrCurveBias: Vector4, SubImageSize: Vector4, SizeBySpeed: Vector4, ConstantAcceleration: Vector, OrbitOffsetBase: Vector, OrbitOffsetRange: Vector, OrbitFrequencyBase: Vector, OrbitFrequencyRange: Vector, OrbitPhaseBase: Vector, OrbitPhaseRange: Vector, GlobalVectorFieldScale: number, GlobalVectorFieldTightness: number, PerParticleVectorFieldScale: number, PerParticleVectorFieldBias: number, DragCoefficientScale: number, DragCoefficientBias: number, ResilienceScale: number, ResilienceBias: number, CollisionRadiusScale: number, CollisionRadiusBias: number, CollisionTimeBias: number, CollisionRandomSpread: number, CollisionRandomDistribution: number, OneMinusFriction: number, RotationRateScale: number, CameraMotionBlurAmount: number, ScreenAlignment: EParticleScreenAlignment, LockAxisFlag: EParticleAxisLock, PivotOffset: Vector2D, bRemoveHMDRoll: boolean, MinFacingCameraBlendDistance: number, MaxFacingCameraBlendDistance: number);

        QuantizedColorSamples: TArray<Color>;
        QuantizedMiscSamples: TArray<Color>;
        QuantizedSimulationAttrSamples: TArray<Color>;
        ColorScale: Vector4;
        ColorBias: Vector4;
        MiscScale: Vector4;
        MiscBias: Vector4;
        SimulationAttrCurveScale: Vector4;
        SimulationAttrCurveBias: Vector4;
        SubImageSize: Vector4;
        SizeBySpeed: Vector4;
        ConstantAcceleration: Vector;
        OrbitOffsetBase: Vector;
        OrbitOffsetRange: Vector;
        OrbitFrequencyBase: Vector;
        OrbitFrequencyRange: Vector;
        OrbitPhaseBase: Vector;
        OrbitPhaseRange: Vector;
        GlobalVectorFieldScale: number;
        GlobalVectorFieldTightness: number;
        PerParticleVectorFieldScale: number;
        PerParticleVectorFieldBias: number;
        DragCoefficientScale: number;
        DragCoefficientBias: number;
        ResilienceScale: number;
        ResilienceBias: number;
        CollisionRadiusScale: number;
        CollisionRadiusBias: number;
        CollisionTimeBias: number;
        CollisionRandomSpread: number;
        CollisionRandomDistribution: number;
        OneMinusFriction: number;
        RotationRateScale: number;
        CameraMotionBlurAmount: number;
        ScreenAlignment: EParticleScreenAlignment;
        LockAxisFlag: EParticleAxisLock;
        PivotOffset: Vector2D;
        bRemoveHMDRoll: boolean;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;

        static StaticClass(): Class;
    }

    export class ParticleModuleTypeDataGpu extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EmitterInfo: GPUSpriteEmitterInfo;
        ResourceData: GPUSpriteResourceData;
        CameraMotionBlurAmount: number;
        bClearExistingParticlesOnInit: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataGpu;

        static Load(InName: string): ParticleModuleTypeDataGpu;
    }

    export enum EMeshScreenAlignment {
        PSMA_MeshFaceCameraWithRoll,
        PSMA_MeshFaceCameraWithSpin,
        PSMA_MeshFaceCameraWithLockedAxis,
        PSMA_MAX
    }

    export enum EMeshCameraFacingUpAxis {
        CameraFacing_NoneUP,
        CameraFacing_ZUp,
        CameraFacing_NegativeZUp,
        CameraFacing_YUp,
        CameraFacing_NegativeYUp,
        CameraFacing_MAX
    }

    export enum EMeshCameraFacingOptions {
        XAxisFacing_NoUp,
        XAxisFacing_ZUp,
        XAxisFacing_NegativeZUp,
        XAxisFacing_YUp,
        XAxisFacing_NegativeYUp,
        LockedAxis_ZAxisFacing,
        LockedAxis_NegativeZAxisFacing,
        LockedAxis_YAxisFacing,
        LockedAxis_NegativeYAxisFacing,
        VelocityAligned_ZAxisFacing,
        VelocityAligned_NegativeZAxisFacing,
        VelocityAligned_YAxisFacing,
        VelocityAligned_NegativeYAxisFacing,
        EMeshCameraFacingOptions_MAX
    }

    export class ParticleModuleTypeDataMesh extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Mesh: StaticMesh;
        LODSizeScale: number;
        bUseStaticMeshLODs: boolean;
        CastShadows: boolean;
        DoCollisions: boolean;
        MeshAlignment: EMeshScreenAlignment;
        bOverrideMaterial: boolean;
        bOverrideDefaultMotionBlurSettings: boolean;
        bEnableMotionBlur: boolean;
        RollPitchYawRange: RawDistributionVector;
        AxisLockOption: EParticleAxisLock;
        bCameraFacing: boolean;
        CameraFacingUpAxisOption: EMeshCameraFacingUpAxis;
        CameraFacingOption: EMeshCameraFacingOptions;
        bApplyParticleRotationAsSpin: boolean;
        bFaceCameraDirectionRatherThanPosition: boolean;
        bCollisionsConsiderPartilceSize: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataMesh;

        static Load(InName: string): ParticleModuleTypeDataMesh;
    }

    export enum ETrailsRenderAxisOption { Trails_CameraUp, Trails_SourceUp, Trails_WorldUp, Trails_MAX }

    export class ParticleModuleTypeDataRibbon extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaxTessellationBetweenParticles: number;
        SheetsPerTrail: number;
        MaxTrailCount: number;
        MaxParticleInTrailCount: number;
        bDeadTrailsOnDeactivate: boolean;
        bDeadTrailsOnSourceLoss: boolean;
        bClipSourceSegement: boolean;
        bEnablePreviousTangentRecalculation: boolean;
        bTangentRecalculationEveryFrame: boolean;
        bSpawnInitialParticle: boolean;
        RenderAxis: ETrailsRenderAxisOption;
        TangentSpawningScalar: number;
        bRenderGeometry: boolean;
        bRenderSpawnPoints: boolean;
        bRenderTangents: boolean;
        bRenderTessellation: boolean;
        TilingDistance: number;
        DistanceTessellationStepSize: number;
        bEnableTangentDiffInterpScale: boolean;
        TangentTessellationScalar: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataRibbon;

        static Load(InName: string): ParticleModuleTypeDataRibbon;
    }

    export class ParticleModuleVectorFieldBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldBase;

        static Load(InName: string): ParticleModuleVectorFieldBase;
    }

    export class ParticleModuleVectorFieldGlobal extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bOverrideGlobalVectorFieldTightness: boolean;
        GlobalVectorFieldScale: number;
        GlobalVectorFieldTightness: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldGlobal;

        static Load(InName: string): ParticleModuleVectorFieldGlobal;
    }

    export class ParticleModuleVectorFieldLocal extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VectorField: VectorField;
        RelativeTranslation: Vector;
        RelativeRotation: Rotator;
        RelativeScale3D: Vector;
        Intensity: number;
        Tightness: number;
        bIgnoreComponentTransform: boolean;
        bTileX: boolean;
        bTileY: boolean;
        bTileZ: boolean;
        bUseFixDT: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldLocal;

        static Load(InName: string): ParticleModuleVectorFieldLocal;
    }

    export class ParticleModuleVectorFieldRotation extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MinInitialRotation: Vector;
        MaxInitialRotation: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldRotation;

        static Load(InName: string): ParticleModuleVectorFieldRotation;
    }

    export class ParticleModuleVectorFieldRotationRate extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RotationRate: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldRotationRate;

        static Load(InName: string): ParticleModuleVectorFieldRotationRate;
    }

    export class ParticleModuleVectorFieldScale extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VectorFieldScale: DistributionFloat;
        VectorFieldScaleRaw: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldScale;

        static Load(InName: string): ParticleModuleVectorFieldScale;
    }

    export class ParticleModuleVectorFieldScaleOverLife extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VectorFieldScaleOverLife: DistributionFloat;
        VectorFieldScaleOverLifeRaw: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldScaleOverLife;

        static Load(InName: string): ParticleModuleVectorFieldScaleOverLife;
    }

    export class ParticleModuleVelocityBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bInWorldSpace: boolean;
        bApplyOwnerScale: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityBase;

        static Load(InName: string): ParticleModuleVelocityBase;
    }

    export class ParticleModuleVelocity extends ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StartVelocity: RawDistributionVector;
        StartVelocityRadial: RawDistributionFloat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocity;

        static Load(InName: string): ParticleModuleVelocity;
    }

    export class ParticleModuleVelocity_Seeded extends ParticleModuleVelocity {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeedInfo: ParticleRandomSeedInfo;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocity_Seeded;

        static Load(InName: string): ParticleModuleVelocity_Seeded;
    }

    export class ParticleModuleVelocityCone extends ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Angle: RawDistributionFloat;
        Velocity: RawDistributionFloat;
        Direction: Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityCone;

        static Load(InName: string): ParticleModuleVelocityCone;
    }

    export class ParticleModuleVelocityInheritParent extends ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Scale: RawDistributionVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityInheritParent;

        static Load(InName: string): ParticleModuleVelocityInheritParent;
    }

    export class ParticleModuleVelocityOverLifetime extends ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VelOverLife: RawDistributionVector;
        Absolute: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityOverLifetime;

        static Load(InName: string): ParticleModuleVelocityOverLifetime;
    }

    export class ParticleSpriteEmitter extends ParticleEmitter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleSpriteEmitter;

        static Load(InName: string): ParticleSpriteEmitter;
    }

    export class ParticleSystemAuditCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HighSpawnRateOrBurstThreshold: number;
        FarLODDistanceTheshold: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleSystemAuditCommandlet;

        static Load(InName: string): ParticleSystemAuditCommandlet;
    }

    export class ParticleSystemFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleSystemFactoryNew;

        static Load(InName: string): ParticleSystemFactoryNew;
    }

    export class ParticleSystemThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NoImage: Texture2D;
        OutOfDate: Texture2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ParticleSystemThumbnailRenderer;

        static Load(InName: string): ParticleSystemThumbnailRenderer;
    }

    export class PlayerReservation {
        constructor();
        constructor(UniqueId: UniqueNetIdRepl, ValidationStr: string, Platform: string, bAllowCrossplay: boolean, ElapsedTime: number);

        UniqueId: UniqueNetIdRepl;
        ValidationStr: string;
        Platform: string;
        bAllowCrossplay: boolean;
        ElapsedTime: number;

        static StaticClass(): Class;
    }

    export class PartyReservation {
        constructor();
        constructor(TeamNum: number, PartyLeader: UniqueNetIdRepl, PartyMembers: TArray<PlayerReservation>, RemovedPartyMembers: TArray<PlayerReservation>);

        TeamNum: number;
        PartyLeader: UniqueNetIdRepl;
        PartyMembers: TArray<PlayerReservation>;
        RemovedPartyMembers: TArray<PlayerReservation>;

        static StaticClass(): Class;
    }

    export enum EClientRequestType {
        NonePending,
        ExistingSessionReservation,
        ReservationUpdate,
        EmptyServerReservation,
        Reconnect,
        Abandon,
        ReservationRemoveMembers,
        EClientRequestType_MAX
    }

    export enum EPartyReservationResult {
        NoResult,
        RequestPending,
        GeneralError,
        PartyLimitReached,
        IncorrectPlayerCount,
        RequestTimedOut,
        ReservationDuplicate,
        ReservationNotFound,
        ReservationAccepted,
        ReservationDenied,
        ReservationDenied_CrossPlayRestriction,
        ReservationDenied_Banned,
        ReservationRequestCanceled,
        ReservationInvalid,
        BadSessionId,
        ReservationDenied_ContainsExistingPlayers,
        EPartyReservationResult_MAX
    }

    export class PartyBeaconClient extends OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DestSessionId: string;
        PendingReservation: PartyReservation;
        RequestType: EClientRequestType;
        bPendingReservationSent: boolean;
        bCancelReservation: boolean;

        ClientCancelReservationResponse(ReservationResponse: EPartyReservationResult): void;

        ClientReservationResponse(ReservationResponse: EPartyReservationResult): void;

        ClientSendReservationFull(): void;

        ClientSendReservationUpdates(NumRemainingReservations: number): void;

        ServerCancelReservationRequest(PartyLeader: UniqueNetIdRepl): void;

        ServerRemoveMemberFromReservationRequest(SessionId: string, ReservationUpdate: PartyReservation): void;

        ServerReservationRequest(SessionId: string, Reservation: PartyReservation): void;

        ServerUpdateReservationRequest(SessionId: string, ReservationUpdate: PartyReservation): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PartyBeaconClient;

        static Load(InName: string): PartyBeaconClient;
    }

    export class PartyBeaconState extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SessionName: string;
        NumConsumedReservations: number;
        MaxReservations: number;
        NumTeams: number;
        NumPlayersPerTeam: number;
        TeamAssignmentMethod: string;
        ReservedHostTeamNum: number;
        ForceTeamNum: number;
        bRestrictCrossConsole: boolean;
        bEnableRemovalRequests: boolean;
        Reservations: TArray<PartyReservation>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PartyBeaconState;

        static Load(InName: string): PartyBeaconState;
    }

    export class PartyBeaconHost extends OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        State: PartyBeaconState;
        bLogoutOnSessionTimeout: boolean;
        SessionTimeoutSecs: number;
        TravelSessionTimeoutSecs: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PartyBeaconHost;

        static Load(InName: string): PartyBeaconHost;
    }

    export class PathFollowingAgentInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PathFollowingAgentInterface;

        static Load(InName: string): PathFollowingAgentInterface;
    }

    export class PathFollowingManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PathFollowingManager;

        static Load(InName: string): PathFollowingManager;
    }

    export class PawnAction_BlueprintBase extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActionFinished(ControlledPawn: $Nullable<Pawn>, WithResult: EPawnActionResult): void;

        ActionPause(ControlledPawn: $Nullable<Pawn>): void;

        ActionResume(ControlledPawn: $Nullable<Pawn>): void;

        ActionStart(ControlledPawn: $Nullable<Pawn>): void;

        ActionTick(ControlledPawn: $Nullable<Pawn>, DeltaSeconds: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnAction_BlueprintBase;

        static Load(InName: string): PawnAction_BlueprintBase;
    }

    export class PawnAction_Move extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GoalActor: Actor;
        GoalLocation: Vector;
        AcceptableRadius: number;
        FilterClass: Class;
        bAllowStrafe: boolean;
        bFinishOnOverlap: boolean;
        bUsePathfinding: boolean;
        bAllowPartialPath: boolean;
        bProjectGoalToNavigation: boolean;
        bUpdatePathToGoal: boolean;
        bAbortChildActionOnPathChange: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnAction_Move;

        static Load(InName: string): PawnAction_Move;
    }

    export enum EPawnActionFailHandling { RequireSuccess, IgnoreFailure, EPawnActionFailHandling_MAX }

    export class PawnAction_Repeat extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActionToRepeat: PawnAction;
        RecentActionCopy: PawnAction;
        ChildFailureHandlingMode: EPawnActionFailHandling;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnAction_Repeat;

        static Load(InName: string): PawnAction_Repeat;
    }

    export class PawnAction_Sequence extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActionSequence: TArray<PawnAction>;
        ChildFailureHandlingMode: EPawnActionFailHandling;
        RecentActionCopy: PawnAction;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnAction_Sequence;

        static Load(InName: string): PawnAction_Sequence;
    }

    export class PawnAction_Wait extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TimeToWait: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnAction_Wait;

        static Load(InName: string): PawnAction_Wait;
    }

    export class PawnNoiseEmitterComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAIPerceptionSystemCompatibilityMode: boolean;
        LastRemoteNoisePosition: Vector;
        NoiseLifetime: number;
        LastRemoteNoiseVolume: number;
        LastRemoteNoiseTime: number;
        LastLocalNoiseVolume: number;
        LastLocalNoiseTime: number;

        MakeNoise(NoiseMaker: $Nullable<Actor>, Loudness: number, NoiseLocation: Vector): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnNoiseEmitterComponent;

        static Load(InName: string): PawnNoiseEmitterComponent;
    }

    export class PawnSensingComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HearingThreshold: number;
        LOSHearingThreshold: number;
        SightRadius: number;
        SensingInterval: number;
        HearingMaxSoundAge: number;
        bEnableSensingUpdates: boolean;
        bOnlySensePlayers: boolean;
        bSeePawns: boolean;
        bHearNoises: boolean;
        OnSeePawn: $MulticastDelegate<(Pawn: $Nullable<Pawn>) => void>;
        OnHearNoise: $MulticastDelegate<(Instigator: $Nullable<Pawn>, Location: Vector, Volume: number) => void>;
        PeripheralVisionAngle: number;
        PeripheralVisionCosine: number;

        GetPeripheralVisionAngle(): number;

        GetPeripheralVisionCosine(): number;

        HearNoiseDelegate__DelegateSignature(Instigator: $Nullable<Pawn>, Location: Vector, Volume: number): void;

        SeePawnDelegate__DelegateSignature(Pawn: $Nullable<Pawn>): void;

        SetPeripheralVisionAngle(NewPeripheralVisionAngle: number): void;

        SetSensingInterval(NewSensingInterval: number): void;

        SetSensingUpdatesEnabled(bEnabled: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PawnSensingComponent;

        static Load(InName: string): PawnSensingComponent;
    }

    export class PEClassMetaData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddAutoCollapseCategory(InCategory: string): void;

        AddAutoExpandCategory(InCategory: string): void;

        AddClassGroup(InGroupName: string): void;

        AddDontAutoCollapseCategory(InCategory: string): void;

        AddHideCategory(InCategory: string): void;

        AddHideFunction(InFunctionName: string): void;

        AddShowCategory(InCategory: string): void;

        AddShowFunction(InFunctionName: string): void;

        AddShowSubCategory(InCategory: string): void;

        AddSparseDataType(InType: string): void;

        SetClassFlags(InFlags: number, bInPlaceable: boolean): void;

        SetClassWithIn(InClassName: string): void;

        SetConfig(InConfigName: string): void;

        SetMetaData(InName: string, InValue: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PEClassMetaData;

        static Load(InName: string): PEClassMetaData;
    }

    export class PEGraphPinType {
        constructor();
        constructor(PinCategory: string, PinSubCategoryObject: Object, PinContainerType: number, bIsReference: boolean);

        PinCategory: string;
        PinSubCategoryObject: Object;
        PinContainerType: number;
        bIsReference: boolean;

        static StaticClass(): Class;
    }

    export class PEGraphTerminalType {
        constructor();
        constructor(PinCategory: string, PinSubCategoryObject: Object);

        PinCategory: string;
        PinSubCategoryObject: Object;

        static StaticClass(): Class;
    }

    export class PEParamMetaData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetMetaData(InName: string, InValue: string): void;

        SetParamFlags(InHighBits: number, InLowBits: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PEParamMetaData;

        static Load(InName: string): PEParamMetaData;
    }

    export class PEPropertyMetaData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetMetaData(InName: string, InValue: string): void;

        SetPropertyFlags(InHighBits: number, InLowBits: number): void;

        SetRepCallbackName(InName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PEPropertyMetaData;

        static Load(InName: string): PEPropertyMetaData;
    }

    export class PEFunctionMetaData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetCppImplName(InName: string): void;

        SetCppValidationImplName(InName: string): void;

        SetEndpointName(InEndpointName: string): void;

        SetForceBlueprintImpure(bInForceBlueprintImpure: boolean): void;

        SetFunctionExportFlags(InFlags: number): void;

        SetFunctionFlags(InHighBits: number, InLowBits: number): void;

        SetIsSealedEvent(bInSealedEvent: boolean): void;

        SetMetaData(InName: string, InValue: string): void;

        SetRPCId(InRPCId: number): void;

        SetRPCResponseId(InRPCResponseId: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PEFunctionMetaData;

        static Load(InName: string): PEFunctionMetaData;
    }

    export class PEBlueprintAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GeneratedClass: Class;
        Blueprint: Blueprint;
        Package: Package;
        NeedSave: boolean;
        HasConstructor: boolean;

        AddFunction(InName: string, IsVoid: boolean, InGraphPinType: PEGraphPinType, InPinValueType: PEGraphTerminalType, InSetFlags: number, InClearFlags: number): void;

        AddFunctionWithMetaData(InName: string, IsVoid: boolean, InGraphPinType: PEGraphPinType, InPinValueType: PEGraphTerminalType, InSetFlags: number, InClearFlags: number, InMetaData: $Nullable<PEFunctionMetaData>): void;

        AddMemberVariable(NewVarName: string, InGraphPinType: PEGraphPinType, InPinValueType: PEGraphTerminalType, InLFlags: number, InHFlags: number, InLifetimeCondition: number): void;

        AddMemberVariableWithMetaData(InNewVarName: string, InGraphPinType: PEGraphPinType, InPinValueType: PEGraphTerminalType, InLFlags: number, InHFLags: number, InLifetimeCondition: number, InMetaData: $Nullable<PEPropertyMetaData>): void;

        AddParameter(InParameterName: string, InGraphPinType: PEGraphPinType, InPinValueType: PEGraphTerminalType): void;

        AddParameterWithMetaData(InParameterName: string, InGraphPinType: PEGraphPinType, InPinValueType: PEGraphTerminalType, InMetaData: $Nullable<PEParamMetaData>): void;

        ClearParameter(): void;

        LoadOrCreate(InName: string, InPath: string, ParentClass: $Nullable<Class>, InSetFlags: number, InClearFlags: number): boolean;

        LoadOrCreateWithMetaData(InName: string, InPath: string, InParentClass: $Nullable<Class>, InSetFlags: number, InClearFlags: number, InMetaData: $Nullable<PEClassMetaData>): boolean;

        RemoveNotExistedFunction(): void;

        RemoveNotExistedMemberVariable(): void;

        Save(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PEBlueprintAsset;

        static Load(InName: string): PEBlueprintAsset;
    }

    export class PEDirectoryWatcher extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnChanged: $MulticastDelegate<(Added: TArray<string>, Modified: TArray<string>, Removed: TArray<string>) => void>;

        UnWatch(): void;

        Watch(InDirectory: string): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PEDirectoryWatcher;

        static Load(InName: string): PEDirectoryWatcher;
    }

    export enum EAnimationViewportCameraFollowMode { None, Bounds, Bone, EAnimationViewportCameraFollowMode_MAX }

    export class ViewportConfigOptions {
        constructor();
        constructor(ViewModeIndex: EViewModeIndex, ViewFOV: number, CameraSpeedSetting: number, CameraSpeedScalar: number, CameraFollowMode: EAnimationViewportCameraFollowMode, CameraFollowBoneName: string);

        ViewModeIndex: EViewModeIndex;
        ViewFOV: number;
        CameraSpeedSetting: number;
        CameraSpeedScalar: number;
        CameraFollowMode: EAnimationViewportCameraFollowMode;
        CameraFollowBoneName: string;

        static StaticClass(): Class;
    }

    export class AssetEditorOptions {
        constructor();
        constructor(Context: string, ViewportConfigs: FixSizeArray<ViewportConfigOptions>);

        Context: string;
        ViewportConfigs: FixSizeArray<ViewportConfigOptions>;

        static StaticClass(): Class;
    }

    export enum EFrameNumberDisplayFormats {
        NonDropFrameTimecode,
        DropFrameTimecode,
        Seconds,
        Frames,
        MAX_Count,
        EFrameNumberDisplayFormats_MAX
    }

    export class PersonaOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoAlignFloorToMesh: boolean;
        bShowGrid: boolean;
        bHighlightOrigin: boolean;
        bMuteAudio: boolean;
        bUseAudioAttenuation: boolean;
        ShowMeshStats: number;
        DefaultLocalAxesSelection: number;
        DefaultBoneDrawSelection: number;
        SectionTimingNodeColor: LinearColor;
        NotifyTimingNodeColor: LinearColor;
        BranchingPointTimingNodeColor: LinearColor;
        bUseInlineSocketEditor: boolean;
        bFlattenSkeletonHierarchyWhenFiltering: boolean;
        bHideParentsWhenFiltering: boolean;
        bAllowPreviewMeshCollectionsToSelectFromDifferentSkeletons: boolean;
        bAllowPreviewMeshCollectionsToUseCustomAnimBP: boolean;
        bAllowMeshSectionSelection: boolean;
        NumFolderFiltersInAssetBrowser: number;
        AssetEditorOptions: TArray<AssetEditorOptions>;
        CurveEditorSnapInterval: number;
        TimelineScrubSnapValue: number;
        TimelineDisplayFormat: EFrameNumberDisplayFormats;
        bTimelineDisplayPercentage: boolean;
        bTimelineDisplayFormatSecondary: boolean;
        bTimelineDisplayCurveKeys: boolean;
        TimelineEnabledSnaps: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PersonaOptions;

        static Load(InName: string): PersonaOptions;
    }

    export class PersonaPreviewSceneController extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneController;

        static Load(InName: string): PersonaPreviewSceneController;
    }

    export class PersonaPreviewSceneAnimationController extends PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Animation: TSoftObjectPtr<AnimationAsset>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneAnimationController;

        static Load(InName: string): PersonaPreviewSceneAnimationController;
    }

    export class PersonaPreviewSceneDefaultController extends PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneDefaultController;

        static Load(InName: string): PersonaPreviewSceneDefaultController;
    }

    export class PreviewMeshCollectionEntry {
        constructor();
        constructor(SkeletalMesh: TSoftObjectPtr<SkeletalMesh>);

        SkeletalMesh: TSoftObjectPtr<SkeletalMesh>;

        static StaticClass(): Class;
    }

    export class PreviewMeshCollection extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Skeleton: Skeleton;
        SkeletalMeshes: TArray<PreviewMeshCollectionEntry>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PreviewMeshCollection;

        static Load(InName: string): PreviewMeshCollection;
    }

    export class PersonaPreviewSceneDescription extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PreviewController: Class;
        PreviewControllerInstance: PersonaPreviewSceneController;
        PreviewControllerInstances: TArray<PersonaPreviewSceneController>;
        PreviewMesh: TSoftObjectPtr<SkeletalMesh>;
        PreviewAnimationBlueprint: TSoftObjectPtr<AnimBlueprint>;
        ApplicationMethod: EPreviewAnimationBlueprintApplicationMethod;
        LinkedAnimGraphTag: string;
        AdditionalMeshes: TSoftObjectPtr<DataAsset>;
        DefaultAdditionalMeshes: PreviewMeshCollection;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneDescription;

        static Load(InName: string): PersonaPreviewSceneDescription;
    }

    export class PersonaPreviewSceneRefPoseController extends PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bResetBoneTransforms: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneRefPoseController;

        static Load(InName: string): PersonaPreviewSceneRefPoseController;
    }

    export class PhasedAutomationActorBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnFunctionalTestingBegin(): void;

        OnFunctionalTestingComplete(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhasedAutomationActorBase;

        static Load(InName: string): PhasedAutomationActorBase;
    }

    export class PhysicalAnimationComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StrengthMultiplyer: number;
        SkeletalMeshComponent: SkeletalMeshComponent;

        ApplyPhysicalAnimationProfileBelow(BodyName: string, ProfileName: string, bIncludeSelf?: boolean /* = true */, bClearNotFound?: boolean /* = false */): void;

        ApplyPhysicalAnimationSettings(BodyName: string, PhysicalAnimationData: PhysicalAnimationData): void;

        ApplyPhysicalAnimationSettingsBelow(BodyName: string, PhysicalAnimationData: PhysicalAnimationData, bIncludeSelf?: boolean /* = true */): void;

        GetBodyTargetTransform(BodyName: string): Transform;

        SetSkeletalMeshComponent(InSkeletalMeshComponent: $Nullable<SkeletalMeshComponent>): void;

        SetStrengthMultiplyer(InStrengthMultiplyer: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicalAnimationComponent;

        static Load(InName: string): PhysicalAnimationComponent;
    }

    export class PhysicalMaterialFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicalMaterialClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialFactoryNew;

        static Load(InName: string): PhysicalMaterialFactoryNew;
    }

    export class PhysicalMaterialMaskFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicalMaterialMaskClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialMaskFactory;

        static Load(InName: string): PhysicalMaterialMaskFactory;
    }

    export class PhysicalMaterialMaskThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialMaskThumbnailRenderer;

        static Load(InName: string): PhysicalMaterialMaskThumbnailRenderer;
    }

    export enum EPhysicsAssetEditorRenderMode { Solid, Wireframe, None, EPhysicsAssetEditorRenderMode_MAX }

    export enum EPhysicsAssetEditorConstraintViewMode {
        None,
        AllPositions,
        AllLimits,
        EPhysicsAssetEditorConstraintViewMode_MAX
    }

    export class PhysicsAssetEditorOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicsBlend: number;
        bUpdateJointsFromAnimation: boolean;
        PhysicsUpdateMode: EPhysicsTransformUpdateMode;
        PokePauseTime: number;
        PokeBlendTime: number;
        GravScale: number;
        GravityOverrideZ: number;
        bUseGravityOverride: boolean;
        MaxFPS: number;
        HandleLinearDamping: number;
        HandleLinearStiffness: number;
        HandleAngularDamping: number;
        HandleAngularStiffness: number;
        InterpolationSpeed: number;
        PokeStrength: number;
        bShowConstraintsAsPoints: boolean;
        bRenderOnlySelectedConstraints: boolean;
        ConstraintDrawSize: number;
        MeshViewMode: EPhysicsAssetEditorRenderMode;
        CollisionViewMode: EPhysicsAssetEditorRenderMode;
        ConstraintViewMode: EPhysicsAssetEditorConstraintViewMode;
        SimulationMeshViewMode: EPhysicsAssetEditorRenderMode;
        SimulationCollisionViewMode: EPhysicsAssetEditorRenderMode;
        SimulationConstraintViewMode: EPhysicsAssetEditorConstraintViewMode;
        CollisionOpacity: number;
        bSolidRenderingForSelectedOnly: boolean;
        bHideSimulatedBodies: boolean;
        bHideKinematicBodies: boolean;
        bResetClothWhenSimulating: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsAssetEditorOptions;

        static Load(InName: string): PhysicsAssetEditorOptions;
    }

    export class PhysicsAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsAssetFactory;

        static Load(InName: string): PhysicsAssetFactory;
    }

    export enum EPhysAssetFitGeomType {
        EFG_Box,
        EFG_Sphyl,
        EFG_Sphere,
        EFG_TaperedCapsule,
        EFG_SingleConvexHull,
        EFG_MultiConvexHull,
        EFG_MAX
    }

    export enum EPhysAssetFitVertWeight { EVW_AnyWeight, EVW_DominantWeight, EVW_MAX }

    export class PhysAssetCreateParams {
        constructor();
        constructor(MinBoneSize: number, MinWeldSize: number, GeomType: EPhysAssetFitGeomType, VertWeight: EPhysAssetFitVertWeight, bAutoOrientToBone: boolean, bCreateConstraints: boolean, bWalkPastSmall: boolean, bBodyForAll: boolean, bDisableCollisionsByDefault: boolean, AngularConstraintMode: EAngularConstraintMotion, HullCount: number, MaxHullVerts: number);

        MinBoneSize: number;
        MinWeldSize: number;
        GeomType: EPhysAssetFitGeomType;
        VertWeight: EPhysAssetFitVertWeight;
        bAutoOrientToBone: boolean;
        bCreateConstraints: boolean;
        bWalkPastSmall: boolean;
        bBodyForAll: boolean;
        bDisableCollisionsByDefault: boolean;
        AngularConstraintMode: EAngularConstraintMotion;
        HullCount: number;
        MaxHullVerts: number;

        static StaticClass(): Class;
    }

    export class PhysicsAssetGenerationSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CreateParams: PhysAssetCreateParams;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsAssetGenerationSettings;

        static Load(InName: string): PhysicsAssetGenerationSettings;
    }

    export class PhysicsAssetThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsAssetThumbnailRenderer;

        static Load(InName: string): PhysicsAssetThumbnailRenderer;
    }

    export class RigidBodyBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RigidBodyBase;

        static Load(InName: string): RigidBodyBase;
    }

    export class PhysicsConstraintActor extends RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ConstraintComp: PhysicsConstraintComponent;
        ConstraintActor1: Actor;
        ConstraintActor2: Actor;
        bDisableCollision: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintActor;

        static Load(InName: string): PhysicsConstraintActor;
    }

    export class PhysicsHandleComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GrabbedComponent: PrimitiveComponent;
        bSoftAngularConstraint: boolean;
        bSoftLinearConstraint: boolean;
        bInterpolateTarget: boolean;
        LinearDamping: number;
        LinearStiffness: number;
        AngularDamping: number;
        AngularStiffness: number;
        InterpolationSpeed: number;

        GetGrabbedComponent(): PrimitiveComponent;

        GetTargetLocationAndRotation(TargetLocation: $Ref<Vector>, TargetRotation: $Ref<Rotator>): void;

        GrabComponent(Component: $Nullable<PrimitiveComponent>, InBoneName: string, GrabLocation: Vector, bConstrainRotation: boolean): void;

        GrabComponentAtLocation(Component: $Nullable<PrimitiveComponent>, InBoneName: string, GrabLocation: Vector): void;

        GrabComponentAtLocationWithRotation(Component: $Nullable<PrimitiveComponent>, InBoneName: string, Location: Vector, Rotation: Rotator): void;

        ReleaseComponent(): void;

        SetAngularDamping(NewAngularDamping: number): void;

        SetAngularStiffness(NewAngularStiffness: number): void;

        SetInterpolationSpeed(NewInterpolationSpeed: number): void;

        SetLinearDamping(NewLinearDamping: number): void;

        SetLinearStiffness(NewLinearStiffness: number): void;

        SetTargetLocation(NewLocation: Vector): void;

        SetTargetLocationAndRotation(NewLocation: Vector, NewRotation: Rotator): void;

        SetTargetRotation(NewRotation: Rotator): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsHandleComponent;

        static Load(InName: string): PhysicsHandleComponent;
    }

    export class PhysicsMesh extends CommonMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicsAnimIns: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsMesh;

        static Load(InName: string): PhysicsMesh;
    }

    export class PhysicsSettingsCore extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultGravityZ: number;
        DefaultTerminalVelocity: number;
        DefaultFluidFriction: number;
        SimulateScratchMemorySize: number;
        RagdollAggregateThreshold: number;
        TriangleMeshTriangleMinAreaThreshold: number;
        bEnableShapeSharing: boolean;
        bEnablePCM: boolean;
        bEnableStabilization: boolean;
        bWarnMissingLocks: boolean;
        bEnable2DPhysics: boolean;
        bDefaultHasComplexCollision: boolean;
        BounceThresholdVelocity: number;
        FrictionCombineMode: EFrictionCombineMode;
        RestitutionCombineMode: EFrictionCombineMode;
        MaxAngularVelocity: number;
        MaxDepenetrationVelocity: number;
        ContactOffsetMultiplier: number;
        MinContactOffset: number;
        MaxContactOffset: number;
        bSimulateSkeletalMeshOnDedicatedServer: boolean;
        DefaultShapeComplexity: ECollisionTraceFlag;
        SolverOptions: ChaosSolverConfiguration;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsSettingsCore;

        static Load(InName: string): PhysicsSettingsCore;
    }

    export class RigidBodyErrorCorrection {
        constructor();
        constructor(PingExtrapolation: number, PingLimit: number, ErrorPerLinearDifference: number, ErrorPerAngularDifference: number, MaxRestoredStateError: number, MaxLinearHardSnapDistance: number, PositionLerp: number, AngleLerp: number, LinearVelocityCoefficient: number, AngularVelocityCoefficient: number, ErrorAccumulationSeconds: number, ErrorAccumulationDistanceSq: number, ErrorAccumulationSimilarity: number);

        PingExtrapolation: number;
        PingLimit: number;
        ErrorPerLinearDifference: number;
        ErrorPerAngularDifference: number;
        MaxRestoredStateError: number;
        MaxLinearHardSnapDistance: number;
        PositionLerp: number;
        AngleLerp: number;
        LinearVelocityCoefficient: number;
        AngularVelocityCoefficient: number;
        ErrorAccumulationSeconds: number;
        ErrorAccumulationDistanceSq: number;
        ErrorAccumulationSimilarity: number;

        static StaticClass(): Class;
    }

    export enum ESettingsLockedAxis { None, X, Y, Z, Invalid, ESettingsLockedAxis_MAX }

    export enum ESettingsDOF { Full3D, YZPlane, XZPlane, XYPlane, ESettingsDOF_MAX }

    export class PhysicalSurfaceName {
        constructor();
        constructor(Type: EPhysicalSurface, Name: string);

        Type: EPhysicalSurface;
        Name: string;

        static StaticClass(): Class;
    }

    export enum EChaosThreadingMode { DedicatedThread, TaskGraph, SingleThread, Num, Invalid, EChaosThreadingMode_MAX }

    export enum EChaosSolverTickMode {
        Fixed,
        Variable,
        VariableCapped,
        VariableCappedWithTarget,
        EChaosSolverTickMode_MAX
    }

    export enum EChaosBufferMode { Double, Triple, Num, Invalid, EChaosBufferMode_MAX }

    export class ChaosPhysicsSettings {
        constructor();
        constructor(DefaultThreadingModel: EChaosThreadingMode, DedicatedThreadTickMode: EChaosSolverTickMode, DedicatedThreadBufferMode: EChaosBufferMode);

        DefaultThreadingModel: EChaosThreadingMode;
        DedicatedThreadTickMode: EChaosSolverTickMode;
        DedicatedThreadBufferMode: EChaosBufferMode;

        static StaticClass(): Class;
    }

    export class PhysicsSettings extends PhysicsSettingsCore {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicErrorCorrection: RigidBodyErrorCorrection;
        LockedAxis: ESettingsLockedAxis;
        DefaultDegreesOfFreedom: ESettingsDOF;
        bSuppressFaceRemapTable: boolean;
        bSupportUVFromHitResults: boolean;
        bDisableActiveActors: boolean;
        bDisableKinematicStaticPairs: boolean;
        bDisableKinematicKinematicPairs: boolean;
        bDisableCCD: boolean;
        bEnableEnhancedDeterminism: boolean;
        AnimPhysicsMinDeltaTime: number;
        bSimulateAnimPhysicsAfterReset: boolean;
        MaxPhysicsDeltaTime: number;
        bSubstepping: boolean;
        bSubsteppingAsync: boolean;
        MaxSubstepDeltaTime: number;
        MaxSubsteps: number;
        SyncSceneSmoothingFactor: number;
        InitialAverageFrameRate: number;
        PhysXTreeRebuildRate: number;
        PhysicalSurfaces: TArray<PhysicalSurfaceName>;
        DefaultBroadphaseSettings: BroadphaseSettings;
        MinDeltaVelocityForHitEvents: number;
        ChaosSettings: ChaosPhysicsSettings;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsSettings;

        static Load(InName: string): PhysicsSettings;
    }

    export class PhysicsSpringComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpringStiffness: number;
        SpringDamping: number;
        SpringLengthAtRest: number;
        SpringRadius: number;
        SpringChannel: ECollisionChannel;
        bIgnoreSelf: boolean;
        SpringCompression: number;

        GetNormalizedCompressionScalar(): number;

        GetSpringCurrentEndPoint(): Vector;

        GetSpringDirection(): Vector;

        GetSpringRestingPoint(): Vector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsSpringComponent;

        static Load(InName: string): PhysicsSpringComponent;
    }

    export class PhysicsThruster extends RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ThrusterComponent: PhysicsThrusterComponent;
        ArrowComponent: ArrowComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PhysicsThruster;

        static Load(InName: string): PhysicsThruster;
    }

    export enum EPIEPreviewDeviceType { Unset, Android, IOS, TVOS, Switch, MAX }

    export class PIEPreviewDeviceSpecification extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PreviewDeviceType: EPIEPreviewDeviceType;
        GPUFamily: string;
        GLVersion: string;
        VulkanVersion: string;
        AndroidVersion: string;
        DeviceMake: string;
        DeviceModel: string;
        DeviceBuildNumber: string;
        UsingHoudini: boolean;
        Hardware: string;
        Chipset: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PIEPreviewDeviceSpecification;

        static Load(InName: string): PIEPreviewDeviceSpecification;
    }

    export class PIEPreviewSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WindowPosX: number;
        WindowPosY: number;
        WindowScalingFactor: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PIEPreviewSettings;

        static Load(InName: string): PIEPreviewSettings;
    }

    export enum EPinnedCommandListType { Command, CustomWidget, EPinnedCommandListType_MAX }

    export class PinnedCommandListCommand {
        constructor();
        constructor(Name: string, Binding: string, Type: EPinnedCommandListType);

        Name: string;
        Binding: string;
        Type: EPinnedCommandListType;

        static StaticClass(): Class;
    }

    export class PinnedCommandListContext {
        constructor();
        constructor(Name: string, Commands: TArray<PinnedCommandListCommand>);

        Name: string;
        Commands: TArray<PinnedCommandListCommand>;

        static StaticClass(): Class;
    }

    export class PinnedCommandListSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Contexts: TArray<PinnedCommandListContext>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PinnedCommandListSettings;

        static Load(InName: string): PinnedCommandListSettings;
    }

    export class PivotPlaneTranslationGizmoHandleGroup extends AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PivotPlaneTranslationGizmoHandleGroup;

        static Load(InName: string): PivotPlaneTranslationGizmoHandleGroup;
    }

    export class PivotRotationGizmoHandleGroup extends AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootFullRotationHandleComponent: SceneComponent;
        FullRotationHandleMeshComponent: GizmoHandleMeshComponent;
        StartRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
        RootStartRotationIdicatorComponent: SceneComponent;
        DeltaRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
        RootDeltaRotationIndicatorComponent: SceneComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PivotRotationGizmoHandleGroup;

        static Load(InName: string): PivotRotationGizmoHandleGroup;
    }

    export class PivotScaleGizmoHandleGroup extends AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PivotScaleGizmoHandleGroup;

        static Load(InName: string): PivotScaleGizmoHandleGroup;
    }

    export class UniformScaleGizmoHandleGroup extends GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UniformScaleGizmoHandleGroup;

        static Load(InName: string): UniformScaleGizmoHandleGroup;
    }

    export class PivotTranslationGizmoHandleGroup extends AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PivotTranslationGizmoHandleGroup;

        static Load(InName: string): PivotTranslationGizmoHandleGroup;
    }

    export class StretchGizmoHandleGroup extends GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StretchGizmoHandleGroup;

        static Load(InName: string): StretchGizmoHandleGroup;
    }

    export class PivotTransformGizmo extends BaseTransformGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
        TranslationGizmoHandleGroup: PivotTranslationGizmoHandleGroup;
        ScaleGizmoHandleGroup: PivotScaleGizmoHandleGroup;
        PlaneTranslationGizmoHandleGroup: PivotPlaneTranslationGizmoHandleGroup;
        RotationGizmoHandleGroup: PivotRotationGizmoHandleGroup;
        StretchGizmoHandleGroup: StretchGizmoHandleGroup;
        LastDraggingHandle: ActorComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PivotTransformGizmo;

        static Load(InName: string): PivotTransformGizmo;
    }

    export class PixelInspectorView extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FinalColor: LinearColor;
        SceneColor: LinearColor;
        PreExposure: number;
        Luminance: number;
        HdrColor: LinearColor;
        Normal: Vector;
        PerObjectGBufferData: number;
        Metallic: number;
        Specular: number;
        Roughness: number;
        MaterialShadingModel: EMaterialShadingModel;
        SelectiveOutputMask: number;
        BaseColor: LinearColor;
        IndirectIrradiance: number;
        AmbientOcclusion: number;
        SubSurfaceColor: LinearColor;
        SubsurfaceProfile: Vector;
        Opacity: number;
        ClearCoat: number;
        ClearCoatRoughness: number;
        WorldNormal: Vector;
        BackLit: number;
        Cloth: number;
        EyeTangent: Vector;
        IrisMask: number;
        IrisDistance: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PixelInspectorView;

        static Load(InName: string): PixelInspectorView;
    }

    export class PkgInfoCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PkgInfoCommandlet;

        static Load(InName: string): PkgInfoCommandlet;
    }

    export class PlacedEditorUtilityBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HelpText: string;

        ClearActorSelectionSet(): void;

        GetActorReference(PathToActor: string): Actor;

        GetLevelViewportCameraInfo(CameraLocation: $Ref<Vector>, CameraRotation: $Ref<Rotator>): boolean;

        GetSelectionSet(): TArray<Actor>;

        SelectNothing(): void;

        SetActorSelectionState(Actor: $Nullable<Actor>, bShouldBeSelected: boolean): void;

        SetLevelViewportCameraInfo(CameraLocation: Vector, CameraRotation: Rotator): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlacedEditorUtilityBase;

        static Load(InName: string): PlacedEditorUtilityBase;
    }

    export class PlanarReflectionComponent extends SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PreviewBox: BoxComponent;
        NormalDistortionStrength: number;
        PrefilterRoughness: number;
        PrefilterRoughnessDistance: number;
        ScreenPercentage: number;
        ExtraFOV: number;
        DistanceFromPlaneFadeStart: number;
        DistanceFromPlaneFadeEnd: number;
        DistanceFromPlaneFadeoutStart: number;
        DistanceFromPlaneFadeoutEnd: number;
        AngleFromPlaneFadeStart: number;
        AngleFromPlaneFadeEnd: number;
        bShowPreviewPlane: boolean;
        bRenderSceneTwoSided: boolean;
        CaptureMaterial: Material;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlanarReflectionComponent;

        static Load(InName: string): PlanarReflectionComponent;
    }

    export class PlanarReflection extends SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlanarReflectionComponent: PlanarReflectionComponent;
        SpriteComponent: BillboardComponent;
        bShowPreviewPlane: boolean;

        OnInterpToggle(bEnable: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlanarReflection;

        static Load(InName: string): PlanarReflection;
    }

    export class PlaneFalloff extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Distance: number;
        Position: Vector;
        Normal: Vector;
        Falloff: EFieldFalloffType;

        SetPlaneFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Distance: number, Position: Vector, Normal: Vector, Falloff: EFieldFalloffType): PlaneFalloff;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlaneFalloff;

        static Load(InName: string): PlaneFalloff;
    }

    export class PlanePositionGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AxisSource: GizmoAxisSource;
        ParameterSource: GizmoVec2ParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bEnableSignedAxis: boolean;
        bFlipX: boolean;
        bFlipY: boolean;
        bInInteraction: boolean;
        InteractionOrigin: Vector;
        InteractionNormal: Vector;
        InteractionAxisX: Vector;
        InteractionAxisY: Vector;
        InteractionStartPoint: Vector;
        InteractionCurPoint: Vector;
        InteractionStartParameter: Vector2D;
        InteractionCurParameter: Vector2D;
        ParameterSigns: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlanePositionGizmo;

        static Load(InName: string): PlanePositionGizmo;
    }

    export class PlanePositionGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlanePositionGizmoBuilder;

        static Load(InName: string): PlanePositionGizmoBuilder;
    }

    export class PlaneReflectionCapture extends ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlaneReflectionCapture;

        static Load(InName: string): PlaneReflectionCapture;
    }

    export class PlaneReflectionCaptureComponent extends ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InfluenceRadiusScale: number;
        PreviewInfluenceRadius: DrawSphereComponent;
        PreviewCaptureBox: BoxComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlaneReflectionCaptureComponent;

        static Load(InName: string): PlaneReflectionCaptureComponent;
    }

    export class PlaneTranslationDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlaneTranslationDragOperation;

        static Load(InName: string): PlaneTranslationDragOperation;
    }

    export class PlatformEventsComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlatformChangedToLaptopModeDelegate: $MulticastDelegate<() => void>;
        PlatformChangedToTabletModeDelegate: $MulticastDelegate<() => void>;

        IsInLaptopMode(): boolean;

        IsInTabletMode(): boolean;

        PlatformEventDelegate__DelegateSignature(): void;

        SupportsConvertibleLaptops(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlatformEventsComponent;

        static Load(InName: string): PlatformEventsComponent;
    }

    export enum EApplicationState { Unknown, Inactive, Background, Active, EApplicationState_MAX }

    export class PlatformGameInstance extends GameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ApplicationWillDeactivateDelegate: $MulticastDelegate<() => void>;
        ApplicationHasReactivatedDelegate: $MulticastDelegate<() => void>;
        ApplicationWillEnterBackgroundDelegate: $MulticastDelegate<() => void>;
        ApplicationHasEnteredForegroundDelegate: $MulticastDelegate<() => void>;
        ApplicationWillTerminateDelegate: $MulticastDelegate<() => void>;
        ApplicationShouldUnloadResourcesDelegate: $MulticastDelegate<() => void>;
        ApplicationReceivedStartupArgumentsDelegate: $MulticastDelegate<(StartupArguments: TArray<string>) => void>;
        ApplicationRegisteredForRemoteNotificationsDelegate: $MulticastDelegate<(inArray: TArray<number>) => void>;
        ApplicationRegisteredForUserNotificationsDelegate: $MulticastDelegate<(inInt: number) => void>;
        ApplicationFailedToRegisterForRemoteNotificationsDelegate: $MulticastDelegate<(inString: string) => void>;
        ApplicationReceivedRemoteNotificationDelegate: $MulticastDelegate<(inString: string, inAppState: EApplicationState) => void>;
        ApplicationReceivedLocalNotificationDelegate: $MulticastDelegate<(inString: string, inInt: number, inAppState: EApplicationState) => void>;
        ApplicationReceivedScreenOrientationChangedNotificationDelegate: $MulticastDelegate<(inScreenOrientation: EScreenOrientation) => void>;

        PlatformDelegate__DelegateSignature(): void;

        PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature(inString: string): void;

        PlatformReceivedLocalNotificationDelegate__DelegateSignature(inString: string, inInt: number, inAppState: EApplicationState): void;

        PlatformReceivedRemoteNotificationDelegate__DelegateSignature(inString: string, inAppState: EApplicationState): void;

        PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature(inArray: TArray<number>): void;

        PlatformRegisteredForUserNotificationsDelegate__DelegateSignature(inInt: number): void;

        PlatformScreenOrientationChangedDelegate__DelegateSignature(inScreenOrientation: EScreenOrientation): void;

        PlatformStartupArgumentsDelegate__DelegateSignature(StartupArguments: TArray<string>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlatformGameInstance;

        static Load(InName: string): PlatformGameInstance;
    }

    export class PlatformInterfaceWebResponse extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OriginalURL: string;
        ResponseCode: number;
        Tag: number;
        StringResponse: string;
        BinaryResponse: TArray<number>;

        GetHeader(HeaderIndex: number, Header: $Ref<string>, Value: $Ref<string>): void;

        GetHeaderValue(HeaderName: string): string;

        GetNumHeaders(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlatformInterfaceWebResponse;

        static Load(InName: string): PlatformInterfaceWebResponse;
    }

    export class PlatformMediaSource extends MediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PlatformMediaSources: TMap<string, MediaSource>;
        MediaSource: MediaSource;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlatformMediaSource;

        static Load(InName: string): PlatformMediaSource;
    }

    export class PlayerStartPIE extends PlayerStart {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlayerStartPIE;

        static Load(InName: string): PlayerStartPIE;
    }

    export class BranchingPointNotifyPayload {
        constructor();

        static StaticClass(): Class;
    }

    export class PlayMontageCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnCompleted: $MulticastDelegate<(NotifyName: string) => void>;
        OnBlendOut: $MulticastDelegate<(NotifyName: string) => void>;
        OnInterrupted: $MulticastDelegate<(NotifyName: string) => void>;
        OnNotifyBegin: $MulticastDelegate<(NotifyName: string) => void>;
        OnNotifyEnd: $MulticastDelegate<(NotifyName: string) => void>;

        OnMontageBlendingOut(Montage: $Nullable<AnimMontage>, bInterrupted: boolean): void;

        OnMontageEnded(Montage: $Nullable<AnimMontage>, bInterrupted: boolean): void;

        OnNotifyBeginReceived(NotifyName: string, BranchingPointNotifyPayload: BranchingPointNotifyPayload): void;

        OnNotifyEndReceived(NotifyName: string, BranchingPointNotifyPayload: BranchingPointNotifyPayload): void;

        static CreateProxyObjectForPlayMontage(InSkeletalMeshComponent: $Nullable<SkeletalMeshComponent>, MontageToPlay: $Nullable<AnimMontage>, PlayRate?: number /* = 1.000000 */, StartingPosition?: number /* = 0.000000 */, StartingSection?: string /* = "None" */): PlayMontageCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PlayMontageCallbackProxy;

        static Load(InName: string): PlayMontageCallbackProxy;
    }

    export class PluginClassTemplate extends ClassTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PluginName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PluginClassTemplate;

        static Load(InName: string): PluginClassTemplate;
    }

    export class PluginCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PluginCommandlet;

        static Load(InName: string): PluginCommandlet;
    }

    export class PluginMetadataObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Version: number;
        VersionName: string;
        FriendlyName: string;
        Description: string;
        Category: string;
        CreatedBy: string;
        CreatedByURL: string;
        DocsURL: string;
        MarketplaceURL: string;
        SupportURL: string;
        bCanContainContent: boolean;
        bIsBetaVersion: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PluginMetadataObject;

        static Load(InName: string): PluginMetadataObject;
    }

    export class PointLight extends Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PointLightComponent: PointLightComponent;

        SetLightFalloffExponent(NewLightFalloffExponent: number): void;

        SetRadius(NewRadius: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PointLight;

        static Load(InName: string): PointLight;
    }

    export class PolysExporterOBJ extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PolysExporterOBJ;

        static Load(InName: string): PolysExporterOBJ;
    }

    export class PolysExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PolysExporterT3D;

        static Load(InName: string): PolysExporterT3D;
    }

    export class PolysFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PolysFactory;

        static Load(InName: string): PolysFactory;
    }

    export class PopulateDialogueWaveFromCharacterSheetCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PopulateDialogueWaveFromCharacterSheetCommandlet;

        static Load(InName: string): PopulateDialogueWaveFromCharacterSheetCommandlet;
    }

    export enum EBoneSpaces { WorldSpace, ComponentSpace, EBoneSpaces_MAX }

    export class PoseableMeshComponent extends SkinnedMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CopyPoseFromSkeletalComponent(InComponentToCopy: $Nullable<SkeletalMeshComponent>): void;

        GetBoneLocationByName(BoneName: string, BoneSpace: EBoneSpaces): Vector;

        GetBoneRotationByName(BoneName: string, BoneSpace: EBoneSpaces): Rotator;

        GetBoneScaleByName(BoneName: string, BoneSpace: EBoneSpaces): Vector;

        GetBoneTransformByName(BoneName: string, BoneSpace: EBoneSpaces): Transform;

        ResetBoneTransformByName(BoneName: string): void;

        SetBoneLocationByName(BoneName: string, InLocation: Vector, BoneSpace: EBoneSpaces): void;

        SetBoneRotationByName(BoneName: string, InRotation: Rotator, BoneSpace: EBoneSpaces): void;

        SetBoneScaleByName(BoneName: string, InScale3D: Vector, BoneSpace: EBoneSpaces): void;

        SetBoneTransformByName(BoneName: string, InTransform: Transform, BoneSpace: EBoneSpaces): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PoseableMeshComponent;

        static Load(InName: string): PoseableMeshComponent;
    }

    export class PoseAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SourceAnimation: AnimSequence;
        PoseNames: TArray<string>;
        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PoseAssetFactory;

        static Load(InName: string): PoseAssetFactory;
    }

    export class PoseMesh extends CombMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PoseMesh;

        static Load(InName: string): PoseMesh;
    }

    export class PrecomputedVisibilityOverrideVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OverrideVisibleActors: TArray<Actor>;
        OverrideInvisibleActors: TArray<Actor>;
        OverrideInvisibleLevels: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PrecomputedVisibilityOverrideVolume;

        static Load(InName: string): PrecomputedVisibilityOverrideVolume;
    }

    export class PrecomputedVisibilityVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PrecomputedVisibilityVolume;

        static Load(InName: string): PrecomputedVisibilityVolume;
    }

    export class PreviewCollectionInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PreviewCollectionInterface;

        static Load(InName: string): PreviewCollectionInterface;
    }

    export class PreviewMaterial extends Material {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PreviewMaterial;

        static Load(InName: string): PreviewMaterial;
    }

    export class PreviewMeshCollectionFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CurrentSkeleton: TWeakObjectPtr<Skeleton>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PreviewMeshCollectionFactory;

        static Load(InName: string): PreviewMeshCollectionFactory;
    }

    export class AssetBundleEntry {
        constructor();
        constructor(BundleScope: PrimaryAssetId, BundleName: string, BundleAssets: TArray<SoftObjectPath>);

        BundleScope: PrimaryAssetId;
        BundleName: string;
        BundleAssets: TArray<SoftObjectPath>;

        static StaticClass(): Class;
    }

    export class AssetBundleData {
        constructor();
        constructor(Bundles: TArray<AssetBundleEntry>);

        Bundles: TArray<AssetBundleEntry>;

        static StaticClass(): Class;
    }

    export class PrimaryDataAsset extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AssetBundleData: AssetBundleData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PrimaryDataAsset;

        static Load(InName: string): PrimaryDataAsset;
    }

    export class CollectionReference {
        constructor();
        constructor(CollectionName: string);

        CollectionName: string;

        static StaticClass(): Class;
    }

    export class PrimaryAssetLabel extends PrimaryDataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Rules: PrimaryAssetRules;
        bLabelAssetsInMyDirectory: boolean;
        bIsRuntimeLabel: boolean;
        ExplicitAssets: TArray<TSoftObjectPtr<Object>>;
        ExplicitBlueprints: TArray<TSoftClassPtr<Object>>;
        AssetCollection: CollectionReference;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PrimaryAssetLabel;

        static Load(InName: string): PrimaryAssetLabel;
    }

    export class PrimitiveStats extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Object: TWeakObjectPtr<Object>;
        Actors: TArray<TWeakObjectPtr<Actor>>;
        Type: string;
        Count: number;
        Sections: number;
        HWInstances: number;
        InstSections: number;
        Triangles: number;
        InstTriangles: number;
        ResourceSize: number;
        VertexColorMem: number;
        InstVertexColorMem: number;
        LightsLM: number;
        LightsOther: number;
        LightsTotal: number;
        ObjLightCost: number;
        LightMapData: number;
        LMSMResolution: number;
        RadiusMin: number;
        RadiusMax: number;
        RadiusAvg: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PrimitiveStats;

        static Load(InName: string): PrimitiveStats;
    }

    export class FoliageTypeObject {
        constructor();
        constructor(FoliageTypeObject: Object, TypeInstance: FoliageType, bIsAsset: boolean, Type: Class);

        FoliageTypeObject: Object;
        TypeInstance: FoliageType;
        bIsAsset: boolean;
        Type: Class;

        static StaticClass(): Class;
    }

    export class ProceduralFoliageSpawner extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RandomSeed: number;
        TileSize: number;
        NumUniqueTiles: number;
        MinimumQuadTreeSize: number;
        FoliageTypes: TArray<FoliageTypeObject>;

        Simulate(NumSteps?: number /* = -1 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageSpawner;

        static Load(InName: string): ProceduralFoliageSpawner;
    }

    export class ProceduralFoliageComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FoliageSpawner: ProceduralFoliageSpawner;
        TileOverlap: number;
        bAllowLandscape: boolean;
        bAllowBSP: boolean;
        bAllowStaticMesh: boolean;
        bAllowTranslucent: boolean;
        bAllowFoliage: boolean;
        bShowDebugTiles: boolean;
        SpawningVolume: Volume;
        ProceduralGuid: Guid;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageComponent;

        static Load(InName: string): ProceduralFoliageComponent;
    }

    export class ProceduralFoliageVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProceduralComponent: ProceduralFoliageComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageVolume;

        static Load(InName: string): ProceduralFoliageVolume;
    }

    export class ProceduralFoliageBlockingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProceduralFoliageVolume: ProceduralFoliageVolume;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageBlockingVolume;

        static Load(InName: string): ProceduralFoliageBlockingVolume;
    }

    export class ProceduralFoliageSpawnerFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageSpawnerFactory;

        static Load(InName: string): ProceduralFoliageSpawnerFactory;
    }

    export class ProceduralFoliageInstance {
        constructor();
        constructor(Rotation: Quat, Location: Vector, Age: number, Normal: Vector, Scale: number, Type: FoliageType);

        Rotation: Quat;
        Location: Vector;
        Age: number;
        Normal: Vector;
        Scale: number;
        Type: FoliageType;

        static StaticClass(): Class;
    }

    export class ProceduralFoliageTile extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FoliageSpawner: ProceduralFoliageSpawner;
        InstancesArray: TArray<ProceduralFoliageInstance>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageTile;

        static Load(InName: string): ProceduralFoliageTile;
    }

    export class ProgressBarStyle extends SlateWidgetStyle {
        constructor();
        constructor(BackgroundImage: SlateBrush, FillImage: SlateBrush, MarqueeImage: SlateBrush);

        BackgroundImage: SlateBrush;
        FillImage: SlateBrush;
        MarqueeImage: SlateBrush;

        static StaticClass(): Class;
    }

    export class ProgressBar extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetStyle: ProgressBarStyle;
        Style: SlateWidgetStyleAsset;
        BackgroundImage: SlateBrushAsset;
        FillImage: SlateBrushAsset;
        MarqueeImage: SlateBrushAsset;
        Percent: number;
        BarFillType: EProgressBarFillType;
        bIsMarquee: boolean;
        BorderPadding: Vector2D;
        PercentDelegate: $Delegate<() => number>;
        FillColorAndOpacity: LinearColor;
        FillColorAndOpacityDelegate: $Delegate<() => LinearColor>;

        SetFillColorAndOpacity(InColor: LinearColor): void;

        SetIsMarquee(InbIsMarquee: boolean): void;

        SetPercent(InPercent: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProgressBar;

        static Load(InName: string): ProgressBar;
    }

    export class ProgressWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProgressBarStyle: ProgressBarStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProgressWidgetStyle;

        static Load(InName: string): ProgressWidgetStyle;
    }

    export enum EProjectPackagingBuild {
        Always,
        Never,
        IfProjectHasCode,
        IfEditorWasBuiltLocally,
        EProjectPackagingBuild_MAX
    }

    export enum EProjectPackagingBuildConfigurations {
        PPBC_Debug,
        PPBC_DebugGame,
        PPBC_Development,
        PPBC_Test,
        PPBC_Shipping,
        PPBC_MAX
    }

    export enum EProjectPackagingBlueprintNativizationMethod {
        Disabled,
        Inclusive,
        Exclusive,
        EProjectPackagingBlueprintNativizationMethod_MAX
    }

    export enum EProjectPackagingInternationalizationPresets {
        English,
        EFIGS,
        EFIGSCJK,
        CJK,
        All,
        EProjectPackagingInternationalizationPresets_MAX
    }

    export class ProjectPackagingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Build: EProjectPackagingBuild;
        BuildConfiguration: EProjectPackagingBuildConfigurations;
        BuildTarget: string;
        StagingDirectory: DirectoryPath;
        FullRebuild: boolean;
        ForDistribution: boolean;
        IncludeDebugFiles: boolean;
        BlueprintNativizationMethod: EProjectPackagingBlueprintNativizationMethod;
        NativizeBlueprintAssets: TArray<FilePath>;
        bIncludeNativizedAssetsInProjectGeneration: boolean;
        bExcludeMonolithicEngineHeadersInNativizedCode: boolean;
        UsePakFile: boolean;
        bUseIoStore: boolean;
        bGenerateChunks: boolean;
        bGenerateNoChunks: boolean;
        bChunkHardReferencesOnly: boolean;
        bForceOneChunkPerFile: boolean;
        MaxChunkSize: bigint;
        bBuildHttpChunkInstallData: boolean;
        HttpChunkInstallDataDirectory: DirectoryPath;
        PakFileCompressionFormats: string;
        PakFileAdditionalCompressionOptions: string;
        HttpChunkInstallDataVersion: string;
        IncludePrerequisites: boolean;
        IncludeAppLocalPrerequisites: boolean;
        bShareMaterialShaderCode: boolean;
        bDeterministicShaderCodeOrder: boolean;
        bSharedMaterialNativeLibraries: boolean;
        ApplocalPrerequisitesDirectory: DirectoryPath;
        IncludeCrashReporter: boolean;
        InternationalizationPreset: EProjectPackagingInternationalizationPresets;
        CulturesToStage: TArray<string>;
        LocalizationTargetsToChunk: TArray<string>;
        LocalizationTargetCatchAllChunkId: number;
        bCookAll: boolean;
        bCookMapsOnly: boolean;
        bCompressed: boolean;
        bEncryptIniFiles: boolean;
        bEncryptPakIndex: boolean;
        GenerateEarlyDownloaderPakFile: boolean;
        bSkipEditorContent: boolean;
        bSkipMovies: boolean;
        UFSMovies: TArray<string>;
        NonUFSMovies: TArray<string>;
        CompressedChunkWildcard: TArray<string>;
        IniKeyBlacklist: TArray<string>;
        IniSectionBlacklist: TArray<string>;
        EarlyDownloaderPakFileFiles: TArray<string>;
        MapsToCook: TArray<FilePath>;
        DirectoriesToAlwaysCook: TArray<DirectoryPath>;
        DirectoriesToNeverCook: TArray<DirectoryPath>;
        TestDirectoriesToNotSearch: TArray<DirectoryPath>;
        DirectoriesToAlwaysStageAsUFS: TArray<DirectoryPath>;
        DirectoriesToAlwaysStageAsNonUFS: TArray<DirectoryPath>;
        DirectoriesToAlwaysStageAsUFSServer: TArray<DirectoryPath>;
        DirectoriesToAlwaysStageAsNonUFSServer: TArray<DirectoryPath>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProjectPackagingSettings;

        static Load(InName: string): ProjectPackagingSettings;
    }

    export class PropertyAccess extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyAccess;

        static Load(InName: string): PropertyAccess;
    }

    export class PropertyEditorTestInstancedObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Number: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyEditorTestInstancedObject;

        static Load(InName: string): PropertyEditorTestInstancedObject;
    }

    export enum PropertyEditorTestEnum {
        PropertyEditorTest_Enum1,
        PropertyEditorTest_Enum2,
        PropertyEditorTest_Enum3,
        PropertyEditorTest_Enum4,
        PropertyEditorTest_Enum5,
        PropertyEditorTest_Enum6,
        PropertyEditorTest_MAX
    }

    export enum EditColor { Red, Orange, Yellow, Green, Blue, Indigo, Violet, Pink, Magenta, Cyan, EditColor_MAX }

    export class PropertyEditorTestSubStruct {
        constructor();
        constructor(FirstProperty: number, SecondProperty: number, CustomizedStructInsideUncustomizedStruct: LinearColor, CustomizedStructInsideUncustomizedStruct2: SoftObjectPath);

        FirstProperty: number;
        SecondProperty: number;
        CustomizedStructInsideUncustomizedStruct: LinearColor;
        CustomizedStructInsideUncustomizedStruct2: SoftObjectPath;

        static StaticClass(): Class;
    }

    export class PropertyEditorTestBasicStruct {
        constructor();
        constructor(IntPropertyInsideAStruct: number, FloatPropertyInsideAStruct: number, ObjectPropertyInsideAStruct: Object, InnerStruct: PropertyEditorTestSubStruct);

        IntPropertyInsideAStruct: number;
        FloatPropertyInsideAStruct: number;
        ObjectPropertyInsideAStruct: Object;
        InnerStruct: PropertyEditorTestSubStruct;

        static StaticClass(): Class;
    }

    export class PropertyEditorTestInstancedStruct {
        constructor();
        constructor(Object: PropertyEditorTestInstancedObject);

        Object: PropertyEditorTestInstancedObject;

        static StaticClass(): Class;
    }

    export class PropertyEditTestTextStruct {
        constructor();
        constructor(NormalProperty: string);

        NormalProperty: string;

        static StaticClass(): Class;
    }

    export class PropertyEditorTestInlineEditCondition {
        constructor();
        constructor(InlineEditCondition: boolean, HasInlineEditCondition: number);

        InlineEditCondition: boolean;
        HasInlineEditCondition: number;

        static StaticClass(): Class;
    }

    export class PropertyEditorTestObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Int8Property: number;
        Int16Property: number;
        Int32Property: number;
        Int64Property: bigint;
        ByteProperty: number;
        UnsignedInt16Property: number;
        UnsignedInt32Property: number;
        UnsignedInt64Property: bigint;
        FloatProperty: number;
        DoubleProperty: number;
        NameProperty: string;
        BoolProperty: boolean;
        StringProperty: string;
        TextProperty: string;
        IntPointProperty: IntPoint;
        Vector3Property: Vector;
        Vector2Property: Vector2D;
        Vector4Property: Vector4;
        RotatorProperty: Rotator;
        ObjectProperty: Object;
        LinearColorProperty: LinearColor;
        ColorProperty: Color;
        enumByteProperty: PropertyEditorTestEnum;
        enumProperty: EditColor;
        MatrixProperty: Matrix;
        TransformProperty: Transform;
        ClassProperty: Class;
        ClassPropertyWithAllowed: Class;
        ClassPropertyWithDisallowed: Class;
        SubclassOfTexture: Class;
        SubclassOfWithAllowed: Class;
        SubclassOfWithDisallowed: Class;
        AssetPointerWithAllowedAndWhitespace: TSoftObjectPtr<Object>;
        IntProperty32Array: TArray<number>;
        BytePropertyArray: TArray<number>;
        FloatPropertyArray: TArray<number>;
        NamePropertyArray: TArray<string>;
        BoolPropertyArray: TArray<boolean>;
        StringPropertyArray: TArray<string>;
        TextPropertyArray: TArray<string>;
        Vector3PropertyArray: TArray<Vector>;
        Vector2PropertyArray: TArray<Vector2D>;
        Vector4PropertyArray: TArray<Vector4>;
        RotatorPropertyArray: TArray<Rotator>;
        ObjectPropertyArray: TArray<Object>;
        ActorPropertyArray: TArray<Actor>;
        LinearColorPropertyArray: TArray<LinearColor>;
        ColorPropertyArray: TArray<Color>;
        enumPropertyArray: TArray<PropertyEditorTestEnum>;
        StructPropertyArray: TArray<PropertyEditorTestBasicStruct>;
        StructPropertyArrayWithTitle: TArray<PropertyEditorTestBasicStruct>;
        InstancedStructArray: TArray<PropertyEditorTestInstancedStruct>;
        InstancedUObjectArray: TArray<PropertyEditorTestInstancedObject>;
        FixedArrayOfInts: TArray<number>;
        StaticArrayOfInts: FixSizeArray<number>;
        StaticArrayOfIntsWithEnumLabels: FixSizeArray<number>;
        FloatPropertyWithClampedRange: number;
        IntPropertyWithClampedRange: number;
        IntThatCannotBeChanged: number;
        StringThatCannotBeChanged: string;
        ObjectThatCannotBeChanged: PrimitiveComponent;
        enumBitflags: number;
        StringPasswordProperty: string;
        TextPasswordProperty: string;
        ThisIsBrokenIfItsVisibleInADetailsView: PropertyEditorTestBasicStruct;
        StructWithMultipleInstances1: PropertyEditorTestBasicStruct;
        bEditConditionStructWithMultipleInstances2: boolean;
        StructWithMultipleInstances2: PropertyEditorTestBasicStruct;
        RichCurve: RichCurve;
        AssetReferenceCustomStruct: SoftObjectPath;
        AssetReferenceCustomStructWithThumbnail: SoftObjectPath;
        ExactlyPointLightActorReference: SoftObjectPath;
        LightActorReference: SoftObjectPath;
        ExactPointOrSpotLightActorReference: SoftObjectPath;
        LightOrStaticMeshActorReference: SoftObjectPath;
        NotLightActorReference: SoftObjectPath;
        MaterialOrTextureAssetReference: SoftObjectPath;
        ActorWithMetaClass: SoftObjectPath;
        DisabledByCanEditChange: SoftObjectPath;
        bEditCondition: boolean;
        SimplePropertyWithEditCondition: number;
        bEditConditionAssetReferenceCustomStructWithEditCondition: boolean;
        AssetReferenceCustomStructWithEditCondition: SoftObjectPath;
        ArrayOfStructs: TArray<PropertyEditorTestBasicStruct>;
        Struct: PropertyEditTestTextStruct;
        EditInlineNewStaticMeshComponent: StaticMeshComponent;
        ArrayOfEditInlineNewSMCs: TArray<StaticMeshComponent>;
        TextureProp: Texture;
        StaticMeshProp: StaticMesh;
        AnyMaterialInterface: MaterialInterface;
        OnlyActorsAllowed: Actor;
        Int32Set: TSet<number>;
        FloatSet: TSet<number>;
        StringSet: TSet<string>;
        ObjectSet: TSet<Object>;
        ActorSet: TSet<Actor>;
        EditColorSet: TSet<EditColor>;
        NameSet: TSet<string>;
        Int32ToStringMap: TMap<number, string>;
        StringToColorMap: TMap<string, LinearColor>;
        Int32ToStructMap: TMap<number, PropertyEditorTestBasicStruct>;
        StringToFloatMap: TMap<string, number>;
        StringToObjectMap: TMap<string, Object>;
        StringToActorMap: TMap<string, Actor>;
        ObjectToInt32Map: TMap<Object, number>;
        ObjectToColorMap: TMap<Object, LinearColor>;
        IntToEnumMap: TMap<number, PropertyEditorTestEnum>;
        NameToNameMap: TMap<string, string>;
        NameToObjectMap: TMap<string, Object>;
        NameToCustomMap: TMap<string, PropertyEditorTestBasicStruct>;
        NameToColorMap: TMap<string, LinearColor>;
        IntToCustomMap: TMap<number, PropertyEditorTestBasicStruct>;
        IntToSubStructMap: TMap<number, PropertyEditorTestSubStruct>;
        LinearColorSet: TSet<LinearColor>;
        VectorSet: TSet<Vector>;
        LinearColorToStringMap: TMap<LinearColor, string>;
        VectorToFloatMap: TMap<Vector, number>;
        LinearColorToVectorMap: TMap<LinearColor, Vector>;
        BlendableInterface: BlendableInterface;
        AnimClassInterface: AnimClassInterface;
        LightPropagationVolumeBlendable: BlendableInterface;
        TextureOrBlendableInterface: Object;
        bSubcategory: boolean;
        bSubcategoryAdvanced: boolean;
        bSubcategoryFooSimple: boolean;
        bSubcategoryFooAdvanced: boolean;
        bSubcategoryBarSimple: boolean;
        bSubcategoryBarAdvanced: boolean;
        bSubcategoryLast: boolean;
        bEnablesNext: boolean;
        bEnabledByPrevious: boolean;
        enumEditCondition: EditColor;
        bEnabledWhenBlue: boolean;
        bEnabledWhenPink: boolean;
        enumAsByteEditCondition: PropertyEditorTestEnum;
        bEnabledWhenEnumIs2: boolean;
        bEnabledWhenEnumIs4: boolean;
        IntegerEditCondition: number;
        bEnabledWhenIntGreaterOrEqual5: boolean;
        bEnabledWhenIntLessOrEqual10: boolean;
        FloatEditCondition: number;
        bEnabledWhenFloatGreaterThan5: boolean;
        bEnabledWhenFloatLessThan10: boolean;
        bEditConditionForArrays: boolean;
        ArrayWithEditCondition: TArray<Texture2D>;
        ArrayOfStructsWithEditCondition: TArray<PropertyEditorTestBasicStruct>;
        bEditConditionForFixedArray: boolean;
        FixedArrayWithEditCondition: FixSizeArray<string>;
        EditConditionFlags: bigint;
        bEnabledWhenFlagsHasTwoOrFour: boolean;
        bDisabledWhenFlagsIsOdd: boolean;
        InlineProperty: EComponentMobility;
        PropertyThatHides: EComponentMobility;
        bVisibleWhenStatic: boolean;
        VisibleWhenStationary: number;
        DateTime: DateTime;
        bInlineEditConditionWithoutMetaToggle: boolean;
        InlineEditConditionWithoutMeta: number;
        bInlineEditConditionWithMetaToggle: boolean;
        InlineEditConditionWithMeta: number;
        bInlineEditConditionNotEditable: boolean;
        HasNonEditableInlineCondition: number;
        bSharedEditCondition: boolean;
        UsesSharedEditCondition1: number;
        UsesSharedEditCondition2: number;
        StructWithInlineCondition: PropertyEditorTestInlineEditCondition;
        ArrayOfStructsWithInlineCondition: TArray<PropertyEditorTestInlineEditCondition>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyEditorTestObject;

        static Load(InName: string): PropertyEditorTestObject;
    }

    export class PropertyEventBroadcaster extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyEventBroadcaster;

        static Load(InName: string): PropertyEventBroadcaster;
    }

    export class PropertyEventSubscriber extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PropertyEventSubscriber;

        static Load(InName: string): PropertyEventSubscriber;
    }

    export class ProxyLODMeshSimplificationSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProxyLODMeshReductionModuleName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ProxyLODMeshSimplificationSettings;

        static Load(InName: string): ProxyLODMeshSimplificationSettings;
    }

    export class PuertsSetting extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AutoModeEnable: boolean;
        DebugEnable: boolean;
        DebugPort: number;
        WaitDebugger: boolean;
        WaitDebuggerTimeout: number;
        NumberOfJsEnv: number;
        WatchDisable: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): PuertsSetting;

        static Load(InName: string): PuertsSetting;
    }

    export enum EQuartzTimeSignatureQuantization {
        HalfNote,
        QuarterNote,
        EighthNote,
        SixteenthNote,
        ThirtySecondNote,
        Count,
        EQuartzTimeSignatureQuantization_MAX
    }

    export class QuartzPulseOverrideStep {
        constructor();
        constructor(NumberOfPulses: number, PulseDuration: EQuartzCommandQuantization);

        NumberOfPulses: number;
        PulseDuration: EQuartzCommandQuantization;

        static StaticClass(): Class;
    }

    export class QuartzTimeSignature {
        constructor();
        constructor(NumBeats: number, BeatType: EQuartzTimeSignatureQuantization, OptionalPulseOverride: TArray<QuartzPulseOverrideStep>);

        NumBeats: number;
        BeatType: EQuartzTimeSignatureQuantization;
        OptionalPulseOverride: TArray<QuartzPulseOverrideStep>;

        static StaticClass(): Class;
    }

    export class QuartzClockSettings {
        constructor();
        constructor(TimeSignature: QuartzTimeSignature, bIgnoreLevelChange: boolean);

        TimeSignature: QuartzTimeSignature;
        bIgnoreLevelChange: boolean;

        static StaticClass(): Class;
    }

    export class QuartzSubsystem extends WorldSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CreateNewClock(WorldContextObject: $Nullable<Object>, ClockName: string, InSettings: QuartzClockSettings, bOverrideSettingsIfClockExists?: boolean /* = false */): QuartzClockHandle;

        DoesClockExist(WorldContextObject: $Nullable<Object>, ClockName: string): boolean;

        GetAudioRenderThreadToGameThreadAverageLatency(): number;

        GetAudioRenderThreadToGameThreadMaxLatency(): number;

        GetAudioRenderThreadToGameThreadMinLatency(): number;

        GetGameThreadToAudioRenderThreadAverageLatency(WorldContextObject: $Nullable<Object>): number;

        GetGameThreadToAudioRenderThreadMaxLatency(WorldContextObject: $Nullable<Object>): number;

        GetGameThreadToAudioRenderThreadMinLatency(WorldContextObject: $Nullable<Object>): number;

        GetHandleForClock(WorldContextObject: $Nullable<Object>, ClockName: string): QuartzClockHandle;

        GetRoundTripAverageLatency(WorldContextObject: $Nullable<Object>): number;

        GetRoundTripMaxLatency(WorldContextObject: $Nullable<Object>): number;

        GetRoundTripMinLatency(WorldContextObject: $Nullable<Object>): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): QuartzSubsystem;

        static Load(InName: string): QuartzSubsystem;
    }

    export class QuitMatchCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;

        static QuitMatch(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, MatchID: string, Outcome: EMPMatchOutcome, TurnTimeoutInSeconds: number): QuitMatchCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): QuitMatchCallbackProxy;

        static Load(InName: string): QuitMatchCallbackProxy;
    }

    export class RadialFalloff extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Radius: number;
        Position: Vector;
        Falloff: EFieldFalloffType;

        SetRadialFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Radius: number, Position: Vector, Falloff: EFieldFalloffType): RadialFalloff;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RadialFalloff;

        static Load(InName: string): RadialFalloff;
    }

    export class RadialForceComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Radius: number;
        Falloff: ERadialImpulseFalloff;
        ImpulseStrength: number;
        bImpulseVelChange: boolean;
        bIgnoreOwningActor: boolean;
        ForceStrength: number;
        DestructibleDamage: number;
        ObjectTypesToAffect: TArray<EObjectTypeQuery>;

        AddObjectTypeToAffect(ObjectType: EObjectTypeQuery): void;

        FireImpulse(): void;

        RemoveObjectTypeToAffect(ObjectType: EObjectTypeQuery): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RadialForceComponent;

        static Load(InName: string): RadialForceComponent;
    }

    export class RadialForceActor extends RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ForceComponent: RadialForceComponent;
        SpriteComponent: BillboardComponent;

        DisableForce(): void;

        EnableForce(): void;

        FireImpulse(): void;

        ToggleForce(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RadialForceActor;

        static Load(InName: string): RadialForceActor;
    }

    export enum ESetMaskConditionType {
        Field_Set_Always,
        Field_Set_IFF_NOT_Interior,
        Field_Set_IFF_NOT_Exterior,
        Field_MaskCondition_Max
    }

    export class RadialIntMask extends FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Radius: number;
        Position: Vector;
        InteriorValue: number;
        ExteriorValue: number;
        SetMaskCondition: ESetMaskConditionType;

        SetRadialIntMask(Radius: number, Position: Vector, InteriorValue: number, ExteriorValue: number, SetMaskConditionIn: ESetMaskConditionType): RadialIntMask;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RadialIntMask;

        static Load(InName: string): RadialIntMask;
    }

    export class RadialVector extends FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;
        Position: Vector;

        SetRadialVector(Magnitude: number, Position: Vector): RadialVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RadialVector;

        static Load(InName: string): RadialVector;
    }

    export class RandomVector extends FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;

        SetRandomVector(Magnitude: number): RandomVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RandomVector;

        static Load(InName: string): RandomVector;
    }

    export class ReactDeclarationGenerator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Gen(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReactDeclarationGenerator;

        static Load(InName: string): ReactDeclarationGenerator;
    }

    export class ReactWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddChild(Content: $Nullable<Widget>): PanelSlot;

        RemoveChild(Content: $Nullable<Widget>): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReactWidget;

        static Load(InName: string): ReactWidget;
    }

    export class RecastFilter_UseDefaultArea extends NavigationQueryFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RecastFilter_UseDefaultArea;

        static Load(InName: string): RecastFilter_UseDefaultArea;
    }

    export class RecastNavMeshDataChunk extends NavigationDataChunk {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RecastNavMeshDataChunk;

        static Load(InName: string): RecastNavMeshDataChunk;
    }

    export class RectangleSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Length: number;
        Width: number;
        bBranchRight: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RectangleSplineGenerator;

        static Load(InName: string): RectangleSplineGenerator;
    }

    export class RectLight extends Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RectLightComponent: RectLightComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RectLight;

        static Load(InName: string): RectLight;
    }

    export class ReimportBasicOverlaysFactory extends BasicOverlaysFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportBasicOverlaysFactory;

        static Load(InName: string): ReimportBasicOverlaysFactory;
    }

    export class ReimportCurveFactory extends CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportCurveFactory;

        static Load(InName: string): ReimportCurveFactory;
    }

    export class ReimportCurveTableFactory extends CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportCurveTableFactory;

        static Load(InName: string): ReimportCurveTableFactory;
    }

    export class ReimportDataTableFactory extends CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportDataTableFactory;

        static Load(InName: string): ReimportDataTableFactory;
    }

    export class ReimportFbxAnimSequenceFactory extends FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportFbxAnimSequenceFactory;

        static Load(InName: string): ReimportFbxAnimSequenceFactory;
    }

    export class ReimportFbxSceneFactory extends FbxSceneImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScriptReimportHelper(Obj: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportFbxSceneFactory;

        static Load(InName: string): ReimportFbxSceneFactory;
    }

    export class ReimportFbxSkeletalMeshFactory extends FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportFbxSkeletalMeshFactory;

        static Load(InName: string): ReimportFbxSkeletalMeshFactory;
    }

    export class ReimportFbxStaticMeshFactory extends FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportFbxStaticMeshFactory;

        static Load(InName: string): ReimportFbxStaticMeshFactory;
    }

    export class SoundFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bAutoCreateCue: boolean;
        bIncludeAttenuationNode: boolean;
        bIncludeLoopingNode: boolean;
        bIncludeModulatorNode: boolean;
        CueVolume: number;
        CuePackageSuffix: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundFactory;

        static Load(InName: string): SoundFactory;
    }

    export class ReimportSoundFactory extends SoundFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportSoundFactory;

        static Load(InName: string): ReimportSoundFactory;
    }

    export class TextureFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NoCompression: boolean;
        NoAlpha: boolean;
        bDeferCompression: boolean;
        CompressionSettings: TextureCompressionSettings;
        bCreateMaterial: boolean;
        bRGBToBaseColor: boolean;
        bRGBToEmissive: boolean;
        bAlphaToRoughness: boolean;
        bAlphaToEmissive: boolean;
        bAlphaToOpacity: boolean;
        bAlphaToOpacityMask: boolean;
        bTwoSided: boolean;
        Blending: EBlendMode;
        ShadingModel: EMaterialShadingModel;
        MipGenSettings: TextureMipGenSettings;
        LODGroup: TextureGroup;
        bDitherMipMapAlpha: boolean;
        AlphaCoverageThresholds: Vector4;
        bPreserveBorder: boolean;
        bFlipNormalMapGreenChannel: boolean;
        bUsingExistingSettings: boolean;
        bUseHashAsGuid: boolean;
        UdimRegexPattern: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureFactory;

        static Load(InName: string): TextureFactory;
    }

    export class ReimportTextureFactory extends TextureFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        pOriginalTex: Texture;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportTextureFactory;

        static Load(InName: string): ReimportTextureFactory;
    }

    export class VectorFieldStaticFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VectorFieldStaticFactory;

        static Load(InName: string): VectorFieldStaticFactory;
    }

    export class ReimportVectorFieldStaticFactory extends VectorFieldStaticFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReimportVectorFieldStaticFactory;

        static Load(InName: string): ReimportVectorFieldStaticFactory;
    }

    export class RendererOverrideSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSupportAllShaderPermutations: boolean;
        bForceRecomputeTangents: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RendererOverrideSettings;

        static Load(InName: string): RendererOverrideSettings;
    }

    export enum EMobileMSAASampleCount { One, Two, Four, Eight, EMobileMSAASampleCount_MAX }

    export enum ETranslucentSortPolicy { SortByDistance, SortByProjectedZ, SortAlongAxis, ETranslucentSortPolicy_MAX }

    export enum ECustomDepthStencil { Disabled, Enabled, EnabledOnDemand, EnabledWithStencil, ECustomDepthStencil_MAX }

    export enum EAlphaChannelMode { Disabled, LinearColorSpaceOnly, AllowThroughTonemapper, EAlphaChannelMode_MAX }

    export enum EAutoExposureMethodUI { AEM_Histogram, AEM_Basic, AEM_Manual, AEM_MAX }

    export enum EAntiAliasingMethod { AAM_None, AAM_FXAA, AAM_TemporalAA, AAM_MSAA, AAM_MAX }

    export enum EDefaultBackBufferPixelFormat {
        DBBPF_B8G8R8A8,
        DBBPF_A16B16G16R16_DEPRECATED,
        DBBPF_FloatRGB_DEPRECATED,
        DBBPF_FloatRGBA,
        DBBPF_A2B10G10R10,
        DBBPF_MAX
    }

    export enum EEarlyZPass { None, OpaqueOnly, OpaqueAndMasked, Auto, EEarlyZPass_MAX }

    export enum EClearSceneOptions { NoClear, HardwareClear, QuadAtMaxZ, EClearSceneOptions_MAX }

    export enum EGBufferFormat {
        Force8BitsPerChannel,
        Default,
        HighPrecisionNormals,
        Force16BitsPerChannel,
        EGBufferFormat_MAX
    }

    export enum ESkinCacheDefaultBehavior { Exclusive, Inclusive, ESkinCacheDefaultBehavior_MAX }

    export enum EMobilePlanarReflectionMode { Usual, MobilePPRExclusive, MobilePPR, EMobilePlanarReflectionMode_MAX }

    export class RendererSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bMobileDisableVertexFog: boolean;
        MaxMobileCascades: number;
        MobileMSAASampleCount: EMobileMSAASampleCount;
        bMobileAllowDitheredLODTransition: boolean;
        bMobileAllowSoftwareOcclusionCulling: boolean;
        bMobileVirtualTextures: boolean;
        bDiscardUnusedQualityLevels: boolean;
        bOcclusionCulling: boolean;
        MinScreenRadiusForLights: number;
        MinScreenRadiusForEarlyZPass: number;
        MinScreenRadiusForCSMdepth: number;
        bPrecomputedVisibilityWarning: boolean;
        bTextureStreaming: boolean;
        bUseDXT5NormalMaps: boolean;
        bVirtualTextures: boolean;
        bVirtualTexturedLightmaps: boolean;
        VirtualTextureTileSize: number;
        VirtualTextureTileBorderSize: number;
        VirtualTextureFeedbackFactor: number;
        bVirtualTextureEnableCompressZlib: boolean;
        bVirtualTextureEnableCompressCrunch: boolean;
        bClearCoatEnableSecondNormal: boolean;
        ReflectionCaptureResolution: number;
        bReflectionCaptureCompression: boolean;
        ReflectionEnvironmentLightmapMixBasedOnRoughness: boolean;
        bForwardShading: boolean;
        bVertexFoggingForOpaque: boolean;
        bAllowStaticLighting: boolean;
        bUseNormalMapsForStaticLighting: boolean;
        bGenerateMeshDistanceFields: boolean;
        bEightBitMeshDistanceFields: boolean;
        bGenerateLandscapeGIData: boolean;
        bCompressMeshDistanceFields: boolean;
        TessellationAdaptivePixelsPerTriangle: number;
        bSeparateTranslucency: boolean;
        TranslucentSortPolicy: ETranslucentSortPolicy;
        TranslucentSortAxis: Vector;
        CustomDepthStencil: ECustomDepthStencil;
        bCustomDepthTaaJitter: boolean;
        bEnableAlphaChannelInPostProcessing: EAlphaChannelMode;
        bDefaultFeatureBloom: boolean;
        bDefaultFeatureAmbientOcclusion: boolean;
        bDefaultFeatureAmbientOcclusionStaticFraction: boolean;
        bDefaultFeatureAutoExposure: boolean;
        DefaultFeatureAutoExposure: EAutoExposureMethodUI;
        DefaultFeatureAutoExposureBias: number;
        bExtendDefaultLuminanceRangeInAutoExposureSettings: boolean;
        bUsePreExposure: boolean;
        bEnablePreExposureOnlyInTheEditor: boolean;
        bDefaultFeatureMotionBlur: boolean;
        bDefaultFeatureLensFlare: boolean;
        bTemporalUpsampling: boolean;
        bSSGI: boolean;
        DefaultFeatureAntiAliasing: EAntiAliasingMethod;
        DefaultLightUnits: ELightUnits;
        DefaultBackBufferPixelFormat: EDefaultBackBufferPixelFormat;
        bRenderUnbuiltPreviewShadowsInGame: boolean;
        bStencilForLODDither: boolean;
        EarlyZPass: EEarlyZPass;
        bEarlyZPassOnlyMaterialMasking: boolean;
        bDBuffer: boolean;
        ClearSceneMethod: EClearSceneOptions;
        bBasePassOutputsVelocity: boolean;
        bVertexDeformationOutputsVelocity: boolean;
        bSelectiveBasePassOutputs: boolean;
        bDefaultParticleCutouts: boolean;
        GPUSimulationTextureSizeX: number;
        GPUSimulationTextureSizeY: number;
        bGlobalClipPlane: boolean;
        GBufferFormat: EGBufferFormat;
        bUseGPUMorphTargets: boolean;
        bNvidiaAftermathEnabled: boolean;
        bMultiView: boolean;
        bMobilePostProcessing: boolean;
        bMobileMultiView: boolean;
        bMobileUseHWsRGBEncoding: boolean;
        bRoundRobinOcclusion: boolean;
        bODSCapture: boolean;
        bMeshStreaming: boolean;
        WireframeCullThreshold: number;
        bEnableRayTracing: boolean;
        bEnableRayTracingTextureLOD: boolean;
        bSupportStationarySkylight: boolean;
        bSupportLowQualityLightmaps: boolean;
        bSupportPointLightWholeSceneShadows: boolean;
        bSupportAtmosphericFog: boolean;
        bSupportSkyAtmosphere: boolean;
        bSupportSkyAtmosphereAffectsHeightFog: boolean;
        bSupportSkinCacheShaders: boolean;
        DefaultSkinCacheBehavior: ESkinCacheDefaultBehavior;
        SkinCacheSceneMemoryLimitInMB: number;
        bMobileEnableStaticAndCSMShadowReceivers: boolean;
        bMobileEnableMovableLightCSMShaderCulling: boolean;
        bMobileAllowDistanceFieldShadows: boolean;
        bMobileAllowMovableDirectionalLights: boolean;
        MobileNumDynamicPointLights: number;
        bMobileDynamicPointLightsUseStaticBranch: boolean;
        bMobileAllowMovableSpotlights: boolean;
        bMobileAllowMovableSpotlightShadows: boolean;
        bSupport16BitBoneIndex: boolean;
        bGPUSkinLimit2BoneInfluences: boolean;
        bSupportDepthOnlyIndexBuffers: boolean;
        bSupportReversedIndexBuffers: boolean;
        bLPV: boolean;
        bMobileAmbientOcclusion: boolean;
        bUseUnlimitedBoneInfluences: boolean;
        UnlimitedBonInfluencesThreshold: number;
        MobilePlanarReflectionMode: EMobilePlanarReflectionMode;
        bStreamSkeletalMeshLODs: PerPlatformBool;
        bDiscardSkeletalMeshOptionalLODs: PerPlatformBool;
        VisualizeCalibrationColorMaterialPath: SoftObjectPath;
        VisualizeCalibrationCustomMaterialPath: SoftObjectPath;
        VisualizeCalibrationGrayscaleMaterialPath: SoftObjectPath;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RendererSettings;

        static Load(InName: string): RendererSettings;
    }

    export class RenderTargetExporterHDR extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RenderTargetExporterHDR;

        static Load(InName: string): RenderTargetExporterHDR;
    }

    export class ReplaceActorCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReplaceActorCommandlet;

        static Load(InName: string): ReplaceActorCommandlet;
    }

    export class ReplaceAssetsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReplaceAssetsCommandlet;

        static Load(InName: string): ReplaceAssetsCommandlet;
    }

    export class ReplayNetConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReplayNetConnection;

        static Load(InName: string): ReplayNetConnection;
    }

    export class ReplaySubsystem extends GameInstanceSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReplaySubsystem;

        static Load(InName: string): ReplaySubsystem;
    }

    export class ReplicationConnectionDriver extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReplicationConnectionDriver;

        static Load(InName: string): ReplicationConnectionDriver;
    }

    export class RetainerBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bRetainRender: boolean;
        RenderOnInvalidation: boolean;
        RenderOnPhase: boolean;
        Phase: number;
        PhaseCount: number;
        EffectMaterial: MaterialInterface;
        TextureParameter: string;

        GetEffectMaterial(): MaterialInstanceDynamic;

        RequestRender(): void;

        SetEffectMaterial(EffectMaterial: $Nullable<MaterialInterface>): void;

        SetRenderingPhase(RenderPhase: number, TotalPhases: number): void;

        SetRetainRendering(bInRetainRendering: boolean): void;

        SetTextureParameter(TextureParameter: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RetainerBox;

        static Load(InName: string): RetainerBox;
    }

    export class ReturnResultsTerminal extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetReturnResultsTerminal(): ReturnResultsTerminal;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReturnResultsTerminal;

        static Load(InName: string): ReturnResultsTerminal;
    }

    export class ReverbEffectFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ReverbEffectFactory;

        static Load(InName: string): ReverbEffectFactory;
    }

    export class RichCurveKeyProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Value: RichCurveKey;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RichCurveKeyProxy;

        static Load(InName: string): RichCurveKeyProxy;
    }

    export class RichTextBlockImageDecorator extends RichTextBlockDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImageSet: DataTable;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RichTextBlockImageDecorator;

        static Load(InName: string): RichTextBlockImageDecorator;
    }

    export class RotateOnAngleDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RotateOnAngleDragOperation;

        static Load(InName: string): RotateOnAngleDragOperation;
    }

    export class RotatingMovementComponent extends MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RotationRate: Rotator;
        PivotTranslation: Vector;
        bRotationInLocalSpace: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RotatingMovementComponent;

        static Load(InName: string): RotatingMovementComponent;
    }

    export class RuntimeOptionsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RuntimeOptionsBase;

        static Load(InName: string): RuntimeOptionsBase;
    }

    export class VirtualTextureBuildSettings {
        constructor();
        constructor(TileSize: number, TileBorderSize: number, bEnableCompressCrunch: boolean, bEnableCompressZlib: boolean);

        TileSize: number;
        TileBorderSize: number;
        bEnableCompressCrunch: boolean;
        bEnableCompressZlib: boolean;

        static StaticClass(): Class;
    }

    export class VirtualTexture2D extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: VirtualTextureBuildSettings;
        bContinuousUpdate: boolean;
        bSinglePhysicalSpace: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VirtualTexture2D;

        static Load(InName: string): VirtualTexture2D;
    }

    export class VirtualTextureBuilder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Texture: VirtualTexture2D;
        BuildHash: bigint;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VirtualTextureBuilder;

        static Load(InName: string): VirtualTextureBuilder;
    }

    export class RuntimeVirtualTextureComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoundsAlignActor: TSoftObjectPtr<Actor>;
        bSetBoundsButton: boolean;
        bSnapBoundsToLandscape: boolean;
        VirtualTexture: RuntimeVirtualTexture;
        bEnableScalability: boolean;
        ScalabilityGroup: number;
        bHidePrimitives: boolean;
        StreamingTexture: VirtualTextureBuilder;
        StreamLowMips: number;
        bBuildStreamingMipsButton: boolean;
        bEnableCompressCrunch: boolean;
        bUseStreamingLowMipsInEditor: boolean;
        bBuildDebugStreamingMips: boolean;

        Invalidate(WorldBounds: BoxSphereBounds): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureComponent;

        static Load(InName: string): RuntimeVirtualTextureComponent;
    }

    export class RuntimeVirtualTextureFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureFactory;

        static Load(InName: string): RuntimeVirtualTextureFactory;
    }

    export class RuntimeVirtualTextureThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureThumbnailRenderer;

        static Load(InName: string): RuntimeVirtualTextureThumbnailRenderer;
    }

    export class RuntimeVirtualTextureVolume extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VirtualTextureComponent: RuntimeVirtualTextureComponent;
        Box: BoxComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureVolume;

        static Load(InName: string): RuntimeVirtualTextureVolume;
    }

    export class RVOAvoidanceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): RVOAvoidanceInterface;

        static Load(InName: string): RVOAvoidanceInterface;
    }

    export class SafeZone extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PadLeft: boolean;
        PadRight: boolean;
        PadTop: boolean;
        PadBottom: boolean;

        SetSidesToPad(InPadLeft: boolean, InPadRight: boolean, InPadTop: boolean, InPadBottom: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SafeZone;

        static Load(InName: string): SafeZone;
    }

    export class SafeZoneSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsTitleSafe: boolean;
        SafeAreaScale: Margin;
        HAlign: EHorizontalAlignment;
        VAlign: EVerticalAlignment;
        Padding: Margin;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SafeZoneSlot;

        static Load(InName: string): SafeZoneSlot;
    }

    export class SakuraSchool_Version1_C extends MWBasicStanceData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SakuraSchool_Version1_C;

        static Load(InName: string): SakuraSchool_Version1_C;
    }

    export class SavePackageUtilitiesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SavePackageUtilitiesCommandlet;

        static Load(InName: string): SavePackageUtilitiesCommandlet;
    }

    export enum EStretch {
        None,
        Fill,
        ScaleToFit,
        ScaleToFitX,
        ScaleToFitY,
        ScaleToFill,
        ScaleBySafeZone,
        UserSpecified,
        EStretch_MAX
    }

    export enum EStretchDirection { Both, DownOnly, UpOnly, EStretchDirection_MAX }

    export class ScaleBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Stretch: EStretch;
        StretchDirection: EStretchDirection;
        UserSpecifiedScale: number;
        IgnoreInheritedScale: boolean;

        SetIgnoreInheritedScale(bInIgnoreInheritedScale: boolean): void;

        SetStretch(InStretch: EStretch): void;

        SetStretchDirection(InStretchDirection: EStretchDirection): void;

        SetUserSpecifiedScale(InUserSpecifiedScale: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScaleBox;

        static Load(InName: string): ScaleBox;
    }

    export class ScaleBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScaleBoxSlot;

        static Load(InName: string): ScaleBoxSlot;
    }

    export class ScaleDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScaleDragOperation;

        static Load(InName: string): ScaleDragOperation;
    }

    export class Scene extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Scene;

        static Load(InName: string): Scene;
    }

    export class TextureRenderTargetCube extends TextureRenderTarget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SizeX: number;
        ClearColor: LinearColor;
        OverrideFormat: EPixelFormat;
        bHDR: boolean;
        bForceLinearGamma: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetCube;

        static Load(InName: string): TextureRenderTargetCube;
    }

    export class SceneCaptureComponentCube extends SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextureTarget: TextureRenderTargetCube;
        bCaptureRotation: boolean;
        TextureTargetLeft: TextureRenderTargetCube;
        TextureTargetRight: TextureRenderTargetCube;
        TextureTargetODS: TextureRenderTarget2D;
        IPD: number;

        CaptureScene(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponentCube;

        static Load(InName: string): SceneCaptureComponentCube;
    }

    export class SceneCaptureCube extends SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CaptureComponentCube: SceneCaptureComponentCube;

        OnInterpToggle(bEnable: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneCaptureCube;

        static Load(InName: string): SceneCaptureCube;
    }

    export class SceneThumbnailInfo extends ThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OrbitPitch: number;
        OrbitYaw: number;
        OrbitZoom: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneThumbnailInfo;

        static Load(InName: string): SceneThumbnailInfo;
    }

    export enum EThumbnailPrimType { TPT_None, TPT_Sphere, TPT_Cube, TPT_Plane, TPT_Cylinder, TPT_MAX }

    export class SceneThumbnailInfoWithPrimitive extends SceneThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PrimitiveType: EThumbnailPrimType;
        PreviewMesh: SoftObjectPath;
        bUserModifiedShape: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SceneThumbnailInfoWithPrimitive;

        static Load(InName: string): SceneThumbnailInfoWithPrimitive;
    }

    export class ScreenshotFunctionalTest extends ScreenshotFunctionalTestBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCameraCutOnScreenshotPrep: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScreenshotFunctionalTest;

        static Load(InName: string): ScreenshotFunctionalTest;
    }

    export class ScrollBar extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetStyle: ScrollBarStyle;
        Style: SlateWidgetStyleAsset;
        bAlwaysShowScrollbar: boolean;
        bAlwaysShowScrollbarTrack: boolean;
        Orientation: EOrientation;
        Thickness: Vector2D;
        Padding: Margin;

        SetState(InOffsetFraction: number, InThumbSizeFraction: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScrollBar;

        static Load(InName: string): ScrollBar;
    }

    export class ScrollBarWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScrollBarStyle: ScrollBarStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScrollBarWidgetStyle;

        static Load(InName: string): ScrollBarWidgetStyle;
    }

    export class ScrollBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScrollBoxSlot;

        static Load(InName: string): ScrollBoxSlot;
    }

    export class ScrollBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ScrollBoxStyle: ScrollBoxStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ScrollBoxWidgetStyle;

        static Load(InName: string): ScrollBoxWidgetStyle;
    }

    export class SCSEditorExtensionContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SCSEditorExtensionContext;

        static Load(InName: string): SCSEditorExtensionContext;
    }

    export class Selection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Selection;

        static Load(InName: string): Selection;
    }

    export class SequenceExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequenceExporterT3D;

        static Load(InName: string): SequenceExporterT3D;
    }

    export class SequencerAnimationSupport extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequencerAnimationSupport;

        static Load(InName: string): SequencerAnimationSupport;
    }

    export class SequenceRecorderActorGroup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GroupName: string;
        SequenceName: string;
        SequenceRecordingBasePath: DirectoryPath;
        bSpecifyTargetLevelSequence: boolean;
        TargetLevelSequence: LevelSequence;
        bDuplicateTargetLevelSequence: boolean;
        bRecordTargetLevelSequenceLength: boolean;
        RecordedActors: TArray<ActorRecording>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequenceRecorderActorGroup;

        static Load(InName: string): SequenceRecorderActorGroup;
    }

    export class SequenceRecorderBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static IsRecordingSequence(): boolean;

        static StartRecordingSequence(ActorsToRecord: TArray<Actor>): void;

        static StopRecordingSequence(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequenceRecorderBlueprintLibrary;

        static Load(InName: string): SequenceRecorderBlueprintLibrary;
    }

    export class SequenceRecorderGroup extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActorGroups: TArray<SequenceRecorderActorGroup>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequenceRecorderGroup;

        static Load(InName: string): SequenceRecorderGroup;
    }

    export enum EAudioRecordingMode { None, AudioTrack, EAudioRecordingMode_MAX }

    export class SequenceRecorderActorFilter {
        constructor();
        constructor(ActorClassesToRecord: TArray<Class>);

        ActorClassesToRecord: TArray<Class>;

        static StaticClass(): Class;
    }

    export class PropertiesToRecordForClass {
        constructor();
        constructor(Class: Class, Properties: TArray<string>);

        Class: Class;
        Properties: TArray<string>;

        static StaticClass(): Class;
    }

    export class PropertiesToRecordForActorClass {
        constructor();
        constructor(Class: Class, Properties: TArray<string>);

        Class: Class;
        Properties: TArray<string>;

        static StaticClass(): Class;
    }

    export class SettingsForActorClass {
        constructor();
        constructor(Class: Class, bRecordToPossessable: boolean);

        Class: Class;
        bRecordToPossessable: boolean;

        static StaticClass(): Class;
    }

    export class SequenceRecorderSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bCreateLevelSequence: boolean;
        bImmersiveMode: boolean;
        SequenceLength: number;
        RecordingDelay: number;
        bAllowLooping: boolean;
        GlobalTimeDilation: number;
        bIgnoreTimeDilation: boolean;
        AnimationSubDirectory: string;
        RecordAudio: EAudioRecordingMode;
        AudioGain: number;
        bSplitAudioChannelsIntoSeparateTracks: boolean;
        bReplaceRecordedAudio: boolean;
        AudioTrackName: string;
        AudioSubDirectory: string;
        bRecordNearbySpawnedActors: boolean;
        NearbyActorRecordingProximity: number;
        bRecordWorldSettingsActor: boolean;
        bReduceKeys: boolean;
        bAutoSaveAsset: boolean;
        ActorFilter: SequenceRecorderActorFilter;
        LevelSequenceActorsToTrigger: TArray<TLazyObjectPtr<LevelSequenceActor>>;
        DefaultAnimationSettings: AnimationRecordingSettings;
        bRecordSequencerSpawnedActors: boolean;
        ClassesAndPropertiesToRecord: TArray<PropertiesToRecordForClass>;
        ActorsAndPropertiesToRecord: TArray<PropertiesToRecordForActorClass>;
        PerActorSettings: TArray<SettingsForActorClass>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequenceRecorderSettings;

        static Load(InName: string): SequenceRecorderSettings;
    }

    export class SequencerExportTask extends AssetExportTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SequencerContext: Object;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequencerExportTask;

        static Load(InName: string): SequencerExportTask;
    }

    export class SequencerKeyActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        KeyMeshComponent: StaticMeshComponent;
        AssociatedActor: Actor;
        TrackSection: MovieScene3DTransformSection;
        KeyTime: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequencerKeyActor;

        static Load(InName: string): SequencerKeyActor;
    }

    export class SequencerMeshTrail extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequencerMeshTrail;

        static Load(InName: string): SequencerMeshTrail;
    }

    export enum EAutoChangeMode { AutoKey, AutoTrack, All, None, EAutoChangeMode_MAX }

    export enum EAllowEditsMode { AllEdits, AllowSequencerEditsOnly, AllowLevelEditsOnly, EAllowEditsMode_MAX }

    export enum EKeyGroupMode { KeyChanged, KeyGroup, KeyAll, EKeyGroupMode_MAX }

    export enum EMovieSceneKeyInterpolation { Auto, User, Break, Linear, Constant, EMovieSceneKeyInterpolation_MAX }

    export enum ESequencerSpawnPosition { SSP_Origin, SSP_PlaceInFrontOfCamera, SSP_MAX }

    export enum ESequencerZoomPosition { SZP_CurrentTime, SZP_MousePosition, SZP_MAX }

    export enum ESequencerLoopMode { SLM_NoLoop, SLM_Loop, SLM_LoopSelectionRange, SLM_MAX }

    export class SequencerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AutoChangeMode: EAutoChangeMode;
        AllowEditsMode: EAllowEditsMode;
        KeyGroupMode: EKeyGroupMode;
        bKeyInterpPropertiesOnly: boolean;
        KeyInterpolation: EMovieSceneKeyInterpolation;
        bAutoSetTrackDefaults: boolean;
        SpawnPosition: ESequencerSpawnPosition;
        bCreateSpawnableCameras: boolean;
        bShowRangeSlider: boolean;
        bIsSnapEnabled: boolean;
        bSnapKeyTimesToInterval: boolean;
        bSnapKeyTimesToKeys: boolean;
        bSnapSectionTimesToInterval: boolean;
        bSnapSectionTimesToSections: boolean;
        bSnapKeysAndSectionsToPlayRange: boolean;
        bSnapPlayTimeToKeys: boolean;
        bSnapPlayTimeToInterval: boolean;
        bSnapPlayTimeToPressedKey: boolean;
        bSnapPlayTimeToDraggedKey: boolean;
        bSnapCurveValueToInterval: boolean;
        bShowSelectedNodesOnly: boolean;
        bRewindOnRecord: boolean;
        ZoomPosition: ESequencerZoomPosition;
        bAutoScrollEnabled: boolean;
        bLinkCurveEditorTimeRange: boolean;
        bSynchronizeCurveEditorSelection: boolean;
        bIsolateCurveEditorToSelection: boolean;
        LoopMode: ESequencerLoopMode;
        bKeepCursorInPlayRangeWhileScrubbing: boolean;
        bKeepCursorInPlayRange: boolean;
        bKeepPlayRangeInSectionBounds: boolean;
        ZeroPadFrames: number;
        bShowCombinedKeyframes: boolean;
        bInfiniteKeyAreas: boolean;
        bShowChannelColors: boolean;
        ReduceKeysTolerance: number;
        bDeleteKeysWhenTrimming: boolean;
        bDisableSectionsAfterBaking: boolean;
        bCleanPlaybackMode: boolean;
        bActivateRealtimeViewports: boolean;
        bEvaluateSubSequencesInIsolation: boolean;
        bRerunConstructionScripts: boolean;
        bShowDebugVisualization: boolean;
        bVisualizePreAndPostRoll: boolean;
        bCompileDirectorOnEvaluate: boolean;
        TrajectoryPathCap: number;
        bShowOutlinerInfoColumn: boolean;
        FrameNumberDisplayFormat: EFrameNumberDisplayFormats;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequencerSettings;

        static Load(InName: string): SequencerSettings;
    }

    export class SequencerSettingsContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SequencerSettingsContainer;

        static Load(InName: string): SequencerSettingsContainer;
    }

    export class SetProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SetProperty;

        static Load(InName: string): SetProperty;
    }

    export class ShaderCodeLibraryToolsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ShaderCodeLibraryToolsCommandlet;

        static Load(InName: string): ShaderCodeLibraryToolsCommandlet;
    }

    export class ShaderCookerStats extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Name: string;
        Platform: string;
        Category: string;
        Compiled: number;
        Cooked: number;
        Permutations: number;
        CompileTime: number;
        Path: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ShaderCookerStats;

        static Load(InName: string): ShaderCookerStats;
    }

    export class ShaderPipelineCacheToolsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ShaderPipelineCacheToolsCommandlet;

        static Load(InName: string): ShaderPipelineCacheToolsCommandlet;
    }

    export enum EShadowMapFlags { SMF_None, SMF_Streamed, SMF_MAX }

    export class ShadowMapTexture2D extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ShadowmapFlags: EShadowMapFlags;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ShadowMapTexture2D;

        static Load(InName: string): ShadowMapTexture2D;
    }

    export class SharedProfiles extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Profiles: TArray<PreviewSceneProfile>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SharedProfiles;

        static Load(InName: string): SharedProfiles;
    }

    export enum ESheetAxis { AX_Horizontal, AX_XAxis, AX_YAxis, AX_MAX }

    export class SheetBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        X: number;
        Y: number;
        XSegments: number;
        YSegments: number;
        Axis: ESheetAxis;
        GroupName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SheetBuilder;

        static Load(InName: string): SheetBuilder;
    }

    export class ShowLoginUICallbackProxy extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnSuccess: $MulticastDelegate<(PlayerController: $Nullable<PlayerController>) => void>;
        OnFailure: $MulticastDelegate<(PlayerController: $Nullable<PlayerController>) => void>;

        static ShowExternalLoginUI(WorldContextObject: $Nullable<Object>, InPlayerController: $Nullable<PlayerController>): ShowLoginUICallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ShowLoginUICallbackProxy;

        static Load(InName: string): ShowLoginUICallbackProxy;
    }

    export class SimpleWheeledVehicleMovementComponent extends WheeledVehicleMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SetBrakeTorque(BrakeTorque: number, WheelIndex: number): void;

        SetDriveTorque(DriveTorque: number, WheelIndex: number): void;

        SetSteerAngle(SteerAngle: number, WheelIndex: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SimpleWheeledVehicleMovementComponent;

        static Load(InName: string): SimpleWheeledVehicleMovementComponent;
    }

    export class SimulatedClientNetConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SimulatedClientNetConnection;

        static Load(InName: string): SimulatedClientNetConnection;
    }

    export class SingleClickInputBehavior extends AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HitTestOnRelease: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SingleClickInputBehavior;

        static Load(InName: string): SingleClickInputBehavior;
    }

    export class SingleClickTool extends InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SingleClickTool;

        static Load(InName: string): SingleClickTool;
    }

    export class SingleClickToolBuilder extends InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SingleClickToolBuilder;

        static Load(InName: string): SingleClickToolBuilder;
    }

    export class SinglePropertyView extends PropertyViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PropertyName: string;
        NameOverride: string;

        GetPropertyName(): string;

        SetPropertyName(NewPropertyName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SinglePropertyView;

        static Load(InName: string): SinglePropertyView;
    }

    export class SizeBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidthOverride: number;
        HeightOverride: number;
        MinDesiredWidth: number;
        MinDesiredHeight: number;
        MaxDesiredWidth: number;
        MaxDesiredHeight: number;
        MinAspectRatio: number;
        MaxAspectRatio: number;
        bOverride_WidthOverride: boolean;
        bOverride_HeightOverride: boolean;
        bOverride_MinDesiredWidth: boolean;
        bOverride_MinDesiredHeight: boolean;
        bOverride_MaxDesiredWidth: boolean;
        bOverride_MaxDesiredHeight: boolean;
        bOverride_MinAspectRatio: boolean;
        bOverride_MaxAspectRatio: boolean;

        ClearHeightOverride(): void;

        ClearMaxAspectRatio(): void;

        ClearMaxDesiredHeight(): void;

        ClearMaxDesiredWidth(): void;

        ClearMinAspectRatio(): void;

        ClearMinDesiredHeight(): void;

        ClearMinDesiredWidth(): void;

        ClearWidthOverride(): void;

        SetHeightOverride(InHeightOverride: number): void;

        SetMaxAspectRatio(InMaxAspectRatio: number): void;

        SetMaxDesiredHeight(InMaxDesiredHeight: number): void;

        SetMaxDesiredWidth(InMaxDesiredWidth: number): void;

        SetMinAspectRatio(InMinAspectRatio: number): void;

        SetMinDesiredHeight(InMinDesiredHeight: number): void;

        SetMinDesiredWidth(InMinDesiredWidth: number): void;

        SetWidthOverride(InWidthOverride: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SizeBox;

        static Load(InName: string): SizeBox;
    }

    export class SizeBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SizeBoxSlot;

        static Load(InName: string): SizeBoxSlot;
    }

    export class SkeletalMeshEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AnimPreviewFloorColor: Color;
        AnimPreviewSkyColor: Color;
        AnimPreviewSkyBrightness: number;
        AnimPreviewLightBrightness: number;
        AnimPreviewLightingDirection: Rotator;
        AnimPreviewDirectionalColor: Color;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshEditorSettings;

        static Load(InName: string): SkeletalMeshEditorSettings;
    }

    export class SkeletalMeshExporterFBX extends ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshExporterFBX;

        static Load(InName: string): SkeletalMeshExporterFBX;
    }

    export class SkeletalMeshSimplificationSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SkeletalMeshReductionModuleName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSimplificationSettings;

        static Load(InName: string): SkeletalMeshSimplificationSettings;
    }

    export class SkeletalMeshSimulationComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PhysicalMaterial: ChaosPhysicalMaterial;
        ChaosSolverActor: ChaosSolverActor;
        OverridePhysicsAsset: PhysicsAsset;
        bSimulating: boolean;
        bNotifyCollisions: boolean;
        ObjectType: EObjectStateTypeEnum;
        Density: number;
        MinMass: number;
        MaxMass: number;
        CollisionType: ECollisionTypeEnum;
        ImplicitShapeParticlesPerUnitArea: number;
        ImplicitShapeMinNumParticles: number;
        ImplicitShapeMaxNumParticles: number;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        CollisionGroup: number;
        InitialVelocityType: EInitialVelocityTypeEnum;
        InitialLinearVelocity: Vector;
        InitialAngularVelocity: Vector;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;

        ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSimulationComponent;

        static Load(InName: string): SkeletalMeshSimulationComponent;
    }

    export class SkeletalMeshThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshThumbnailRenderer;

        static Load(InName: string): SkeletalMeshThumbnailRenderer;
    }

    export class SkeletalMeshToolMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletalMeshToolMenuContext;

        static Load(InName: string): SkeletalMeshToolMenuContext;
    }

    export class SkeletonFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TargetSkeletalMesh: SkeletalMesh;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkeletonFactory;

        static Load(InName: string): SkeletonFactory;
    }

    export class SkinWeightImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ProfileName: string;
        FilePath: string;
        LODIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkinWeightImportOptions;

        static Load(InName: string): SkinWeightImportOptions;
    }

    export enum ESkyAtmosphereTransformMode {
        PlanetTopAtAbsoluteWorldOrigin,
        PlanetTopAtComponentTransform,
        PlanetCenterAtComponentTransform,
        ESkyAtmosphereTransformMode_MAX
    }

    export class TentDistribution {
        constructor();
        constructor(TipAltitude: number, TipValue: number, Width: number);

        TipAltitude: number;
        TipValue: number;
        Width: number;

        static StaticClass(): Class;
    }

    export class SkyAtmosphereComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TransformMode: ESkyAtmosphereTransformMode;
        BottomRadius: number;
        GroundAlbedo: Color;
        AtmosphereHeight: number;
        MultiScatteringFactor: number;
        TraceSampleCountScale: number;
        RayleighScatteringScale: number;
        RayleighScattering: LinearColor;
        RayleighExponentialDistribution: number;
        MieScatteringScale: number;
        MieScattering: LinearColor;
        MieAbsorptionScale: number;
        MieAbsorption: LinearColor;
        MieAnisotropy: number;
        MieExponentialDistribution: number;
        OtherAbsorptionScale: number;
        OtherAbsorption: LinearColor;
        OtherTentDistribution: TentDistribution;
        SkyLuminanceFactor: LinearColor;
        AerialPespectiveViewDistanceScale: number;
        HeightFogContribution: number;
        TransmittanceMinLightElevationAngle: number;
        AerialPerspectiveStartDepth: number;
        bStaticLightingBuiltGUID: Guid;

        OverrideAtmosphereLightDirection(AtmosphereLightIndex: number, LightDirection: Vector): void;

        SetAerialPespectiveViewDistanceScale(NewValue: number): void;

        SetHeightFogContribution(NewValue: number): void;

        SetMieAbsorption(NewValue: LinearColor): void;

        SetMieAbsorptionScale(NewValue: number): void;

        SetMieAnisotropy(NewValue: number): void;

        SetMieExponentialDistribution(NewValue: number): void;

        SetMieScattering(NewValue: LinearColor): void;

        SetMieScatteringScale(NewValue: number): void;

        SetOtherAbsorption(NewValue: LinearColor): void;

        SetOtherAbsorptionScale(NewValue: number): void;

        SetRayleighExponentialDistribution(NewValue: number): void;

        SetRayleighScattering(NewValue: LinearColor): void;

        SetRayleighScatteringScale(NewValue: number): void;

        SetSkyLuminanceFactor(NewValue: LinearColor): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkyAtmosphereComponent;

        static Load(InName: string): SkyAtmosphereComponent;
    }

    export class SkyAtmosphere extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SkyAtmosphereComponent: SkyAtmosphereComponent;
        ArrowComponent: ArrowComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SkyAtmosphere;

        static Load(InName: string): SkyAtmosphere;
    }

    export class SlateBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AbsoluteToLocal(Geometry: Geometry, AbsoluteCoordinate: Vector2D): Vector2D;

        static AbsoluteToViewport(WorldContextObject: $Nullable<Object>, AbsoluteDesktopCoordinate: Vector2D, PixelPosition: $Ref<Vector2D>, ViewportPosition: $Ref<Vector2D>): void;

        static EqualEqual_SlateBrush(A: SlateBrush, B: SlateBrush): boolean;

        static GetAbsoluteSize(Geometry: Geometry): Vector2D;

        static GetLocalSize(Geometry: Geometry): Vector2D;

        static GetLocalTopLeft(Geometry: Geometry): Vector2D;

        static IsUnderLocation(Geometry: Geometry, AbsoluteCoordinate: Vector2D): boolean;

        static LocalToAbsolute(Geometry: Geometry, LocalCoordinate: Vector2D): Vector2D;

        static LocalToViewport(WorldContextObject: $Nullable<Object>, Geometry: Geometry, LocalCoordinate: Vector2D, PixelPosition: $Ref<Vector2D>, ViewportPosition: $Ref<Vector2D>): void;

        static ScreenToViewport(WorldContextObject: $Nullable<Object>, ScreenPosition: Vector2D, ViewportPosition: $Ref<Vector2D>): void;

        static ScreenToWidgetAbsolute(WorldContextObject: $Nullable<Object>, ScreenPosition: Vector2D, AbsoluteCoordinate: $Ref<Vector2D>, bIncludeWindowPosition: boolean): void;

        static ScreenToWidgetLocal(WorldContextObject: $Nullable<Object>, Geometry: Geometry, ScreenPosition: Vector2D, LocalCoordinate: $Ref<Vector2D>, bIncludeWindowPosition: boolean): void;

        static TransformScalarAbsoluteToLocal(Geometry: Geometry, AbsoluteScalar: number): number;

        static TransformScalarLocalToAbsolute(Geometry: Geometry, LocalScalar: number): number;

        static TransformVectorAbsoluteToLocal(Geometry: Geometry, AbsoluteVector: Vector2D): Vector2D;

        static TransformVectorLocalToAbsolute(Geometry: Geometry, LocalVector: Vector2D): Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateBlueprintLibrary;

        static Load(InName: string): SlateBlueprintLibrary;
    }

    export class SlateBrushAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialTexture: Texture2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateBrushAssetFactory;

        static Load(InName: string): SlateBrushAssetFactory;
    }

    export class SlateBrushThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateBrushThumbnailRenderer;

        static Load(InName: string): SlateBrushThumbnailRenderer;
    }

    export class SlateSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bExplicitCanvasChildZOrder: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateSettings;

        static Load(InName: string): SlateSettings;
    }

    export class SlateTabManagerContext extends ToolMenuContextBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateTabManagerContext;

        static Load(InName: string): SlateTabManagerContext;
    }

    export class SlateTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateTypes;

        static Load(InName: string): SlateTypes;
    }

    export class SlateMeshVertex {
        constructor();
        constructor(Position: Vector2D, Color: Color, UV0: Vector2D, UV1: Vector2D, UV2: Vector2D, UV3: Vector2D, UV4: Vector2D, UV5: Vector2D);

        Position: Vector2D;
        Color: Color;
        UV0: Vector2D;
        UV1: Vector2D;
        UV2: Vector2D;
        UV3: Vector2D;
        UV4: Vector2D;
        UV5: Vector2D;

        static StaticClass(): Class;
    }

    export class SlateVectorArtData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MeshAsset: StaticMesh;
        SourceMaterial: MaterialInterface;
        VertexData: TArray<SlateMeshVertex>;
        IndexData: TArray<number>;
        Material: MaterialInterface;
        ExtentMin: Vector2D;
        ExtentMax: Vector2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateVectorArtData;

        static Load(InName: string): SlateVectorArtData;
    }

    export class SlateVectorArtDataFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateVectorArtDataFactory;

        static Load(InName: string): SlateVectorArtDataFactory;
    }

    export class SlateWidgetStyleAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StyleType: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleAssetFactory;

        static Load(InName: string): SlateWidgetStyleAssetFactory;
    }

    export class SlateWidgetStyleContainerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleContainerInterface;

        static Load(InName: string): SlateWidgetStyleContainerInterface;
    }

    export class SliderStyle extends SlateWidgetStyle {
        constructor();
        constructor(NormalBarImage: SlateBrush, HoveredBarImage: SlateBrush, DisabledBarImage: SlateBrush, NormalThumbImage: SlateBrush, HoveredThumbImage: SlateBrush, DisabledThumbImage: SlateBrush, BarThickness: number);

        NormalBarImage: SlateBrush;
        HoveredBarImage: SlateBrush;
        DisabledBarImage: SlateBrush;
        NormalThumbImage: SlateBrush;
        HoveredThumbImage: SlateBrush;
        DisabledThumbImage: SlateBrush;
        BarThickness: number;

        static StaticClass(): Class;
    }

    export class Slider extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Value: number;
        ValueDelegate: $Delegate<() => number>;
        MinValue: number;
        MaxValue: number;
        WidgetStyle: SliderStyle;
        Orientation: EOrientation;
        SliderBarColor: LinearColor;
        SliderHandleColor: LinearColor;
        IndentHandle: boolean;
        Locked: boolean;
        MouseUsesStep: boolean;
        RequiresControllerLock: boolean;
        StepSize: number;
        IsFocusable: boolean;
        OnMouseCaptureBegin: $MulticastDelegate<() => void>;
        OnMouseCaptureEnd: $MulticastDelegate<() => void>;
        OnControllerCaptureBegin: $MulticastDelegate<() => void>;
        OnControllerCaptureEnd: $MulticastDelegate<() => void>;
        OnValueChanged: $MulticastDelegate<(Value: number) => void>;

        GetNormalizedValue(): number;

        GetValue(): number;

        SetIndentHandle(InValue: boolean): void;

        SetLocked(InValue: boolean): void;

        SetMaxValue(InValue: number): void;

        SetMinValue(InValue: number): void;

        SetSliderBarColor(InValue: LinearColor): void;

        SetSliderHandleColor(InValue: LinearColor): void;

        SetStepSize(InValue: number): void;

        SetValue(InValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Slider;

        static Load(InName: string): Slider;
    }

    export class SmokeTestCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SmokeTestCommandlet;

        static Load(InName: string): SmokeTestCommandlet;
    }

    export class SoftObjectProperty extends ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoftObjectProperty;

        static Load(InName: string): SoftObjectProperty;
    }

    export class SoftClassProperty extends SoftObjectProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoftClassProperty;

        static Load(InName: string): SoftClassProperty;
    }

    export class SoundAttenuationFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundAttenuationFactory;

        static Load(InName: string): SoundAttenuationFactory;
    }

    export class SoundClassFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundClassFactory;

        static Load(InName: string): SoundClassFactory;
    }

    export class SoundClassGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundClassGraph;

        static Load(InName: string): SoundClassGraph;
    }

    export class SoundClassGraphNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundClass: SoundClass;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundClassGraphNode;

        static Load(InName: string): SoundClassGraphNode;
    }

    export class SoundClassGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundClassGraphSchema;

        static Load(InName: string): SoundClassGraphSchema;
    }

    export class SoundConcurrencyFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundConcurrencyFactory;

        static Load(InName: string): SoundConcurrencyFactory;
    }

    export class SoundCueFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialSoundWave: SoundWave;
        InitialDialogueWave: DialogueWave;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundCueFactoryNew;

        static Load(InName: string): SoundCueFactoryNew;
    }

    export class SoundCueGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundCueGraph;

        static Load(InName: string): SoundCueGraph;
    }

    export class SoundCueGraphNode_Base extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode_Base;

        static Load(InName: string): SoundCueGraphNode_Base;
    }

    export class SoundCueGraphNode extends SoundCueGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundNode: SoundNode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode;

        static Load(InName: string): SoundCueGraphNode;
    }

    export class SoundCueGraphNode_Root extends SoundCueGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode_Root;

        static Load(InName: string): SoundCueGraphNode_Root;
    }

    export class SoundCueGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundCueGraphSchema;

        static Load(InName: string): SoundCueGraphSchema;
    }

    export class SoundEffectPresetUserWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Preset: SoundEffectPreset;

        OnPresetChanged(PropertyName: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundEffectPresetUserWidget;

        static Load(InName: string): SoundEffectPresetUserWidget;
    }

    export class SoundEffectSourcePresetClassTemplate extends ClassTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundEffectSourcePresetClassTemplate;

        static Load(InName: string): SoundEffectSourcePresetClassTemplate;
    }

    export class SoundEffectSubmixPresetClassTemplate extends ClassTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundEffectSubmixPresetClassTemplate;

        static Load(InName: string): SoundEffectSubmixPresetClassTemplate;
    }

    export class SoundExporterOGG extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundExporterOGG;

        static Load(InName: string): SoundExporterOGG;
    }

    export class SoundExporterWAV extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundExporterWAV;

        static Load(InName: string): SoundExporterWAV;
    }

    export class SoundfieldEffectSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundfieldEffectSettingsBase;

        static Load(InName: string): SoundfieldEffectSettingsBase;
    }

    export class SoundfieldEffectBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: SoundfieldEffectSettingsBase;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundfieldEffectBase;

        static Load(InName: string): SoundfieldEffectBase;
    }

    export class SoundfieldEndpointSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundfieldEndpointSettingsBase;

        static Load(InName: string): SoundfieldEndpointSettingsBase;
    }

    export class SoundfieldEndpointSubmix extends SoundSubmixBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundfieldEndpointType: string;
        EndpointSettingsClass: Class;
        EndpointSettings: SoundfieldEndpointSettingsBase;
        EncodingSettingsClass: Class;
        EncodingSettings: SoundfieldEncodingSettingsBase;
        SoundfieldEffectChain: TArray<SoundfieldEffectBase>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundfieldEndpointSubmix;

        static Load(InName: string): SoundfieldEndpointSubmix;
    }

    export class SoundfieldEndpointSubmixFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundfieldEndpointSubmixFactory;

        static Load(InName: string): SoundfieldEndpointSubmixFactory;
    }

    export class SoundfieldSubmix extends SoundSubmixWithParentBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundfieldEncodingFormat: string;
        EncodingSettings: SoundfieldEncodingSettingsBase;
        SoundfieldEffectChain: TArray<SoundfieldEffectBase>;
        EncodingSettingsClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundfieldSubmix;

        static Load(InName: string): SoundfieldSubmix;
    }

    export class SoundfieldSubmixFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundfieldSubmixFactory;

        static Load(InName: string): SoundfieldSubmixFactory;
    }

    export class SoundGroup {
        constructor();
        constructor(SoundGroup: ESoundGroup, DisplayName: string, bAlwaysDecompressOnLoad: boolean, DecompressedDuration: number);

        SoundGroup: ESoundGroup;
        DisplayName: string;
        bAlwaysDecompressOnLoad: boolean;
        DecompressedDuration: number;

        static StaticClass(): Class;
    }

    export class SoundGroups extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundGroupProfiles: TArray<SoundGroup>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundGroups;

        static Load(InName: string): SoundGroups;
    }

    export class SoundMixFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundMixFactory;

        static Load(InName: string): SoundMixFactory;
    }

    export class SoundNodeAssetReferencer extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeAssetReferencer;

        static Load(InName: string): SoundNodeAssetReferencer;
    }

    export class SoundNodeAttenuation extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AttenuationSettings: SoundAttenuation;
        AttenuationOverrides: SoundAttenuationSettings;
        bOverrideAttenuation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeAttenuation;

        static Load(InName: string): SoundNodeAttenuation;
    }

    export class SoundNodeBranch extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BoolParameterName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeBranch;

        static Load(InName: string): SoundNodeBranch;
    }

    export class SoundNodeConcatenator extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputVolume: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeConcatenator;

        static Load(InName: string): SoundNodeConcatenator;
    }

    export class SoundNodeDelay extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelayMin: number;
        DelayMax: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeDelay;

        static Load(InName: string): SoundNodeDelay;
    }

    export class DialogueWaveParameter {
        constructor();
        constructor(DialogueWave: DialogueWave, Context: DialogueContext);

        DialogueWave: DialogueWave;
        Context: DialogueContext;

        static StaticClass(): Class;
    }

    export class SoundNodeDialoguePlayer extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DialogueWaveParameter: DialogueWaveParameter;
        bLooping: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeDialoguePlayer;

        static Load(InName: string): SoundNodeDialoguePlayer;
    }

    export class DistanceDatum {
        constructor();
        constructor(FadeInDistanceStart: number, FadeInDistanceEnd: number, FadeOutDistanceStart: number, FadeOutDistanceEnd: number, Volume: number);

        FadeInDistanceStart: number;
        FadeInDistanceEnd: number;
        FadeOutDistanceStart: number;
        FadeOutDistanceEnd: number;
        Volume: number;

        static StaticClass(): Class;
    }

    export class SoundNodeDistanceCrossFade extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CrossFadeInput: TArray<DistanceDatum>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeDistanceCrossFade;

        static Load(InName: string): SoundNodeDistanceCrossFade;
    }

    export class SoundNodeDoppler extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DopplerIntensity: number;
        bUseSmoothing: boolean;
        SmoothingInterpSpeed: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeDoppler;

        static Load(InName: string): SoundNodeDoppler;
    }

    export class SoundNodeEnveloper extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LoopStart: number;
        LoopEnd: number;
        DurationAfterLoop: number;
        LoopCount: number;
        bLoopIndefinitely: boolean;
        bLoop: boolean;
        VolumeInterpCurve: DistributionFloatConstantCurve;
        PitchInterpCurve: DistributionFloatConstantCurve;
        VolumeCurve: RuntimeFloatCurve;
        PitchCurve: RuntimeFloatCurve;
        PitchMin: number;
        PitchMax: number;
        VolumeMin: number;
        VolumeMax: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeEnveloper;

        static Load(InName: string): SoundNodeEnveloper;
    }

    export class SoundNodeGroupControl extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GroupSizes: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeGroupControl;

        static Load(InName: string): SoundNodeGroupControl;
    }

    export class SoundNodeLooping extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LoopCount: number;
        bLoopIndefinitely: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeLooping;

        static Load(InName: string): SoundNodeLooping;
    }

    export class SoundNodeMature extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeMature;

        static Load(InName: string): SoundNodeMature;
    }

    export class SoundNodeMixer extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InputVolume: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeMixer;

        static Load(InName: string): SoundNodeMixer;
    }

    export class SoundNodeModulator extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PitchMin: number;
        PitchMax: number;
        VolumeMin: number;
        VolumeMax: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeModulator;

        static Load(InName: string): SoundNodeModulator;
    }

    export enum ModulationParamMode { MPM_Normal, MPM_Abs, MPM_Direct, MPM_MAX }

    export class ModulatorContinuousParams {
        constructor();
        constructor(ParameterName: string, Default: number, MinInput: number, MaxInput: number, MinOutput: number, MaxOutput: number, ParamMode: ModulationParamMode);

        ParameterName: string;
        Default: number;
        MinInput: number;
        MaxInput: number;
        MinOutput: number;
        MaxOutput: number;
        ParamMode: ModulationParamMode;

        static StaticClass(): Class;
    }

    export class SoundNodeModulatorContinuous extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PitchModulationParams: ModulatorContinuousParams;
        VolumeModulationParams: ModulatorContinuousParams;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeModulatorContinuous;

        static Load(InName: string): SoundNodeModulatorContinuous;
    }

    export class SoundNodeOscillator extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bModulateVolume: boolean;
        bModulatePitch: boolean;
        AmplitudeMin: number;
        AmplitudeMax: number;
        FrequencyMin: number;
        FrequencyMax: number;
        OffsetMin: number;
        OffsetMax: number;
        CenterMin: number;
        CenterMax: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeOscillator;

        static Load(InName: string): SoundNodeOscillator;
    }

    export class SoundNodeParamCrossFade extends SoundNodeDistanceCrossFade {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ParamName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeParamCrossFade;

        static Load(InName: string): SoundNodeParamCrossFade;
    }

    export class SoundNodeQualityLevel extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CookedQualityLevelIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeQualityLevel;

        static Load(InName: string): SoundNodeQualityLevel;
    }

    export class SoundNodeRandom extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Weights: TArray<number>;
        HasBeenUsed: TArray<boolean>;
        NumRandomUsed: number;
        PreselectAtLevelLoad: number;
        bShouldExcludeFromBranchCulling: boolean;
        bSoundCueExcludedFromBranchCulling: boolean;
        bRandomizeWithoutReplacement: boolean;
        PIEHiddenNodes: TArray<number>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeRandom;

        static Load(InName: string): SoundNodeRandom;
    }

    export class SoundNodeSoundClass extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundClassOverride: SoundClass;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeSoundClass;

        static Load(InName: string): SoundNodeSoundClass;
    }

    export class SoundNodeSwitch extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IntParameterName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeSwitch;

        static Load(InName: string): SoundNodeSwitch;
    }

    export class SoundNodeWaveParam extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WaveParameterName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeWaveParam;

        static Load(InName: string): SoundNodeWaveParam;
    }

    export class SoundNodeWavePlayer extends SoundNodeAssetReferencer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundWaveAssetPtr: TSoftObjectPtr<SoundWave>;
        SoundWave: SoundWave;
        bLooping: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundNodeWavePlayer;

        static Load(InName: string): SoundNodeWavePlayer;
    }

    export class SoundSourceBusFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSourceBusFactory;

        static Load(InName: string): SoundSourceBusFactory;
    }

    export class SoundSourceEffectChainFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSourceEffectChainFactory;

        static Load(InName: string): SoundSourceEffectChainFactory;
    }

    export class SoundSourceEffectFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundEffectSourcepresetClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSourceEffectFactory;

        static Load(InName: string): SoundSourceEffectFactory;
    }

    export class SoundSubmixEffectFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundEffectSubmixPresetClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSubmixEffectFactory;

        static Load(InName: string): SoundSubmixEffectFactory;
    }

    export class SoundSubmixFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSubmixFactory;

        static Load(InName: string): SoundSubmixFactory;
    }

    export class SoundSubmixGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RootSoundSubmix: SoundSubmixBase;
        StaleRoots: TArray<SoundSubmixBase>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraph;

        static Load(InName: string): SoundSubmixGraph;
    }

    export class SoundSubmixGraphNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SoundSubmix: SoundSubmixBase;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraphNode;

        static Load(InName: string): SoundSubmixGraphNode;
    }

    export class SoundSubmixGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraphSchema;

        static Load(InName: string): SoundSubmixGraphSchema;
    }

    export class SoundSurroundExporterWAV extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundSurroundExporterWAV;

        static Load(InName: string): SoundSurroundExporterWAV;
    }

    export class SoundWaveThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SoundWaveThumbnailRenderer;

        static Load(InName: string): SoundWaveThumbnailRenderer;
    }

    export class SourceCodeAccessSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        PreferredAccessor: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SourceCodeAccessSettings;

        static Load(InName: string): SourceCodeAccessSettings;
    }

    export class SourceControlState {
        constructor();
        constructor(Filename: string, bIsValid: boolean, bIsUnknown: boolean, bCanCheckIn: boolean, bCanCheckOut: boolean, bIsCheckedOut: boolean, bIsCurrent: boolean, bIsSourceControlled: boolean, bIsAdded: boolean, bIsDeleted: boolean, bIsIgnored: boolean, bCanEdit: boolean, bCanDelete: boolean, bIsModified: boolean, bCanAdd: boolean, bIsConflicted: boolean, bCanRevert: boolean, bIsCheckedOutOther: boolean, CheckedOutOther: string);

        Filename: string;
        bIsValid: boolean;
        bIsUnknown: boolean;
        bCanCheckIn: boolean;
        bCanCheckOut: boolean;
        bIsCheckedOut: boolean;
        bIsCurrent: boolean;
        bIsSourceControlled: boolean;
        bIsAdded: boolean;
        bIsDeleted: boolean;
        bIsIgnored: boolean;
        bCanEdit: boolean;
        bCanDelete: boolean;
        bIsModified: boolean;
        bCanAdd: boolean;
        bIsConflicted: boolean;
        bCanRevert: boolean;
        bIsCheckedOutOther: boolean;
        CheckedOutOther: string;

        static StaticClass(): Class;
    }

    export class SourceControlHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CheckInFile(InFile: string, InDescription: string, bSilent?: boolean /* = false */): boolean;

        static CheckInFiles(InFiles: TArray<string>, InDescription: string, bSilent?: boolean /* = false */): boolean;

        static CheckOutFile(InFile: string, bSilent?: boolean /* = false */): boolean;

        static CheckOutFiles(InFiles: TArray<string>, bSilent?: boolean /* = false */): boolean;

        static CheckOutOrAddFile(InFile: string, bSilent?: boolean /* = false */): boolean;

        static CopyFile(InSourceFile: string, InDestFile: string, bSilent?: boolean /* = false */): boolean;

        static CurrentProvider(): string;

        static IsAvailable(): boolean;

        static IsEnabled(): boolean;

        static LastErrorMsg(): string;

        static MarkFileForAdd(InFile: string, bSilent?: boolean /* = false */): boolean;

        static MarkFileForDelete(InFile: string, bSilent?: boolean /* = false */): boolean;

        static MarkFilesForAdd(InFiles: TArray<string>, bSilent?: boolean /* = false */): boolean;

        static QueryFileState(InFile: string, bSilent?: boolean /* = false */): SourceControlState;

        static RevertFile(InFile: string, bSilent?: boolean /* = false */): boolean;

        static RevertFiles(InFiles: TArray<string>, bSilent?: boolean /* = false */): boolean;

        static RevertUnchangedFile(InFile: string, bSilent?: boolean /* = false */): boolean;

        static RevertUnchangedFiles(InFiles: TArray<string>, bSilent?: boolean /* = false */): boolean;

        static SyncFile(InFile: string, bSilent?: boolean /* = false */): boolean;

        static SyncFiles(InFiles: TArray<string>, bSilent?: boolean /* = false */): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SourceControlHelpers;

        static Load(InName: string): SourceControlHelpers;
    }

    export class Spacer extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Size: Vector2D;

        SetSize(InSize: Vector2D): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Spacer;

        static Load(InName: string): Spacer;
    }

    export class SparseDelegateFunction extends DelegateFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SparseDelegateFunction;

        static Load(InName: string): SparseDelegateFunction;
    }

    export class SpectatorReservation {
        constructor();
        constructor(SpectatorId: UniqueNetIdRepl, Spectator: PlayerReservation);

        SpectatorId: UniqueNetIdRepl;
        Spectator: PlayerReservation;

        static StaticClass(): Class;
    }

    export enum ESpectatorClientRequestType {
        NonePending,
        ExistingSessionReservation,
        ReservationUpdate,
        EmptyServerReservation,
        Reconnect,
        Abandon,
        ESpectatorClientRequestType_MAX
    }

    export enum ESpectatorReservationResult {
        NoResult,
        RequestPending,
        GeneralError,
        SpectatorLimitReached,
        IncorrectPlayerCount,
        RequestTimedOut,
        ReservationDuplicate,
        ReservationNotFound,
        ReservationAccepted,
        ReservationDenied,
        ReservationDenied_CrossPlayRestriction,
        ReservationDenied_Banned,
        ReservationRequestCanceled,
        ReservationInvalid,
        BadSessionId,
        ReservationDenied_ContainsExistingPlayers,
        ESpectatorReservationResult_MAX
    }

    export class SpectatorBeaconClient extends OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DestSessionId: string;
        PendingReservation: SpectatorReservation;
        RequestType: ESpectatorClientRequestType;
        bPendingReservationSent: boolean;
        bCancelReservation: boolean;

        ClientCancelReservationResponse(ReservationResponse: ESpectatorReservationResult): void;

        ClientReservationResponse(ReservationResponse: ESpectatorReservationResult): void;

        ClientSendReservationFull(): void;

        ClientSendReservationUpdates(NumRemainingReservations: number): void;

        ServerCancelReservationRequest(Spectator: UniqueNetIdRepl): void;

        ServerReservationRequest(SessionId: string, Reservation: SpectatorReservation): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconClient;

        static Load(InName: string): SpectatorBeaconClient;
    }

    export class SpectatorBeaconState extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SessionName: string;
        NumConsumedReservations: number;
        MaxReservations: number;
        bRestrictCrossConsole: boolean;
        Reservations: TArray<SpectatorReservation>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconState;

        static Load(InName: string): SpectatorBeaconState;
    }

    export class SpectatorBeaconHost extends OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        State: SpectatorBeaconState;
        bLogoutOnSessionTimeout: boolean;
        SessionTimeoutSecs: number;
        TravelSessionTimeoutSecs: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconHost;

        static Load(InName: string): SpectatorBeaconHost;
    }

    export class SpectatorPawnMovement extends FloatingPawnMovement {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIgnoreTimeDilation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpectatorPawnMovement;

        static Load(InName: string): SpectatorPawnMovement;
    }

    export class SphereReflectionCapture extends ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DrawCaptureRadius: DrawSphereComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SphereReflectionCapture;

        static Load(InName: string): SphereReflectionCapture;
    }

    export class SphereReflectionCaptureComponent extends ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InfluenceRadius: number;
        CaptureDistanceScale: number;
        PreviewInfluenceRadius: DrawSphereComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SphereReflectionCaptureComponent;

        static Load(InName: string): SphereReflectionCaptureComponent;
    }

    export class SpinBoxStyle extends SlateWidgetStyle {
        constructor();
        constructor(BackgroundBrush: SlateBrush, HoveredBackgroundBrush: SlateBrush, ActiveFillBrush: SlateBrush, InactiveFillBrush: SlateBrush, ArrowsImage: SlateBrush, ForegroundColor: SlateColor, TextPadding: Margin);

        BackgroundBrush: SlateBrush;
        HoveredBackgroundBrush: SlateBrush;
        ActiveFillBrush: SlateBrush;
        InactiveFillBrush: SlateBrush;
        ArrowsImage: SlateBrush;
        ForegroundColor: SlateColor;
        TextPadding: Margin;

        static StaticClass(): Class;
    }

    export class SpinBox extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Value: number;
        ValueDelegate: $Delegate<() => number>;
        WidgetStyle: SpinBoxStyle;
        Style: SlateWidgetStyleAsset;
        MinFractionalDigits: number;
        MaxFractionalDigits: number;
        bAlwaysUsesDeltaSnap: boolean;
        Delta: number;
        SliderExponent: number;
        Font: SlateFontInfo;
        Justification: ETextJustify;
        MinDesiredWidth: number;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        ForegroundColor: SlateColor;
        OnValueChanged: $MulticastDelegate<(InValue: number) => void>;
        OnValueCommitted: $MulticastDelegate<(InValue: number, CommitMethod: ETextCommit) => void>;
        OnBeginSliderMovement: $MulticastDelegate<() => void>;
        OnEndSliderMovement: $MulticastDelegate<(InValue: number) => void>;
        bOverride_MinValue: boolean;
        bOverride_MaxValue: boolean;
        bOverride_MinSliderValue: boolean;
        bOverride_MaxSliderValue: boolean;
        MinValue: number;
        MaxValue: number;
        MinSliderValue: number;
        MaxSliderValue: number;

        ClearMaxSliderValue(): void;

        ClearMaxValue(): void;

        ClearMinSliderValue(): void;

        ClearMinValue(): void;

        GetAlwaysUsesDeltaSnap(): boolean;

        GetDelta(): number;

        GetMaxFractionalDigits(): number;

        GetMaxSliderValue(): number;

        GetMaxValue(): number;

        GetMinFractionalDigits(): number;

        GetMinSliderValue(): number;

        GetMinValue(): number;

        GetValue(): number;

        OnSpinBoxBeginSliderMovement__DelegateSignature(): void;

        OnSpinBoxValueChangedEvent__DelegateSignature(InValue: number): void;

        OnSpinBoxValueCommittedEvent__DelegateSignature(InValue: number, CommitMethod: ETextCommit): void;

        SetAlwaysUsesDeltaSnap(bNewValue: boolean): void;

        SetDelta(NewValue: number): void;

        SetForegroundColor(InForegroundColor: SlateColor): void;

        SetMaxFractionalDigits(NewValue: number): void;

        SetMaxSliderValue(NewValue: number): void;

        SetMaxValue(NewValue: number): void;

        SetMinFractionalDigits(NewValue: number): void;

        SetMinSliderValue(NewValue: number): void;

        SetMinValue(NewValue: number): void;

        SetValue(NewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpinBox;

        static Load(InName: string): SpinBox;
    }

    export class SpinBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpinBoxStyle: SpinBoxStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpinBoxWidgetStyle;

        static Load(InName: string): SpinBoxWidgetStyle;
    }

    export class SpiralStairBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InnerRadius: number;
        StepWidth: number;
        StepHeight: number;
        StepThickness: number;
        NumStepsPer360: number;
        NumSteps: number;
        GroupName: string;
        SlopedCeiling: boolean;
        SlopedFloor: boolean;
        CounterClockwise: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SpiralStairBuilder;

        static Load(InName: string): SpiralStairBuilder;
    }

    export class PropertyNameAndIndex {
        constructor();
        constructor(Name: string, Index: number);

        Name: string;
        Index: number;

        static StaticClass(): Class;
    }

    export class ComponentPropertyPath {
        constructor();
        constructor(ParentOwningActor: TWeakObjectPtr<Actor>, LastResortComponentPtr: TWeakObjectPtr<ActorComponent>, PropertyChain: TArray<PropertyNameAndIndex>);

        ParentOwningActor: TWeakObjectPtr<Actor>;
        LastResortComponentPtr: TWeakObjectPtr<ActorComponent>;
        PropertyChain: TArray<PropertyNameAndIndex>;

        static StaticClass(): Class;
    }

    export enum ESelectedTangentHandle { None, Leave, Arrive, ESelectedTangentHandle_MAX }

    export class SplineComponentVisualizerSelectionState extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SplinePropertyPath: ComponentPropertyPath;
        SelectedKeys: TSet<number>;
        LastKeyIndexSelected: number;
        SelectedSegmentIndex: number;
        SelectedTangentHandle: number;
        SelectedTangentHandleType: ESelectedTangentHandle;
        SelectedSplinePosition: Vector;
        CachedRotation: Quat;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SplineComponentVisualizerSelectionState;

        static Load(InName: string): SplineComponentVisualizerSelectionState;
    }

    export class SplineMeshActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SplineMeshComponent: SplineMeshComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SplineMeshActor;

        static Load(InName: string): SplineMeshActor;
    }

    export class SplineMetadataDetailsFactoryBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SplineMetadataDetailsFactoryBase;

        static Load(InName: string): SplineMetadataDetailsFactoryBase;
    }

    export class SquareSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Length: number;
        bBranchRight: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SquareSplineGenerator;

        static Load(InName: string): SquareSplineGenerator;
    }

    export class SSCSEditorMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SSCSEditorMenuContext;

        static Load(InName: string): SSCSEditorMenuContext;
    }

    export class StabilizeLocalizationKeysCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StabilizeLocalizationKeysCommandlet;

        static Load(InName: string): StabilizeLocalizationKeysCommandlet;
    }

    export class Stance_Default_C extends MWSysAnimInstance_StanceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UberGraphFrame: PointerToUberGraphFrame;
        AnimGraphNode_Root: AnimNode_Root;
        AnimGraphNode_LinkedInputPose: AnimNode_LinkedInputPose;
        AnimGraphNode_Slot_1: AnimNode_Slot;
        AnimGraphNode_LayeredBoneBlend: AnimNode_LayeredBoneBlend;
        AnimGraphNode_SaveCachedPose: AnimNode_SaveCachedPose;
        AnimGraphNode_UseCachedPose_1: AnimNode_UseCachedPose;
        AnimGraphNode_UseCachedPose: AnimNode_UseCachedPose;
        AnimGraphNode_Slot: AnimNode_Slot;

        AnimGraph(InPose: PoseLink, AnimGraph: $Ref<PoseLink>): void;

        ExecuteUbergraph_Stance_Default(EntryPoint: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Stance_Default_C;

        static Load(InName: string): Stance_Default_C;
    }

    export class StandardMacros_C extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StandardMacros_C;

        static Load(InName: string): StandardMacros_C;
    }

    export class StaticMeshExporterFBX extends ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshExporterFBX;

        static Load(InName: string): StaticMeshExporterFBX;
    }

    export class StaticMeshExporterOBJ extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshExporterOBJ;

        static Load(InName: string): StaticMeshExporterOBJ;
    }

    export class StaticMeshLightingInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StaticMeshActor: TWeakObjectPtr<Actor>;
        StaticMesh: TWeakObjectPtr<StaticMesh>;
        LevelName: string;
        TextureMapping: string;
        bTextureMapping: boolean;
        bHasLightmapTexCoords: boolean;
        StaticLightingResolution: number;
        TextureLightMapMemoryUsage: number;
        VertexLightMapMemoryUsage: number;
        LightMapLightCount: number;
        TextureShadowMapMemoryUsage: number;
        VertexShadowMapMemoryUsage: number;
        ShadowMapLightCount: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshLightingInfo;

        static Load(InName: string): StaticMeshLightingInfo;
    }

    export class StaticMeshSimulationComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Simulating: boolean;
        bNotifyCollisions: boolean;
        ObjectType: EObjectStateTypeEnum;
        Mass: number;
        CollisionType: ECollisionTypeEnum;
        ImplicitType: EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        InitialVelocityType: EInitialVelocityTypeEnum;
        InitialLinearVelocity: Vector;
        InitialAngularVelocity: Vector;
        DamageThreshold: number;
        PhysicalMaterial: ChaosPhysicalMaterial;
        ChaosSolverActor: ChaosSolverActor;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
        SimulatedComponents: TArray<PrimitiveComponent>;

        ForceRecreatePhysicsState(): void;

        ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshSimulationComponent;

        static Load(InName: string): StaticMeshSimulationComponent;
    }

    export class StaticMeshThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StaticMeshThumbnailRenderer;

        static Load(InName: string): StaticMeshThumbnailRenderer;
    }

    export class EquirectProps {
        constructor();
        constructor(LeftUVRect: Box2D, RightUVRect: Box2D, LeftScale: Vector2D, RightScale: Vector2D, LeftBias: Vector2D, RightBias: Vector2D);

        LeftUVRect: Box2D;
        RightUVRect: Box2D;
        LeftScale: Vector2D;
        RightScale: Vector2D;
        LeftBias: Vector2D;
        RightBias: Vector2D;

        static StaticClass(): Class;
    }

    export enum EStereoLayerType { SLT_WorldLocked, SLT_TrackerLocked, SLT_FaceLocked, SLT_MAX }

    export enum EStereoLayerShape {
        SLSH_QuadLayer,
        SLSH_CylinderLayer,
        SLSH_CubemapLayer,
        SLSH_EquirectLayer,
        SLSH_MAX
    }

    export class StereoLayerShape extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StereoLayerShape;

        static Load(InName: string): StereoLayerShape;
    }

    export class StereoLayerComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bLiveTexture: boolean;
        bSupportsDepth: boolean;
        bNoAlphaChannel: boolean;
        Texture: Texture;
        LeftTexture: Texture;
        bQuadPreserveTextureRatio: boolean;
        QuadSize: Vector2D;
        UVRect: Box2D;
        CylinderRadius: number;
        CylinderOverlayArc: number;
        CylinderHeight: number;
        EquirectProps: EquirectProps;
        StereoLayerType: EStereoLayerType;
        StereoLayerShape: EStereoLayerShape;
        Shape: StereoLayerShape;
        Priority: number;

        GetLeftTexture(): Texture;

        GetPriority(): number;

        GetQuadSize(): Vector2D;

        GetTexture(): Texture;

        GetUVRect(): Box2D;

        MarkTextureForUpdate(): void;

        SetEquirectProps(InScaleBiases: EquirectProps): void;

        SetLeftTexture(InTexture: $Nullable<Texture>): void;

        SetPriority(InPriority: number): void;

        SetQuadSize(InQuadSize: Vector2D): void;

        SetTexture(InTexture: $Nullable<Texture>): void;

        SetUVRect(InUVRect: Box2D): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StereoLayerComponent;

        static Load(InName: string): StereoLayerComponent;
    }

    export class StereoLayerFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static EnableAutoLoadingSplashScreen(InAutoShowEnabled: boolean): void;

        static HideSplashScreen(): void;

        static SetSplashScreen(Texture: $Nullable<Texture>, Scale?: Vector2D /* = (X=1.000,Y=1.000) */, Offset?: Vector /* = 0.000000,0.000000,0.000000 */, bShowLoadingMovie?: boolean /* = false */, bShowOnSet?: boolean /* = false */): void;

        static ShowSplashScreen(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StereoLayerFunctionLibrary;

        static Load(InName: string): StereoLayerFunctionLibrary;
    }

    export class StereoLayerShapeCubemap extends StereoLayerShape {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StereoLayerShapeCubemap;

        static Load(InName: string): StereoLayerShapeCubemap;
    }

    export class StereoLayerShapeCylinder extends StereoLayerShape {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Radius: number;
        OverlayArc: number;
        Height: number;

        SetHeight(InHeight: number): void;

        SetOverlayArc(InOverlayArc: number): void;

        SetRadius(InRadius: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StereoLayerShapeCylinder;

        static Load(InName: string): StereoLayerShapeCylinder;
    }

    export class StereoLayerShapeEquirect extends StereoLayerShape {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LeftUVRect: Box2D;
        RightUVRect: Box2D;
        LeftScale: Vector2D;
        RightScale: Vector2D;
        LeftBias: Vector2D;
        RightBias: Vector2D;

        SetEquirectProps(InScaleBiases: EquirectProps): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StereoLayerShapeEquirect;

        static Load(InName: string): StereoLayerShapeEquirect;
    }

    export class StereoLayerShapeQuad extends StereoLayerShape {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StereoLayerShapeQuad;

        static Load(InName: string): StereoLayerShapeQuad;
    }

    export class StreamingSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AsyncLoadingThreadEnabled: boolean;
        WarnIfTimeLimitExceeded: boolean;
        TimeLimitExceededMultiplier: number;
        TimeLimitExceededMinTime: number;
        MinBulkDataSizeForAsyncLoading: number;
        UseBackgroundLevelStreaming: boolean;
        AsyncLoadingUseFullTimeLimit: boolean;
        AsyncLoadingTimeLimit: number;
        PriorityAsyncLoadingExtraTime: number;
        LevelStreamingActorsUpdateTimeLimit: number;
        PriorityLevelStreamingActorsUpdateExtraTime: number;
        LevelStreamingComponentsRegistrationGranularity: number;
        LevelStreamingUnregisterComponentsTimeLimit: number;
        LevelStreamingComponentsUnregistrationGranularity: number;
        FlushStreamingOnExit: boolean;
        EventDrivenLoaderEnabled: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StreamingSettings;

        static Load(InName: string): StreamingSettings;
    }

    export class StreamMediaSource extends BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        StreamUrl: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StreamMediaSource;

        static Load(InName: string): StreamMediaSource;
    }

    export class StretchGizmoHandleDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StretchGizmoHandleDragOperation;

        static Load(InName: string): StretchGizmoHandleDragOperation;
    }

    export class StringTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StringTable;

        static Load(InName: string): StringTable;
    }

    export class StringTableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StringTableFactory;

        static Load(InName: string): StringTableFactory;
    }

    export class StrProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StrProperty;

        static Load(InName: string): StrProperty;
    }

    export class StructureFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StructureFactory;

        static Load(InName: string): StructureFactory;
    }

    export enum EStructViewerDeveloperType { SVDT_None, SVDT_CurrentUser, SVDT_All, SVDT_Max, SVDT_MAX }

    export class StructViewerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DisplayInternalStructs: boolean;
        DeveloperFolderType: EStructViewerDeveloperType;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): StructViewerSettings;

        static Load(InName: string): StructViewerSettings;
    }

    export enum ESubmixEffectDynamicsProcessorType {
        Compressor,
        Limiter,
        Expander,
        Gate,
        Count,
        ESubmixEffectDynamicsProcessorType_MAX
    }

    export enum ESubmixEffectDynamicsPeakMode {
        MeanSquared,
        RootMeanSquared,
        Peak,
        Count,
        ESubmixEffectDynamicsPeakMode_MAX
    }

    export enum ESubmixEffectDynamicsChannelLinkMode {
        Disabled,
        Average,
        Peak,
        Count,
        ESubmixEffectDynamicsChannelLinkMode_MAX
    }

    export class SubmixEffectDynamicProcessorFilterSettings {
        constructor();
        constructor(bEnabled: boolean, Cutoff: number, GainDb: number);

        bEnabled: boolean;
        Cutoff: number;
        GainDb: number;

        static StaticClass(): Class;
    }

    export class SubmixEffectDynamicsProcessorSettings {
        constructor();
        constructor(DynamicsProcessorType: ESubmixEffectDynamicsProcessorType, PeakMode: ESubmixEffectDynamicsPeakMode, LinkMode: ESubmixEffectDynamicsChannelLinkMode, InputGainDb: number, ThresholdDb: number, Ratio: number, KneeBandwidthDb: number, LookAheadMsec: number, AttackTimeMsec: number, ReleaseTimeMsec: number, ExternalSubmix: SoundSubmix, bChannelLinked: boolean, bAnalogMode: boolean, bKeyAudition: boolean, KeyGainDb: number, OutputGainDb: number, KeyHighshelf: SubmixEffectDynamicProcessorFilterSettings, KeyLowshelf: SubmixEffectDynamicProcessorFilterSettings);

        DynamicsProcessorType: ESubmixEffectDynamicsProcessorType;
        PeakMode: ESubmixEffectDynamicsPeakMode;
        LinkMode: ESubmixEffectDynamicsChannelLinkMode;
        InputGainDb: number;
        ThresholdDb: number;
        Ratio: number;
        KneeBandwidthDb: number;
        LookAheadMsec: number;
        AttackTimeMsec: number;
        ReleaseTimeMsec: number;
        ExternalSubmix: SoundSubmix;
        bChannelLinked: boolean;
        bAnalogMode: boolean;
        bKeyAudition: boolean;
        KeyGainDb: number;
        OutputGainDb: number;
        KeyHighshelf: SubmixEffectDynamicProcessorFilterSettings;
        KeyLowshelf: SubmixEffectDynamicProcessorFilterSettings;

        static StaticClass(): Class;
    }

    export class SubmixEffectDynamicsProcessorPreset extends SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: SubmixEffectDynamicsProcessorSettings;

        SetExternalSubmix(Submix: $Nullable<SoundSubmix>): void;

        SetSettings(Settings: SubmixEffectDynamicsProcessorSettings): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubmixEffectDynamicsProcessorPreset;

        static Load(InName: string): SubmixEffectDynamicsProcessorPreset;
    }

    export class SubmixEffectReverbSettings {
        constructor();
        constructor(bBypassEarlyReflections: boolean, ReflectionsDelay: number, GainHF: number, ReflectionsGain: number, bBypassLateReflections: boolean, LateDelay: number, DecayTime: number, Density: number, Diffusion: number, AirAbsorptionGainHF: number, DecayHFRatio: number, LateGain: number, Gain: number, WetLevel: number, DryLevel: number, bBypass: boolean);

        bBypassEarlyReflections: boolean;
        ReflectionsDelay: number;
        GainHF: number;
        ReflectionsGain: number;
        bBypassLateReflections: boolean;
        LateDelay: number;
        DecayTime: number;
        Density: number;
        Diffusion: number;
        AirAbsorptionGainHF: number;
        DecayHFRatio: number;
        LateGain: number;
        Gain: number;
        WetLevel: number;
        DryLevel: number;
        bBypass: boolean;

        static StaticClass(): Class;
    }

    export class SubmixEffectReverbPreset extends SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: SubmixEffectReverbSettings;

        SetSettings(InSettings: SubmixEffectReverbSettings): void;

        SetSettingsWithReverbEffect(InReverbEffect: $Nullable<ReverbEffect>, WetLevel: number, DryLevel?: number /* = 0.000000 */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubmixEffectReverbPreset;

        static Load(InName: string): SubmixEffectReverbPreset;
    }

    export class SubmixEffectEQBand {
        constructor();
        constructor(Frequency: number, Bandwidth: number, GainDb: number, bEnabled: boolean);

        Frequency: number;
        Bandwidth: number;
        GainDb: number;
        bEnabled: boolean;

        static StaticClass(): Class;
    }

    export class SubmixEffectSubmixEQSettings {
        constructor();
        constructor(EQBands: TArray<SubmixEffectEQBand>);

        EQBands: TArray<SubmixEffectEQBand>;

        static StaticClass(): Class;
    }

    export class SubmixEffectSubmixEQPreset extends SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: SubmixEffectSubmixEQSettings;

        SetSettings(InSettings: SubmixEffectSubmixEQSettings): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubmixEffectSubmixEQPreset;

        static Load(InName: string): SubmixEffectSubmixEQPreset;
    }

    export class SubsurfaceProfileFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfileFactory;

        static Load(InName: string): SubsurfaceProfileFactory;
    }

    export class SubsurfaceProfileRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfileRenderer;

        static Load(InName: string): SubsurfaceProfileRenderer;
    }

    export class SubsystemBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetEngineSubsystem(Class: $Nullable<Class>): EngineSubsystem;

        static GetGameInstanceSubsystem(ContextObject: $Nullable<Object>, Class: $Nullable<Class>): GameInstanceSubsystem;

        static GetLocalPlayerSubsystem(ContextObject: $Nullable<Object>, Class: $Nullable<Class>): LocalPlayerSubsystem;

        static GetLocalPlayerSubSystemFromPlayerController(PlayerController: $Nullable<PlayerController>, Class: $Nullable<Class>): LocalPlayerSubsystem;

        static GetWorldSubsystem(ContextObject: $Nullable<Object>, Class: $Nullable<Class>): WorldSubsystem;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubsystemBlueprintLibrary;

        static Load(InName: string): SubsystemBlueprintLibrary;
    }

    export class SubUVAnimationFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialTexture: Texture2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SubUVAnimationFactory;

        static Load(InName: string): SubUVAnimationFactory;
    }

    export class SuperAnimationBP_C extends MWSysAnimInstance_Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UberGraphFrame: PointerToUberGraphFrame;
        AnimGraphNode_Root_2: AnimNode_Root;
        AnimGraphNode_LinkedInputPose_1: AnimNode_LinkedInputPose;
        AnimGraphNode_LinkedAnimGraph_1: AnimNode_LinkedAnimGraph;
        AnimGraphNode_SaveCachedPose_4: AnimNode_SaveCachedPose;
        AnimGraphNode_SaveCachedPose_3: AnimNode_SaveCachedPose;
        AnimGraphNode_BlendListByBool_3: AnimNode_BlendListByBool;
        AnimGraphNode_BlendListByBool_2: AnimNode_BlendListByBool;
        AnimGraphNode_LinkedInputPose: AnimNode_LinkedInputPose;
        AnimGraphNode_Root_1: AnimNode_Root;
        AnimGraphNode_LayeredBoneBlend_1: AnimNode_LayeredBoneBlend;
        AnimGraphNode_UseCachedPose_10: AnimNode_UseCachedPose;
        AnimGraphNode_UseCachedPose_9: AnimNode_UseCachedPose;
        AnimGraphNode_UseCachedPose_8: AnimNode_UseCachedPose;
        AnimGraphNode_UseCachedPose_7: AnimNode_UseCachedPose;
        AnimGraphNode_UseCachedPose_6: AnimNode_UseCachedPose;
        AnimGraphNode_Root: AnimNode_Root;
        AnimGraphNode_Slot_2: AnimNode_Slot;
        AnimGraphNode_LinkedAnimGraph: AnimNode_LinkedAnimGraph;
        AnimGraphNode_Slot_1: AnimNode_Slot;
        AnimGraphNode_Slot: AnimNode_Slot;
        AnimGraphNode_LayeredBoneBlend: AnimNode_LayeredBoneBlend;
        AnimGraphNode_SaveCachedPose_2: AnimNode_SaveCachedPose;
        AnimGraphNode_UseCachedPose_5: AnimNode_UseCachedPose;
        AnimGraphNode_UseCachedPose_4: AnimNode_UseCachedPose;
        AnimGraphNode_LinkedAnimLayer: AnimNode_LinkedAnimLayer;
        AnimGraphNode_SaveCachedPose_1: AnimNode_SaveCachedPose;
        AnimGraphNode_UseCachedPose_3: AnimNode_UseCachedPose;
        AnimGraphNode_BlendListByBool_1: AnimNode_BlendListByBool;
        AnimGraphNode_UseCachedPose_2: AnimNode_UseCachedPose;
        AnimGraphNode_ComponentToLocalSpace: AnimNode_ConvertComponentToLocalSpace;
        AnimGraphNode_ModifyBone_22: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_21: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_20: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_19: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_18: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_17: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_16: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_15: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_14: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_13: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_12: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_11: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_10: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_9: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_8: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_7: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_6: AnimNode_ModifyBone;
        AnimGraphNode_LocalToComponentSpace: AnimNode_ConvertLocalToComponentSpace;
        AnimGraphNode_ModifyBone_5: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_4: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_3: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_2: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone_1: AnimNode_ModifyBone;
        AnimGraphNode_ModifyBone: AnimNode_ModifyBone;
        AnimGraphNode_BlendListByBool: AnimNode_BlendListByBool;
        AnimGraphNode_SaveCachedPose: AnimNode_SaveCachedPose;
        AnimGraphNode_UseCachedPose_1: AnimNode_UseCachedPose;
        AnimGraphNode_UseCachedPose: AnimNode_UseCachedPose;
        IsMoving: boolean;
        BlendUpper: boolean;
        BlendLower: boolean;
        IsPlayMontage: boolean;

        AnimationInterfaceStance(Input1: PoseLink, InSpeed: number, InDirection: number, InPitch: number, AnimationInterfaceStance: $Ref<PoseLink>): void;

        AnimGraph(AnimGraph: $Ref<PoseLink>): void;

        BlueprintUpdateAnimation(DeltaTimeX: number): void;

        DriveStance(Stance: $Nullable<MWSysAnimInstance_StanceBase>): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_BlendListByBool_16656D9140BCEA5774EA5CAC60C0717C(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_BlendListByBool_7024C878490CBBCA3D7554A3EB40FE1A(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_BlendListByBool_916D149D4802A55B43B84EABCFDB8F51(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_BlendListByBool_B84728E144C47F9F630A52A87A938AA4(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_085345A34513EE8C46FA67A8F2A412D4(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_25F9A9CA424016B8E1460E98D085BFD4(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_293959474EE287A3E8E682A0809524D0(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_328738E840CA4118B7CD3387EAC9DDBE(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_3B18368C4134380A64E179A5A2737F24(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_56ACDC61431B3CEB1B4663AA7500786E(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_66F22A0743A8039B83EF56957C747B6B(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_6AEF86864E977F91182C91886D3C862A(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_813E024441FEA63AAA5A08B312B3B9C8(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_8E6EDE8340BC334B28953CA3B8F8E9DA(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_95A458F1478FFEF4F8578DA2C3C67875(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_9A1308E6454B17689EF55DB5EBDCBD0A(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_A35FCC03450B1CF6E2D27E9F73B01968(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_A3D4B1A94DDFA290D5657A939D90CBE5(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_B1A32CC04D27E1A2CA1AD79FB4E35516(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_BE13707749DD48326AE3CB9689BE4BB8(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_BEF4F7F944071EF3C97A2D85444D06BA(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_D147A82B4E726BAC62DD02BA8B122905(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_D3792E1C43518004E49C53A583FA3CBE(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_E22860D04E8E9986CBB8ABA297A5ED91(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_F34C6A474722D70819E9E28ECEF7D0E0(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_F7237C834D09F363B79EC3A6309D31E1(): void;

        EvaluateGraphExposedInputs_ExecuteUbergraph_SuperAnimationBP_AnimGraphNode_ModifyBone_FAAFA82E408A1863EEB81192C56912EB(): void;

        ExecuteUbergraph_SuperAnimationBP(EntryPoint: number): void;

        StanceLayer(InPose: PoseLink, StanceLayer: $Ref<PoseLink>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SuperAnimationBP_C;

        static Load(InName: string): SuperAnimationBP_C;
    }

    export class SwapSoundForDialogueInCuesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SwapSoundForDialogueInCuesCommandlet;

        static Load(InName: string): SwapSoundForDialogueInCuesCommandlet;
    }

    export class SynthComponentClassTemplate extends ClassTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SynthComponentClassTemplate;

        static Load(InName: string): SynthComponentClassTemplate;
    }

    export class SysDirectionalLight extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DirectionalLightComponent: DirectionalLightComponent;
        Intensity: number;
        LightColor: LinearColor;
        bCastShadows: boolean;
        DynamicShadowDistance: number;
        Temperature: number;
        bUseTemperature: boolean;
        PitchAngle: number;
        YawAngle: number;

        GetCastShadows(): boolean;

        GetDirectionalLightComponent(): DirectionalLightComponent;

        GetIntensity(): number;

        GetPitchAngle(): number;

        GetSysLightColor(): LinearColor;

        GetTemperature(): number;

        GetUseTemperature(): boolean;

        GetYawAngle(): number;

        MarkRenderStateDirty(): void;

        OnRep_Refresh(): void;

        OnRep_RefreshPitchAngle(): void;

        OnRep_RefreshShadow(): void;

        OnRep_RefreshTemperature(): void;

        OnRep_RefreshUseTemperature(): void;

        OnRep_RefreshYawAngle(): void;

        SetIntensity(NewIntensity: number): void;

        SetPitchAngle(Value: number): void;

        SetSysCastShadows(NewCastShadows: boolean): void;

        SetSysLightColor(NewLightColor: LinearColor): void;

        SetTemperature(Value: number): void;

        SetUseTemperature(Value: boolean): void;

        SetYawAngle(Value: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SysDirectionalLight;

        static Load(InName: string): SysDirectionalLight;
    }

    export enum EMWSysSkyLightSourceType { CaptureScene, CaptureCubemap, EMWSysSkyLightSourceType_MAX }

    export class SysSkyLight extends MWActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IntensityScale: number;
        LightColor: LinearColor;
        bRealTimeCapture: boolean;
        SkyLightSourceType: EMWSysSkyLightSourceType;
        CubeMapAssetRecorder: MWAssetRecorder;
        CubeMap: TextureCube;
        CubeMapAssetID: string;
        CubemapResolution: number;
        SkyLightComponent: SkyLightComponent;

        ClampCubemapResolution(InCubemapResolution: number): number;

        GetCubemapResolution(): number;

        GetIntensityScale(): number;

        GetLightColor(): LinearColor;

        GetRealTimeCapture(): boolean;

        GetSkyLightSourceType(): EMWSysSkyLightSourceType;

        MarkRenderStateDirty(): void;

        OnRep_Refresh(): void;

        SetCubemapResolution(NewResolution: number): void;

        SetIntensityScale(NewIntensityScale: number): void;

        SetLightColor(NewLightColor: LinearColor): void;

        SetRealTimeCapture(bInRealTimeCapture: boolean): void;

        SetSkylightSourceType(NewSourceType: EMWSysSkyLightSourceType): void;

        static GetTextureCubeByID(ID: string): TextureCube;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SysSkyLight;

        static Load(InName: string): SysSkyLight;
    }

    export class SystemTimeTimecodeProvider extends TimecodeProvider {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FrameRate: FrameRate;
        bGenerateFullFrame: boolean;
        bUseHighPerformanceClock: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): SystemTimeTimecodeProvider;

        static Load(InName: string): SystemTimeTimecodeProvider;
    }

    export class TargetPoint extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SpriteComponent: BillboardComponent;
        ArrowComponent: ArrowComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TargetPoint;

        static Load(InName: string): TargetPoint;
    }

    export class TcpMessagingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EnableTransport: boolean;
        ListenEndpoint: string;
        ConnectToEndpoints: TArray<string>;
        ConnectionRetryDelay: number;
        bStopServiceWhenAppDeactivates: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TcpMessagingSettings;

        static Load(InName: string): TcpMessagingSettings;
    }

    export class TemplateBindingGenerator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Gen(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TemplateBindingGenerator;

        static Load(InName: string): TemplateBindingGenerator;
    }

    export class TemplateCategoryDef {
        constructor();
        constructor(Key: string, LocalizedDisplayNames: TArray<LocalizedTemplateString>, LocalizedDescriptions: TArray<LocalizedTemplateString>, Icon: string, IsMajorCategory: boolean);

        Key: string;
        LocalizedDisplayNames: TArray<LocalizedTemplateString>;
        LocalizedDescriptions: TArray<LocalizedTemplateString>;
        Icon: string;
        IsMajorCategory: boolean;

        static StaticClass(): Class;
    }

    export class TemplateCategories extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Categories: TArray<TemplateCategoryDef>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TemplateCategories;

        static Load(InName: string): TemplateCategories;
    }

    export class TemplateMapMetadata extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TemplateMapMetadata;

        static Load(InName: string): TemplateMapMetadata;
    }

    export class TestBeaconClient extends OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ClientPing(): void;

        ServerPong(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBeaconClient;

        static Load(InName: string): TestBeaconClient;
    }

    export class TestBeaconHost extends OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBeaconHost;

        static Load(InName: string): TestBeaconHost;
    }

    export class TestBTDecorator_Blackboard extends BTDecorator_Blackboard {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LogIndexBecomeRelevant: number;
        LogIndexCeaseRelevant: number;
        LogIndexCalculate: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBTDecorator_Blackboard;

        static Load(InName: string): TestBTDecorator_Blackboard;
    }

    export class TestBTDecorator_CantExecute extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBTDecorator_CantExecute;

        static Load(InName: string): TestBTDecorator_CantExecute;
    }

    export class TestBTDecorator_DelayedAbort extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DelayTicks: number;
        bOnlyOnce: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBTDecorator_DelayedAbort;

        static Load(InName: string): TestBTDecorator_DelayedAbort;
    }

    export class TestBTService_Log extends BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LogActivation: number;
        LogDeactivation: number;
        KeyNameTick: string;
        LogTick: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBTService_Log;

        static Load(InName: string): TestBTService_Log;
    }

    export class TestBTTask_LatentWithFlags extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LogIndexExecuteStart: number;
        LogIndexExecuteFinish: number;
        LogIndexAbortStart: number;
        LogIndexAbortFinish: number;
        ExecuteTicks: number;
        AbortTicks: number;
        KeyNameExecute: string;
        KeyNameAbort: string;
        LogResult: EBTNodeResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBTTask_LatentWithFlags;

        static Load(InName: string): TestBTTask_LatentWithFlags;
    }

    export class TestBTTask_Log extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LogIndex: number;
        LogFinished: number;
        ExecutionTicks: number;
        LogResult: EBTNodeResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBTTask_Log;

        static Load(InName: string): TestBTTask_Log;
    }

    export class TestBTTask_SetFlag extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        KeyName: string;
        bValue: boolean;
        TaskResult: EBTNodeResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBTTask_SetFlag;

        static Load(InName: string): TestBTTask_SetFlag;
    }

    export class TestBTTask_SetValue extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        KeyName: string;
        Value: number;
        TaskResult: EBTNodeResult;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestBTTask_SetValue;

        static Load(InName: string): TestBTTask_SetValue;
    }

    export class TestMovieSceneSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestMovieSceneSection;

        static Load(InName: string): TestMovieSceneSection;
    }

    export class TestMovieSceneSequence extends MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MovieScene: MovieScene;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestMovieSceneSequence;

        static Load(InName: string): TestMovieSceneSequence;
    }

    export class TestMovieSceneSubSection extends MovieSceneSubSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestMovieSceneSubSection;

        static Load(InName: string): TestMovieSceneSubSection;
    }

    export class TestMovieSceneSubTrack extends MovieSceneSubTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SectionArray: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestMovieSceneSubTrack;

        static Load(InName: string): TestMovieSceneSubTrack;
    }

    export class TestMovieSceneTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bHighPassFilter: boolean;
        SectionArray: TArray<MovieSceneSection>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestMovieSceneTrack;

        static Load(InName: string): TestMovieSceneTrack;
    }

    export class TestPawnAction_Log extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestPawnAction_Log;

        static Load(InName: string): TestPawnAction_Log;
    }

    export class TestPawnAction_CallFunction extends TestPawnAction_Log {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestPawnAction_CallFunction;

        static Load(InName: string): TestPawnAction_CallFunction;
    }

    export class TestPhaseComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestPhaseComponent;

        static Load(InName: string): TestPhaseComponent;
    }

    export class TestSparseClassDataBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestSparseClassDataBase;

        static Load(InName: string): TestSparseClassDataBase;
    }

    export class TestSparseClassData extends TestSparseClassDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TestSparseClassData;

        static Load(InName: string): TestSparseClassData;
    }

    export class TetrahedronBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Radius: number;
        SphereExtrapolation: number;
        GroupName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TetrahedronBuilder;

        static Load(InName: string): TetrahedronBuilder;
    }

    export enum ETexAlign {
        TEXALIGN_None,
        TEXALIGN_Default,
        TEXALIGN_Box,
        TEXALIGN_Planar,
        TEXALIGN_Fit,
        TEXALIGN_PlanarAuto,
        TEXALIGN_PlanarWall,
        TEXALIGN_PlanarFloor,
        TEXALIGN_MAX
    }

    export class TexAligner extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefTexAlign: ETexAlign;
        TAxis: number;
        UTile: number;
        VTile: number;
        Desc: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TexAligner;

        static Load(InName: string): TexAligner;
    }

    export class TexAlignerBox extends TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TexAlignerBox;

        static Load(InName: string): TexAlignerBox;
    }

    export class TexAlignerDefault extends TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TexAlignerDefault;

        static Load(InName: string): TexAlignerDefault;
    }

    export class TexAlignerFit extends TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TexAlignerFit;

        static Load(InName: string): TexAlignerFit;
    }

    export class TexAlignerPlanar extends TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TexAlignerPlanar;

        static Load(InName: string): TexAlignerPlanar;
    }

    export class TextAssetCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextAssetCommandlet;

        static Load(InName: string): TextAssetCommandlet;
    }

    export class TextBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetStringValue(): string;

        GetTextValue(): string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextBinding;

        static Load(InName: string): TextBinding;
    }

    export class TextBlockWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextBlockStyle: TextBlockStyle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextBlockWidgetStyle;

        static Load(InName: string): TextBlockWidgetStyle;
    }

    export class TextBuffer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextBuffer;

        static Load(InName: string): TextBuffer;
    }

    export class TextBufferExporterTXT extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextBufferExporterTXT;

        static Load(InName: string): TextBufferExporterTXT;
    }

    export class TextProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextProperty;

        static Load(InName: string): TextProperty;
    }

    export class TextPropertyTestObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultedText: string;
        UndefaultedText: string;
        TransientText: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextPropertyTestObject;

        static Load(InName: string): TextPropertyTestObject;
    }

    export class TextRenderActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TextRender: TextRenderComponent;
        SpriteComponent: BillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextRenderActor;

        static Load(InName: string): TextRenderActor;
    }

    export class Texture2DArrayFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialTextures: TArray<Texture2D>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Texture2DArrayFactory;

        static Load(InName: string): Texture2DArrayFactory;
    }

    export class Texture2DArrayThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Texture2DArrayThumbnailRenderer;

        static Load(InName: string): Texture2DArrayThumbnailRenderer;
    }

    export class Texture2DFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Width: number;
        Height: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Texture2DFactoryNew;

        static Load(InName: string): Texture2DFactoryNew;
    }

    export class TextureCubeExporterHDR extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureCubeExporterHDR;

        static Load(InName: string): TextureCubeExporterHDR;
    }

    export class TextureCubeThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureCubeThumbnailRenderer;

        static Load(InName: string): TextureCubeThumbnailRenderer;
    }

    export class TextureExporterBMP extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureExporterBMP;

        static Load(InName: string): TextureExporterBMP;
    }

    export class TextureExporterHDR extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureExporterHDR;

        static Load(InName: string): TextureExporterHDR;
    }

    export class TextureExporterPCX extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureExporterPCX;

        static Load(InName: string): TextureExporterPCX;
    }

    export class TextureExporterTGA extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureExporterTGA;

        static Load(InName: string): TextureExporterTGA;
    }

    export class TextureImportSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AutoVTSize: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureImportSettings;

        static Load(InName: string): TextureImportSettings;
    }

    export class TextureMipDataProviderFactory extends AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureMipDataProviderFactory;

        static Load(InName: string): TextureMipDataProviderFactory;
    }

    export class TextureRenderTarget2DArrayFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Width: number;
        Height: number;
        Slices: number;
        Format: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTarget2DArrayFactoryNew;

        static Load(InName: string): TextureRenderTarget2DArrayFactoryNew;
    }

    export class TextureRenderTargetCubeFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Width: number;
        Format: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetCubeFactoryNew;

        static Load(InName: string): TextureRenderTargetCubeFactoryNew;
    }

    export class TextureRenderTargetFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Width: number;
        Height: number;
        Format: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetFactoryNew;

        static Load(InName: string): TextureRenderTargetFactoryNew;
    }

    export class TextureRenderTargetVolumeFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Width: number;
        Height: number;
        Depth: number;
        Format: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetVolumeFactoryNew;

        static Load(InName: string): TextureRenderTargetVolumeFactoryNew;
    }

    export class TextureStats extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Texture: TWeakObjectPtr<Texture>;
        Actors: TArray<TWeakObjectPtr<Actor>>;
        Type: string;
        MaxDim: Vector2D;
        CurrentDim: Vector2D;
        Format: EPixelFormat;
        Group: TextureGroup;
        LODBias: number;
        CurrentKB: number;
        FullyLoadedKB: number;
        NumUses: number;
        LastTimeRendered: number;
        Path: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TextureStats;

        static Load(InName: string): TextureStats;
    }

    export class Throbber extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        NumberOfPieces: number;
        bAnimateHorizontally: boolean;
        bAnimateVertically: boolean;
        bAnimateOpacity: boolean;
        PieceImage: SlateBrushAsset;
        Image: SlateBrush;

        SetAnimateHorizontally(bInAnimateHorizontally: boolean): void;

        SetAnimateOpacity(bInAnimateOpacity: boolean): void;

        SetAnimateVertically(bInAnimateVertically: boolean): void;

        SetNumberOfPieces(InNumberOfPieces: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Throbber;

        static Load(InName: string): Throbber;
    }

    export class ThumbnailRenderingInfo {
        constructor();
        constructor(ClassNeedingThumbnailName: string, ClassNeedingThumbnail: Class, RendererClassName: string, Renderer: ThumbnailRenderer);

        ClassNeedingThumbnailName: string;
        ClassNeedingThumbnail: Class;
        RendererClassName: string;
        Renderer: ThumbnailRenderer;

        static StaticClass(): Class;
    }

    export class ThumbnailManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RenderableThumbnailTypes: TArray<ThumbnailRenderingInfo>;
        NotSupported: ThumbnailRenderingInfo;
        EditorCube: StaticMesh;
        EditorSphere: StaticMesh;
        EditorCylinder: StaticMesh;
        EditorPlane: StaticMesh;
        EditorSkySphere: StaticMesh;
        FloorPlaneMaterial: Material;
        AmbientCubemap: TextureCube;
        CheckerboardTexture: Texture2D;
        ThumbnailManagerClassName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ThumbnailManager;

        static Load(InName: string): ThumbnailManager;
    }

    export class TickableAttributeSetInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TickableAttributeSetInterface;

        static Load(InName: string): TickableAttributeSetInterface;
    }

    export enum EListItemAlignment {
        EvenlyDistributed,
        EvenlySize,
        EvenlyWide,
        LeftAligned,
        RightAligned,
        CenterAligned,
        Fill,
        EListItemAlignment_MAX
    }

    export class TileView extends ListView {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EntryHeight: number;
        EntryWidth: number;
        TileAlignment: EListItemAlignment;
        bWrapHorizontalNavigation: boolean;

        GetEntryHeight(): number;

        GetEntryWidth(): number;

        SetEntryHeight(NewHeight: number): void;

        SetEntryWidth(NewWidth: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TileView;

        static Load(InName: string): TileView;
    }

    export class TimelineEventEntry {
        constructor();
        constructor(Time: number, EventFunc: $Delegate<() => void>);

        Time: number;
        EventFunc: $Delegate<() => void>;

        static StaticClass(): Class;
    }

    export class TimelineVectorTrack {
        constructor();
        constructor(VectorCurve: CurveVector, InterpFunc: $Delegate<(Output: Vector) => void>, TrackName: string, VectorPropertyName: string);

        VectorCurve: CurveVector;
        InterpFunc: $Delegate<(Output: Vector) => void>;
        TrackName: string;
        VectorPropertyName: string;

        static StaticClass(): Class;
    }

    export class TimelineFloatTrack {
        constructor();
        constructor(FloatCurve: CurveFloat, InterpFunc: $Delegate<(Output: number) => void>, TrackName: string, FloatPropertyName: string);

        FloatCurve: CurveFloat;
        InterpFunc: $Delegate<(Output: number) => void>;
        TrackName: string;
        FloatPropertyName: string;

        static StaticClass(): Class;
    }

    export class TimelineLinearColorTrack {
        constructor();
        constructor(LinearColorCurve: CurveLinearColor, InterpFunc: $Delegate<(Output: LinearColor) => void>, TrackName: string, LinearColorPropertyName: string);

        LinearColorCurve: CurveLinearColor;
        InterpFunc: $Delegate<(Output: LinearColor) => void>;
        TrackName: string;
        LinearColorPropertyName: string;

        static StaticClass(): Class;
    }

    export class Timeline {
        constructor();
        constructor(LengthMode: ETimelineLengthMode, bLooping: boolean, bReversePlayback: boolean, bPlaying: boolean, Length: number, PlayRate: number, Position: number, Events: TArray<TimelineEventEntry>, InterpVectors: TArray<TimelineVectorTrack>, InterpFloats: TArray<TimelineFloatTrack>, InterpLinearColors: TArray<TimelineLinearColorTrack>, TimelinePostUpdateFunc: $Delegate<() => void>, TimelineFinishedFunc: $Delegate<() => void>, PropertySetObject: TWeakObjectPtr<Object>, DirectionPropertyName: string);

        LengthMode: ETimelineLengthMode;
        bLooping: boolean;
        bReversePlayback: boolean;
        bPlaying: boolean;
        Length: number;
        PlayRate: number;
        Position: number;
        Events: TArray<TimelineEventEntry>;
        InterpVectors: TArray<TimelineVectorTrack>;
        InterpFloats: TArray<TimelineFloatTrack>;
        InterpLinearColors: TArray<TimelineLinearColorTrack>;
        TimelinePostUpdateFunc: $Delegate<() => void>;
        TimelineFinishedFunc: $Delegate<() => void>;
        PropertySetObject: TWeakObjectPtr<Object>;
        DirectionPropertyName: string;

        static StaticClass(): Class;
    }

    export class TimelineComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TheTimeline: Timeline;
        bIgnoreTimeDilation: boolean;

        GetIgnoreTimeDilation(): boolean;

        GetPlaybackPosition(): number;

        GetPlayRate(): number;

        GetTimelineLength(): number;

        IsLooping(): boolean;

        IsPlaying(): boolean;

        IsReversing(): boolean;

        OnRep_Timeline(): void;

        Play(): void;

        PlayFromStart(): void;

        Reverse(): void;

        ReverseFromEnd(): void;

        SetFloatCurve(NewFloatCurve: $Nullable<CurveFloat>, FloatTrackName: string): void;

        SetIgnoreTimeDilation(bNewIgnoreTimeDilation: boolean): void;

        SetLinearColorCurve(NewLinearColorCurve: $Nullable<CurveLinearColor>, LinearColorTrackName: string): void;

        SetLooping(bNewLooping: boolean): void;

        SetNewTime(NewTime: number): void;

        SetPlaybackPosition(NewPosition: number, bFireEvents: boolean, bFireUpdate?: boolean /* = true */): void;

        SetPlayRate(NewRate: number): void;

        SetTimelineLength(NewLength: number): void;

        SetTimelineLengthMode(NewLengthMode: ETimelineLengthMode): void;

        SetVectorCurve(NewVectorCurve: $Nullable<CurveVector>, VectorTrackName: string): void;

        Stop(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TimelineComponent;

        static Load(InName: string): TimelineComponent;
    }

    export class TimeManagementBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static Add_FrameNumberFrameNumber(A: FrameNumber, B: FrameNumber): FrameNumber;

        static Add_FrameNumberInteger(A: FrameNumber, B: number): FrameNumber;

        static Conv_FrameNumberToInteger(InFrameNumber: FrameNumber): number;

        static Conv_FrameRateToSeconds(InFrameRate: FrameRate): number;

        static Conv_QualifiedFrameTimeToSeconds(InFrameTime: QualifiedFrameTime): number;

        static Conv_TimecodeToString(InTimecode: Timecode, bForceSignDisplay?: boolean /* = false */): string;

        static Divide_FrameNumberInteger(A: FrameNumber, B: number): FrameNumber;

        static GetTimecode(): Timecode;

        static GetTimecodeFrameRate(): FrameRate;

        static IsValid_Framerate(InFrameRate: FrameRate): boolean;

        static IsValid_MultipleOf(InFrameRate: FrameRate, OtherFramerate: FrameRate): boolean;

        static Multiply_FrameNumberInteger(A: FrameNumber, B: number): FrameNumber;

        static Multiply_SecondsFrameRate(TimeInSeconds: number, FrameRate: FrameRate): FrameTime;

        static SnapFrameTimeToRate(SourceTime: FrameTime, SourceRate: FrameRate, SnapToRate: FrameRate): FrameTime;

        static Subtract_FrameNumberFrameNumber(A: FrameNumber, B: FrameNumber): FrameNumber;

        static Subtract_FrameNumberInteger(A: FrameNumber, B: number): FrameNumber;

        static TransformTime(SourceTime: FrameTime, SourceRate: FrameRate, DestinationRate: FrameRate): FrameTime;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TimeManagementBlueprintLibrary;

        static Load(InName: string): TimeManagementBlueprintLibrary;
    }

    export class TimeSynchronizableMediaSource extends BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseTimeSynchronization: boolean;
        FrameDelay: number;
        TimeDelay: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TimeSynchronizableMediaSource;

        static Load(InName: string): TimeSynchronizableMediaSource;
    }

    export class TimeSynchronizationSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseForSynchronization: boolean;
        FrameOffset: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TimeSynchronizationSource;

        static Load(InName: string): TimeSynchronizationSource;
    }

    export class ToFloatField extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IntField: FieldNodeInt;

        SetToFloatField(IntegerField: $Nullable<FieldNodeInt>): ToFloatField;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToFloatField;

        static Load(InName: string): ToFloatField;
    }

    export class ToIntegerField extends FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FloatField: FieldNodeFloat;

        SetToIntegerField(FloatField: $Nullable<FieldNodeFloat>): ToIntegerField;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToIntegerField;

        static Load(InName: string): ToIntegerField;
    }

    export class ToolFrameworkComponent extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolFrameworkComponent;

        static Load(InName: string): ToolFrameworkComponent;
    }

    export class ToolMenuContextExtensions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static FindByClass(Context: ToolMenuContext, InClass: $Nullable<Class>): Object;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenuContextExtensions;

        static Load(InName: string): ToolMenuContextExtensions;
    }

    export enum EToolMenuStringCommandType { Command, Python, Custom, EToolMenuStringCommandType_MAX }

    export class ToolMenuStringCommand {
        constructor();
        constructor(Type: EToolMenuStringCommandType, CustomType: string, String: string);

        Type: EToolMenuStringCommandType;
        CustomType: string;
        String: string;

        static StaticClass(): Class;
    }

    export class ToolMenuEntryExtensions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static BreakScriptSlateIcon(InValue: ScriptSlateIcon, StyleSetName: $Ref<string>, StyleName: $Ref<string>, SmallStyleName: $Ref<string>): void;

        static BreakStringCommand(InValue: ToolMenuStringCommand, Type: $Ref<EToolMenuStringCommandType>, CustomType: $Ref<string>, String: $Ref<string>): void;

        static BreakToolMenuOwner(InValue: ToolMenuOwner, Name: $Ref<string>): void;

        static GetLabel(Target: ToolMenuEntry): string;

        static GetToolTip(Target: ToolMenuEntry): string;

        static InitMenuEntry(InOwner: string, InName: string, InLabel: string, InToolTip: string, CommandType: EToolMenuStringCommandType, CustomCommandType: string, CommandString: string): ToolMenuEntry;

        static MakeScriptSlateIcon(StyleSetName: string, StyleName: string, SmallStyleName?: string /* = "None" */): ScriptSlateIcon;

        static MakeStringCommand(Type: EToolMenuStringCommandType, CustomType: string, String: string): ToolMenuStringCommand;

        static MakeToolMenuOwner(Name: string): ToolMenuOwner;

        static SetIcon(Target: $Ref<ToolMenuEntry>, StyleSetName: string, StyleName?: string /* = "None" */, SmallStyleName?: string /* = "None" */): void;

        static SetLabel(Target: $Ref<ToolMenuEntry>, Label: string): void;

        static SetStringCommand(Target: $Ref<ToolMenuEntry>, Type: EToolMenuStringCommandType, CustomType: string, String: string): void;

        static SetToolTip(Target: $Ref<ToolMenuEntry>, ToolTip: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenuEntryExtensions;

        static Load(InName: string): ToolMenuEntryExtensions;
    }

    export enum ECustomizedToolMenuVisibility { None, Visible, Hidden, ECustomizedToolMenuVisibility_MAX }

    export class CustomizedToolMenuEntry {
        constructor();
        constructor(Visibility: ECustomizedToolMenuVisibility);

        Visibility: ECustomizedToolMenuVisibility;

        static StaticClass(): Class;
    }

    export class CustomizedToolMenuSection {
        constructor();
        constructor(Visibility: ECustomizedToolMenuVisibility);

        Visibility: ECustomizedToolMenuVisibility;

        static StaticClass(): Class;
    }

    export class CustomizedToolMenuNameArray {
        constructor();
        constructor(Names: TArray<string>);

        Names: TArray<string>;

        static StaticClass(): Class;
    }

    export class CustomizedToolMenu {
        constructor();
        constructor(Name: string, Entries: TMap<string, CustomizedToolMenuEntry>, Sections: TMap<string, CustomizedToolMenuSection>, EntryOrder: TMap<string, CustomizedToolMenuNameArray>, SectionOrder: TArray<string>);

        Name: string;
        Entries: TMap<string, CustomizedToolMenuEntry>;
        Sections: TMap<string, CustomizedToolMenuSection>;
        EntryOrder: TMap<string, CustomizedToolMenuNameArray>;
        SectionOrder: TArray<string>;

        static StaticClass(): Class;
    }

    export class ToolMenus extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CustomizedMenus: TArray<CustomizedToolMenu>;
        MenuSubstitutionsDuringGenerate: TMap<string, string>;
        Menus: TMap<string, ToolMenu>;

        ExtendMenu(Name: string): ToolMenu;

        FindMenu(Name: string): ToolMenu;

        IsMenuRegistered(Name: string): boolean;

        RefreshAllWidgets(): void;

        RefreshMenuWidget(Name: string): boolean;

        RegisterMenu(Name: string, Parent?: string /* = "None" */, Type?: EMultiBoxType /* = Menu */, bWarnIfAlreadyRegistered?: boolean /* = true */): ToolMenu;

        RemoveEntry(MenuName: string, Section: string, Name: string): void;

        RemoveMenu(MenuName: string): void;

        RemoveSection(MenuName: string, Section: string): void;

        SetSectionLabel(MenuName: string, SectionName: string, Label: string): void;

        SetSectionPosition(MenuName: string, SectionName: string, OtherSectionName: string, PositionType: EToolMenuInsertType): void;

        UnregisterOwnerByName(InOwnerName: string): void;

        static AddMenuEntryObject(MenuEntryObject: $Nullable<ToolMenuEntryScript>): boolean;

        static FindContext(InContext: ToolMenuContext, InClass: $Nullable<Class>): Object;

        static Get(): ToolMenus;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenus;

        static Load(InName: string): ToolMenus;
    }

    export class ToolMenuSectionExtensions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddEntry(Section: $Ref<ToolMenuSection>, Args: ToolMenuEntry): void;

        static AddEntryObject(Section: $Ref<ToolMenuSection>, InObject: $Nullable<ToolMenuEntryScript>): void;

        static GetLabel(Section: ToolMenuSection): string;

        static SetLabel(Section: $Ref<ToolMenuSection>, Label: string): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ToolMenuSectionExtensions;

        static Load(InName: string): ToolMenuSectionExtensions;
    }

    export class TouchInterfaceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TouchInterfaceFactory;

        static Load(InName: string): TouchInterfaceFactory;
    }

    export class TransBuffer extends Transactor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TransBuffer;

        static Load(InName: string): TransBuffer;
    }

    export enum EToolContextCoordinateSystem { World, Local, EToolContextCoordinateSystem_MAX }

    export class TransformGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActiveTarget: TransformProxy;
        bSnapToWorldGrid: boolean;
        bGridSizeIsExplicit: boolean;
        ExplicitGridSize: Vector;
        bRotationGridSizeIsExplicit: boolean;
        ExplicitRotationGridSize: Rotator;
        bSnapToWorldRotGrid: boolean;
        bUseContextCoordinateSystem: boolean;
        CurrentCoordinateSystem: EToolContextCoordinateSystem;
        ActiveComponents: TArray<PrimitiveComponent>;
        NonuniformScaleComponents: TArray<PrimitiveComponent>;
        ActiveGizmos: TArray<InteractiveGizmo>;
        CameraAxisSource: GizmoConstantFrameAxisSource;
        AxisXSource: GizmoComponentAxisSource;
        AxisYSource: GizmoComponentAxisSource;
        AxisZSource: GizmoComponentAxisSource;
        UnitAxisXSource: GizmoComponentAxisSource;
        UnitAxisYSource: GizmoComponentAxisSource;
        UnitAxisZSource: GizmoComponentAxisSource;
        StateTarget: GizmoTransformChangeStateTarget;
        ScaledTransformSource: GizmoScaledTransformSource;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TransformGizmo;

        static Load(InName: string): TransformGizmo;
    }

    export class TransformGizmoActor extends GizmoActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TranslateX: PrimitiveComponent;
        TranslateY: PrimitiveComponent;
        TranslateZ: PrimitiveComponent;
        TranslateYZ: PrimitiveComponent;
        TranslateXZ: PrimitiveComponent;
        TranslateXY: PrimitiveComponent;
        RotateX: PrimitiveComponent;
        RotateY: PrimitiveComponent;
        RotateZ: PrimitiveComponent;
        UniformScale: PrimitiveComponent;
        AxisScaleX: PrimitiveComponent;
        AxisScaleY: PrimitiveComponent;
        AxisScaleZ: PrimitiveComponent;
        PlaneScaleYZ: PrimitiveComponent;
        PlaneScaleXZ: PrimitiveComponent;
        PlaneScaleXY: PrimitiveComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TransformGizmoActor;

        static Load(InName: string): TransformGizmoActor;
    }

    export class TransformGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TransformGizmoBuilder;

        static Load(InName: string): TransformGizmoBuilder;
    }

    export class TranslationDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TranslationDragOperation;

        static Load(InName: string): TranslationDragOperation;
    }

    export class TranslationPickerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bSubmitTranslationPickerChangesToLocalizationService: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TranslationPickerSettings;

        static Load(InName: string): TranslationPickerSettings;
    }

    export class TranslationChange {
        constructor();
        constructor(Version: string, DateAndTime: DateTime, Source: string, Translation: string);

        Version: string;
        DateAndTime: DateTime;
        Source: string;
        Translation: string;

        static StaticClass(): Class;
    }

    export class TranslationContextInfo {
        constructor();
        constructor(Key: string, Context: string, Changes: TArray<TranslationChange>);

        Key: string;
        Context: string;
        Changes: TArray<TranslationChange>;

        static StaticClass(): Class;
    }

    export class TranslationUnit extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Namespace: string;
        Key: string;
        Source: string;
        Translation: string;
        Contexts: TArray<TranslationContextInfo>;
        HasBeenReviewed: boolean;
        TranslationBeforeImport: string;
        LocresPath: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TranslationUnit;

        static Load(InName: string): TranslationUnit;
    }

    export class TreeView extends ListView {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BP_OnGetItemChildren: $Delegate<(Item: $Nullable<Object>, Children: $Ref<TArray<Object>>) => void>;
        BP_OnItemExpansionChanged: $MulticastDelegate<(Item: $Nullable<Object>, bIsExpanded: boolean) => void>;

        CollapseAll(): void;

        ExpandAll(): void;

        SetItemExpansion(Item: $Nullable<Object>, bExpandItem: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TreeView;

        static Load(InName: string): TreeView;
    }

    export class TriggerBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CollisionComponent: ShapeComponent;
        SpriteComponent: BillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TriggerBase;

        static Load(InName: string): TriggerBase;
    }

    export class TriggerBox extends TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TriggerBox;

        static Load(InName: string): TriggerBox;
    }

    export class TriggerCapsule extends TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TriggerCapsule;

        static Load(InName: string): TriggerCapsule;
    }

    export class TriggerSphere extends TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TriggerSphere;

        static Load(InName: string): TriggerSphere;
    }

    export class TriggerVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TriggerVolume;

        static Load(InName: string): TriggerVolume;
    }

    export class TrueTypeFontFactory extends TextureFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ImportOptions: FontImportOptions;
        bPropertiesConfigured: boolean;
        bFontSelected: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TrueTypeFontFactory;

        static Load(InName: string): TrueTypeFontFactory;
    }

    export class TSCompileCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TSCompileCommandlet;

        static Load(InName: string): TSCompileCommandlet;
    }

    export class TurnBasedBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetIsMyTurn(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, MatchID: string, bIsMyTurn: $Ref<boolean>): void;

        static GetMyPlayerIndex(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, MatchID: string, PlayerIndex: $Ref<number>): void;

        static GetPlayerDisplayName(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, MatchID: string, PlayerIndex: number, PlayerDisplayName: $Ref<string>): void;

        static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: $Nullable<Object>, PlayerController: $Nullable<PlayerController>, Object: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TurnBasedBlueprintLibrary;

        static Load(InName: string): TurnBasedBlueprintLibrary;
    }

    export class TutorialSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Categories: TArray<TutorialCategory>;
        StartupTutorial: SoftClassPath;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TutorialSettings;

        static Load(InName: string): TutorialSettings;
    }

    export class TutorialProgress {
        constructor();
        constructor(Tutorial: SoftClassPath, CurrentStage: number, bUserDismissed: boolean);

        Tutorial: SoftClassPath;
        CurrentStage: number;
        bUserDismissed: boolean;

        static StaticClass(): Class;
    }

    export class TutorialStateSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        TutorialsProgress: TArray<TutorialProgress>;
        bDismissedAllTutorials: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TutorialStateSettings;

        static Load(InName: string): TutorialStateSettings;
    }

    export enum ETwitterRequestMethod { TRM_Get, TRM_Post, TRM_Delete, TRM_MAX }

    export class TwitterIntegrationBase extends PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AuthorizeAccounts(): boolean;

        CanShowTweetUI(): boolean;

        GetAccountName(AccountIndex: number): string;

        GetNumAccounts(): number;

        Init(): void;

        ShowTweetUI(InitialMessage: string, URL: string, Picture: string): boolean;

        TwitterRequest(URL: string, ParamKeysAndValues: TArray<string>, RequestMethod: ETwitterRequestMethod, AccountIndex: number): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TwitterIntegrationBase;

        static Load(InName: string): TwitterIntegrationBase;
    }

    export class TypeScriptBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TypeScriptBlueprint;

        static Load(InName: string): TypeScriptBlueprint;
    }

    export class TypeScriptGeneratedClass extends BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HasConstructor: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TypeScriptGeneratedClass;

        static Load(InName: string): TypeScriptGeneratedClass;
    }

    export class TypeScriptObject extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): TypeScriptObject;

        static Load(InName: string): TypeScriptObject;
    }

    export enum EUdpMessageFormat {
        None,
        Json,
        TaggedProperty,
        CborPlatformEndianness,
        CborStandardEndianness,
        EUdpMessageFormat_MAX
    }

    export class UdpMessagingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EnabledByDefault: boolean;
        EnableTransport: boolean;
        bAutoRepair: boolean;
        bStopServiceWhenAppDeactivates: boolean;
        UnicastEndpoint: string;
        MulticastEndpoint: string;
        MessageFormat: EUdpMessageFormat;
        MulticastTimeToLive: number;
        StaticEndpoints: TArray<string>;
        EnableTunnel: boolean;
        TunnelUnicastEndpoint: string;
        TunnelMulticastEndpoint: string;
        RemoteTunnelEndpoints: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UdpMessagingSettings;

        static Load(InName: string): UdpMessagingSettings;
    }

    export class UInt16Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UInt16Property;

        static Load(InName: string): UInt16Property;
    }

    export class UInt32Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UInt32Property;

        static Load(InName: string): UInt32Property;
    }

    export class UInt64Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UInt64Property;

        static Load(InName: string): UInt64Property;
    }

    export enum EPropertyBindingPermissionLevel {
        Allow,
        Prevent,
        PreventAndWarn,
        PreventAndError,
        EPropertyBindingPermissionLevel_MAX
    }

    export class WidgetCompilerOptions {
        constructor();
        constructor(bAllowBlueprintTick: boolean, bAllowBlueprintPaint: boolean, PropertyBindingRule: EPropertyBindingPermissionLevel, Rules: TArray<TSoftClassPtr<WidgetCompilerRule>>);

        bAllowBlueprintTick: boolean;
        bAllowBlueprintPaint: boolean;
        PropertyBindingRule: EPropertyBindingPermissionLevel;
        Rules: TArray<TSoftClassPtr<WidgetCompilerRule>>;

        static StaticClass(): Class;
    }

    export class DirectoryWidgetCompilerOptions {
        constructor();
        constructor(Directory: DirectoryPath, IgnoredWidgets: TArray<TSoftObjectPtr<WidgetBlueprint>>, Options: WidgetCompilerOptions);

        Directory: DirectoryPath;
        IgnoredWidgets: TArray<TSoftObjectPtr<WidgetBlueprint>>;
        Options: WidgetCompilerOptions;

        static StaticClass(): Class;
    }

    export class DebugResolution {
        constructor();
        constructor(Width: number, Height: number, Description: string, Color: LinearColor);

        Width: number;
        Height: number;
        Description: string;
        Color: LinearColor;

        static StaticClass(): Class;
    }

    export class UMGEditorProjectSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultCompilerOptions: WidgetCompilerOptions;
        DirectoryCompilerOptions: TArray<DirectoryWidgetCompilerOptions>;
        bShowWidgetsFromEngineContent: boolean;
        bShowWidgetsFromDeveloperContent: boolean;
        CategoriesToHide: TArray<string>;
        WidgetClassesToHide: TArray<SoftClassPath>;
        bUseWidgetTemplateSelector: boolean;
        DefaultRootWidget: Class;
        DefaultWidgetParentClass: TSoftClassPtr<UserWidget>;
        DebugResolutions: TArray<DebugResolution>;
        Version: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UMGEditorProjectSettings;

        static Load(InName: string): UMGEditorProjectSettings;
    }

    export class UMGManager extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static CreateReactWidget(World: $Nullable<World>): ReactWidget;

        static CreateWidget(World: $Nullable<World>, Class: $Nullable<Class>): UserWidget;

        static SynchronizeSlotProperties(Slot: $Nullable<PanelSlot>): void;

        static SynchronizeWidgetProperties(Widget: $Nullable<Widget>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UMGManager;

        static Load(InName: string): UMGManager;
    }

    export class UniformGridSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;
        Row: number;
        Column: number;

        SetColumn(InColumn: number): void;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetRow(InRow: number): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UniformGridSlot;

        static Load(InName: string): UniformGridSlot;
    }

    export class UniformGridPanel extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SlotPadding: Margin;
        MinDesiredSlotWidth: number;
        MinDesiredSlotHeight: number;

        AddChildToUniformGrid(Content: $Nullable<Widget>, InRow?: number /* = 0 */, InColumn?: number /* = 0 */): UniformGridSlot;

        SetMinDesiredSlotHeight(InMinDesiredSlotHeight: number): void;

        SetMinDesiredSlotWidth(InMinDesiredSlotWidth: number): void;

        SetSlotPadding(InSlotPadding: Margin): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UniformGridPanel;

        static Load(InName: string): UniformGridPanel;
    }

    export class UniformInteger extends FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;

        SetUniformInteger(Magnitude: number): UniformInteger;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UniformInteger;

        static Load(InName: string): UniformInteger;
    }

    export class UniformScalar extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;

        SetUniformScalar(Magnitude: number): UniformScalar;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UniformScalar;

        static Load(InName: string): UniformScalar;
    }

    export class UniformScaleDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UniformScaleDragOperation;

        static Load(InName: string): UniformScaleDragOperation;
    }

    export class UniformVector extends FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Magnitude: number;
        Direction: Vector;

        SetUniformVector(Magnitude: number, Direction: Vector): UniformVector;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UniformVector;

        static Load(InName: string): UniformVector;
    }

    export class EditorCommandCategory {
        constructor();
        constructor(Parent: string, Name: string);

        Parent: string;
        Name: string;

        static StaticClass(): Class;
    }

    export class EditorCommand {
        constructor();
        constructor(Parent: string, CommandName: string, ExecCommand: string, Description: string);

        Parent: string;
        CommandName: string;
        ExecCommand: string;
        Description: string;

        static StaticClass(): Class;
    }

    export class EditorKeyBinding {
        constructor();
        constructor(bCtrlDown: boolean, bAltDown: boolean, bShiftDown: boolean, Key: Key, CommandName: string);

        bCtrlDown: boolean;
        bAltDown: boolean;
        bShiftDown: boolean;
        Key: Key;
        CommandName: string;

        static StaticClass(): Class;
    }

    export class UnrealEdKeyBindings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        KeyBindings: TArray<EditorKeyBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UnrealEdKeyBindings;

        static Load(InName: string): UnrealEdKeyBindings;
    }

    export class ClassPickerDefaults {
        constructor();
        constructor(ClassName: string, AssetClass: string);

        ClassName: string;
        AssetClass: string;

        static StaticClass(): Class;
    }

    export class UnrealEdOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EditorCategories: TArray<EditorCommandCategory>;
        EditorCommands: TArray<EditorCommand>;
        EditorKeyBindings: UnrealEdKeyBindings;
        bExpandClassPickerClassList: boolean;
        NewAssetDefaultClasses: TArray<ClassPickerDefaults>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UnrealEdOptions;

        static Load(InName: string): UnrealEdOptions;
    }

    export class TemplateMapInfo {
        constructor();
        constructor(ThumbnailTexture: Texture2D, Map: string);

        ThumbnailTexture: Texture2D;
        Map: string;

        static StaticClass(): Class;
    }

    export class UnrealEdEngine extends EditorEngine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        EditorOptionsInst: UnrealEdOptions;
        AutoReimportManager: AutoReimportManager;
        MaterialCopyPasteBuffer: Material;
        MatineeCopyPasteBuffer: TArray<Object>;
        SoundCueCopyPasteBuffer: SoundCue;
        AnimationCompressionAlgorithms: TArray<AnimCompress>;
        PackagesToBeFullyLoadedAtStartup: TArray<string>;
        CurrentLODParentActor: Actor;
        bNeedWarningForPkgEngineVer: boolean;
        SortedSpriteCategories: TArray<string>;
        TemplateMapInfos: TArray<TemplateMapInfo>;
        CookServer: CookOnTheFlyServer;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UnrealEdEngine;

        static Load(InName: string): UnrealEdEngine;
    }

    export class UnrealEdTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UnrealEdTypes;

        static Load(InName: string): UnrealEdTypes;
    }

    export class UnrealPakCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UnrealPakCommandlet;

        static Load(InName: string): UnrealPakCommandlet;
    }

    export class UpdateGameProjectCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UpdateGameProjectCommandlet;

        static Load(InName: string): UpdateGameProjectCommandlet;
    }

    export class CapturedPixelsID {
        constructor();
        constructor(Identifiers: TMap<string, string>);

        Identifiers: TMap<string, string>;

        static StaticClass(): Class;
    }

    export class CapturedPixels {
        constructor();

        static StaticClass(): Class;
    }

    export class FrameMetrics {
        constructor();
        constructor(TotalElapsedTime: number, FrameDelta: number, FrameNumber: number, NumDroppedFrames: number);

        TotalElapsedTime: number;
        FrameDelta: number;
        FrameNumber: number;
        NumDroppedFrames: number;

        static StaticClass(): Class;
    }

    export class UserDefinedCaptureProtocol extends MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        World: World;

        GenerateFilename(InFrameMetrics: FrameMetrics): string;

        GetCurrentFrameMetrics(): FrameMetrics;

        OnBeginFinalize(): void;

        OnCanFinalize(): boolean;

        OnCaptureFrame(): void;

        OnFinalize(): void;

        OnPauseCapture(): void;

        OnPixelsReceived(Pixels: CapturedPixels, ID: CapturedPixelsID, FrameMetrics: FrameMetrics): void;

        OnPreTick(): void;

        OnSetup(): boolean;

        OnStartCapture(): void;

        OnTick(): void;

        OnWarmUp(): void;

        ResolveBuffer(Buffer: $Nullable<Texture>, BufferID: CapturedPixelsID): void;

        StartCapturingFinalPixels(StreamID: CapturedPixelsID): void;

        StopCapturingFinalPixels(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserDefinedCaptureProtocol;

        static Load(InName: string): UserDefinedCaptureProtocol;
    }

    export class UserDefinedImageCaptureProtocol extends UserDefinedCaptureProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Format: EDesiredImageFormat;
        bEnableCompression: boolean;
        CompressionQuality: number;

        GenerateFilenameForBuffer(Buffer: $Nullable<Texture>, StreamID: CapturedPixelsID): string;

        GenerateFilenameForCurrentFrame(): string;

        WriteImageToDisk(PixelData: CapturedPixels, StreamID: CapturedPixelsID, FrameMetrics: FrameMetrics, bCopyImageData?: boolean /* = false */): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserDefinedImageCaptureProtocol;

        static Load(InName: string): UserDefinedImageCaptureProtocol;
    }

    export class StructVariableDescription {
        constructor();
        constructor(VarName: string, VarGuid: Guid, FriendlyName: string, DefaultValue: string, Category: string, SubCategory: string, SubCategoryObject: TSoftObjectPtr<Object>, PinValueType: EdGraphTerminalType, ContainerType: EPinContainerType, bIsArray: boolean, bIsSet: boolean, bIsMap: boolean, bInvalidMember: boolean, bDontEditOnInstance: boolean, bEnableSaveGame: boolean, bEnableMultiLineText: boolean, bEnable3dWidget: boolean, CurrentDefaultValue: string, ToolTip: string);

        VarName: string;
        VarGuid: Guid;
        FriendlyName: string;
        DefaultValue: string;
        Category: string;
        SubCategory: string;
        SubCategoryObject: TSoftObjectPtr<Object>;
        PinValueType: EdGraphTerminalType;
        ContainerType: EPinContainerType;
        bIsArray: boolean;
        bIsSet: boolean;
        bIsMap: boolean;
        bInvalidMember: boolean;
        bDontEditOnInstance: boolean;
        bEnableSaveGame: boolean;
        bEnableMultiLineText: boolean;
        bEnable3dWidget: boolean;
        CurrentDefaultValue: string;
        ToolTip: string;

        static StaticClass(): Class;
    }

    export class UserDefinedStructEditorData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UniqueNameId: number;
        VariablesDescriptions: TArray<StructVariableDescription>;
        ToolTip: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserDefinedStructEditorData;

        static Load(InName: string): UserDefinedStructEditorData;
    }

    export enum ERenderFocusRule { Always, NonPointer, NavigationOnly, Never, ERenderFocusRule_MAX }

    export class HardwareCursorReference {
        constructor();
        constructor(CursorPath: string, HotSpot: Vector2D);

        CursorPath: string;
        HotSpot: Vector2D;

        static StaticClass(): Class;
    }

    export enum EUIScalingRule {
        ShortestSide,
        LongestSide,
        Horizontal,
        Vertical,
        ScaleToFit,
        Custom,
        EUIScalingRule_MAX
    }

    export class UserInterfaceSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        RenderFocusRule: ERenderFocusRule;
        HardwareCursors: TMap<EMouseCursor, HardwareCursorReference>;
        SoftwareCursors: TMap<EMouseCursor, SoftClassPath>;
        DefaultCursor: SoftClassPath;
        TextEditBeamCursor: SoftClassPath;
        CrosshairsCursor: SoftClassPath;
        HandCursor: SoftClassPath;
        GrabHandCursor: SoftClassPath;
        GrabHandClosedCursor: SoftClassPath;
        SlashedCircleCursor: SoftClassPath;
        ApplicationScale: number;
        UIScaleRule: EUIScalingRule;
        CustomScalingRuleClass: SoftClassPath;
        UIScaleCurve: RuntimeFloatCurve;
        bAllowHighDPIInGameMode: boolean;
        DesignScreenSize: IntPoint;
        bLoadWidgetsOnDedicatedServer: boolean;
        CursorClasses: TArray<Object>;
        CustomScalingRuleClassInstance: Class;
        CustomScalingRule: DPICustomScalingRule;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserInterfaceSettings;

        static Load(InName: string): UserInterfaceSettings;
    }

    export class UserListEntry extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BP_OnEntryReleased(): void;

        BP_OnItemExpansionChanged(bIsExpanded: boolean): void;

        BP_OnItemSelectionChanged(bIsSelected: boolean): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserListEntry;

        static Load(InName: string): UserListEntry;
    }

    export class UserListEntryLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetOwningListView(UserListEntry: UserListEntry): ListViewBase;

        static IsListItemExpanded(UserListEntry: UserListEntry): boolean;

        static IsListItemSelected(UserListEntry: UserListEntry): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserListEntryLibrary;

        static Load(InName: string): UserListEntryLibrary;
    }

    export class UserObjectListEntry extends UserListEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnListItemObjectSet(ListItemObject: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserObjectListEntry;

        static Load(InName: string): UserObjectListEntry;
    }

    export class UserObjectListEntryLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetListItemObject(UserObjectListEntry: UserObjectListEntry): Object;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): UserObjectListEntryLibrary;

        static Load(InName: string): UserObjectListEntryLibrary;
    }

    export enum EVectorFieldConstructionOp { VFCO_Extrude, VFCO_Revolve, VFCO_MAX }

    export class VectorFieldStatic extends VectorField {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        SizeX: number;
        SizeY: number;
        SizeZ: number;
        bAllowCPUAccess: boolean;
        SourceFilePath: string;
        AssetImportData: AssetImportData;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VectorFieldStatic;

        static Load(InName: string): VectorFieldStatic;
    }

    export class VectorFieldAnimated extends VectorField {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Texture: Texture2D;
        ConstructionOp: EVectorFieldConstructionOp;
        VolumeSizeX: number;
        VolumeSizeY: number;
        VolumeSizeZ: number;
        SubImagesX: number;
        SubImagesY: number;
        FrameCount: number;
        FramesPerSecond: number;
        bLoop: boolean;
        NoiseField: VectorFieldStatic;
        NoiseScale: number;
        NoiseMax: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VectorFieldAnimated;

        static Load(InName: string): VectorFieldAnimated;
    }

    export class VectorFieldComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VectorField: VectorField;
        Intensity: number;
        Tightness: number;
        bPreviewVectorField: boolean;

        SetIntensity(NewIntensity: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VectorFieldComponent;

        static Load(InName: string): VectorFieldComponent;
    }

    export class VectorFieldExporter extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VectorFieldExporter;

        static Load(InName: string): VectorFieldExporter;
    }

    export class VectorFieldVolume extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VectorFieldComponent: VectorFieldComponent;
        SpriteComponent: BillboardComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VectorFieldVolume;

        static Load(InName: string): VectorFieldVolume;
    }

    export class WheeledVehicle extends Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Mesh: SkeletalMeshComponent;
        VehicleMovement: WheeledVehicleMovementComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WheeledVehicle;

        static Load(InName: string): WheeledVehicle;
    }

    export class VehicleAnimInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WheeledVehicleMovementComponent: WheeledVehicleMovementComponent;

        GetVehicle(): WheeledVehicle;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VehicleAnimInstance;

        static Load(InName: string): VehicleAnimInstance;
    }

    export class VertexColorImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        UVIndex: number;
        LODIndex: number;
        bRed: boolean;
        bBlue: boolean;
        bGreen: boolean;
        bAlpha: boolean;
        bImportToInstance: boolean;
        bCanImportToInstance: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VertexColorImportOptions;

        static Load(InName: string): VertexColorImportOptions;
    }

    export class VerticalBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Size: SlateChildSize;
        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetSize(InSize: SlateChildSize): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VerticalBoxSlot;

        static Load(InName: string): VerticalBoxSlot;
    }

    export class VerticalBox extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddChildToVerticalBox(Content: $Nullable<Widget>): VerticalBoxSlot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VerticalBox;

        static Load(InName: string): VerticalBox;
    }

    export class VideoCaptureProtocol extends FrameGrabberProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bUseCompression: boolean;
        CompressionQuality: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VideoCaptureProtocol;

        static Load(InName: string): VideoCaptureProtocol;
    }

    export class ViewModeUtils extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewModeUtils;

        static Load(InName: string): ViewModeUtils;
    }

    export class Viewport extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BackgroundColor: LinearColor;

        GetViewLocation(): Vector;

        GetViewportWorld(): World;

        GetViewRotation(): Rotator;

        SetViewLocation(Location: Vector): void;

        SetViewRotation(Rotation: Rotator): void;

        Spawn(ActorClass: $Nullable<Class>): Actor;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): Viewport;

        static Load(InName: string): Viewport;
    }

    export class ViewportInteractableInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewportInteractableInterface;

        static Load(InName: string): ViewportInteractableInterface;
    }

    export class ViewportStatsSubsystem extends WorldSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AddDisplayDelegate(Delegate: $Delegate<(OutText: $Ref<string>, OutColor: $Ref<LinearColor>) => boolean>): number;

        AddTimedDisplay(Text: string, Color?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, Duration?: number /* = 0.000000 */): void;

        RemoveDisplayDelegate(IndexToRemove: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ViewportStatsSubsystem;

        static Load(InName: string): ViewportStatsSubsystem;
    }

    export class VirtualTextureBuilderExporterBMP extends TextureExporterBMP {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VirtualTextureBuilderExporterBMP;

        static Load(InName: string): VirtualTextureBuilderExporterBMP;
    }

    export class VirtualTextureBuilderFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VirtualTextureBuilderFactory;

        static Load(InName: string): VirtualTextureBuilderFactory;
    }

    export class VirtualTextureBuilderThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VirtualTextureBuilderThumbnailRenderer;

        static Load(InName: string): VirtualTextureBuilderThumbnailRenderer;
    }

    export class VirtualTextureSpacePoolConfig {
        constructor();
        constructor(MinTileSize: number, MaxTileSize: number, Formats: TArray<EPixelFormat>, SizeInMegabyte: number, bAllowSizeScale: boolean, ScalabilityGroup: number);

        MinTileSize: number;
        MaxTileSize: number;
        Formats: TArray<EPixelFormat>;
        SizeInMegabyte: number;
        bAllowSizeScale: boolean;
        ScalabilityGroup: number;

        static StaticClass(): Class;
    }

    export class VirtualTexturePoolConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DefaultSizeInMegabyte: number;
        Pools: TArray<VirtualTextureSpacePoolConfig>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VirtualTexturePoolConfig;

        static Load(InName: string): VirtualTexturePoolConfig;
    }

    export class VISettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bScaleWorldFromFloor: boolean;
        bScaleWorldWithDynamicPivot: boolean;
        bAllowSimultaneousWorldScalingAndRotation: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VISettings;

        static Load(InName: string): VISettings;
    }

    export class VisibilityBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetValue(): ESlateVisibility;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VisibilityBinding;

        static Load(InName: string): VisibilityBinding;
    }

    export class VisualLoggerAutomationTests extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VisualLoggerAutomationTests;

        static Load(InName: string): VisualLoggerAutomationTests;
    }

    export class VisualLoggerDebugSnapshotInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VisualLoggerDebugSnapshotInterface;

        static Load(InName: string): VisualLoggerDebugSnapshotInterface;
    }

    export class VisualLoggerExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VisualLoggerExtension;

        static Load(InName: string): VisualLoggerExtension;
    }

    export class VisualLoggerKismetLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static EnableRecording(bEnabled: boolean): void;

        static LogBox(WorldContextObject: $Nullable<Object>, BoxShape: Box, Text: string, ObjectColor?: LinearColor /* = (R=0.000000,G=0.000000,B=1.000000,A=1.000000) */, LogCategory?: string /* = "VisLogBP" */, bAddToMessageLog?: boolean /* = false */): void;

        static LogLocation(WorldContextObject: $Nullable<Object>, Location: Vector, Text: string, ObjectColor?: LinearColor /* = (R=0.000000,G=0.000000,B=1.000000,A=1.000000) */, Radius?: number /* = 10.000000 */, LogCategory?: string /* = "VisLogBP" */, bAddToMessageLog?: boolean /* = false */): void;

        static LogSegment(WorldContextObject: $Nullable<Object>, SegmentStart: Vector, SegmentEnd: Vector, Text: string, ObjectColor?: LinearColor /* = (R=0.000000,G=0.000000,B=1.000000,A=1.000000) */, Thickness?: number /* = 0.000000 */, CategoryName?: string /* = "VisLogBP" */, bAddToMessageLog?: boolean /* = false */): void;

        static LogText(WorldContextObject: $Nullable<Object>, Text: string, LogCategory?: string /* = "VisLogBP" */, bAddToMessageLog?: boolean /* = false */): void;

        static RedirectVislog(SourceOwner: $Nullable<Object>, DestinationOwner: $Nullable<Object>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VisualLoggerKismetLibrary;

        static Load(InName: string): VisualLoggerKismetLibrary;
    }

    export class VoiceChannel extends Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VoiceChannel;

        static Load(InName: string): VoiceChannel;
    }

    export class VoipListenerSynthComponent extends SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        IsIdling(): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VoipListenerSynthComponent;

        static Load(InName: string): VoipListenerSynthComponent;
    }

    export class VOIPStatics extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static SetMicThreshold(InThreshold: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VOIPStatics;

        static Load(InName: string): VOIPStatics;
    }

    export class VoiceSettings {
        constructor();
        constructor(ComponentToAttachTo: SceneComponent, AttenuationSettings: SoundAttenuation, SourceEffectChain: SoundEffectSourcePresetChain);

        ComponentToAttachTo: SceneComponent;
        AttenuationSettings: SoundAttenuation;
        SourceEffectChain: SoundEffectSourcePresetChain;

        static StaticClass(): Class;
    }

    export class VOIPTalker extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Settings: VoiceSettings;

        BPOnTalkingBegin(AudioComponent: $Nullable<AudioComponent>): void;

        BPOnTalkingEnd(): void;

        GetVoiceLevel(): number;

        RegisterWithPlayerState(OwningState: $Nullable<PlayerState>): void;

        static CreateTalkerForPlayer(OwningState: $Nullable<PlayerState>): VOIPTalker;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VOIPTalker;

        static Load(InName: string): VOIPTalker;
    }

    export class VolumeTextureFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InitialTexture: Texture2D;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VolumeTextureFactory;

        static Load(InName: string): VolumeTextureFactory;
    }

    export class VolumeTextureThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        MaterialInstance: MaterialInstanceConstant;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VolumeTextureThumbnailRenderer;

        static Load(InName: string): VolumeTextureThumbnailRenderer;
    }

    export class VolumetricBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Z: number;
        Radius: number;
        NumSheets: number;
        GroupName: string;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VolumetricBuilder;

        static Load(InName: string): VolumetricBuilder;
    }

    export class VolumetricCloudComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        LayerBottomAltitude: number;
        LayerHeight: number;
        TracingStartMaxDistance: number;
        TracingMaxDistance: number;
        PlanetRadius: number;
        GroundAlbedo: Color;
        Material: MaterialInterface;
        bUsePerSampleAtmosphericLightTransmittance: boolean;
        SkyLightCloudBottomOcclusion: number;
        ViewSampleCountScale: number;
        ReflectionSampleCountScale: number;
        ShadowViewSampleCountScale: number;
        ShadowReflectionSampleCountScale: number;
        ShadowTracingDistance: number;

        SetbUsePerSampleAtmosphericLightTransmittance(NewValue: boolean): void;

        SetGroundAlbedo(NewValue: Color): void;

        SetLayerBottomAltitude(NewValue: number): void;

        SetLayerHeight(NewValue: number): void;

        SetMaterial(NewValue: $Nullable<MaterialInterface>): void;

        SetPlanetRadius(NewValue: number): void;

        SetReflectionSampleCountScale(NewValue: number): void;

        SetShadowReflectionSampleCountScale(NewValue: number): void;

        SetShadowTracingDistance(NewValue: number): void;

        SetShadowViewSampleCountScale(NewValue: number): void;

        SetSkyLightCloudBottomOcclusion(NewValue: number): void;

        SetTracingMaxDistance(NewValue: number): void;

        SetTracingStartMaxDistance(NewValue: number): void;

        SetViewSampleCountScale(NewValue: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VolumetricCloudComponent;

        static Load(InName: string): VolumetricCloudComponent;
    }

    export class VolumetricCloud extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VolumetricCloudComponent: VolumetricCloudComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VolumetricCloud;

        static Load(InName: string): VolumetricCloud;
    }

    export class VolumetricLightmapDensityVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AllowedMipLevelRange: Int32Interval;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VolumetricLightmapDensityVolume;

        static Load(InName: string): VolumetricLightmapDensityVolume;
    }

    export class VREditorAssetContainer extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DockableWindowCloseSound: SoundBase;
        DockableWindowOpenSound: SoundBase;
        DockableWindowDropSound: SoundBase;
        DockableWindowDragSound: SoundBase;
        DropFromContentBrowserSound: SoundBase;
        RadialMenuOpenSound: SoundBase;
        RadialMenuCloseSound: SoundBase;
        TeleportSound: SoundBase;
        ButtonPressSound: SoundCue;
        AutoScaleSound: SoundBase;
        GenericHMDMesh: StaticMesh;
        PlaneMesh: StaticMesh;
        CylinderMesh: StaticMesh;
        LaserPointerStartMesh: StaticMesh;
        LaserPointerMesh: StaticMesh;
        LaserPointerEndMesh: StaticMesh;
        LaserPointerHoverMesh: StaticMesh;
        VivePreControllerMesh: StaticMesh;
        OculusControllerMesh: StaticMesh;
        GenericControllerMesh: StaticMesh;
        TeleportRootMesh: StaticMesh;
        WindowMesh: StaticMesh;
        WindowSelectionBarMesh: StaticMesh;
        WindowCloseButtonMesh: StaticMesh;
        RadialMenuMainMesh: StaticMesh;
        RadialMenuPointerMesh: StaticMesh;
        PointerCursorMesh: StaticMesh;
        LineSegmentCylinderMesh: StaticMesh;
        JointSphereMesh: StaticMesh;
        DockingButtonMesh: StaticMesh;
        GridMaterial: MaterialInterface;
        LaserPointerMaterial: MaterialInterface;
        LaserPointerTranslucentMaterial: MaterialInterface;
        WorldMovementPostProcessMaterial: Material;
        TextMaterial: MaterialInterface;
        VivePreControllerMaterial: MaterialInterface;
        OculusControllerMaterial: MaterialInterface;
        TeleportMaterial: MaterialInterface;
        WindowMaterial: MaterialInterface;
        WindowTranslucentMaterial: MaterialInterface;
        LineMaterial: Material;
        TranslucentTextMaterial: MaterialInterface;
        TextFont: Font;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorAssetContainer;

        static Load(InName: string): VREditorAssetContainer;
    }

    export class VREditorAvatarActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HeadMeshComponent: StaticMeshComponent;
        WorldMovementGridMeshComponent: StaticMeshComponent;
        WorldMovementGridMID: MaterialInstanceDynamic;
        WorldMovementGridOpacity: number;
        bIsDrawingWorldMovementPostProcess: boolean;
        WorldMovementPostProcessMaterial: MaterialInstanceDynamic;
        ScaleProgressMeshComponent: StaticMeshComponent;
        CurrentScaleProgressMeshComponent: StaticMeshComponent;
        UserScaleIndicatorText: TextRenderComponent;
        FixedUserScaleMID: MaterialInstanceDynamic;
        TranslucentFixedUserScaleMID: MaterialInstanceDynamic;
        CurrentUserScaleMID: MaterialInstanceDynamic;
        TranslucentCurrentUserScaleMID: MaterialInstanceDynamic;
        PostProcessComponent: PostProcessComponent;
        VRMode: VREditorMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorAvatarActor;

        static Load(InName: string): VREditorAvatarActor;
    }

    export class VREditorBaseActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VRMode: VREditorMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorBaseActor;

        static Load(InName: string): VREditorBaseActor;
    }

    export class VREditorFloatingUICreationContext {
        constructor();
        constructor(WidgetClass: Class, PanelID: string, ParentActor: Actor, PanelSpawnOffset: Transform, PanelSize: Vector2D, PanelMesh: StaticMesh, EditorUISize: number, bHideWindowHandles: boolean, bMaskOutWidgetBackground: boolean, bNoCloseButton: boolean);

        WidgetClass: Class;
        PanelID: string;
        ParentActor: Actor;
        PanelSpawnOffset: Transform;
        PanelSize: Vector2D;
        PanelMesh: StaticMesh;
        EditorUISize: number;
        bHideWindowHandles: boolean;
        bMaskOutWidgetBackground: boolean;
        bNoCloseButton: boolean;

        static StaticClass(): Class;
    }

    export enum EVREditorWidgetDrawingPolicy { Always, Hovering, EVREditorWidgetDrawingPolicy_MAX }

    export class VREditorWidgetComponent extends WidgetComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DrawingPolicy: EVREditorWidgetDrawingPolicy;
        bIsHovering: boolean;
        bHasEverDrawn: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorWidgetComponent;

        static Load(InName: string): VREditorWidgetComponent;
    }

    export class VREditorFloatingUI extends VREditorBaseActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CreationContext: VREditorFloatingUICreationContext;
        UserWidget: UserWidget;
        WidgetComponent: VREditorWidgetComponent;
        WindowMeshComponent: StaticMeshComponent;
        UserWidgetClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorFloatingUI;

        static Load(InName: string): VREditorFloatingUI;
    }

    export class VREditorRadialFloatingUI extends VREditorBaseActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetComponents: TArray<VREditorWidgetComponent>;
        WindowMeshComponent: StaticMeshComponent;
        ArrowMeshComponent: StaticMeshComponent;
        CentralWidgetComponent: VREditorWidgetComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorRadialFloatingUI;

        static Load(InName: string): VREditorRadialFloatingUI;
    }

    export class VREditorDockableWindow extends VREditorFloatingUI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        DockButtonMeshComponent: StaticMeshComponent;
        SelectionBarMeshComponent: StaticMeshComponent;
        CloseButtonMeshComponent: StaticMeshComponent;
        DockButtonMID: MaterialInstanceDynamic;
        SelectionBarMID: MaterialInstanceDynamic;
        SelectionBarTranslucentMID: MaterialInstanceDynamic;
        CloseButtonMID: MaterialInstanceDynamic;
        CloseButtonTranslucentMID: MaterialInstanceDynamic;
        DragOperationComponent: ViewportDragOperationComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorDockableWindow;

        static Load(InName: string): VREditorDockableWindow;
    }

    export enum EControllerType { Laser, AssistingLaser, UI, Navigation, Unknown, EControllerType_MAX }

    export class VREditorTeleporter extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VRMode: VREditorMode;
        TeleportDirectionMeshComponent: StaticMeshComponent;
        HMDMeshComponent: StaticMeshComponent;
        LeftMotionControllerMeshComponent: StaticMeshComponent;
        RightMotionControllerMeshComponent: StaticMeshComponent;
        TeleportMID: MaterialInstanceDynamic;
        InteractorTryingTeleport: ViewportInteractor;

        DoTeleport(): void;

        GetInteractorTryingTeleport(): ViewportInteractor;

        GetSlideDelta(Interactor: $Nullable<VREditorInteractor>, Axis: boolean): number;

        GetVRMode(): VREditorMode;

        Init(InMode: $Nullable<VREditorMode>): void;

        IsAiming(): boolean;

        IsTeleporting(): boolean;

        SetColor(Color: LinearColor): void;

        SetVisibility(bVisible: boolean): void;

        Shutdown(): void;

        StartAiming(Interactor: $Nullable<ViewportInteractor>): void;

        StartTeleport(): void;

        StopAiming(): void;

        TeleportDone(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorTeleporter;

        static Load(InName: string): VREditorTeleporter;
    }

    export class VREditorInteractor extends ViewportInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bIsUndoRedoSwipeEnabled: boolean;
        MotionControllerComponent: MotionControllerComponent;
        HandMeshComponent: StaticMeshComponent;
        LaserSplineComponent: SplineComponent;
        LaserSplineMeshComponents: TArray<SplineMeshComponent>;
        LaserPointerMID: MaterialInstanceDynamic;
        TranslucentLaserPointerMID: MaterialInstanceDynamic;
        HoverMeshComponent: StaticMeshComponent;
        HoverPointLightComponent: PointLightComponent;
        HandMeshMID: MaterialInstanceDynamic;
        OwningAvatar: Actor;
        ControllerType: EControllerType;
        OverrideControllerType: EControllerType;
        ControllerMotionSource: string;
        VRMode: VREditorMode;

        GetControllerHandSide(): string;

        GetControllerSide(): EControllerHand;

        GetControllerType(): EControllerType;

        GetHMDDeviceType(): string;

        GetLaserEnd(): Vector;

        GetLaserStart(): Vector;

        GetLastTrackpadPosition(): Vector2D;

        GetMotionControllerComponent(): MotionControllerComponent;

        GetSelectAndMoveTriggerValue(): number;

        GetSlideDelta(): number;

        GetTeleportActor(): VREditorTeleporter;

        GetTrackpadPosition(): Vector2D;

        Init(InVRMode: $Nullable<VREditorMode>): void;

        IsClickingOnUI(): boolean;

        IsHoveringOverUI(): boolean;

        IsTouchingTrackpad(): boolean;

        ReplaceHandMeshComponent(NewMesh: $Nullable<StaticMesh>): void;

        SetControllerHandSide(InControllerHandSide: string): void;

        SetControllerType(InControllerType: EControllerType): void;

        SetForceLaserColor(InColor: LinearColor): void;

        SetForceShowLaser(bInForceShow: boolean): void;

        SetupComponent(OwningActor: $Nullable<Actor>): void;

        TryOverrideControllerType(InControllerType: EControllerType): boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorInteractor;

        static Load(InName: string): VREditorInteractor;
    }

    export class VRButton {
        constructor();
        constructor(ButtonWidget: VREditorWidgetComponent);

        ButtonWidget: VREditorWidgetComponent;

        static StaticClass(): Class;
    }

    export class VRRadialMenuHandler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VRRadialMenuHandler;

        static Load(InName: string): VRRadialMenuHandler;
    }

    export class VREditorUISystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VRMode: VREditorMode;
        FloatingUIs: TMap<string, VREditorFloatingUI>;
        PreviewWindowInfo: TMap<string, Actor>;
        InfoDisplayPanel: VREditorFloatingUI;
        QuickRadialMenu: VREditorRadialFloatingUI;
        DraggingUI: VREditorDockableWindow;
        ColorPickerUI: VREditorDockableWindow;
        LaserInteractor: VREditorInteractor;
        UIInteractor: VREditorInteractor;
        VRButtons: TArray<VRButton>;
        RadialMenuHandler: VRRadialMenuHandler;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorUISystem;

        static Load(InName: string): VREditorUISystem;
    }

    export class VREditorPlacement extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VRMode: VREditorMode;
        ViewportWorldInteraction: ViewportWorldInteraction;
        FloatingUIAssetDraggedFrom: WidgetComponent;
        PlacingMaterialOrTextureAsset: Object;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorPlacement;

        static Load(InName: string): VREditorPlacement;
    }

    export class VREditorMode extends EditorWorldExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        AvatarActor: VREditorAvatarActor;
        UISystem: VREditorUISystem;
        TeleportActor: VREditorTeleporter;
        AutoScalerSystem: VREditorAutoScaler;
        WorldInteraction: ViewportWorldInteraction;
        PlacementSystem: VREditorPlacement;
        Interactors: TArray<VREditorInteractor>;
        AssetContainer: VREditorAssetContainer;

        GetWorldScaleFactor(): number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorMode;

        static Load(InName: string): VREditorMode;
    }

    export class VREditorAutoScaler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        VRMode: VREditorMode;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorAutoScaler;

        static Load(InName: string): VREditorAutoScaler;
    }

    export class VREditorBaseUserWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Owner: TWeakObjectPtr<VREditorFloatingUI>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorBaseUserWidget;

        static Load(InName: string): VREditorBaseUserWidget;
    }

    export class VREditorCameraWidgetComponent extends VREditorWidgetComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorCameraWidgetComponent;

        static Load(InName: string): VREditorCameraWidgetComponent;
    }

    export class VREditorDockableCameraWindow extends VREditorDockableWindow {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorDockableCameraWindow;

        static Load(InName: string): VREditorDockableCameraWindow;
    }

    export class VREditorFloatingCameraUI extends VREditorFloatingUI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OffsetFromCamera: Vector;
        LinkedActor: TWeakObjectPtr<Actor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VREditorFloatingCameraUI;

        static Load(InName: string): VREditorFloatingCameraUI;
    }

    export enum EInteractorHand { Right, Left, EInteractorHand_MAX }

    export class VRModeSettings extends VISettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bEnableAutoVREditMode: boolean;
        bAutokeySequences: boolean;
        InteractorHand: EInteractorHand;
        bShowWorldMovementGrid: boolean;
        bShowWorldMovementPostProcess: boolean;
        bShowWorldScaleProgressBar: boolean;
        UIBrightness: number;
        GizmoScale: number;
        DoubleClickTime: number;
        TriggerPressedThreshold_Vive: number;
        TriggerPressedThreshold_Rift: number;
        InteractorClass: TSoftClassPtr<VREditorInteractor>;
        TeleporterClass: TSoftClassPtr<VREditorTeleporter>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VRModeSettings;

        static Load(InName: string): VRModeSettings;
    }

    export class VRNotificationsComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate: $MulticastDelegate<() => void>;
        HMDTrackingInitializedDelegate: $MulticastDelegate<() => void>;
        HMDRecenteredDelegate: $MulticastDelegate<() => void>;
        HMDLostDelegate: $MulticastDelegate<() => void>;
        HMDReconnectedDelegate: $MulticastDelegate<() => void>;
        HMDConnectCanceledDelegate: $MulticastDelegate<() => void>;
        HMDPutOnHeadDelegate: $MulticastDelegate<() => void>;
        HMDRemovedFromHeadDelegate: $MulticastDelegate<() => void>;
        VRControllerRecenteredDelegate: $MulticastDelegate<() => void>;

        VRNotificationsDelegate__DelegateSignature(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VRNotificationsComponent;

        static Load(InName: string): VRNotificationsComponent;
    }

    export enum EGizmoHandleTypes { All, Translate, Rotate, Scale, EGizmoHandleTypes_MAX }

    export class VRScoutingInteractor extends VREditorInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        FlyingIndicatorComponent: StaticMeshComponent;

        GetGizmoMode(): EGizmoHandleTypes;

        SetGizmoMode(InGizmoMode: EGizmoHandleTypes): void;

        static GetSelectedActors(): TArray<Actor>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): VRScoutingInteractor;

        static Load(InName: string): VRScoutingInteractor;
    }

    export class WeakObjectProperty extends ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WeakObjectProperty;

        static Load(InName: string): WeakObjectProperty;
    }

    export class WeightAndEasingEvaluatorSystem extends MovieSceneEntitySystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WeightAndEasingEvaluatorSystem;

        static Load(InName: string): WeightAndEasingEvaluatorSystem;
    }

    export class BlueprintWidgetAnimationDelegateBinding {
        constructor();
        constructor(Action: EWidgetAnimationEvent, AnimationToBind: string, FunctionNameToBind: string, UserTag: string);

        Action: EWidgetAnimationEvent;
        AnimationToBind: string;
        FunctionNameToBind: string;
        UserTag: string;

        static StaticClass(): Class;
    }

    export class WidgetAnimationDelegateBinding extends DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetAnimationDelegateBindings: TArray<BlueprintWidgetAnimationDelegateBinding>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetAnimationDelegateBinding;

        static Load(InName: string): WidgetAnimationDelegateBinding;
    }

    export class WidgetAnimationPlayCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Finished: $MulticastDelegate<() => void>;

        static CreatePlayAnimationProxyObject(Result: $Ref<UMGSequencePlayer>, Widget: $Nullable<UserWidget>, InAnimation: $Nullable<WidgetAnimation>, StartAtTime?: number /* = 0.000000 */, NumLoopsToPlay?: number /* = 1 */, PlayMode?: EUMGSequencePlayMode /* = Forward */, PlaybackSpeed?: number /* = 1.000000 */): WidgetAnimationPlayCallbackProxy;

        static CreatePlayAnimationTimeRangeProxyObject(Result: $Ref<UMGSequencePlayer>, Widget: $Nullable<UserWidget>, InAnimation: $Nullable<WidgetAnimation>, StartAtTime?: number /* = 0.000000 */, EndAtTime?: number /* = 0.000000 */, NumLoopsToPlay?: number /* = 1 */, PlayMode?: EUMGSequencePlayMode /* = Forward */, PlaybackSpeed?: number /* = 1.000000 */): WidgetAnimationPlayCallbackProxy;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetAnimationPlayCallbackProxy;

        static Load(InName: string): WidgetAnimationPlayCallbackProxy;
    }

    export class WidgetBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GetValue(): Widget;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetBinding;

        static Load(InName: string): WidgetBinding;
    }

    export class WidgetBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        BlueprintType: EBlueprintType;
        ParentClass: Class;
        RootWidgetClass: Class;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintFactory;

        static Load(InName: string): WidgetBlueprintFactory;
    }

    export enum EWindowTitleBarMode { Overlay, VerticalBox, EWindowTitleBarMode_MAX }

    export class NavigationEvent extends InputEvent {
        constructor();

        static StaticClass(): Class;
    }

    export class WidgetBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnGameWindowCloseButtonClickedDelegate__DelegateSignature(): void;

        static CancelDragDrop(): void;

        static CaptureJoystick(Reply: $Ref<EventReply>, CapturingWidget: $Nullable<Widget>, bInAllJoysticks?: boolean /* = false */): EventReply;

        static CaptureMouse(Reply: $Ref<EventReply>, CapturingWidget: $Nullable<Widget>): EventReply;

        static ClearUserFocus(Reply: $Ref<EventReply>, bInAllUsers?: boolean /* = false */): EventReply;

        static Create(WorldContextObject: $Nullable<Object>, WidgetType: $Nullable<Class>, OwningPlayer: $Nullable<PlayerController>): UserWidget;

        static CreateDragDropOperation(OperationClass: $Nullable<Class>): DragDropOperation;

        static DetectDrag(Reply: $Ref<EventReply>, WidgetDetectingDrag: $Nullable<Widget>, DragKey: Key): EventReply;

        static DetectDragIfPressed(PointerEvent: PointerEvent, WidgetDetectingDrag: $Nullable<Widget>, DragKey: Key): EventReply;

        static DismissAllMenus(): void;

        static DrawBox(Context: $Ref<PaintContext>, Position: Vector2D, Size: Vector2D, Brush: $Nullable<SlateBrushAsset>, Tint?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        static DrawLine(Context: $Ref<PaintContext>, PositionA: Vector2D, PositionB: Vector2D, Tint?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, bAntiAlias?: boolean /* = true */, Thickness?: number /* = 1.000000 */): void;

        static DrawLines(Context: $Ref<PaintContext>, Points: TArray<Vector2D>, Tint?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */, bAntiAlias?: boolean /* = true */, Thickness?: number /* = 1.000000 */): void;

        static DrawText(Context: $Ref<PaintContext>, InString: string, Position: Vector2D, Tint?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        static DrawTextFormatted(Context: $Ref<PaintContext>, Text: string, Position: Vector2D, Font: $Nullable<Font>, FontSize?: number /* = 16 */, FontTypeFace?: string /* = "Regular" */, Tint?: LinearColor /* = (R=1.000000,G=1.000000,B=1.000000,A=1.000000) */): void;

        static EndDragDrop(Reply: $Ref<EventReply>): EventReply;

        static GetAllWidgetsOfClass(WorldContextObject: $Nullable<Object>, FoundWidgets: $Ref<TArray<UserWidget>>, WidgetClass: $Nullable<Class>, TopLevelOnly?: boolean /* = true */): void;

        static GetAllWidgetsWithInterface(WorldContextObject: $Nullable<Object>, FoundWidgets: $Ref<TArray<UserWidget>>, Interface: $Nullable<Class>, TopLevelOnly: boolean): void;

        static GetBrushResource(Brush: SlateBrush): Object;

        static GetBrushResourceAsMaterial(Brush: SlateBrush): MaterialInterface;

        static GetBrushResourceAsTexture2D(Brush: SlateBrush): Texture2D;

        static GetDragDroppingContent(): DragDropOperation;

        static GetDynamicMaterial(Brush: $Ref<SlateBrush>): MaterialInstanceDynamic;

        static GetInputEventFromCharacterEvent(Event: CharacterEvent): InputEvent;

        static GetInputEventFromKeyEvent(Event: KeyEvent): InputEvent;

        static GetInputEventFromNavigationEvent(Event: NavigationEvent): InputEvent;

        static GetInputEventFromPointerEvent(Event: PointerEvent): InputEvent;

        static GetKeyEventFromAnalogInputEvent(Event: AnalogInputEvent): KeyEvent;

        static GetSafeZonePadding(WorldContextObject: $Nullable<Object>, SafePadding: $Ref<Vector4>, SafePaddingScale: $Ref<Vector2D>, SpillOverPadding: $Ref<Vector4>): void;

        static Handled(): EventReply;

        static IsDragDropping(): boolean;

        static LockMouse(Reply: $Ref<EventReply>, CapturingWidget: $Nullable<Widget>): EventReply;

        static MakeBrushFromAsset(BrushAsset: $Nullable<SlateBrushAsset>): SlateBrush;

        static MakeBrushFromMaterial(Material: $Nullable<MaterialInterface>, Width?: number /* = 32 */, Height?: number /* = 32 */): SlateBrush;

        static MakeBrushFromTexture(Texture: $Nullable<Texture2D>, Width?: number /* = 0 */, Height?: number /* = 0 */): SlateBrush;

        static NoResourceBrush(): SlateBrush;

        static ReleaseJoystickCapture(Reply: $Ref<EventReply>, bInAllJoysticks?: boolean /* = false */): EventReply;

        static ReleaseMouseCapture(Reply: $Ref<EventReply>): EventReply;

        static RestorePreviousWindowTitleBarState(): void;

        static SetBrushResourceToMaterial(Brush: $Ref<SlateBrush>, Material: $Nullable<MaterialInterface>): void;

        static SetBrushResourceToTexture(Brush: $Ref<SlateBrush>, Texture: $Nullable<Texture2D>): void;

        static SetColorVisionDeficiencyType(Type: EColorVisionDeficiency, Severity: number, CorrectDeficiency: boolean, ShowCorrectionWithDeficiency: boolean): void;

        static SetFocusToGameViewport(): void;

        static SetHardwareCursor(WorldContextObject: $Nullable<Object>, CursorShape: EMouseCursor, CursorName: string, HotSpot: Vector2D): boolean;

        static SetInputMode_GameAndUI(Target: $Nullable<PlayerController>, InWidgetToFocus?: Widget /* = None */, bLockMouseToViewport?: boolean /* = false */, bHideCursorDuringCapture?: boolean /* = true */): void;

        static SetInputMode_GameAndUIEx(PlayerController: $Nullable<PlayerController>, InWidgetToFocus?: Widget /* = None */, InMouseLockMode?: EMouseLockMode /* = DoNotLock */, bHideCursorDuringCapture?: boolean /* = true */): void;

        static SetInputMode_GameOnly(PlayerController: $Nullable<PlayerController>): void;

        static SetInputMode_UIOnly(Target: $Nullable<PlayerController>, InWidgetToFocus?: Widget /* = None */, bLockMouseToViewport?: boolean /* = false */): void;

        static SetInputMode_UIOnlyEx(PlayerController: $Nullable<PlayerController>, InWidgetToFocus?: Widget /* = None */, InMouseLockMode?: EMouseLockMode /* = DoNotLock */): void;

        static SetMousePosition(Reply: $Ref<EventReply>, NewMousePosition: Vector2D): EventReply;

        static SetUserFocus(Reply: $Ref<EventReply>, FocusWidget: $Nullable<Widget>, bInAllUsers?: boolean /* = false */): EventReply;

        static SetWindowTitleBarCloseButtonActive(bActive: boolean): void;

        static SetWindowTitleBarOnCloseClickedDelegate(Delegate: $Delegate<() => void>): void;

        static SetWindowTitleBarState(TitleBarContent: $Nullable<Widget>, Mode: EWindowTitleBarMode, bTitleBarDragEnabled: boolean, bWindowButtonsVisible: boolean, bTitleBarVisible: boolean): void;

        static Unhandled(): EventReply;

        static UnlockMouse(Reply: $Ref<EventReply>): EventReply;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintLibrary;

        static Load(InName: string): WidgetBlueprintLibrary;
    }

    export class WidgetCompilerRule extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetCompilerRule;

        static Load(InName: string): WidgetCompilerRule;
    }

    export class WidgetPaletteFavorites extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Favorites: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetPaletteFavorites;

        static Load(InName: string): WidgetPaletteFavorites;
    }

    export class WidgetDesignerSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GridSnapEnabled: boolean;
        GridSnapSize: number;
        bLockToPanelOnDragByDefault: boolean;
        bShowOutlines: boolean;
        bExecutePreConstructEvent: boolean;
        bRespectLocks: boolean;
        Favorites: WidgetPaletteFavorites;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetDesignerSettings;

        static Load(InName: string): WidgetDesignerSettings;
    }

    export class WidgetGraphSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetGraphSchema;

        static Load(InName: string): WidgetGraphSchema;
    }

    export enum EWidgetInteractionSource { World, Mouse, CenterScreen, Custom, EWidgetInteractionSource_MAX }

    export class WidgetInteractionComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        OnHoveredWidgetChanged: $MulticastDelegate<(WidgetComponent: $Nullable<WidgetComponent>, PreviousWidgetComponent: $Nullable<WidgetComponent>) => void>;
        VirtualUserIndex: number;
        PointerIndex: number;
        TraceChannel: ECollisionChannel;
        InteractionDistance: number;
        InteractionSource: EWidgetInteractionSource;
        bEnableHitTesting: boolean;
        bShowDebug: boolean;
        DebugSphereLineThickness: number;
        DebugLineThickness: number;
        DebugColor: LinearColor;
        CustomHitResult: HitResult;
        LocalHitLocation: Vector2D;
        LastLocalHitLocation: Vector2D;
        HoveredWidgetComponent: WidgetComponent;
        LastHitResult: HitResult;
        bIsHoveredWidgetInteractable: boolean;
        bIsHoveredWidgetFocusable: boolean;
        bIsHoveredWidgetHitTestVisible: boolean;
        ArrowComponent: ArrowComponent;

        Get2DHitLocation(): Vector2D;

        GetHoveredWidgetComponent(): WidgetComponent;

        GetLastHitResult(): HitResult;

        IsOverFocusableWidget(): boolean;

        IsOverHitTestVisibleWidget(): boolean;

        IsOverInteractableWidget(): boolean;

        PressAndReleaseKey(Key: Key): boolean;

        PressKey(Key: Key, bRepeat?: boolean /* = false */): boolean;

        PressPointerKey(Key: Key): void;

        ReleaseKey(Key: Key): boolean;

        ReleasePointerKey(Key: Key): void;

        ScrollWheel(ScrollDelta: number): void;

        SendKeyChar(Characters: string, bRepeat?: boolean /* = false */): boolean;

        SetCustomHitResult(HitResult: HitResult): void;

        SetFocus(FocusWidget: $Nullable<Widget>): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetInteractionComponent;

        static Load(InName: string): WidgetInteractionComponent;
    }

    export class WrapBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        bFillEmptySpace: boolean;
        FillSpanWhenLessThan: number;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetFillEmptySpace(InbFillEmptySpace: boolean): void;

        SetFillSpanWhenLessThan(InFillSpanWhenLessThan: number): void;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WrapBoxSlot;

        static Load(InName: string): WrapBoxSlot;
    }

    export class WidgetSwitcherSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetSwitcherSlot;

        static Load(InName: string): WidgetSwitcherSlot;
    }

    export class WidgetLayoutLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static GetMousePositionOnPlatform(): Vector2D;

        static GetMousePositionOnViewport(WorldContextObject: $Nullable<Object>): Vector2D;

        static GetMousePositionScaledByDPI(Player: $Nullable<PlayerController>, LocationX: $Ref<number>, LocationY: $Ref<number>): boolean;

        static GetPlayerScreenWidgetGeometry(PlayerController: $Nullable<PlayerController>): Geometry;

        static GetViewportScale(WorldContextObject: $Nullable<Object>): number;

        static GetViewportSize(WorldContextObject: $Nullable<Object>): Vector2D;

        static GetViewportWidgetGeometry(WorldContextObject: $Nullable<Object>): Geometry;

        static ProjectWorldLocationToWidgetPosition(PlayerController: $Nullable<PlayerController>, WorldLocation: Vector, ScreenPosition: $Ref<Vector2D>, bPlayerViewportRelative: boolean): boolean;

        static RemoveAllWidgets(WorldContextObject: $Nullable<Object>): void;

        static SlotAsBorderSlot(Widget: $Nullable<Widget>): BorderSlot;

        static SlotAsCanvasSlot(Widget: $Nullable<Widget>): CanvasPanelSlot;

        static SlotAsGridSlot(Widget: $Nullable<Widget>): GridSlot;

        static SlotAsHorizontalBoxSlot(Widget: $Nullable<Widget>): HorizontalBoxSlot;

        static SlotAsOverlaySlot(Widget: $Nullable<Widget>): OverlaySlot;

        static SlotAsSafeBoxSlot(Widget: $Nullable<Widget>): SafeZoneSlot;

        static SlotAsScaleBoxSlot(Widget: $Nullable<Widget>): ScaleBoxSlot;

        static SlotAsScrollBoxSlot(Widget: $Nullable<Widget>): ScrollBoxSlot;

        static SlotAsSizeBoxSlot(Widget: $Nullable<Widget>): SizeBoxSlot;

        static SlotAsUniformGridSlot(Widget: $Nullable<Widget>): UniformGridSlot;

        static SlotAsVerticalBoxSlot(Widget: $Nullable<Widget>): VerticalBoxSlot;

        static SlotAsWidgetSwitcherSlot(Widget: $Nullable<Widget>): WidgetSwitcherSlot;

        static SlotAsWrapBoxSlot(Widget: $Nullable<Widget>): WrapBoxSlot;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetLayoutLibrary;

        static Load(InName: string): WidgetLayoutLibrary;
    }

    export class WidgetSlotPair extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        WidgetName: string;
        SlotPropertyNames: TArray<string>;
        SlotPropertyValues: TArray<string>;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetSlotPair;

        static Load(InName: string): WidgetSlotPair;
    }

    export class WidgetSwitcher extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        ActiveWidgetIndex: number;

        GetActiveWidget(): Widget;

        GetActiveWidgetIndex(): number;

        GetNumWidgets(): number;

        GetWidgetAtIndex(Index: number): Widget;

        SetActiveWidget(Widget: $Nullable<Widget>): void;

        SetActiveWidgetIndex(Index: number): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WidgetSwitcher;

        static Load(InName: string): WidgetSwitcher;
    }

    export enum EWindSourceType { Directional, Point, EWindSourceType_MAX }

    export class WindDirectionalSourceComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Strength: number;
        Speed: number;
        MinGustAmount: number;
        MaxGustAmount: number;
        Radius: number;
        bPointWind: boolean;

        SetMaximumGustAmount(InNewMaxGust: number): void;

        SetMinimumGustAmount(InNewMinGust: number): void;

        SetRadius(InNewRadius: number): void;

        SetSpeed(InNewSpeed: number): void;

        SetStrength(InNewStrength: number): void;

        SetWindType(InNewType: EWindSourceType): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WindDirectionalSourceComponent;

        static Load(InName: string): WindDirectionalSourceComponent;
    }

    export class WindDirectionalSource extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Component: WindDirectionalSourceComponent;
        ArrowComponent: ArrowComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WindDirectionalSource;

        static Load(InName: string): WindDirectionalSource;
    }

    export enum ECompilerVersion { Default, VisualStudio2015, VisualStudio2017, VisualStudio2019, ECompilerVersion_MAX }

    export enum EDefaultGraphicsRHI {
        DefaultGraphicsRHI_Default,
        DefaultGraphicsRHI_DX11,
        DefaultGraphicsRHI_DX12,
        DefaultGraphicsRHI_Vulkan,
        DefaultGraphicsRHI_MAX
    }

    export enum EMinimumSupportedOS { MSOS_Vista, MSOS_MAX }

    export class PlatformRuntimeAudioCompressionOverrides {
        constructor();
        constructor(bOverrideCompressionTimes: boolean, DurationThreshold: number, MaxNumRandomBranches: number, SoundCueQualityIndex: number);

        bOverrideCompressionTimes: boolean;
        DurationThreshold: number;
        MaxNumRandomBranches: number;
        SoundCueQualityIndex: number;

        static StaticClass(): Class;
    }

    export class WindowsTargetSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Compiler: ECompilerVersion;
        TargetedRHIs: TArray<string>;
        DefaultGraphicsRHI: EDefaultGraphicsRHI;
        MinimumOSVersion: EMinimumSupportedOS;
        bTarget32Bit: boolean;
        AudioSampleRate: number;
        AudioCallbackBufferFrameSize: number;
        AudioNumBuffersToEnqueue: number;
        AudioMaxChannels: number;
        AudioNumSourceWorkers: number;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        CompressionOverrides: PlatformRuntimeAudioCompressionOverrides;
        bUseAudioStreamCaching: boolean;
        CacheSizeKB: number;
        MaxChunkSizeOverrideKB: number;
        bResampleForDevice: boolean;
        MaxSampleRate: number;
        HighSampleRate: number;
        MedSampleRate: number;
        LowSampleRate: number;
        MinSampleRate: number;
        CompressionQualityModifier: number;
        AutoStreamingThreshold: number;
        SoundCueCookQualityIndex: number;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WindowsTargetSettings;

        static Load(InName: string): WindowsTargetSettings;
    }

    export class WindowTitleBarArea extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        bWindowButtonsEnabled: boolean;
        bDoubleClickTogglesFullscreen: boolean;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WindowTitleBarArea;

        static Load(InName: string): WindowTitleBarArea;
    }

    export class WindowTitleBarAreaSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        Padding: Margin;
        HorizontalAlignment: EHorizontalAlignment;
        VerticalAlignment: EVerticalAlignment;

        SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;

        SetPadding(InPadding: Margin): void;

        SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WindowTitleBarAreaSlot;

        static Load(InName: string): WindowTitleBarAreaSlot;
    }

    export class WorldFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WorldFactory;

        static Load(InName: string): WorldFactory;
    }

    export enum EOrthoThumbnailDirection { Top, Bottom, Left, Right, Front, Back, EOrthoThumbnailDirection_MAX }

    export class WorldThumbnailInfo extends SceneThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        CameraMode: ECameraProjectionMode;
        OrthoDirection: EOrthoThumbnailDirection;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WorldThumbnailInfo;

        static Load(InName: string): WorldThumbnailInfo;
    }

    export class WorldThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        GlobalOrbitPitchOffset: number;
        GlobalOrbitYawOffset: number;
        bUseUnlitScene: boolean;
        bAllowWorldThumbnails: boolean;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WorldThumbnailRenderer;

        static Load(InName: string): WorldThumbnailRenderer;
    }

    export class WrangleContentCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WrangleContentCommandlet;

        static Load(InName: string): WrangleContentCommandlet;
    }

    export class WrapBox extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        InnerSlotPadding: Vector2D;
        WrapWidth: number;
        WrapSize: number;
        bExplicitWrapWidth: boolean;
        bExplicitWrapSize: boolean;
        Orientation: EOrientation;

        AddChildToWrapBox(Content: $Nullable<Widget>): WrapBoxSlot;

        SetInnerSlotPadding(InPadding: Vector2D): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): WrapBox;

        static Load(InName: string): WrapBox;
    }

    export class XRAssetFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddDeviceVisualizationComponentBlocking(Target: $Nullable<Actor>, XRDeviceId: XRDeviceId, bManualAttachment: boolean, RelativeTransform: Transform): PrimitiveComponent;

        static AddNamedDeviceVisualizationComponentBlocking(Target: $Nullable<Actor>, SystemName: string, DeviceName: string, bManualAttachment: boolean, RelativeTransform: Transform, XRDeviceId: $Ref<XRDeviceId>): PrimitiveComponent;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): XRAssetFunctionLibrary;

        static Load(InName: string): XRAssetFunctionLibrary;
    }

    export class XRLoadingScreenFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static AddLoadingScreenSplash(Texture: $Nullable<Texture>, Translation: Vector, Rotation: Rotator, Size?: Vector2D /* = (X=1.000,Y=1.000) */, DeltaRotation?: Rotator /* =  */, bClearBeforeAdd?: boolean /* = false */): void;

        static ClearLoadingScreenSplashes(): void;

        static HideLoadingScreen(): void;

        static SetLoadingScreen(Texture: $Nullable<Texture>, Scale?: Vector2D /* = (X=1.000,Y=1.000) */, Offset?: Vector /* =  */, bShowLoadingMovie?: boolean /* = false */, bShowOnSet?: boolean /* = false */): void;

        static ShowLoadingScreen(): void;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): XRLoadingScreenFunctionLibrary;

        static Load(InName: string): XRLoadingScreenFunctionLibrary;
    }

    export class ZYJ_Test extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);

        static Test_AysncLoadPhysicsAsset(InGuid: string): void;

        static Test_AysncLoadSkeletalMesh(InGuid: string, InSkeletalMeshComp: $Nullable<SkeletalMeshComponent>): void;

        static Test_AysncLoadSkeleton(InGuid: string): void;

        static Test_LoadAnimInstance(InGuid: string): AnimInstance;

        static Test_LoadAnimMontage(InGuid: string): AnimMontage;

        static Test_LoadAsync(InMeshComponent: $Nullable<SkeletalMeshComponent>, InGuid?: string /* = "8407" */): void;

        static Test_LoadPhysicsAsset(InGuid: string): PhysicsAsset;

        static Test_LoadSkeletalMesh(InGuid: string): SkeletalMesh;

        static Test_LoadSkeleton(InGuid: string): Skeleton;

        static StaticClass(): Class;

        static Find(OrigInName: string, Outer?: Object): ZYJ_Test;

        static Load(InName: string): ZYJ_Test;
    }

}
